[{"FileName": "before_convertbmp.c", "Caller": "opj_t1_encode_cblks", "Source": false, "Sink": false, "idx": 0, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "N/A", "line": 330, "label": -3, "slices": ["int main(int argc, char **argv)", "{", "    opj_cparameters_t parameters;", "    opj_stream_t *l_stream = 00;", "    opj_codec_t* l_codec = 00;", "    opj_image_t *image = NULL;", "    raw_cparameters_t raw_cp;", "    OPJ_SIZE_T num_compressed_files = 0;", "    char indexfilename[OPJ_PATH_LEN];", "    unsigned int i, num_images, imageno;", "    img_fol_t img_fol;", "    dircnt_t *dirptr = NULL;", "    int ret = 0;", "    OPJ_BOOL bSuccess;", "    OPJ_BOOL bUseTiles = OPJ_FALSE;", "    OPJ_UINT32 l_nb_tiles = 4;", "    OPJ_FLOAT64 t = opj_clock();", "    opj_set_default_encoder_parameters(&parameters);", "    *indexfilename = 0;", "    memset(&img_fol, 0, sizeof(img_fol_t));", "    raw_cp.rawBitDepth = 0;", "    raw_cp.rawComp = 0;", "    raw_cp.rawComps = 0;", "    raw_cp.rawHeight = 0;", "    raw_cp.rawSigned = 0;", "    raw_cp.rawWidth = 0;", "    parameters.tcp_mct = (char)255;", "    if (parse_cmdline_encoder(argc, argv, &parameters, &img_fol, &raw_cp, indexfilename, sizeof(indexfilename)) == 1) {", "    if (img_fol.set_imgdir == 1) {", "        num_images = get_num_images(img_fol.imgdirpath);", "        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));", "        if (dirptr) {", "            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(char));", "            dirptr->filename = (char**) malloc(num_images * sizeof(char*));", "            if (!dirptr->filename_buf) {", "            for (i = 0; i < num_images; i++) {", "                dirptr->filename[i] = dirptr->filename_buf + i * OPJ_PATH_LEN;", "            }", "        }", "        if (load_images(dirptr, img_fol.imgdirpath) == 1) {", "        if (num_images == 0) {", "    } else {", "        num_images = 1;", "    }", "    for (imageno = 0; imageno < num_images; imageno++) {", "        image = NULL;", "        fprintf(stderr, \"\\n\");", "        if (img_fol.set_imgdir == 1) {", "            if (get_next_file((int)imageno, dirptr, &img_fol, &parameters)) {", "                fprintf(stderr, \"skipping file...\\n\");", "                continue;", "            }", "        }", "        switch (parameters.decod_format) {", "        case PGX_DFMT:", "            break;", "        case PXM_DFMT:", "            break;", "        case BMP_DFMT:", "            break;", "        case TIF_DFMT:", "            break;", "        case RAW_DFMT:", "            break;", "        case RAWL_DFMT:", "            break;", "        case TGA_DFMT:", "            break;", "        case PNG_DFMT:", "            break;", "        default:", "            fprintf(stderr, \"skipping file...\\n\");", "            continue;", "        }", "        switch (parameters.decod_format) {", "        case PGX_DFMT:", "            image = pgxtoimage(parameters.infile, &parameters);", "            if (!image) {", "            break;", "        case PXM_DFMT:", "            image = pnmtoimage(parameters.infile, &parameters);", "            if (!image) {", "            break;", "        case BMP_DFMT:", "            image = bmptoimage(parameters.infile, &parameters);", "                opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)", "                {", "                    opj_image_cmptparm_t cmptparm[4];", "                    OPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];", "                    OPJ_UINT8 const* pLUT[3];", "                    opj_image_t * image = NULL;", "                    FILE *IN;", "                    OPJ_BITMAPFILEHEADER File_h;", "                    OPJ_BITMAPINFOHEADER Info_h;", "                    OPJ_UINT32 i, palette_len, numcmpts = 1U;", "                    OPJ_BOOL l_result = OPJ_FALSE;", "                    OPJ_UINT8* pData = NULL;", "                    OPJ_UINT32 stride;", "                    pLUT[0] = lut_R;", "                    pLUT[1] = lut_G;", "                    pLUT[2] = lut_B;", "                    IN = fopen(filename, \"rb\");", "                    if (!IN) {", "                    if (!bmp_read_file_header(IN, &File_h)) {", "                    if (!bmp_read_info_header(IN, &Info_h)) {", "                    if (Info_h.biBitCount <= 8U) {", "                        memset(&lut_R[0], 0, sizeof(lut_R));", "                        memset(&lut_G[0], 0, sizeof(lut_G));", "                        memset(&lut_B[0], 0, sizeof(lut_B));", "                        palette_len = Info_h.biClrUsed;", "                        if ((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {", "                            palette_len = (1U << Info_h.biBitCount);", "                        }", "                        if (palette_len > 256U) {", "                            palette_len = 256U;", "                        }", "                        if (palette_len > 0U) {", "                            OPJ_UINT8 has_color = 0U;", "                            for (i = 0U; i < palette_len; i++) {", "                                lut_B[i] = (OPJ_UINT8)getc(IN);", "                                lut_G[i] = (OPJ_UINT8)getc(IN);", "                                lut_R[i] = (OPJ_UINT8)getc(IN);", "                                (void)getc(IN);", "                                has_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);", "                            }", "                            if (has_color) {", "                                numcmpts = 3U;", "                            }", "                        }", "                    } else {", "                        numcmpts = 3U;", "                        if ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {", "                            numcmpts++;", "                        }", "                    }", "                    if (Info_h.biWidth == 0 || Info_h.biHeight == 0) {", "                    if (Info_h.biBitCount > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {", "                    stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U;", "                    if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) {", "                        if (8 > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {", "                        stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;", "                    }", "                    if (stride > ((OPJ_UINT32) - 1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {", "                    pData = (OPJ_UINT8 *) calloc(1, sizeof(OPJ_UINT8) * stride * Info_h.biHeight);", "                    if (pData == NULL) {", "                    fseek(IN, 0, SEEK_SET);", "                    fseek(IN, (long)File_h.bfOffBits, SEEK_SET);", "                    switch (Info_h.biCompression) {", "                    case 0:", "                    case 3:", "                        l_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);", "                        break;", "                    case 1:", "                        l_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);", "            if (!image) {", "            break;", "        #ifdef OPJ_HAVE_LIBTIFF", "        case TIF_DFMT:", "            image = tiftoimage(parameters.infile, &parameters);", "            if (!image) {", "            break;", "        #endif", "        case RAW_DFMT:", "            image = rawtoimage(parameters.infile, &parameters, &raw_cp);", "            if (!image) {", "            break;", "        case RAWL_DFMT:", "            image = rawltoimage(parameters.infile, &parameters, &raw_cp);", "            if (!image) {", "            break;", "        case TGA_DFMT:", "            image = tgatoimage(parameters.infile, &parameters);", "            if (!image) {", "            break;", "        #ifdef OPJ_HAVE_LIBPNG", "        case PNG_DFMT:", "            image = pngtoimage(parameters.infile, &parameters);", "            if (!image) {", "            break;", "        #endif", "        }", "        if (!image) {", "        if (parameters.tcp_mct == (char)255) {", "            parameters.tcp_mct = (image->numcomps >= 3) ? 1 : 0;", "        } else {", "            if ((parameters.tcp_mct == 1) && (image->numcomps < 3)) {", "            if ((parameters.tcp_mct == 2) && (!parameters.mct_data)) {", "        }", "        switch (parameters.cod_format) {", "        case J2K_CFMT: {", "            l_codec = opj_create_compress(OPJ_CODEC_J2K);", "            break;", "        }", "        opj_set_info_handler(l_codec, info_callback, 00);", "        opj_set_warning_handler(l_codec, warning_callback, 00);", "        opj_set_error_handler(l_codec, error_callback, 00);", "        if (bUseTiles) {", "            parameters.cp_tx0 = 0;", "            parameters.cp_ty0 = 0;", "            parameters.tile_size_on = OPJ_TRUE;", "            parameters.cp_tdx = 512;", "            parameters.cp_tdy = 512;", "        }", "        if (! opj_setup_encoder(l_codec, &parameters, image)) {", "        l_stream = opj_stream_create_default_file_stream(parameters.outfile, OPJ_FALSE);", "        if (! l_stream) {", "        bSuccess = opj_start_compress(l_codec, image, l_stream);", "        if (!bSuccess)  {", "            fprintf(stderr, \"failed to encode image: opj_start_compress\\n\");", "        }", "        if (bSuccess && bUseTiles) {", "        } else {", "            bSuccess = bSuccess && opj_encode(l_codec, l_stream);", "OPJ_BOOL OPJ_CALLCONV opj_encode(opj_codec_t *p_info, opj_stream_t *p_stream)", "{", "    if (p_info && p_stream) {", "        opj_codec_private_t * l_codec = (opj_codec_private_t *) p_info;", "        opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;", "        if (! l_codec->is_decompressor) {", "            return l_codec->m_codec_data.m_compression.opj_encode(l_codec->m_codec, l_stream, &(l_codec->m_event_mgr));", "        }", "    }", "    return OPJ_FALSE;", "}", "opj_codec_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT p_format)", "{", "    opj_codec_private_t *l_codec = 00;", "    l_codec = (opj_codec_private_t*)opj_calloc(1, sizeof(opj_codec_private_t));", "    if (!l_codec) {", "        return 00;", "    }", "    l_codec->is_decompressor = 0;", "    switch (p_format) {", "    case OPJ_CODEC_J2K:", "        l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL(*)(void *, struct opj_stream_private *, struct opj_event_mgr *)) opj_j2k_encode;", "        break;", "    default:", "        break;", "    }", "    return (opj_codec_t*)l_codec;", "}", "OPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,", "                        opj_stream_private_t *p_stream,", "                        opj_event_mgr_t * p_manager)", "{", "    OPJ_UINT32 i, j;", "    OPJ_UINT32 l_nb_tiles;", "    OPJ_SIZE_T l_max_tile_size = 0, l_current_tile_size;", "    OPJ_BYTE * l_current_data = 00;", "    OPJ_BOOL l_reuse_data = OPJ_FALSE;", "    opj_tcd_t* p_tcd = 00;", "    assert(p_j2k != 00);", "    assert(p_stream != 00);", "    assert(p_manager != 00);", "    p_tcd = p_j2k->m_tcd;", "    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;", "    if (l_nb_tiles == 1) {", "        l_reuse_data = OPJ_TRUE;", "        #ifdef __SSE__", "        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {", "            opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;", "            if (((size_t)l_img_comp->data & 0xFU) !=", "                    0U) {", "                l_reuse_data = OPJ_FALSE;", "            }", "        }", "        #endif", "    }", "    for (i = 0; i < l_nb_tiles; ++i) {", "        if (! opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager)) {", "            if (l_current_data) {", "                opj_free(l_current_data);", "            }", "            return OPJ_FALSE;", "        }", "        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {", "            opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;", "            if (l_reuse_data) {", "                opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;", "                l_tilec->data  =  l_img_comp->data;", "                l_tilec->ownsData = OPJ_FALSE;", "            } else {", "                if (! opj_alloc_tile_component_data(l_tilec)) {", "                    opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\");", "                    if (l_current_data) {", "                        opj_free(l_current_data);", "                    }", "                    return OPJ_FALSE;", "                }", "            }", "        }", "        l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);", "        if (!l_reuse_data) {", "            if (l_current_tile_size > l_max_tile_size) {", "                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,", "                                               l_current_tile_size);", "                if (! l_new_current_data) {", "                    if (l_current_data) {", "                        opj_free(l_current_data);", "                    }", "                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to encode all tiles\\n\");", "                    return OPJ_FALSE;", "                }", "                l_current_data = l_new_current_data;", "                l_max_tile_size = l_current_tile_size;", "            }", "            if (l_current_data == NULL) {", "                assert(0);", "                return OPJ_FALSE;", "            }", "            opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);", "            if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data,", "                                         l_current_tile_size)) {", "                opj_event_msg(p_manager, EVT_ERROR,", "                              \"Size mismatch between tile data and sent data.\");", "                opj_free(l_current_data);", "                return OPJ_FALSE;", "            }", "        }", "        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {", "static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t * p_j2k,", "                                        opj_stream_private_t *p_stream,", "                                        opj_event_mgr_t * p_manager)", "{", "    OPJ_UINT32 l_nb_bytes_written;", "    OPJ_BYTE * l_current_data = 00;", "    OPJ_UINT32 l_tile_size = 0;", "    OPJ_UINT32 l_available_data;", "    assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);", "    l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;", "    l_available_data = l_tile_size;", "    l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;", "    l_nb_bytes_written = 0;", "    if (! opj_j2k_write_first_tile_part(p_j2k, l_current_data, &l_nb_bytes_written,", "                                        l_available_data, p_stream, p_manager)) {", "static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,", "        OPJ_BYTE * p_data,", "        OPJ_UINT32 * p_data_written,", "        OPJ_UINT32 p_total_data_size,", "        opj_stream_private_t *p_stream,", "        struct opj_event_mgr * p_manager)", "{", "    OPJ_UINT32 l_nb_bytes_written = 0;", "    OPJ_UINT32 l_current_nb_bytes_written;", "    OPJ_BYTE * l_begin_data = 00;", "    opj_tcd_t * l_tcd = 00;", "    opj_cp_t * l_cp = 00;", "    l_tcd = p_j2k->m_tcd;", "    l_cp = &(p_j2k->m_cp);", "    l_tcd->cur_pino = 0;", "    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;", "    l_current_nb_bytes_written = 0;", "    l_begin_data = p_data;", "    if (! opj_j2k_write_sot(p_j2k, p_data, p_total_data_size,", "                            &l_current_nb_bytes_written, p_stream,", "                            p_manager)) {", "        return OPJ_FALSE;", "    }", "    l_nb_bytes_written += l_current_nb_bytes_written;", "    p_data += l_current_nb_bytes_written;", "    p_total_data_size -= l_current_nb_bytes_written;", "    if (!OPJ_IS_CINEMA(l_cp->rsiz)) {", "        if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {", "            l_current_nb_bytes_written = 0;", "            opj_j2k_write_poc_in_memory(p_j2k, p_data, &l_current_nb_bytes_written,", "                                        p_manager);", "            l_nb_bytes_written += l_current_nb_bytes_written;", "            p_data += l_current_nb_bytes_written;", "            p_total_data_size -= l_current_nb_bytes_written;", "        }", "    }", "    l_current_nb_bytes_written = 0;", "    if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,", "                            p_total_data_size, p_stream, p_manager)) {", "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,", "                                  opj_tcd_t * p_tile_coder,", "                                  OPJ_BYTE * p_data,", "                                  OPJ_UINT32 * p_data_written,", "                                  OPJ_UINT32 p_total_data_size,", "                                  const opj_stream_private_t *p_stream,", "                                  opj_event_mgr_t * p_manager)", "{", "    opj_codestream_info_t *l_cstr_info = 00;", "    OPJ_UINT32 l_remaining_data;", "    assert(p_j2k != 00);", "    assert(p_manager != 00);", "    assert(p_stream != 00);", "    OPJ_UNUSED(p_stream);", "    if (p_total_data_size < 4) {", "    opj_write_bytes(p_data, J2K_MS_SOD,", "                    2);", "    p_data += 2;", "    l_remaining_data =  p_total_data_size - 4;", "    p_tile_coder->tp_num =", "        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;", "    p_tile_coder->cur_tp_num =", "        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;", "    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {", "        p_tile_coder->tcd_image->tiles->packno = 0;", "        #ifdef deadcode", "        if (l_cstr_info) {", "            l_cstr_info->packno = 0;", "        }", "        #endif", "    }", "    *p_data_written = 0;", "    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,", "                              p_data_written, p_total_data_size, l_cstr_info,", "                              p_manager))", "OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd,", "                             OPJ_UINT32 p_tile_no,", "                             OPJ_BYTE *p_dest,", "                             OPJ_UINT32 * p_data_written,", "                             OPJ_UINT32 p_max_length,", "                             opj_codestream_info_t *p_cstr_info,", "                             opj_event_mgr_t *p_manager)", "{", "    if (p_tcd->cur_tp_num == 0) {", "        p_tcd->tcd_tileno = p_tile_no;", "        p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];", "        if (p_cstr_info)  {", "            OPJ_UINT32 l_num_packs = 0;", "            OPJ_UINT32 i;", "            opj_tcd_tilecomp_t *l_tilec_idx =", "                &p_tcd->tcd_image->tiles->comps[0];", "            opj_tccp_t *l_tccp = p_tcd->tcp->tccps;", "            for (i = 0; i < l_tilec_idx->numresolutions; i++) {", "                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];", "                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;", "                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;", "                l_num_packs += l_res_idx->pw * l_res_idx->ph;", "                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];", "                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];", "            }", "            p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((", "                    OPJ_SIZE_T)p_cstr_info->numcomps * (OPJ_SIZE_T)p_cstr_info->numlayers *", "                                                  l_num_packs,", "                                                  sizeof(opj_packet_info_t));", "            if (!p_cstr_info->tile[p_tile_no].packet) {", "        }", "        if (! opj_tcd_dc_level_shift_encode(p_tcd)) {", "        if (! opj_tcd_mct_encode(p_tcd)) {", "        if (! opj_tcd_dwt_encode(p_tcd)) {", "        if (! opj_tcd_t1_encode(p_tcd)) {", "static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd)", "{", "    opj_t1_t * l_t1;", "    const OPJ_FLOAT64 * l_mct_norms;", "    OPJ_UINT32 l_mct_numcomps = 0U;", "    opj_tcp_t * l_tcp = p_tcd->tcp;", "    l_t1 = opj_t1_create(OPJ_TRUE);", "    if (l_t1 == 00) {", "        return OPJ_FALSE;", "    }", "    if (l_tcp->mct == 1) {", "        l_mct_numcomps = 3U;", "        if (l_tcp->tccps->qmfbid == 0) {", "            l_mct_norms = opj_mct_get_mct_norms_real();", "        } else {", "            l_mct_norms = opj_mct_get_mct_norms();", "        }", "    } else {", "        l_mct_numcomps = p_tcd->image->numcomps;", "        l_mct_norms = (const OPJ_FLOAT64 *)(l_tcp->mct_norms);", "    }", "    if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles, l_tcp, l_mct_norms,", "                              l_mct_numcomps)) {", "OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1,", "                             opj_tcd_tile_t *tile,", "                             opj_tcp_t *tcp,", "                             const OPJ_FLOAT64 * mct_norms,", "                             OPJ_UINT32 mct_numcomps)", "{", "    OPJ_UINT32 compno, resno, bandno, precno, cblkno;", "    tile->distotile = 0;", "    for (compno = 0; compno < tile->numcomps; ++compno) {", "        opj_tcd_tilecomp_t* tilec = &tile->comps[compno];", "        opj_tccp_t* tccp = &tcp->tccps[compno];", "        OPJ_UINT32 tile_w = (OPJ_UINT32)(tilec->x1 - tilec->x0);", "        for (resno = 0; resno < tilec->numresolutions; ++resno) {", "            opj_tcd_resolution_t *res = &tilec->resolutions[resno];", "            for (bandno = 0; bandno < res->numbands; ++bandno) {", "                opj_tcd_band_t* OPJ_RESTRICT band = &res->bands[bandno];", "                OPJ_INT32 bandconst;", "                if (opj_tcd_is_band_empty(band)) {", "                    continue;", "                }", "                bandconst = 8192 * 8192 / ((OPJ_INT32) floor(band->stepsize * 8192));", "                for (precno = 0; precno < res->pw * res->ph; ++precno) {", "                    opj_tcd_precinct_t *prc = &band->precincts[precno];", "                    for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {"], "tokenized": "int main(int  Var1,char **Var2){STRUCT1  Var3; STRUCT2 *Var4=00; STRUCT3 *Var5=00; STRUCT4 *Var6=NULL ; STRUCT5  Var7; STRUCT6  Var8=0; char  Var9[Var10]; unsigned int  Var11,Var12,Var13; STRUCT7  Var14; STRUCT8 *Var15=NULL ; int  Var16=0; STRUCT9  Var17; STRUCT9  Var18=Var19; STRUCT10  Var20=4; STRUCT11  Var21=FUNC1(); FUNC2(&Var3); *Var9=0; memset(&Var14,0,sizeof (STRUCT7)); Var7.memberVar1=0; Var7.memberVar2=0; Var7.memberVar3=0; Var7.memberVar4=0; Var7.memberVar5=0; Var7.memberVar6=0; Var3.memberVar1=(char ) 255; if (FUNC3(Var1,Var2,&Var3,&Var14,&Var7,Var9,sizeof (Var9)) == 1){if (Var14.memberVar1 == 1){Var12=FUNC4(Var14.memberVar2); Var15=(STRUCT8 *) malloc(sizeof (STRUCT8)); if (Var15){Var15->memberVar1=(char *) malloc(Var12 *Var10 *sizeof (char )); Var15->memberVar2=(char **) malloc(Var12 *sizeof (char *)); if (!Var15->memberVar1){for (Var11=0; Var11<Var12; Var11  Var22){Var15->memberVar2[Var11]=Var15->memberVar1+Var11 *Var10; }}if (FUNC5(Var15,Var14.memberVar2) == 1){if (Var12 == 0){}else {Var12=1; }for (Var13=0; Var13<Var12; Var13  Var22){Var6=NULL ; fprintf(Var23,STRING); if (Var14.memberVar1 == 1){if (FUNC6((int ) Var13,Var15,&Var14,&Var3)){fprintf(Var23,STRING); continue ; }}switch (Var3.memberVar2){case  STRUCT12 break ; case  STRUCT13 break ; case  STRUCT14 break ; case  STRUCT15 break ; case  STRUCT16 break ; case  STRUCT17 break ; case  STRUCT18 break ; case  STRUCT19 break ; default fprintf(Var23,STRING); continue ; }switch (Var3.memberVar2){case  STRUCT12  Var6=FUNC7(Var3.memberVar3,&Var3); if (!Var6){break ; case  STRUCT13  Var6=FUNC8(Var3.memberVar3,&Var3); if (!Var6){break ; case  STRUCT14  Var6=FUNC9(Var3.memberVar3,&Var3); STRUCT4 *FUNC9(const char *memberVar2,STRUCT1 *Var3){STRUCT20  Var24[4]; STRUCT21  Var25[256],Var26[256],Var27[256]; STRUCT21 const *Var28[3]; STRUCT4 *Var6=NULL ; STRUCT22 *Var29; STRUCT23  Var30; STRUCT24  Var31; STRUCT10  Var11,Var32,Var33=Var34; STRUCT9  Var35=Var19; STRUCT21 *Var36=NULL ; STRUCT10  Var37; Var28[0]=Var25; Var28[1]=Var26; Var28[2]=Var27; Var29=fopen(memberVar2,STRING); if (!Var29){if (!FUNC10(Var29,&Var30)){if (!FUNC11(Var29,&Var31)){if (Var31.memberVar1 <=  Var38){memset(&Var25[0],0,sizeof (Var25)); memset(&Var26[0],0,sizeof (Var26)); memset(&Var27[0],0,sizeof (Var27)); Var32=Var31.memberVar2; if ((Var32 ==  Var39)&&(Var31.memberVar1 <=  Var38)){Var32=(Var34<<Var31.memberVar1); }if (Var32>Var40){Var32=Var40; }if (Var32>Var39){STRUCT21  Var41=Var39; for (Var11=Var39; Var11<Var32; Var11  Var22){Var27[Var11]=(STRUCT21) getc(Var29); Var26[Var11]=(STRUCT21) getc(Var29); Var25[Var11]=(STRUCT21) getc(Var29); (void ) getc(Var29); Var41 FUNC12(Var27[Var11]Var26[Var11])|(Var26[Var11]Var25[Var11]); }if (Var41){Var33=Var42; }}}else {Var33=Var42; if ((Var31.memberVar3 == 3)&&(Var31.memberVar4 !=  Var39)){Var33  Var22; }}if (Var31.memberVar5 == 0||Var31.memberVar6 == 0){if (Var31.memberVar1>(((STRUCT10)-1)-31)/Var31.memberVar5){Var37=((Var31.memberVar5 *Var31.memberVar1+Var43)/Var44)*Var45; if (Var31.memberVar1 == 4&&Var31.memberVar3 == 2){if (8>(((STRUCT10)-1)-31)/Var31.memberVar5){Var37=((Var31.memberVar5 *Var38+Var43)/Var44)*Var45; }if (Var37>((STRUCT10)-1)/sizeof (STRUCT21)/Var31.memberVar6){Var36=(STRUCT21 *) calloc(1,sizeof (STRUCT21)*Var37 *Var31.memberVar6); if (Var36 == NULL ){FUNC13(Var29,0,Var46); FUNC13(Var29,(long ) Var30.memberVar1,Var46); switch (Var31.memberVar3){case 0case 3 Var35=FUNC14(Var29,Var36,Var37,Var31.memberVar5,Var31.memberVar6); break ; case 1 Var35=FUNC15(Var29,Var36,Var37,Var31.memberVar5,Var31.memberVar6); if (!Var6){break ; Var47  Var48 case  STRUCT15  Var6=FUNC16(Var3.memberVar3,&Var3); if (!Var6){break ; Var49 case  STRUCT16  Var6=FUNC17(Var3.memberVar3,&Var3,&Var7); if (!Var6){break ; case  STRUCT17  Var6=FUNC18(Var3.memberVar3,&Var3,&Var7); if (!Var6){break ; case  STRUCT18  Var6=FUNC19(Var3.memberVar3,&Var3); if (!Var6){break ; Var47  Var50 case  STRUCT19  Var6=FUNC20(Var3.memberVar3,&Var3); if (!Var6){break ; Var49}if (!Var6){if (Var3.memberVar1 == (char ) 255){Var3.memberVar1=(Var6->memberVar1 >= 3) 10; }else {if ((Var3.memberVar1 == 1)&&(Var6->memberVar1<3)){if ((Var3.memberVar1 == 2)&&(!Var3.memberVar4)){}switch (Var3.memberVar5){case  Var51{Var5=FUNC21(Var52); break ; }FUNC22(Var5,Var53,00); FUNC23(Var5,Var54,00); FUNC24(Var5,Var55,00); if (Var18){Var3.memberVar6=0; Var3.memberVar7=0; Var3.memberVar8=Var56; Var3.memberVar9=512; Var3.memberVar10=512; }if (!FUNC25(Var5,&Var3,Var6)){Var4=FUNC26(Var3.memberVar11,Var19); if (!Var4){Var17=FUNC27(Var5,Var6,Var4); if (!Var17){fprintf(Var23,STRING); }if (Var17&&Var18){}else {Var17=Var17&&FUNC28(Var5,Var4); STRUCT9  STRUCT25 FUNC28(STRUCT3 *Var57,STRUCT2 *Var58){if (Var57&&Var58){STRUCT26 *Var5=(STRUCT26 *) Var57; STRUCT27 *Var4=(STRUCT27 *) Var58; if (!Var5->memberVar1){return  Var5->memberVar2.memberVar1.FUNC28(Var5->memberVar3,Var4,&(Var5->memberVar4)); }}return  Var19; }STRUCT3 *STRUCT25 FUNC21(STRUCT28  Var59){STRUCT26 *Var5=00; Var5=(STRUCT26 *) FUNC29(1,sizeof (STRUCT26)); if (!Var5){return 00; }Var5->memberVar1=0; switch (Var59){case  Var52  Var5->memberVar2.memberVar1.memberVar1=(STRUCT9(*)(void *,struct STRUCT29 *,struct STRUCT30 *)) Var60; break ; default break ; }return (STRUCT3 *) Var5; }STRUCT9 Var60(STRUCT31 *Var61,STRUCT27 *Var58,STRUCT32 *Var62){STRUCT10  Var11,Var63; STRUCT10  Var20; STRUCT6  Var64=0,Var65; STRUCT33 *Var66=00; STRUCT9  Var67=Var19; STRUCT34 *Var68=00; assert(Var61 != 00); assert(Var58 != 00); assert(Var62 != 00); Var68=Var61->memberVar1; Var20=Var61->memberVar2.STRUCT35 *Var61->memberVar2.memberVar1; if (Var20 == 1){Var67=Var56; Var47  STRUCT36 for (Var63=0; Var63<Var61->memberVar1->memberVar1->memberVar1; Var22  Var63){STRUCT37 *Var69=Var68->memberVar1->memberVar2+Var63; if (((size_t ) Var69->memberVar1&Var70) !=  Var39){Var67=Var19; }}Var49}for (Var11=0; Var11<Var20; Var22  Var11){if (!FUNC30(Var61,Var11,Var58,Var62)){if (Var66){FUNC31(Var66); }return  Var19; }for (Var63=0; Var63<Var61->memberVar1->memberVar1->memberVar1; Var22  Var63){STRUCT38 *Var71=Var68->memberVar2->memberVar1->memberVar1+Var63; if (Var67){STRUCT37 *Var69=Var68->memberVar1->memberVar2+Var63; Var71->memberVar1=Var69->memberVar1; Var71->memberVar2=Var19; }else {if (!FUNC32(Var71)){FUNC33(Var62,Var72,STRING); if (Var66){FUNC31(Var66); }return  Var19; }}}Var65=FUNC34(Var61->memberVar1); if (!Var67){if (Var65>Var64){STRUCT33 *Var73=(STRUCT33 *) FUNC35(Var66,Var65); if (!Var73){if (Var66){FUNC31(Var66); }FUNC33(Var62,Var72,STRING); return  Var19; }Var66=Var73; Var64=Var65; }if (Var66 == NULL ){assert(0); return  Var19; }FUNC36(Var61->memberVar1,Var66); if (!FUNC37(Var61->memberVar1,Var66,Var65)){FUNC33(Var62,Var72,STRING); FUNC31(Var66); return  Var19; }}if (!FUNC38(Var61,Var58,Var62)){static  STRUCT9 FUNC38(STRUCT31 *Var61,STRUCT27 *Var58,STRUCT32 *Var62){STRUCT10  Var74; STRUCT33 *Var66=00; STRUCT10  Var75=0; STRUCT10  Var76; assert(Var61->memberVar3.memberVar1.memberVar1); Var75=Var61->memberVar3.memberVar1.memberVar2; Var76=Var75; Var66=Var61->memberVar3.memberVar1.memberVar1; Var74=0; if (!FUNC39(Var61,Var66,&Var74,Var76,Var58,Var62)){static  STRUCT9 FUNC39(STRUCT31 *Var61,STRUCT33 *Var77,STRUCT10 *Var78,STRUCT10  Var79,STRUCT27 *Var58,struct STRUCT30 *Var62){STRUCT10  Var74=0; STRUCT10  Var80; STRUCT33 *Var81=00; STRUCT34 *Var82=00; STRUCT39 *Var83=00; Var82=Var61->memberVar1; Var83=&(Var61->memberVar2); Var82->memberVar1=0; Var61->memberVar3.memberVar1.memberVar3=0; Var80=0; Var81=Var77; if (!FUNC40(Var61,Var77,Var79,&Var80,Var58,Var62)){return  Var19; }Var74  STRUCT40  Var80; Var77  STRUCT40  Var80; Var79  STRUCT41  Var80; if (!FUNC41(Var83->memberVar1)){if (Var83->memberVar2[Var61->memberVar4].memberVar1){Var80=0; FUNC42(Var61,Var77,&Var80,Var62); Var74  STRUCT40  Var80; Var77  STRUCT40  Var80; Var79  STRUCT41  Var80; }}Var80=0; if (!FUNC43(Var61,Var82,Var77,&Var80,Var79,Var58,Var62)){static  STRUCT9 FUNC43(STRUCT31 *Var61,STRUCT34 *Var84,STRUCT33 *Var77,STRUCT10 *Var78,STRUCT10  Var79,const STRUCT27 *Var58,STRUCT32 *Var62){STRUCT42 *Var85=00; STRUCT10  Var86; assert(Var61 != 00); assert(Var62 != 00); assert(Var58 != 00); FUNC44(Var58); if (Var79<4){FUNC45(Var77,Var87,2); Var77  STRUCT40 2; Var86=Var79-4; Var84->memberVar1=Var61->memberVar3.memberVar1.memberVar3; Var84->memberVar2=Var61->memberVar3.memberVar1.memberVar4; if (Var61->memberVar3.memberVar1.memberVar4 == 0){Var84->memberVar3->memberVar1->memberVar2=0; Var47  STRUCT43 if (Var85){Var85->memberVar1=0; }Var49}*Var78=0; if (!FUNC46(Var84,Var61->memberVar4,Var77,Var78,Var79,Var85,Var62)) STRUCT9 FUNC46(STRUCT34 *Var68,STRUCT10  Var88,STRUCT33 *Var89,STRUCT10 *Var78,STRUCT10  Var90,STRUCT42 *Var91,STRUCT32 *Var62){if (Var68->memberVar3 == 0){Var68->memberVar4=Var88; Var68->memberVar5=&Var68->memberVar6->memberVar1[Var88]; if (Var91){STRUCT10  Var92=0; STRUCT10  Var11; STRUCT38 *Var93=&Var68->memberVar2->memberVar1->memberVar1[0]; STRUCT44 *Var94=Var68->memberVar5->memberVar1; for (Var11=0; Var11<Var93->memberVar1; Var11  Var22){STRUCT45 *Var95=&Var93->memberVar2[Var11]; Var91->memberVar1[Var88].memberVar1[Var11]=(int ) Var95->memberVar1; Var91->memberVar1[Var88].memberVar2[Var11]=(int ) Var95->memberVar2; Var92  STRUCT40  Var95->memberVar1 *Var95->memberVar2; Var91->memberVar1[Var88].memberVar3[Var11]=(int ) Var94->memberVar1[Var11]; Var91->memberVar1[Var88].memberVar4[Var11]=(int ) Var94->memberVar2[Var11]; }Var91->memberVar1[Var88].memberVar5=(STRUCT46 *) FUNC29((STRUCT6) Var91->memberVar1 *(STRUCT6) Var91->STRUCT47 *Var92,sizeof (STRUCT46)); if (!Var91->memberVar1[Var88].memberVar5){}if (!FUNC47(Var68)){if (!FUNC48(Var68)){if (!FUNC49(Var68)){if (!FUNC50(Var68)){static  STRUCT9 FUNC50(STRUCT34 *Var68){STRUCT48 *Var96; const STRUCT11 *Var97; STRUCT10  Var98=Var39; STRUCT49 *Var99=Var68->memberVar5; Var96=FUNC51(Var56); if (Var96 == 00){return  Var19; }if (Var99->memberVar1 == 1){Var98=Var42; if (Var99->memberVar2->memberVar1 == 0){Var97=FUNC52(); }else {Var97=FUNC53(); }}else {Var98=Var68->memberVar1->memberVar1; Var97=(const STRUCT11 *)(Var99->memberVar3); }if (!FUNC54(Var96,Var68->memberVar2->memberVar1,Var99,Var97,Var98)){STRUCT9 FUNC54(STRUCT48 *Var100,STRUCT50 *memberVar1,STRUCT49 *memberVar5,const STRUCT11 *memberVar3,STRUCT10  Var101){STRUCT10  Var102,Var103,Var104,Var105,Var106; memberVar1->memberVar1=0; for (Var102=0; Var102<memberVar1->memberVar2; Var22  Var102){STRUCT38 *Var107=&memberVar1->memberVar3[Var102]; STRUCT44 *Var108=&memberVar5->memberVar1[Var102]; STRUCT10  Var109=(STRUCT10)(Var107->memberVar1-Var107->memberVar2); for (Var103=0; Var103<Var107->memberVar3; Var22  Var103){STRUCT45 *Var110=&Var107->memberVar4[Var103]; for (Var104=0; Var104<Var110->memberVar1; Var22  Var104){STRUCT51 *STRUCT52  Var111=&Var110->memberVar2[Var104]; STRUCT53  Var112; if (FUNC55(Var111)){continue ; }Var112=8192*8192/((STRUCT53) FUNC56(Var111->STRUCT54 *8192)); for (Var105=0; Var105<Var110->memberVar1 *Var110->memberVar3; Var22  Var105){STRUCT55 *Var113=&Var111->memberVar1[Var105]; for (Var106=0; Var106<Var113->STRUCT56 *Var113->memberVar1; Var22  Var106){"}]