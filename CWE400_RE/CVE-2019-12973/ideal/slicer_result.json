[
    {
        "FileName": "before_convertbmp.c",
        "Caller": "opj_t1_encode_cblks",
        "Source": false,
        "Sink": false,
        "idx": 0,
        "CWE-ID": "CWE-",
        "category": "CallExpression",
        "criterion": "N/A",
        "line": 330,
        "label": -3,
        "slices": [
                    "int main(int argc, char **argv)",
                    "{",
                    "    opj_cparameters_t parameters;",
                    "    opj_stream_t *l_stream = 00;",
                    "    opj_codec_t* l_codec = 00;",
                    "    opj_image_t *image = NULL;",
                    "    raw_cparameters_t raw_cp;",
                    "    OPJ_SIZE_T num_compressed_files = 0;",
                    "    char indexfilename[OPJ_PATH_LEN];",
                    "    unsigned int i, num_images, imageno;",
                    "    img_fol_t img_fol;",
                    "    dircnt_t *dirptr = NULL;",
                    "    int ret = 0;",
                    "    OPJ_BOOL bSuccess;",
                    "    OPJ_BOOL bUseTiles = OPJ_FALSE;",
                    "    OPJ_UINT32 l_nb_tiles = 4;",
                    "    OPJ_FLOAT64 t = opj_clock();",
                    "    opj_set_default_encoder_parameters(&parameters);",
                    "    *indexfilename = 0;",
                    "    memset(&img_fol, 0, sizeof(img_fol_t));",
                    "    raw_cp.rawBitDepth = 0;",
                    "    raw_cp.rawComp = 0;",
                    "    raw_cp.rawComps = 0;",
                    "    raw_cp.rawHeight = 0;",
                    "    raw_cp.rawSigned = 0;",
                    "    raw_cp.rawWidth = 0;",
                    "    parameters.tcp_mct = (char)255;",
                    "    if (parse_cmdline_encoder(argc, argv, &parameters, &img_fol, &raw_cp, indexfilename, sizeof(indexfilename)) == 1) {",
                    "    if (img_fol.set_imgdir == 1) {",
                    "        num_images = get_num_images(img_fol.imgdirpath);",
                    "        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));",
                    "        if (dirptr) {",
                    "            dirptr->filename_buf = (char*)malloc(num_images * OPJ_PATH_LEN * sizeof(char));",
                    "            dirptr->filename = (char**) malloc(num_images * sizeof(char*));",
                    "            if (!dirptr->filename_buf) {",
                    "            for (i = 0; i < num_images; i++) {",
                    "                dirptr->filename[i] = dirptr->filename_buf + i * OPJ_PATH_LEN;",
                    "            }",
                    "        }",
                    "        if (load_images(dirptr, img_fol.imgdirpath) == 1) {",
                    "        if (num_images == 0) {",
                    "    } else {",
                    "        num_images = 1;",
                    "    }",
                    "    for (imageno = 0; imageno < num_images; imageno++) {",
                    "        image = NULL;",
                    "        fprintf(stderr, \"\\n\");",
                    "        if (img_fol.set_imgdir == 1) {",
                    "            if (get_next_file((int)imageno, dirptr, &img_fol, &parameters)) {",
                    "                fprintf(stderr, \"skipping file...\\n\");",
                    "                continue;",
                    "            }",
                    "        }",
                    "        switch (parameters.decod_format) {",
                    "        case PGX_DFMT:",
                    "            break;",
                    "        case PXM_DFMT:",
                    "            break;",
                    "        case BMP_DFMT:",
                    "            break;",
                    "        case TIF_DFMT:",
                    "            break;",
                    "        case RAW_DFMT:",
                    "            break;",
                    "        case RAWL_DFMT:",
                    "            break;",
                    "        case TGA_DFMT:",
                    "            break;",
                    "        case PNG_DFMT:",
                    "            break;",
                    "        default:",
                    "            fprintf(stderr, \"skipping file...\\n\");",
                    "            continue;",
                    "        }",
                    "        switch (parameters.decod_format) {",
                    "        case PGX_DFMT:",
                    "            image = pgxtoimage(parameters.infile, &parameters);",
                    "            if (!image) {",
                    "            break;",
                    "        case PXM_DFMT:",
                    "            image = pnmtoimage(parameters.infile, &parameters);",
                    "            if (!image) {",
                    "            break;",
                    "        case BMP_DFMT:",
                    "            image = bmptoimage(parameters.infile, &parameters);",
                    "                opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)",
                    "                {",
                    "                    opj_image_cmptparm_t cmptparm[4];",
                    "                    OPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];",
                    "                    OPJ_UINT8 const* pLUT[3];",
                    "                    opj_image_t * image = NULL;",
                    "                    FILE *IN;",
                    "                    OPJ_BITMAPFILEHEADER File_h;",
                    "                    OPJ_BITMAPINFOHEADER Info_h;",
                    "                    OPJ_UINT32 i, palette_len, numcmpts = 1U;",
                    "                    OPJ_BOOL l_result = OPJ_FALSE;",
                    "                    OPJ_UINT8* pData = NULL;",
                    "                    OPJ_UINT32 stride;",
                    "                    pLUT[0] = lut_R;",
                    "                    pLUT[1] = lut_G;",
                    "                    pLUT[2] = lut_B;",
                    "                    IN = fopen(filename, \"rb\");",
                    "                    if (!IN) {",
                    "                    if (!bmp_read_file_header(IN, &File_h)) {",
                    "                    if (!bmp_read_info_header(IN, &Info_h)) {",
                    "                    if (Info_h.biBitCount <= 8U) {",
                    "                        memset(&lut_R[0], 0, sizeof(lut_R));",
                    "                        memset(&lut_G[0], 0, sizeof(lut_G));",
                    "                        memset(&lut_B[0], 0, sizeof(lut_B));",
                    "                        palette_len = Info_h.biClrUsed;",
                    "                        if ((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {",
                    "                            palette_len = (1U << Info_h.biBitCount);",
                    "                        }",
                    "                        if (palette_len > 256U) {",
                    "                            palette_len = 256U;",
                    "                        }",
                    "                        if (palette_len > 0U) {",
                    "                            OPJ_UINT8 has_color = 0U;",
                    "                            for (i = 0U; i < palette_len; i++) {",
                    "                                lut_B[i] = (OPJ_UINT8)getc(IN);",
                    "                                lut_G[i] = (OPJ_UINT8)getc(IN);",
                    "                                lut_R[i] = (OPJ_UINT8)getc(IN);",
                    "                                (void)getc(IN);",
                    "                                has_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);",
                    "                            }",
                    "                            if (has_color) {",
                    "                                numcmpts = 3U;",
                    "                            }",
                    "                        }",
                    "                    } else {",
                    "                        numcmpts = 3U;",
                    "                        if ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {",
                    "                            numcmpts++;",
                    "                        }",
                    "                    }",
                    "                    if (Info_h.biWidth == 0 || Info_h.biHeight == 0) {",
                    "                    if (Info_h.biBitCount > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {",
                    "                    stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U;",
                    "                    if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) {",
                    "                        if (8 > (((OPJ_UINT32) - 1) - 31) / Info_h.biWidth) {",
                    "                        stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;",
                    "                    }",
                    "                    if (stride > ((OPJ_UINT32) - 1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {",
                    "                    pData = (OPJ_UINT8 *) calloc(1, sizeof(OPJ_UINT8) * stride * Info_h.biHeight);",
                    "                    if (pData == NULL) {",
                    "                    fseek(IN, 0, SEEK_SET);",
                    "                    fseek(IN, (long)File_h.bfOffBits, SEEK_SET);",
                    "                    switch (Info_h.biCompression) {",
                    "                    case 0:",
                    "                    case 3:",
                    "                        l_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);",
                    "                        break;",
                    "                    case 1:",
                    "                        l_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);",
                    "            if (!image) {",
                    "            break;",
                    "        #ifdef OPJ_HAVE_LIBTIFF",
                    "        case TIF_DFMT:",
                    "            image = tiftoimage(parameters.infile, &parameters);",
                    "            if (!image) {",
                    "            break;",
                    "        #endif",
                    "        case RAW_DFMT:",
                    "            image = rawtoimage(parameters.infile, &parameters, &raw_cp);",
                    "            if (!image) {",
                    "            break;",
                    "        case RAWL_DFMT:",
                    "            image = rawltoimage(parameters.infile, &parameters, &raw_cp);",
                    "            if (!image) {",
                    "            break;",
                    "        case TGA_DFMT:",
                    "            image = tgatoimage(parameters.infile, &parameters);",
                    "            if (!image) {",
                    "            break;",
                    "        #ifdef OPJ_HAVE_LIBPNG",
                    "        case PNG_DFMT:",
                    "            image = pngtoimage(parameters.infile, &parameters);",
                    "            if (!image) {",
                    "            break;",
                    "        #endif",
                    "        }",
                    "        if (!image) {",
                    "        if (parameters.tcp_mct == (char)255) {",
                    "            parameters.tcp_mct = (image->numcomps >= 3) ? 1 : 0;",
                    "        } else {",
                    "            if ((parameters.tcp_mct == 1) && (image->numcomps < 3)) {",
                    "            if ((parameters.tcp_mct == 2) && (!parameters.mct_data)) {",
                    "        }",
                    "        switch (parameters.cod_format) {",
                    "        case J2K_CFMT: {",
                    "            l_codec = opj_create_compress(OPJ_CODEC_J2K);",
                    "            break;",
                    "        }",
                    "        opj_set_info_handler(l_codec, info_callback, 00);",
                    "        opj_set_warning_handler(l_codec, warning_callback, 00);",
                    "        opj_set_error_handler(l_codec, error_callback, 00);",
                    "        if (bUseTiles) {",
                    "            parameters.cp_tx0 = 0;",
                    "            parameters.cp_ty0 = 0;",
                    "            parameters.tile_size_on = OPJ_TRUE;",
                    "            parameters.cp_tdx = 512;",
                    "            parameters.cp_tdy = 512;",
                    "        }",
                    "        if (! opj_setup_encoder(l_codec, &parameters, image)) {",
                    "        l_stream = opj_stream_create_default_file_stream(parameters.outfile, OPJ_FALSE);",
                    "        if (! l_stream) {",
                    "        bSuccess = opj_start_compress(l_codec, image, l_stream);",
                    "        if (!bSuccess)  {",
                    "            fprintf(stderr, \"failed to encode image: opj_start_compress\\n\");",
                    "        }",
                    "        if (bSuccess && bUseTiles) {",
                    "        } else {",
                    "            bSuccess = bSuccess && opj_encode(l_codec, l_stream);",
                    "OPJ_BOOL OPJ_CALLCONV opj_encode(opj_codec_t *p_info, opj_stream_t *p_stream)",
                    "{",
                    "    if (p_info && p_stream) {",
                    "        opj_codec_private_t * l_codec = (opj_codec_private_t *) p_info;",
                    "        opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;",
                    "        if (! l_codec->is_decompressor) {",
                    "            return l_codec->m_codec_data.m_compression.opj_encode(l_codec->m_codec, l_stream, &(l_codec->m_event_mgr));",
                    "        }",
                    "    }",
                    "    return OPJ_FALSE;",
                    "}",
                    "opj_codec_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT p_format)",
                    "{",
                    "    opj_codec_private_t *l_codec = 00;",
                    "    l_codec = (opj_codec_private_t*)opj_calloc(1, sizeof(opj_codec_private_t));",
                    "    if (!l_codec) {",
                    "        return 00;",
                    "    }",
                    "    l_codec->is_decompressor = 0;",
                    "    switch (p_format) {",
                    "    case OPJ_CODEC_J2K:",
                    "        l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL(*)(void *, struct opj_stream_private *, struct opj_event_mgr *)) opj_j2k_encode;",
                    "        break;",
                    "    default:",
                    "        break;",
                    "    }",
                    "    return (opj_codec_t*)l_codec;",
                    "}",
                    "OPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,",
                    "                        opj_stream_private_t *p_stream,",
                    "                        opj_event_mgr_t * p_manager)",
                    "{",
                    "    OPJ_UINT32 i, j;",
                    "    OPJ_UINT32 l_nb_tiles;",
                    "    OPJ_SIZE_T l_max_tile_size = 0, l_current_tile_size;",
                    "    OPJ_BYTE * l_current_data = 00;",
                    "    OPJ_BOOL l_reuse_data = OPJ_FALSE;",
                    "    opj_tcd_t* p_tcd = 00;",
                    "    assert(p_j2k != 00);",
                    "    assert(p_stream != 00);",
                    "    assert(p_manager != 00);",
                    "    p_tcd = p_j2k->m_tcd;",
                    "    l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;",
                    "    if (l_nb_tiles == 1) {",
                    "        l_reuse_data = OPJ_TRUE;",
                    "        #ifdef __SSE__",
                    "        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {",
                    "            opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;",
                    "            if (((size_t)l_img_comp->data & 0xFU) !=",
                    "                    0U) {",
                    "                l_reuse_data = OPJ_FALSE;",
                    "            }",
                    "        }",
                    "        #endif",
                    "    }",
                    "    for (i = 0; i < l_nb_tiles; ++i) {",
                    "        if (! opj_j2k_pre_write_tile(p_j2k, i, p_stream, p_manager)) {",
                    "            if (l_current_data) {",
                    "                opj_free(l_current_data);",
                    "            }",
                    "            return OPJ_FALSE;",
                    "        }",
                    "        for (j = 0; j < p_j2k->m_tcd->image->numcomps; ++j) {",
                    "            opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;",
                    "            if (l_reuse_data) {",
                    "                opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;",
                    "                l_tilec->data  =  l_img_comp->data;",
                    "                l_tilec->ownsData = OPJ_FALSE;",
                    "            } else {",
                    "                if (! opj_alloc_tile_component_data(l_tilec)) {",
                    "                    opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\");",
                    "                    if (l_current_data) {",
                    "                        opj_free(l_current_data);",
                    "                    }",
                    "                    return OPJ_FALSE;",
                    "                }",
                    "            }",
                    "        }",
                    "        l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);",
                    "        if (!l_reuse_data) {",
                    "            if (l_current_tile_size > l_max_tile_size) {",
                    "                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data,",
                    "                                               l_current_tile_size);",
                    "                if (! l_new_current_data) {",
                    "                    if (l_current_data) {",
                    "                        opj_free(l_current_data);",
                    "                    }",
                    "                    opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to encode all tiles\\n\");",
                    "                    return OPJ_FALSE;",
                    "                }",
                    "                l_current_data = l_new_current_data;",
                    "                l_max_tile_size = l_current_tile_size;",
                    "            }",
                    "            if (l_current_data == NULL) {",
                    "                assert(0);",
                    "                return OPJ_FALSE;",
                    "            }",
                    "            opj_j2k_get_tile_data(p_j2k->m_tcd, l_current_data);",
                    "            if (! opj_tcd_copy_tile_data(p_j2k->m_tcd, l_current_data,",
                    "                                         l_current_tile_size)) {",
                    "                opj_event_msg(p_manager, EVT_ERROR,",
                    "                              \"Size mismatch between tile data and sent data.\");",
                    "                opj_free(l_current_data);",
                    "                return OPJ_FALSE;",
                    "            }",
                    "        }",
                    "        if (! opj_j2k_post_write_tile(p_j2k, p_stream, p_manager)) {",
                    "static OPJ_BOOL opj_j2k_post_write_tile(opj_j2k_t * p_j2k,",
                    "                                        opj_stream_private_t *p_stream,",
                    "                                        opj_event_mgr_t * p_manager)",
                    "{",
                    "    OPJ_UINT32 l_nb_bytes_written;",
                    "    OPJ_BYTE * l_current_data = 00;",
                    "    OPJ_UINT32 l_tile_size = 0;",
                    "    OPJ_UINT32 l_available_data;",
                    "    assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);",
                    "    l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;",
                    "    l_available_data = l_tile_size;",
                    "    l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;",
                    "    l_nb_bytes_written = 0;",
                    "    if (! opj_j2k_write_first_tile_part(p_j2k, l_current_data, &l_nb_bytes_written,",
                    "                                        l_available_data, p_stream, p_manager)) {",
                    "static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,",
                    "        OPJ_BYTE * p_data,",
                    "        OPJ_UINT32 * p_data_written,",
                    "        OPJ_UINT32 p_total_data_size,",
                    "        opj_stream_private_t *p_stream,",
                    "        struct opj_event_mgr * p_manager)",
                    "{",
                    "    OPJ_UINT32 l_nb_bytes_written = 0;",
                    "    OPJ_UINT32 l_current_nb_bytes_written;",
                    "    OPJ_BYTE * l_begin_data = 00;",
                    "    opj_tcd_t * l_tcd = 00;",
                    "    opj_cp_t * l_cp = 00;",
                    "    l_tcd = p_j2k->m_tcd;",
                    "    l_cp = &(p_j2k->m_cp);",
                    "    l_tcd->cur_pino = 0;",
                    "    p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;",
                    "    l_current_nb_bytes_written = 0;",
                    "    l_begin_data = p_data;",
                    "    if (! opj_j2k_write_sot(p_j2k, p_data, p_total_data_size,",
                    "                            &l_current_nb_bytes_written, p_stream,",
                    "                            p_manager)) {",
                    "        return OPJ_FALSE;",
                    "    }",
                    "    l_nb_bytes_written += l_current_nb_bytes_written;",
                    "    p_data += l_current_nb_bytes_written;",
                    "    p_total_data_size -= l_current_nb_bytes_written;",
                    "    if (!OPJ_IS_CINEMA(l_cp->rsiz)) {",
                    "        if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {",
                    "            l_current_nb_bytes_written = 0;",
                    "            opj_j2k_write_poc_in_memory(p_j2k, p_data, &l_current_nb_bytes_written,",
                    "                                        p_manager);",
                    "            l_nb_bytes_written += l_current_nb_bytes_written;",
                    "            p_data += l_current_nb_bytes_written;",
                    "            p_total_data_size -= l_current_nb_bytes_written;",
                    "        }",
                    "    }",
                    "    l_current_nb_bytes_written = 0;",
                    "    if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,",
                    "                            p_total_data_size, p_stream, p_manager)) {",
                    "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,",
                    "                                  opj_tcd_t * p_tile_coder,",
                    "                                  OPJ_BYTE * p_data,",
                    "                                  OPJ_UINT32 * p_data_written,",
                    "                                  OPJ_UINT32 p_total_data_size,",
                    "                                  const opj_stream_private_t *p_stream,",
                    "                                  opj_event_mgr_t * p_manager)",
                    "{",
                    "    opj_codestream_info_t *l_cstr_info = 00;",
                    "    OPJ_UINT32 l_remaining_data;",
                    "    assert(p_j2k != 00);",
                    "    assert(p_manager != 00);",
                    "    assert(p_stream != 00);",
                    "    OPJ_UNUSED(p_stream);",
                    "    if (p_total_data_size < 4) {",
                    "    opj_write_bytes(p_data, J2K_MS_SOD,",
                    "                    2);",
                    "    p_data += 2;",
                    "    l_remaining_data =  p_total_data_size - 4;",
                    "    p_tile_coder->tp_num =",
                    "        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;",
                    "    p_tile_coder->cur_tp_num =",
                    "        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;",
                    "    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {",
                    "        p_tile_coder->tcd_image->tiles->packno = 0;",
                    "        #ifdef deadcode",
                    "        if (l_cstr_info) {",
                    "            l_cstr_info->packno = 0;",
                    "        }",
                    "        #endif",
                    "    }",
                    "    *p_data_written = 0;",
                    "    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,",
                    "                              p_data_written, p_total_data_size, l_cstr_info,",
                    "                              p_manager))",
                    "OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd,",
                    "                             OPJ_UINT32 p_tile_no,",
                    "                             OPJ_BYTE *p_dest,",
                    "                             OPJ_UINT32 * p_data_written,",
                    "                             OPJ_UINT32 p_max_length,",
                    "                             opj_codestream_info_t *p_cstr_info,",
                    "                             opj_event_mgr_t *p_manager)",
                    "{",
                    "    if (p_tcd->cur_tp_num == 0) {",
                    "        p_tcd->tcd_tileno = p_tile_no;",
                    "        p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];",
                    "        if (p_cstr_info)  {",
                    "            OPJ_UINT32 l_num_packs = 0;",
                    "            OPJ_UINT32 i;",
                    "            opj_tcd_tilecomp_t *l_tilec_idx =",
                    "                &p_tcd->tcd_image->tiles->comps[0];",
                    "            opj_tccp_t *l_tccp = p_tcd->tcp->tccps;",
                    "            for (i = 0; i < l_tilec_idx->numresolutions; i++) {",
                    "                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];",
                    "                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;",
                    "                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;",
                    "                l_num_packs += l_res_idx->pw * l_res_idx->ph;",
                    "                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];",
                    "                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];",
                    "            }",
                    "            p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((",
                    "                    OPJ_SIZE_T)p_cstr_info->numcomps * (OPJ_SIZE_T)p_cstr_info->numlayers *",
                    "                                                  l_num_packs,",
                    "                                                  sizeof(opj_packet_info_t));",
                    "            if (!p_cstr_info->tile[p_tile_no].packet) {",
                    "        }",
                    "        if (! opj_tcd_dc_level_shift_encode(p_tcd)) {",
                    "        if (! opj_tcd_mct_encode(p_tcd)) {",
                    "        if (! opj_tcd_dwt_encode(p_tcd)) {",
                    "        if (! opj_tcd_t1_encode(p_tcd)) {",
                    "static OPJ_BOOL opj_tcd_t1_encode(opj_tcd_t *p_tcd)",
                    "{",
                    "    opj_t1_t * l_t1;",
                    "    const OPJ_FLOAT64 * l_mct_norms;",
                    "    OPJ_UINT32 l_mct_numcomps = 0U;",
                    "    opj_tcp_t * l_tcp = p_tcd->tcp;",
                    "    l_t1 = opj_t1_create(OPJ_TRUE);",
                    "    if (l_t1 == 00) {",
                    "        return OPJ_FALSE;",
                    "    }",
                    "    if (l_tcp->mct == 1) {",
                    "        l_mct_numcomps = 3U;",
                    "        if (l_tcp->tccps->qmfbid == 0) {",
                    "            l_mct_norms = opj_mct_get_mct_norms_real();",
                    "        } else {",
                    "            l_mct_norms = opj_mct_get_mct_norms();",
                    "        }",
                    "    } else {",
                    "        l_mct_numcomps = p_tcd->image->numcomps;",
                    "        l_mct_norms = (const OPJ_FLOAT64 *)(l_tcp->mct_norms);",
                    "    }",
                    "    if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles, l_tcp, l_mct_norms,",
                    "                              l_mct_numcomps)) {",
                    "OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1,",
                    "                             opj_tcd_tile_t *tile,",
                    "                             opj_tcp_t *tcp,",
                    "                             const OPJ_FLOAT64 * mct_norms,",
                    "                             OPJ_UINT32 mct_numcomps)",
                    "{",
                    "    OPJ_UINT32 compno, resno, bandno, precno, cblkno;",
                    "    tile->distotile = 0;",
                    "    for (compno = 0; compno < tile->numcomps; ++compno) {",
                    "        opj_tcd_tilecomp_t* tilec = &tile->comps[compno];",
                    "        opj_tccp_t* tccp = &tcp->tccps[compno];",
                    "        OPJ_UINT32 tile_w = (OPJ_UINT32)(tilec->x1 - tilec->x0);",
                    "        for (resno = 0; resno < tilec->numresolutions; ++resno) {",
                    "            opj_tcd_resolution_t *res = &tilec->resolutions[resno];",
                    "            for (bandno = 0; bandno < res->numbands; ++bandno) {",
                    "                opj_tcd_band_t* OPJ_RESTRICT band = &res->bands[bandno];",
                    "                OPJ_INT32 bandconst;",
                    "                if (opj_tcd_is_band_empty(band)) {",
                    "                    continue;",
                    "                }",
                    "                bandconst = 8192 * 8192 / ((OPJ_INT32) floor(band->stepsize * 8192));",
                    "                for (precno = 0; precno < res->pw * res->ph; ++precno) {",
                    "                    opj_tcd_precinct_t *prc = &band->precincts[precno];",
                    "                    for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {"
        ]
    }
]