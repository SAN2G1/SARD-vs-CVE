# 📁 CVE-2019-17351

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/torvalds/linux/commit/6f0c4d4f7c6c)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2019-17351)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/400.html)**

> Linux 커널의 Xen 메모리 풍선(balloon) 드라이버의 `balloon_process()` 함수에서 발생한 Resource Exhaustion(CWE-400) 취약점입니다.

* **Source**: 사용자가 balloon_set_new_target()을 통해 target 값을 설정 → credit = target_pages - current_pages 계산 → balloon_process()가 워크큐에 등록됨

* **취약 조건**: balloon_stats.max_retry_count = RETRY_UNLIMITED으로 설정됨 → BP_EAGAIN 상태가 반복되어도 루프가 종료되지 않음

* **취약 조건(메모리 할당의 경우)**: credit > 0이면서 balloon_is_inflated() == true일 경우에만 → increase_reservation() 경로로 진입

* **Sink**: 
- credit > 0이면 → increase_reservation() → Xen 하이퍼콜 실패 시 BP_EAGAIN 반환
- credit < 0이면 → decrease_reservation() → alloc_page() 실패 시 BP_EAGAIN 반환
- → update_schedule()에서 delay 증가 및 retry count 갱신
- → BP_EAGAIN 상태 유지 시 balloon_process()가 워크큐에 다시 등록됨
- → 이 루프가 무제한 반복되어 CPU와 워크큐 자원을 지속적으로 소모
- → 결국 CWE-400 (Resource Exhaustion) 상태로 이어짐


## 탐지 결과 요약
슬라이스 미탐지

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **부적절한 criterion**
    - CWE400의 SARD/README.md에 따르면 
        > ```bash
        > C:\Users\user\Downloads\xsv-0.13.0-i686-pc-windows-gnu>xsv search -s predict 1 C:\Users\user\Desktop\SARD-vs-CVE\CWE400_RE\SARD\test_output.csv | xsv select criterion | xsv frequency -s criterion | xsv select value
        > 
        > value
        > strlen
        > fopen
        > fwrite
        > fclose
        > ```
    - 이 취약점은 alloc_page()와 xenmem_reservation_increase() 같은 커널 내부 함수에 의존하여 동작하지만, 이들 중 alloc_page()는 커널 전용 메모리 할당 함수이고, xenmem_reservation_increase()는 Xen 하이퍼바이저와의 메모리 교환을 위한 인터페이스 함수이다. 슬라이서가 이러한 함수들을 criterion으로 인식하지 못할 경우, 실제로는 재시도 루프 조건이 존재하더라도 슬라이스가 생성되지 않아 취약하지 않은 코드로 오판될 수 있다.
    - 특히 alloc_page()는 슬라이서의 l_funcs 필터 기준에 '\*alloc'은 포함되어 있으나 'alloc\*'은 포함되어 있지 않아 탐지되지 않은 것으로 보인다
    - 이 함수는 decrease_reservation() (before_balloon.c:459) 내부에서 호출되며, 실제 호출 위치는 before_balloon.c:471이다.
    - 또한 xenmem_reservation_increase()는 Xen 하이퍼바이저가 메모리 증가 요청을 거부할 경우 실패하며, 이는 게스트 외부의 상태에 따라 유발될 수 있는 비의도적 실패이다.
    - 이 함수는 increase_reservation() (before_balloon.c:419) 내부에서 호출되며, 실제 호출 위치는 before_balloon.c:439이다

---

## 취약점 세부 사항 ① – decrease_reservation() 경로 (메모리 반환)

### ❗️ 취약 코드

#### Source1: 사용자가 설정한 target 값(before_balloon.c:558)
```c
void balloon_set_new_target(unsigned long target)
{
    /* No need for lock. Not read-modify-write updates. */
    balloon_stats.target_pages = target;
    schedule_delayed_work(&balloon_worker, 0); // 워크큐 등록
}
```
사용자가 balloon_set_new_target()을 통해 현재보다 작은 target 값을 설정하면, 시스템은 메모리 반환 작업을 수행하기 위해 balloon_process()를 실행하게 된다.

#### Source2: 초기 설정값 – 무제한 재시도 허용 (before_balloon.c:713)
```c
balloon_stats.max_retry_count = RETRY_UNLIMITED;
```

시스템 초기화 시 retry_count에 제한이 없도록 설정되어 있으며, 이는 이후 BP_EAGAIN 상태가 반복되어도 루프가 종료되지 않게 만드는 중요한 전제 조건이다.

#### Trace

#### Trace1: 워크 항목 정의 (before_balloon.c:154)
```c
static DECLARE_DELAYED_WORK(balloon_worker, balloon_process);
```

ballooning 처리를 위한 함수인 balloon_process()를 실행할 수 있도록, 지연 워크 항목 balloon_worker가 정의됨.

해당 항목은 추후 필요 시 워크큐에 등록되어 백그라운드에서 실행된다

#### Trace2: 워크큐 등록 (balloon_set_new_target, before_balloon.c:562)
```c
schedule_delayed_work(&balloon_worker, 0);
```

사용자가 새로운 target 메모리 크기를 설정하면, balloon_set_new_target() 함수가 호출되고, 이 시점에 balloon_worker가 워크큐에 등록되어 balloon_process() 함수가 비동기로 실행되도록 예약된다.

#### Trace3: credit 계산 (current_credit, before_balloon.c:409)
```c
static long current_credit(void)
{
    return balloon_stats.target_pages - balloon_stats.current_pages;
}
```
balloon_process() 함수 내부에서 호출되며, 현재 메모리 사용량(current_pages)과 사용자가 설정한 목표 메모리(target_pages) 간 차이를 계산한다.

이 값이 음수(credit < 0)일 경우, 메모리를 반환해야 한다고 판단된다.

Trace4: 음수 credit 처리 (balloon_process, before_balloon.c:541-542)
```c
static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;


	do {
		mutex_lock(&balloon_mutex);

		credit = current_credit();

        // 중략 ..

		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON); // 음수 크레딧 처리

		state = update_schedule(state);

		mutex_unlock(&balloon_mutex);

		cond_resched();

	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
}
```

credit이 음수이면, decrease_reservation() 함수를 호출해 지정된 수만큼의 페이지를 Xen에게 반환하려 시도한다.

#### Trace5: 메모리 할당 실패 → 실패 상태 반환 (decrease_reservation, before_balloon.c:471-474)
```c
// before_balloon.c:459-515
static enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)
{
    // 중략..

    for (i = 0; i < nr_pages; i++) {
        page = alloc_page(gfp);  // 페이지 할당 시도
        if (page == NULL) {      // 메모리 부족 시
            nr_pages = i;
            state = BP_EAGAIN;   // 재시도 요청 -- 주요 부분
            break;
        }
        // ... 메모리 처리 ...
    }
    // ... 나머지 처리 ...
}
```

alloc_page(GFP_BALLOON)을 통해 페이지를 할당하려 하지만, 메모리가 부족하면 실패하고 BP_EAGAIN 상태를 반환한다.

#### Trace6: 무제한 재시도 로직 (update_schedule, before_balloon.c:223)

```c
static enum bp_state update_schedule(enum bp_state state)
{
	// 중략 ..

	++balloon_stats.retry_count;

	if (balloon_stats.max_retry_count != RETRY_UNLIMITED &&
			balloon_stats.retry_count > balloon_stats.max_retry_count) {
		balloon_stats.schedule_delay = 1;
		balloon_stats.retry_count = 1;
		return BP_ECANCELED;
	}

	balloon_stats.schedule_delay <<= 1;

	if (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)
		balloon_stats.schedule_delay = balloon_stats.max_schedule_delay;

	return BP_EAGAIN;
}
```

max_retry_count가 RETRY_UNLIMITED로 설정되어 있어, BP_EAGAIN 상태가 반복되어도 루프가 중단되지 않고, 지연 시간만 증가하면서 반복된다.

#### Sink: 재시도 워크큐 재등록 (balloon_process, before_balloon.c:554)
```c
static void balloon_process(struct work_struct *work)
{
	// 중략 ..

	while (credit && state == BP_DONE);

	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ); // 다시 반복됨
}
```

#### **문제점**:
alloc_page() 호출이 반복적으로 실패하더라도, balloon_process()는 계속 워크큐에 재등록되어 실행된다. 이 반복 과정에서 다음과 같은 시스템 리소스가 지속적으로 소모된다:

 - CPU 사이클: mutex_lock, update_schedule 등의 커널 함수들이 반복 실행되며 CPU 사용이 지속됨

 - 워크큐 자원: schedule_delayed_work()에 의해 커널 워크큐와 타이머 큐가 반복 점유됨

 - 상태 유지 비용: retry_count, schedule_delay 등이 루프마다 갱신되며 상태 관리 비용이 발생함

비록 메모리 페이지 자체는 할당되지 않더라도, 이러한 반복 실행은 실질적인 커널 자원 소모를 초래하며, 외부 입력에 의해 유도될 수 있기 때문에 CWE-400 (Resource Exhaustion) 에 해당한다.

---

## 취약점 세부 사항 ② – increase_reservation() 경로 (메모리 반환)

### ❗️ 취약 코드

#### Source1: 사용자가 설정한 target 값(before_balloon.c:558)
```c
void balloon_set_new_target(unsigned long target)
{
    /* No need for lock. Not read-modify-write updates. */
    balloon_stats.target_pages = target;
    schedule_delayed_work(&balloon_worker, 0); // 워크큐 등록
}
```
사용자가 balloon_set_new_target()을 통해 현재보다 작은 target 값을 설정하면, 시스템은 메모리 반환 작업을 수행하기 위해 balloon_process()를 실행하게 된다.

#### Source2: reclaim 가능한 balloon 페이지 존재 여부 (before_balloon.c:414)
```c
static bool balloon_is_inflated(void)
{
    return balloon_stats.balloon_low || balloon_stats.balloon_high;
}
```

- credit > 0 상태일지라도, balloon 상태로 확보된 페이지가 없으면 increase_reservation()은 호출되지 않고, 대신 reserve_additional_memory() 경로로 분기된다.

- 따라서 balloon_is_inflated() == true, 즉 reclaim 가능한 페이지가 존재해야 increase_reservation() 경로로 진입하여 본 취약점이 발생할 수 있다.

#### Source3: 초기 설정값 – 무제한 재시도 허용 (before_balloon.c:713)
```c
balloon_stats.max_retry_count = RETRY_UNLIMITED;
```

시스템 초기화 시 retry_count에 제한이 없도록 설정되어 있으며, 이는 이후 BP_EAGAIN 상태가 반복되어도 루프가 종료되지 않게 만드는 중요한 전제 조건이다.

#### Trace

#### Trace 1~3: 워크 항목 정의 ~ credit 계산
 - 세부 사항 ① - Trace 1~3과 동일

#### Trace 4: 양수 credit 처리 → increase_reservation() 호출 (balloon_process, before_balloon.c:536)
```c
static void balloon_process(struct work_struct *work)
{
	// 중략 ..
    credit = current_credit();

    if (credit > 0) {
        if (balloon_is_inflated())
            state = increase_reservation(credit); // 주요 부분
        else
            state = reserve_additional_memory();
    }
    // 나머지 ..
}
```

credit > 0인 경우, 이미 balloon 상태로 확보된 페이지가 있으면 increase_reservation()을 통해 회수를 시도한다.

#### Trace 5: ballooned 페이지 회수 실패 → BP_EAGAIN 반환 (increase_reservation, before_balloon.c:441)
```c
static enum bp_state increase_reservation(unsigned long nr_pages)
{
	int rc;
	unsigned long i;
	struct page   *page;

	if (nr_pages > ARRAY_SIZE(frame_list))
		nr_pages = ARRAY_SIZE(frame_list);

	page = list_first_entry_or_null(&ballooned_pages, struct page, lru);
	for (i = 0; i < nr_pages; i++) {
		if (!page) {
			nr_pages = i;
			break;
		}

		frame_list[i] = page_to_xen_pfn(page);
		page = balloon_next_page(page);
	}

	rc = xenmem_reservation_increase(nr_pages, frame_list);
	if (rc <= 0)
		return BP_EAGAIN;
    // 나머지 ..
}
```

#### Trace 6: 동일: 세부 사항 ① - Trace 6 (update_schedule) 참조

#### Sink: 동일: 세부 사항 ① - Sink 참조
- 동일한 실패가 반복되며, xenmem_reservation_increase()가 계속 호출된다.

#### **문제점**:

이 경로에서 반복되는 increase_reservation() 루틴은 다음과 같은 리소스를 지속적으로 소비한다:

- CPU 사이클: Xen 인터페이스 호출, 워크큐 스케줄링, 상태 갱신 등

- 워크큐 자원: balloon_worker가 반복 등록되며 커널 워크큐가 점유됨

- Xen 하이퍼콜 시도 비용: 하이퍼바이저와의 인터페이스 실패가 반복되어 불필요한 시스템 call 오버헤드가 누적됨


### ✅ 개선 코드

**패치 위치**: 

1. 과도한 메모리 반환 방지 `after_balloon.c:541`

```diff
- if (credit < 0)
-     state = decrease_reservation(-credit, GFP_BALLOON);
+ if (credit < 0) {
+     long n_pages;
+
+     n_pages = min(-credit, si_mem_available());
+     state = decrease_reservation(n_pages, GFP_BALLOON);
+     if (state == BP_DONE && n_pages != -credit &&
+         n_pages < totalreserve_pages)
+         state = BP_EAGAIN;
+ }
```

2. ballooned 페이지 추가 시 가용 메모리 체크 추가 `after_balloon.c:588`
```diff
+ if (si_mem_available() < nr_pages)
+     return -ENOMEM;
```

3. 무한 재시도 방지 – retry count 제한 추가 `after_balloon.c:723`
```diff
- balloon_stats.max_retry_count = RETRY_UNLIMITED;
+ balloon_stats.max_retry_count = 4;
```


**개선 방법**:

1. 실제 가능한 범위 내에서만 메모리 반환 수행 → 시스템 안정성 유지
- 기존에는 반환해야 할 페이지 수(-credit)만큼 무조건 decrease_reservation()을 호출하였으나,
- 이제는 현재 시스템에 실제로 사용 가능한 메모리(si_mem_available())를 기준으로 반환 가능한 양을 제한합니다.
- 또한, 반환한 페이지 수가 기대치보다 적고, 시스템 예약 메모리(totalreserve_pages)를 침범할 경우, 실패 상태(BP_EAGAIN)를 강제로 설정하여 과도한 메모리 해제를 막습니다.

2. 시도 전 가용 자원 확인 → 불필요한 작업 회피
- add_ballooned_pages() 함수에서 ballooned 페이지를 추가하기 전에, 시스템에 실제로 충분한 여유 메모리가 있는지를 si_mem_available()로 점검합니다.
- 이를 통해 메모리 부족 상태에서 불필요한 시도를 하지 않고, 사전에 중단하여 리소스 소모를 예방합니다.

3. 재시도 횟수 제한 → 루프 기반 자원 고갈 방지 (CWE-400 완화)
- 기존에는 재시도 횟수 제한이 없어서 BP_EAGAIN 상태가 반복될 경우 balloon_process()가 무한히 워크큐에 등록되어 실행되었습니다.
- 패치에서는 max_retry_count 값을 4로 제한함으로써, 재시도 루프에 빠지는 것을 방지하고 시스템 자원 고갈(CPU, 워크큐)을 차단합니다.


## 양수 부분에 대해서는 왜 패치가 되지 않았을까..? (GPT..)

### 1. **increase\_reservation() 경로는 ballooned 페이지가 있을 때만 실행됨**

```c
if (credit > 0) {
    if (balloon_is_inflated())
        state = increase_reservation(credit); // 이미 확보된 메모리 회수
    else
        state = reserve_additional_memory();  // hotplug memory
}
```

* 이 경로는 이미 ballooned 상태인 메모리(즉, 이전에 반환해 둔 페이지)를 다시 회수하는 작업
* 회수는 **시스템에 새로 부담을 주는 동작이 아니라, 이미 확보해둔 자원을 되돌리는 것**이기 때문에, **할당 실패가 치명적인 리스크를 유발하지 않는다고 판단**했을 가능성이 높음

---

### 2. **실제 자원 소모보다 하이퍼콜 실패가 문제인 구조**

```c
rc = xenmem_reservation_increase(nr_pages, frame_list);
if (rc <= 0)
    return BP_EAGAIN;
```

* 실패 조건은 대부분 Xen 하이퍼바이저의 거절에 의한 것이며, `alloc_page()` 같은 커널 자원 부족으로 인한 실패는 아님
* 즉, **호출이 실패하더라도 커널 내부 자원을 심각하게 소모하지 않는다고 판단**되었을 수 있음

---

### 3. **패치 목적이 명확히 "리소스 고갈(CWE-400)" 대응이었기 때문**

* `decrease_reservation()`는 `alloc_page(GFP_BALLOON)` 호출이 직접적으로 **물리 메모리 부족을 유발할 수 있는 코드**
* 반면 `increase_reservation()`은 **reclaim 가능한 ballooned 페이지를 단순히 반환하는 작업이기 때문에, 시스템 메모리 부족과 직접 연결되기 어렵다**

→ 따라서 **리소스 소모 관점에서 더 위협적인 경로인 `decrease_reservation()`만을 패치 대상으로 삼은 것**

---

### 4. ❗ 가능성은 존재: 패치 누락 또는 개선 여지

* 단기적으로 문제를 해결하려면 `decrease_reservation()`만 막아도 CWE-400을 완화할 수 있지만,
* **이론적으로 `xenmem_reservation_increase()`가 계속 실패할 경우에도 `balloon_process()`는 반복 실행**되므로,
  **워크큐와 CPU를 계속 사용하는 문제가 남아 있음**
  → 즉, 이 부분도 **패치 대상으로 고려되어야 마땅하며**, 실제로는 **미처 개선되지 않았거나 영향도가 작다고 판단해 제외되었을 수 있다.**
