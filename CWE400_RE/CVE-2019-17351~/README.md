# 📁 CVE-2019-17351

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/torvalds/linux/commit/6f0c4d4f7c6c)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2019-17351)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/400.html)**

> Linux 커널의 Xen 메모리 풍선(balloon) 드라이버의 `balloon_process()` 함수에서 발생한 Resource Exhaustion(CWE-400) 취약점입니다.

* **Source**: `balloon_stats.max_retry_count = RETRY_UNLIMITED`로 설정된 재시도 횟수 제한
* **취약 조건**: 메모리 감소 시 가용 메모리 확인 없이 진행
* **Sink**: `balloon_process()` 함수의 메모리 감소 로직에서 무제한 재시도 가능

---

## 탐지 결과 요약
슬라이스 미탐지

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **부적절한 criterion**
    - CWE400의 SARD/README.md에 따르면 
        > ```bash
        > C:\Users\user\Downloads\xsv-0.13.0-i686-pc-windows-gnu>xsv search -s predict 1 C:\Users\user\Desktop\SARD-vs-CVE\CWE400_RE\SARD\test_output.csv | xsv select criterion | xsv frequency -s criterion | xsv select value
        > 
        > value
        > strlen
        > fopen
        > fwrite
        > fclose
        > ```
    - 이 취약점의 경우 criterion으로 메모리 관련 함수가 잡히지 않아 정상으로 판단된 것으로 보임.
    - 실제 취약점은 `decrease_reservation()`, `increase_reservation()`, `balloon_process()` 등 메모리 관리 함수들의 상호작용에서 발생하나, 이러한 복잡한 패턴을 단일 criterion으로 탐지하기 어려움.

---

## 취약점 세부 사항

### ❗️ 취약 코드

#### Source: `before_balloon.c:541-542`
```c
if (credit < 0)
    state = decrease_reservation(-credit, GFP_BALLOON);
```

**문제점**:
메모리 감소 시 실제 가용 메모리를 확인하지 않고 요청된 크기만큼 감소를 시도하여 **리소스 고갈**이 발생할 수 있음.

#### Trace
```c
// before_balloon.c:541-542
if (credit < 0)
    state = decrease_reservation(-credit, GFP_BALLOON);

// before_balloon.c:459-515
static enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)
{
    enum bp_state state = BP_DONE;
    unsigned long i;
    struct page *page, *tmp;
    int ret;
    LIST_HEAD(pages);

    if (nr_pages > ARRAY_SIZE(frame_list))
        nr_pages = ARRAY_SIZE(frame_list);

    for (i = 0; i < nr_pages; i++) {
        page = alloc_page(gfp);
        if (page == NULL) {
            nr_pages = i;
            state = BP_EAGAIN;
            break;
        }
        // ... 메모리 처리 ...
    }
    // ... 나머지 처리 ...
}
```

#### Sink: `before_balloon.c:713`
```c
balloon_stats.max_retry_count = RETRY_UNLIMITED;
```

**문제점**:
재시도 횟수가 무제한(`RETRY_UNLIMITED`)으로 설정되어 있어, 메모리 할당 실패 시 무한 재시도로 인한 **CPU 리소스 고갈**이 발생할 수 있음.

---

### ✅ 개선 코드

**패치 위치**: `after_balloon.c:541-549`

```c
if (credit < 0) {
    long n_pages;
    n_pages = min(-credit, si_mem_available());
    state = decrease_reservation(n_pages, GFP_BALLOON);
    if (state == BP_DONE && n_pages != -credit &&
        n_pages < totalreserve_pages)
        state = BP_EAGAIN;
}
```

**개선 방법**:

1. **메모리 감소 제한** (`after_balloon.c:541-549`)
   ```c
   if (credit < 0) {
       long n_pages;
       n_pages = min(-credit, si_mem_available());
       state = decrease_reservation(n_pages, GFP_BALLOON);
       if (state == BP_DONE && n_pages != -credit &&
           n_pages < totalreserve_pages)
           state = BP_EAGAIN;
   }
   ```
   - `si_mem_available()`을 통해 실제 가용 메모리를 확인
   - `min(-credit, si_mem_available())`으로 감소할 메모리 크기를 가용 메모리로 제한
   - 시스템의 실제 가용 메모리를 초과하지 않도록 보호

2. **재시도 횟수 제한** (`after_balloon.c:723`)
   ```c
   balloon_stats.max_retry_count = 4;  // 무제한에서 4회로 제한
   ```
   - 재시도 횟수를 무제한에서 4회로 제한하여 CPU 리소스 고갈 방지
   - 메모리 할당 실패 시 적절한 오류 처리 가능

3. **메모리 예약 보호** (`after_balloon.c:546-548`)
   ```c
   if (state == BP_DONE && n_pages != -credit &&
       n_pages < totalreserve_pages)
       state = BP_EAGAIN;
   ```
   - `totalreserve_pages`와 비교하여 시스템 예약 메모리 보호
   - 메모리 감소 시도가 예약 메모리보다 작은 경우 추가 재시도 가능
