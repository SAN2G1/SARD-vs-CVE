# 📁 CVE-2019-17351

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2019-17351)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/400.html)**

> Linux 커널의 Xen 메모리 풍선(balloon) 드라이버의 `balloon_process()` 함수에서 발생한 Resource Exhaustion(CWE-400) 취약점입니다.

* **Source**: 사용자가 balloon_set_new_target()을 통해 target 값을 설정 → credit = target_pages - current_pages 계산 → balloon_process()가 워크큐에 등록됨

* **취약 조건**: balloon_stats.max_retry_count = RETRY_UNLIMITED으로 설정됨 → BP_EAGAIN 상태가 반복되어도 루프가 종료되지 않음

* **Sink**: 
- credit > 0이면 → increase_reservation() → Xen 하이퍼콜 실패 시 BP_EAGAIN 반환
- → update_schedule()에서 delay 증가 및 retry count 갱신
- → BP_EAGAIN 상태 유지 시 balloon_process()가 워크큐에 다시 등록됨
- → 이 루프가 무제한 반복되어 CPU와 워크큐 자원을 지속적으로 소모
- → 결국 CWE-400 (Resource Exhaustion) 상태로 이어짐


## 탐지 결과 요약
슬라이스 미탐지

이 CVE 취약점을 유발하는 코드(sink:balloon.c:542)는 아래와 같다.
```
static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;
	do {
		mutex_lock(&balloon_mutex);
		credit = current_credit();
		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON);
```
이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.

```c

/* drivers/xen/balloon.c:562 */
void balloon_set_new_target(unsigned long target)
{
	/* No need for lock. Not read-modify-write updates. */
	balloon_stats.target_pages = target;
	schedule_delayed_work(&balloon_worker, 0);

/* drivers/xen/balloon.c:154 */
struct delayed_work balloon_worker = { .work = { .data = { ((unsigned long)(WORK_STRUCT_NO_POOL | WORK_STRUCT_STATIC)) }, .entry = { &((balloon_worker).work).entry, &((balloon_worker).work).entry }, .func = ((balloon_process)),  }, .timer = { .entry = { .next = ((void *) 0x300 + 0) }, .function = (delayed_work_timer_fn), .flags = ((0) | 0x00200000),  }, }

/* drivers/xen/balloon.c:542 */
static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;
	do {
		mutex_lock(&balloon_mutex);
		credit = current_credit();
            static long current_credit(void) {
	            return balloon_stats.target_pages - balloon_stats.current_pages;
            }
		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON);
                static enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)
                    {
                        enum bp_state state = BP_DONE;
                        unsigned long i;
                        struct page *page, *tmp;
                        int ret;
                        LIST_HEAD(pages);

                        if (nr_pages > ARRAY_SIZE(frame_list))
                            nr_pages = ARRAY_SIZE(frame_list);

                        for (i = 0; i < nr_pages; i++) {
                            page = alloc_page(gfp);
                            if (page == NULL) {
                                nr_pages = i;
                                state = BP_EAGAIN;
        state = update_schedule(state);
            static enum bp_state update_schedule(enum bp_state state)
            {
                if (state == BP_WAIT)
                    return BP_WAIT;

                if (state == BP_ECANCELED)
                    return BP_ECANCELED;

                if (state == BP_DONE) {
                    balloon_stats.schedule_delay = 1;
                    balloon_stats.retry_count = 1;
                    return BP_DONE;
                }

                ++balloon_stats.retry_count;

                if (balloon_stats.max_retry_count != RETRY_UNLIMITED &&
                        balloon_stats.retry_count > balloon_stats.max_retry_count) {
                    balloon_stats.schedule_delay = 1;
                    balloon_stats.retry_count = 1;
                    return BP_ECANCELED;
                }

                balloon_stats.schedule_delay <<= 1;

                if (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)
                    balloon_stats.schedule_delay = balloon_stats.max_schedule_delay;

                return BP_EAGAIN;
    		mutex_unlock(&balloon_mutex);
		cond_resched();
	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);

/* include/linux/workqueue.h:606 */
static inline bool schedule_delayed_work(struct delayed_work *dwork,
					 unsigned long delay)
{
	return queue_delayed_work(system_wq, dwork, delay);

/* include/linux/workqueue.h:501 */
static inline bool queue_delayed_work(struct workqueue_struct *wq,
				      struct delayed_work *dwork,
				      unsigned long delay)
{
	return queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);

/* kernel/workqueue.c:1674 */
bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,
			   struct delayed_work *dwork, unsigned long delay)
{
	struct work_struct *work = &dwork->work;
	bool ret = false;
	unsigned long flags;

	/* read the comment in __queue_work() */
	local_irq_save(flags);

	if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
		__queue_delayed_work(cpu, wq, dwork, delay);

/* kernel/workqueue.c:1649 */
static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,
				struct delayed_work *dwork, unsigned long delay)
{
	struct timer_list *timer = &dwork->timer;
	struct work_struct *work = &dwork->work;

	WARN_ON_ONCE(!wq);
	WARN_ON_ONCE(timer->function != delayed_work_timer_fn);
	WARN_ON_ONCE(timer_pending(timer));
	WARN_ON_ONCE(!list_empty(&work->entry));

	/*
	 * If @delay is 0, queue @dwork->work immediately.  This is for
	 * both optimization and correctness.  The earliest @timer can
	 * expire is on the closest next tick and delayed_work users depend
	 * on that there's no such delay when @delay is 0.
	 */
	if (!delay) {
		__queue_work(cpu, wq, &dwork->work);
		return;
	}

	dwork->wq = wq;
	dwork->cpu = cpu;
	timer->expires = jiffies + delay;

	if (unlikely(cpu != WORK_CPU_UNBOUND))
		add_timer_on(timer, cpu);
	else
		add_timer(timer);
```

```
[
    {
        "FileName": "manager.c",
        "Caller": "add_server",
        "Source": false,
        "Sink": true,
        "idx": 0,
        "CWE-ID": "CWE-78",
        "category": "CallExpression",
        "criterion": "system",
        "line": 42,
        "label": -3,
        "slices": [
            "int main(int argc, char **argv)\n",
            "{\n",
            "    int sfd;\n",
            "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
            "        struct sockaddr_un svaddr;\n",
            "        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);\n",
            "        if (sfd == -1) {\n",
            "        setnonblocking(sfd);\n",
            "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
            "    } \n",
            "    manager.fd = sfd;\n",
            "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
            "}\n",
            "static void manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
            "{\n",
            "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
            "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
            "    if (r == -1) {\n",
            "    if (r > BUF_SIZE / 2) {\n",
            "    char *action = get_action(buf, r);\n",
            "    if (action == NULL) {\n",
            "    if (strcmp(action, \"add\") == 0) {\n",
            "        struct server *server = get_server(buf, r);\n",
            "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
            "        int ret = add_server(manager, server);\n",
            "}\n",
            "static int add_server(struct manager_ctx *manager, struct server *server)\n",
            "{\n",
            "    int ret = check_port(manager, server);\n",
            "    cork_hash_table_put(server_table, (void *)server->port, (void *)server, &new, NULL, NULL);\n",
            "    char *cmd = construct_command_line(manager, server);\n",
            "    construct_command_line(struct manager_ctx *manager, struct server *server){\n",
            "        static char cmd[BUF_SIZE];\n",
            "        char *method = manager->method;\n",
            "        int i;\n",
            "        build_config(working_dir, server);\n",
            "        if (server->method) method = server->method;\n",
            "        memset(cmd, 0, BUF_SIZE);\n",
            "        snprintf(cmd, BUF_SIZE,\n",
            "                \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n",
            "                executable, method, manager->manager_address,\n",
            "                working_dir, server->port, working_dir, server->port);\n",
            "        return cmd;\n",
            "    }\n",
            "    if (system(cmd) == -1) {\n",
            "}\n"
        ]
    }
]
```

이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **부적절한 criterion**
    - CWE400의 SARD/README.md에 따르면 
        > ```bash
        > C:\Users\user\Downloads\xsv-0.13.0-i686-pc-windows-gnu>xsv search -s predict 1 C:\Users\user\Desktop\SARD-vs-CVE\CWE400_RE\SARD\test_output.csv | xsv select criterion | xsv frequency -s criterion | xsv select value
        > 
        > value
        > strlen
        > fopen
        > fwrite
        > fclose
        > ```
    - 이 취약점은 alloc_page()와 xenmem_reservation_increase() 같은 커널 내부 함수에 의존하여 동작하지만, 이들 중 alloc_page()는 커널 전용 메모리 할당 함수이고, xenmem_reservation_increase()는 Xen 하이퍼바이저와의 메모리 교환을 위한 인터페이스 함수이다. 슬라이서가 이러한 함수들을 criterion으로 인식하지 못할 경우, 실제로는 재시도 루프 조건이 존재하더라도 슬라이스가 생성되지 않아 취약하지 않은 코드로 오판될 수 있다.
    - 특히 alloc_page()는 슬라이서의 l_funcs 필터 기준에 '\*alloc'은 포함되어 있으나 'alloc\*'은 포함되어 있지 않아 탐지되지 않은 것으로 보인다
    - 이 함수는 decrease_reservation() (before_balloon.c:459) 내부에서 호출되며, 실제 호출 위치는 before_balloon.c:471이다.

---

## 취약점 세부 사항 ① – decrease_reservation() 경로 (메모리 반환)

### ❗️ 취약 코드

#### Source1: 사용자가 설정한 target 값(before_balloon.c:558)
```c
void balloon_set_new_target(unsigned long target)
{
    /* No need for lock. Not read-modify-write updates. */
    balloon_stats.target_pages = target;
    schedule_delayed_work(&balloon_worker, 0); // 워크큐 등록
}
```
사용자가 balloon_set_new_target()을 통해 현재보다 작은 target 값을 설정하면, 시스템은 메모리 반환 작업을 수행하기 위해 balloon_process()를 실행하게 된다.

#### Source2: 초기 설정값 – 무제한 재시도 허용 (before_balloon.c:713)
```c
balloon_stats.max_retry_count = RETRY_UNLIMITED;
```

시스템 초기화 시 retry_count에 제한이 없도록 설정되어 있으며, 이는 이후 BP_EAGAIN 상태가 반복되어도 루프가 종료되지 않게 만드는 중요한 전제 조건이다.

#### Trace

#### Trace1: 워크 항목 정의 (before_balloon.c:154)
```c
static DECLARE_DELAYED_WORK(balloon_worker, balloon_process);
```

ballooning 처리를 위한 함수인 balloon_process()를 실행할 수 있도록, 지연 워크 항목 balloon_worker가 정의됨.

해당 항목은 추후 필요 시 워크큐에 등록되어 백그라운드에서 실행된다

#### Trace2: 워크큐 등록 (balloon_set_new_target, before_balloon.c:562)
```c
schedule_delayed_work(&balloon_worker, 0);
```

사용자가 새로운 target 메모리 크기를 설정하면, balloon_set_new_target() 함수가 호출되고, 이 시점에 balloon_worker가 워크큐에 등록되어 balloon_process() 함수가 비동기로 실행되도록 예약된다.

#### Trace3: credit 계산 (current_credit, before_balloon.c:409)
```c
static long current_credit(void)
{
    return balloon_stats.target_pages - balloon_stats.current_pages;
}
```
balloon_process() 함수 내부에서 호출되며, 현재 메모리 사용량(current_pages)과 사용자가 설정한 목표 메모리(target_pages) 간 차이를 계산한다.

이 값이 음수(credit < 0)일 경우, 메모리를 반환해야 한다고 판단된다.

Trace4: 음수 credit 처리 (balloon_process, before_balloon.c:541-542)
```c
static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;


	do {
		mutex_lock(&balloon_mutex);

		credit = current_credit();

        // 중략 ..

		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON); // 음수 크레딧 처리

		state = update_schedule(state);

		mutex_unlock(&balloon_mutex);

		cond_resched();

	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
}
```

credit이 음수이면, decrease_reservation() 함수를 호출해 지정된 수만큼의 페이지를 Xen에게 반환하려 시도한다.

#### Trace5: 메모리 할당 실패 → 실패 상태 반환 (decrease_reservation, before_balloon.c:471-474)
```c
// before_balloon.c:459-515
static enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)
{
    // 중략..

    for (i = 0; i < nr_pages; i++) {
        page = alloc_page(gfp);  // 페이지 할당 시도
        if (page == NULL) {      // 메모리 부족 시
            nr_pages = i;
            state = BP_EAGAIN;   // 재시도 요청 -- 주요 부분
            break;
        }
        // ... 메모리 처리 ...
    }
    // ... 나머지 처리 ...
}
```

alloc_page(GFP_BALLOON)을 통해 페이지를 할당하려 하지만, 메모리가 부족하면 실패하고 BP_EAGAIN 상태를 반환한다.

#### Trace6: 무제한 재시도 로직 (update_schedule, before_balloon.c:223)

```c
static enum bp_state update_schedule(enum bp_state state)
{
	// 중략 ..

	++balloon_stats.retry_count;

	if (balloon_stats.max_retry_count != RETRY_UNLIMITED &&
			balloon_stats.retry_count > balloon_stats.max_retry_count) {
		balloon_stats.schedule_delay = 1;
		balloon_stats.retry_count = 1;
		return BP_ECANCELED;
	}

	balloon_stats.schedule_delay <<= 1;

	if (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)
		balloon_stats.schedule_delay = balloon_stats.max_schedule_delay;

	return BP_EAGAIN;
}
```

max_retry_count가 RETRY_UNLIMITED로 설정되어 있어, BP_EAGAIN 상태가 반복되어도 루프가 중단되지 않고, 지연 시간만 증가하면서 반복된다.

#### Sink: 재시도 워크큐 재등록 (balloon_process, before_balloon.c:554)
```c
static void balloon_process(struct work_struct *work)
{
	// 중략 ..

	while (credit && state == BP_DONE);

	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ); // 다시 반복됨
}
```

#### **문제점**:
alloc_page() 호출이 반복적으로 실패하더라도, balloon_process()는 계속 워크큐에 재등록되어 실행된다. 이 반복 과정에서 다음과 같은 시스템 리소스가 지속적으로 소모된다:

 - CPU 사이클: mutex_lock, update_schedule 등의 커널 함수들이 반복 실행되며 CPU 사용이 지속됨

 - 워크큐 자원: schedule_delayed_work()에 의해 커널 워크큐와 타이머 큐가 반복 점유됨

 - 상태 유지 비용: retry_count, schedule_delay 등이 루프마다 갱신되며 상태 관리 비용이 발생함

비록 메모리 페이지 자체는 할당되지 않더라도, 이러한 반복 실행은 실질적인 커널 자원 소모를 초래하며, 외부 입력에 의해 유도될 수 있기 때문에 CWE-400 (Resource Exhaustion) 에 해당한다.

---


### ✅ 개선 코드

**패치 위치**: 

1. 과도한 메모리 반환 방지 `after_balloon.c:541`

```diff
- if (credit < 0)
-     state = decrease_reservation(-credit, GFP_BALLOON);
+ if (credit < 0) {
+     long n_pages;
+
+     n_pages = min(-credit, si_mem_available());
+     state = decrease_reservation(n_pages, GFP_BALLOON);
+     if (state == BP_DONE && n_pages != -credit &&
+         n_pages < totalreserve_pages)
+         state = BP_EAGAIN;
+ }
```

2. ballooned 페이지 추가 시 가용 메모리 체크 추가 `after_balloon.c:588`
```diff
+ if (si_mem_available() < nr_pages)
+     return -ENOMEM;
```

3. 무한 재시도 방지 – retry count 제한 추가 `after_balloon.c:723`
```diff
- balloon_stats.max_retry_count = RETRY_UNLIMITED;
+ balloon_stats.max_retry_count = 4;
```


**개선 방법**:

1. 실제 가능한 범위 내에서만 메모리 반환 수행 → 시스템 안정성 유지
- 기존에는 반환해야 할 페이지 수(-credit)만큼 무조건 decrease_reservation()을 호출하였으나,
- 이제는 현재 시스템에 실제로 사용 가능한 메모리(si_mem_available())를 기준으로 반환 가능한 양을 제한합니다.
- 또한, 반환한 페이지 수가 기대치보다 적고, 시스템 예약 메모리(totalreserve_pages)를 침범할 경우, 실패 상태(BP_EAGAIN)를 강제로 설정하여 과도한 메모리 해제를 막습니다.

2. 시도 전 가용 자원 확인 → 불필요한 작업 회피
- add_ballooned_pages() 함수에서 ballooned 페이지를 추가하기 전에, 시스템에 실제로 충분한 여유 메모리가 있는지를 si_mem_available()로 점검합니다.
- 이를 통해 메모리 부족 상태에서 불필요한 시도를 하지 않고, 사전에 중단하여 리소스 소모를 예방합니다.

3. 재시도 횟수 제한 → 루프 기반 자원 고갈 방지 (CWE-400 완화)
- 기존에는 재시도 횟수 제한이 없어서 BP_EAGAIN 상태가 반복될 경우 balloon_process()가 무한히 워크큐에 등록되어 실행되었습니다.
- 패치에서는 max_retry_count 값을 4로 제한함으로써, 재시도 루프에 빠지는 것을 방지하고 시스템 자원 고갈(CPU, 워크큐)을 차단합니다.
