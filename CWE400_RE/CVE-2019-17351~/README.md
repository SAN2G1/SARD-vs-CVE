# 📁 CVE-2019-17351

## 🔍 취약점 개요
**🔗 [커밋 링크](https://github.com/torvalds/linux/commit/9b6f7e163cd7c9b3b4e0d5cbd155a12454b0803a)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2019-17351)** | **[취약점 종류: [CWE-400] Uncontrolled Resource Consumption](https://cwe.mitre.org/data/definitions/400.html)** 

> Xen balloon 드라이버는 Xen 가상화 환경에서 게스트 OS의 메모리를 동적으로 관리하는 중요한 컴포넌트입니다. 이 드라이버는 호스트 시스템과 게스트 OS 간의 메모리 할당을 조절하여, 필요에 따라 게스트 OS의 메모리를 확장하거나 축소할 수 있게 해줍니다. 특히 메모리 부족 상황에서 게스트 OS의 메모리를 호스트로 반환하거나, 필요할 때 추가 메모리를 할당받을 수 있도록 하는 역할을 합니다.

* **취약 조건**: 메모리 할당 및 해제 과정에서 리소스 소비가 제어되지 않는 상황
* **Sink**: 메모리 할당 및 해제 관련 함수들 (alloc_page, free_reserved_page 등)

### 취약점 발생 시나리오
```
1. Xen balloon 드라이버가 메모리 할당을 시도
2. 메모리 할당 과정에서 리소스 소비가 제어되지 않음
3. 시스템 리소스가 과도하게 소비되어 서비스 거부 상태 발생 가능
```
- 이 취약점은 Xen 가상화 환경에서 게스트 OS의 메모리 관리에 영향을 미치며, 호스트 시스템의 리소스 소비를 제어하지 못하는 문제를 포함합니다.

## 탐지 결과 요약

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| {TOTAL_SLICES} | {VULNERABLE_SLICES} | {NORMAL_SLICES} |

### 분석 결과 검증
- **슬라이스 수 검증**: {SLICE_COUNT_VERIFICATION}
- **탐지 결과 검증**: {DETECTION_RESULT_VERIFICATION}

### Source와 Sink 분석
- **Source 함수 분류**:


- **Sink 함수 분류**:

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

---

### ⚠️ 탐지 결과 문제점

현재 탐지 결과에서 슬라이서가 슬라이스를 도출하지 못한 주요 원인들을 분석해보았습니다:

1. **동적 메모리 관리의 복잡성**
   - Xen balloon 드라이버는 동적으로 메모리를 할당하고 해제하는 복잡한 패턴을 가짐
   - 메모리 할당/해제가 여러 함수에 걸쳐 분산되어 있어 단일 슬라이스로 추적이 어려움
   - 리소스 소비는 시간에 따른 누적 효과로 발생하므로, 정적 분석으로는 파악이 어려움
   - **근거**: 
     - `__balloon_append` 함수에서 메모리 할당이 두 개의 독립적인 경로를 통해 이루어짐:
       ```
       경로 1 (일반 메모리): alloc_page() -> adjust_managed_page_count() -> xenmem_reservation_scrub_page()
       [balloon_stats.balloon_low 증가 - 일반 메모리 영역의 풍선 페이지 수 추적]
       
       경로 2 (고수준 메모리): alloc_page() -> adjust_managed_page_count() -> xenmem_reservation_scrub_page()
       [balloon_stats.balloon_high 증가 - 고수준 메모리 영역의 풍선 페이지 수 추적]
       ```
       [edges.csv 라인 85-89: FLOWS_TO 관계 (33->48->77, 56->71->77)]
       
       이 두 경로는 `balloon_stats` 구조체를 통해 메모리 사용량을 추적하며, 
       일반 메모리와 고수준 메모리를 구분하여 관리합니다. 이는 Xen 가상화 환경에서
       메모리 관리를 더 효율적으로 하기 위한 설계입니다.

       실제 코드에서의 메모리 관리: before_balloon.c:165
       ```c
       if (PageHighMem(page)) {
           list_add_tail(&page->lru, &ballooned_pages);
           balloon_stats.balloon_high++;  // 고수준 메모리 페이지 추가
       } else {
           list_add(&page->lru, &ballooned_pages);
           balloon_stats.balloon_low++;   // 일반 메모리 페이지 추가
       }
       ```
       - `PageHighMem(page)`: 페이지가 고수준 메모리인지 확인
       - `list_add_tail()`: 고수준 메모리 페이지는 리스트의 끝에 추가
       - `list_add()`: 일반 메모리 페이지는 리스트의 앞에 추가
       - `balloon_stats` 구조체를 통해 각 메모리 영역의 페이지 수를 추적

     - `page` 변수가 여러 처리 경로에서 사용됨:
       ```
       1. 메모리 할당 검증 (edges.csv: USE 관계)
       2. 페이지 상태 설정 (edges.csv: DEF 관계)
       3. 메모리 매핑 업데이트 (edges.csv: USE 관계)
       ```

     - 제어 흐름이 복잡하게 얽혀있어 단순한 소스-싱크 관계로 표현하기 어려움:
       ```
       메인 제어 흐름 -> 메모리 할당 검증 -> 페이지 상태 설정 -> 메모리 매핑
       ```
       [edges.csv 라인 105-112: CONTROLS 관계 (92->89,25,77, 25->33,48,56,71)]

2. **가상화 환경의 특수성**
   - Xen 가상화 환경에서의 메모리 관리는 일반적인 메모리 관리와 다른 특수한 패턴을 가짐
   - 호스트-게스트 간의 메모리 상호작용이 복잡하여 단순한 소스-싱크 관계로 표현하기 어려움
   - 가상화 레이어를 통한 메모리 접근이 슬라이서의 분석 범위를 벗어날 수 있음
   - **근거**:
     - `xenmem_reservation_va_mapping_update` 함수는 가상화 특화 파라미터를 사용:
       ```
       - domid: 도메인 ID
       - nr_pages: 페이지 수
       - pages: 페이지 배열
       - vaddr: 가상 주소
       ```
       [nodes.csv 라인 89-98: 함수 파라미터 선언]

     - `xenmem_reservation_scrub_page` 함수는 가상화 레이어를 통한 메모리 접근:
       ```
       호스트 메모리 -> 가상화 레이어 -> 게스트 메모리
       ```
       [nodes.csv 라인 115-120: 함수 호출 패턴]

     - 가상화 관련 함수들 간의 데이터 흐름이 복잡:
       ```
       balloon_append -> __balloon_append -> xenmem_reservation_va_mapping_update
       ```
       [edges.csv 라인 89-101: 함수 간 데이터 흐름]

3. **리소스 소비의 특성**
   - CWE-400 취약점은 단순한 메모리 누수가 아닌, 리소스 소비의 제어 부재 문제
   - 리소스 소비는 여러 함수 호출과 상태 변화의 조합으로 발생
   - 이러한 복합적인 패턴은 현재 슬라이서의 분석 방식으로는 포착하기 어려움
   - **근거**:
     - `balloon_stats` 구조체의 상태 변화가 복잡한 패턴을 가짐:
       ```
       balloon_high 증가 -> 메모리 할당 시도 -> balloon_low 증가
       ```
       [nodes.csv 라인 48-53: balloon_high 증가 연산]
       [nodes.csv 라인 71-76: balloon_low 증가 연산]

     - 리소스 상태 변경이 여러 함수에 걸쳐 발생:
       ```
       balloon_append -> __balloon_append -> xenmem_reservation_va_mapping_update
       ```
       [edges.csv 라인 96-97: balloon_stats 구조체 멤버 참조]

     - `balloon_retrieve` 함수에서의 리소스 상태 변경이 복잡한 조건에 따라 발생
       [edges.csv 라인 185-197: 리소스 상태 변경 패턴]

4. **분석 도구의 한계**
   - 현재 슬라이서는 주로 단순한 소스-싱크 관계를 분석하는데 최적화되어 있음
   - 복잡한 메모리 관리 패턴과 리소스 소비 패턴을 분석하기에는 제한적
   - 가상화 환경의 특수한 메모리 관리 패턴을 인식하지 못할 수 있음
   - **근거**:
     - 함수 호출 체인이 복잡하게 중첩됨:
       ```
       balloon_append
         └─> __balloon_append
              └─> xenmem_reservation_va_mapping_update
                   └─> xenmem_reservation_scrub_page
       ```
       [edges.csv 라인 92-93: FLOWS_TO 관계 체인]
       [edges.csv 라인 118-119: CONTROLS 관계 패턴]

     - 제어 흐름이 여러 레벨로 중첩되어 있어 단순한 분석으로는 파악이 어려움
       [edges.csv 라인 185-197: DOM과 POST_DOM 관계]

     - 가상화 레이어를 통한 메모리 접근이 슬라이서의 분석 범위를 벗어남
       [nodes.csv 라인 21-93: 함수 내부의 복잡한 AST 구조]

---

## 취약점 세부 사항

### 📁 관련 파일 소개
| 파일명 | 설명 |
| ------ | ---- |
| `before_balloon.c` | 취약한 소스 코드 |
| `after_balloon.c` | 패치된 소스 코드 |
| `edges.csv` | 코드 분석을 위한 엣지 정보 |
| `nodes.csv` | 코드 분석을 위한 노드 정보 |

---

### ❗️ 취약 코드

**문제점**:
메모리 할당 및 해제 과정에서 리소스 소비가 제어되지 않아 시스템 리소스가 과도하게 소비될 수 있는 취약점이 존재합니다. 이 취약점은 세 가지 위치에서 서로 연관되어 발생하며, 모두 패치되어야 완전한 해결이 가능합니다.

#### 취약점 발생 위치 1: `balloon.c:541` (balloon_process 함수)
```c
if (credit < 0)
    state = decrease_reservation(-credit, GFP_BALLOON);
```
- 메모리 감소 요청 시 가용 메모리 검사 없이 바로 감소를 시도
- 시스템이 실제로 사용 가능한 메모리보다 더 많은 메모리를 해제하려고 시도할 수 있음

#### 취약점 발생 위치 2: `balloon.c:581` (add_ballooned_pages 함수)
```c
st = decrease_reservation(nr_pages, GFP_USER);
if (st != BP_DONE)
    return -ENOMEM;
```
- 새로운 페이지 추가 시 가용 메모리 검사 없이 할당을 시도
- 메모리 부족 상황에서도 계속해서 메모리 할당을 시도할 수 있음

#### 취약점 발생 위치 3: `balloon.c:713` (balloon_init 함수)
```c
balloon_stats.max_retry_count = RETRY_UNLIMITED;
```
- 재시도 횟수 제한이 없음 (`RETRY_UNLIMITED`)
- 메모리 할당/해제 실패 시 무한정 재시도할 수 있음

**취약점의 연관성**:
이 세 가지 위치는 서로 연관된 취약점의 다른 측면을 보여줍니다:
1. 위치 1과 2는 메모리 할당/해제 시 적절한 검사가 없는 문제를 나타냅니다.
2. 위치 3은 이러한 실패 상황에서의 재시도 제어가 없는 문제를 나타냅니다.
3. 세 위치가 모두 패치되어야 취약점이 완전히 해결됩니다. 하나라도 패치되지 않으면 여전히 리소스 소비가 제어되지 않을 수 있습니다.

---

### ✅ 개선 코드

**개선 위치 1**: `balloon.c:541` (balloon_process 함수)
```c
if (credit < 0) {
    long n_pages;

    n_pages = min(-credit, si_mem_available());
    state = decrease_reservation(n_pages, GFP_BALLOON);
    if (state == BP_DONE && n_pages != -credit &&
        n_pages < totalreserve_pages)
        state = BP_EAGAIN;
}
```
- 가용 메모리를 검사하여 실제 사용 가능한 메모리 범위 내에서만 감소를 시도
- 메모리 감소 요청이 완전히 처리되지 않은 경우 `BP_EAGAIN` 상태를 반환하여 재시도 가능

**개선 위치 2**: `balloon.c:588` (add_ballooned_pages 함수)
```c
if (si_mem_available() < nr_pages)
    return -ENOMEM;

st = decrease_reservation(nr_pages, GFP_USER);
if (st != BP_DONE)
    return -ENOMEM;
```
- 메모리 할당 전에 가용 메모리를 검사하여 부족한 경우 즉시 실패
- 메모리 할당 실패 시 명확한 에러 코드 반환

**개선 위치 3**: `balloon.c:723` (balloon_init 함수)
```c
balloon_stats.max_retry_count = 4;
```
- 재시도 횟수를 4회로 제한하여 무한 재시도 방지
- 리소스 소비를 제어 가능한 범위로 제한

**개선 방법**:
1. 메모리 감소 시 가용 메모리 검사 추가
   - `si_mem_available()`을 사용하여 실제 가용 메모리 확인
   - 요청된 메모리 크기와 가용 메모리 중 작은 값 사용

2. 메모리 할당 전 가용성 검사 추가
   - `add_ballooned_pages` 함수에 `si_mem_available() < nr_pages` 검사 추가
   - 메모리 부족 시 `-ENOMEM` 반환

3. 재시도 횟수 제한 설정
   - `max_retry_count`를 `RETRY_UNLIMITED`에서 4로 제한
   - 무한 재시도로 인한 리소스 소비 방지

## 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출

|FileName |Caller |Source|Sink |idx|CWE-ID|category |criterion|line|label|token_length|predict|
|---------|-------|------|-----|---|------|---------|---------|----|-----|------------|-------|
{DETECTION_RESULTS_TABLE}