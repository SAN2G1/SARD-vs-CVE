# 📁 CVE-2018-20784

## 🔍 취약점 개요

🔗 [커밋 링크](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0f8cf3b8497dc45c010c44ed9e96518e11e19fc3) | 🔗 [CVE 링크](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20784) | 🔗 [CWE 링크 (CWE-400)](https://cwe.mitre.org/data/definitions/400.html)

Linux 커널 Completely Fair Scheduler(CFS)의 `update_blocked_averages()` 함수에서,
리스트 순회 루프(`for_each_leaf_cfs_rq_safe`)가 리스트 손상 시 종료되지 않고
\*\*무한 루프에 빠져 서비스 거부(DoS)\*\*를 유발하는 취약점입니다.

**취약점 종류:** \[CWE-400] Uncontrolled Resource Consumption

* **Source:** CFS 런큐 리스트 `rq->leaf_cfs_rq_list`
* **취약 조건:** 리스트 무결성이 손상된 경우 순회 포인터(`pos`)가 정상 갱신되지 않음
* **Sink:** `for_each_leaf_cfs_rq_safe` 매크로 반복문이 종료되지 않고 무한 반복

---

## 탐지 결과 요약

CVE 설명에 기반해 `update_blocked_averages()` 함수 중심으로 슬라이스를 수집한 결과:

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
| :------: | :-----: | :-----: |
|    5개    |    2개   |    3개   |

`update_blocked_averages()` 함수 내 `for_each_leaf_cfs_rq_safe` 반복문에 대한 슬라이스는 **존재하지 않음**.
탐지된 슬라이스는 모두 `memset()` 호출 단위로 구성되어 있음.

| FileName       | Caller                          | Source |  Sink | idx | CWE-ID |    category    | criterion | line | label | token\_length | predict |
| :------------- | :------------------------------ | :----: | :---: | :-: | :----: | :------------: | :-------: | :--: | :---: | :-----------: | :-----: |
| before\_fair.c | init\_entity\_runnable\_average |  False | False |  0  |  CWE-  | CallExpression |   memset  |  703 |   -3  |       85      |    1    |
| before\_fair.c | update\_numa\_stats             |  False | False |  1  |  CWE-  | CallExpression |   memset  | 1476 |   -3  |       95      |    1    |
| before\_fair.c | update\_task\_scan\_period      |  False | False |  2  |  CWE-  | CallExpression |   memset  | 1978 |   -3  |      409      |    0    |
| before\_fair.c | task\_numa\_fault               |  False | False |  3  |  CWE-  | CallExpression |   memset  | 2375 |   -3  |      419      |    0    |
| before\_fair.c | update\_sg\_lb\_stats           |  False | False |  4  |  CWE-  | CallExpression |   memset  | 8172 |   -3  |      390      |    0    |

---

## SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

**1. 슬라이스 추출 기준 한계**

* 본 취약점은 `for_each_leaf_cfs_rq_safe` 매크로 기반 반복문 내부에서 발생하지만,
  슬라이서는 **함수 호출(CallExpression)** 단위로 슬라이스를 생성.
* 리스트 순회 흐름과 포인터(`pos`) 갱신 여부는 슬라이스에 포함되지 못하고,
  `memset()` 호출 등 단편적인 코드 조각만 슬라이스로 생성됨.

> 📄 기대하는 슬라이스:
>
> ```c
> for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
>     ...
> }
> ```

> 📄 실제 슬라이스:
>
> ```c
> memset(&cfs_rq->avg, 0, sizeof(cfs_rq->avg));
> ```

---

**2. 리스트 순회 조건 변수 추적 실패**

* **`rq->leaf_cfs_rq_list`**: 스케줄러 런큐의 leaf runqueue 리스트.
* **`pos` 포인터**: 리스트 노드를 순회하면서 다음 노드를 가리켜야 하지만,
  리스트 손상 시 정상 갱신되지 않음 → 무한 루프 발생.

정상 흐름:

* `pos`가 리스트의 다음 엔트리를 정상적으로 가리키며 순회 종료.

비정상 흐름:

* 리스트 손상으로 `pos`가 `NULL`이나 순환되지 않는 노드를 가리킴 → 루프 탈출 불가 → 무한 루프 발생.

---

**3. 탐지 모델 입력 정보 부족**

* `vectors.json`을 분석한 결과, 슬라이스 input\_token 시퀀스는 다음과 같이 단편적임:

> 📄 vectors.json (idx: 0)
>
> ```plaintext
> <s>, memset, (, Var2, ,, 0, ,, sizeof, (, Var2, ), ), ;, ...
> ```

* **문제점**: 리스트 순회 구조, 포인터 갱신 흐름, 무한 반복 가능성을 모델 입력에서 제공하지 않음.
* **결과**: 모델이 무한 루프 위험을 학습할 수 없음.

---

## 📁 관련 파일 소개

| 파일명             | 설명             |
| :-------------- | :------------- |
| `before_fair.c` | 취약 코드(수정 전) 포함 |
| `after_fair.c`  | 개선 코드(수정 후) 포함 |

---

## ❗️ 취약 코드

📄 **Source:** `rq->leaf_cfs_rq_list` 리스트 (`before_fair.c:`)
📄 **Sink:** `for_each_leaf_cfs_rq_safe` 매크로 기반 무한 순회 (`before_fair.c:356`)

```c
for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {   // (Line 356) 리스트 순회 반복문
    ...
}
```

### 📌 반복문 관련 변수 설명

| 변수                     | 설명                                             |
| :--------------------- | :--------------------------------------------- |
| `rq->leaf_cfs_rq_list` | 스케줄러 런큐에 등록된 leaf runqueue 리스트.                |
| `pos`                  | 현재 순회 중인 리스트 노드 포인터. 다음 엔트리를 가리켜야 루프 정상 종료 가능. |

---

### 📌 정상 흐름

* `pos`가 리스트 내 다음 엔트리를 가리키며 순회 완료 → 루프 종료.

### 📌 비정상 흐름

* 리스트 손상 시 `pos`가 갱신되지 않음 → 루프 탈출 실패 → 무한 반복 발생.

---

## ✅ 개선 코드

📄 **패치 위치:** `after_fair.c:356`

```c
#define for_each_leaf_cfs_rq(rq, cfs_rq) \
    list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
```

### 📌 개선 방법

* 기존 `for_each_leaf_cfs_rq_safe` 매크로를,
  \*\*RCU 기반 안전 리스트 순회 매크로(`list_for_each_entry_rcu`)\*\*로 변경.
* RCU(Read-Copy-Update) 기법을 통해 리스트 동기화, 삭제/변경 상황에서도 안전한 순회 보장.
* 포인터 갱신이 보장되므로 무한 루프 위험 제거.

---

## 🧪 탐지 결과

*CVE 설명에 나온 취약한 함수(Caller) 기반 슬라이스 관련 데이터만 추출.*

| FileName       | Caller                          | Source |  Sink | idx | CWE-ID |    category    | criterion | line | label | token\_length | predict |
| :------------- | :------------------------------ | :----: | :---: | :-: | :----: | :------------: | :-------: | :--: | :---: | :-----------: | :-----: |
| before\_fair.c | init\_entity\_runnable\_average |  False | False |  0  |  CWE-  | CallExpression |   memset  |  703 |   -3  |       85      |    1    |
| before\_fair.c | update\_numa\_stats             |  False | False |  1  |  CWE-  | CallExpression |   memset  | 1476 |   -3  |       95      |    1    |
| before\_fair.c | update\_task\_scan\_period      |  False | False |  2  |  CWE-  | CallExpression |   memset  | 1978 |   -3  |      409      |    0    |
| before\_fair.c | task\_numa\_fault               |  False | False |  3  |  CWE-  | CallExpression |   memset  | 2375 |   -3  |      419      |    0    |
| before\_fair.c | update\_sg\_lb\_stats           |  False | False |  4  |  CWE-  | CallExpression |   memset  | 8172 |   -3  |      390      |    0    |



