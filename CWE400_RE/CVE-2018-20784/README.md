# 📁 CVE-2018-20784

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3)**| **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2018-20784/)**

> Linux 커널 CFS 스케줄러의 `update_blocked_averages()` 함수 내 리스트 순회 루프가 비정상적인 리스트 상태(`rq->leaf_cfs_rq_list`)에서 종료되지 않고 **무한 루프에 빠지는 DoS 취약점**입니다.
> 이는 고부하 상황에서 시스템 응답 중단, 커널 lockup 등의 문제를 유발할 수 있습니다.

**취약점 종류**: \[[CWE-400](https://cwe.mitre.org/data/definitions/400.html)] Uncontrolled Resource Consumption

* **취약 조건**: 리스트 순회 중 제거된 엔트리 접근, `tmp_alone_branch` 포인터 유지 실패
* **Sink**: `for_each_leaf_cfs_rq_safe()` 매크로 반복문 내 무한 순회

---

## 탐지 결과 요약

| 총 슬라이스 수 | 취약으로 탐지 | 정상으로 탐지 |
| -------- | ------- | ------- |
| 5개       | 2개      | 3개      |

그러나 **취약 함수인 `update_blocked_averages()` 함수는 슬라이스에 포함되지 않았으며**, 모두 다른 함수들에서 생성된 `memset()` 호출 슬라이스입니다.

---

## ⚠️ 탐지 결과 문제점

1. **핵심 취약 함수 누락**

   * 실제 취약한 `update_blocked_averages()` 함수에 대한 슬라이스가 생성되지 않음

2. **무한 루프 구조 탐지 실패**

   * `for_each_leaf_cfs_rq_safe()` 반복문이 조건 없이 순회할 수 있는 구조를 모델이 인식하지 못함

3. **CFS 리스트 구조 이해 부족**

   * `rq->leaf_cfs_rq_list`의 리스트 상태가 손상될 경우 발생하는 문제를 반영하지 못함

4. **불충분한 컨텍스트 및 흐름 추적**

   * `tmp_alone_branch` → `leaf_cfs_rq_list` 간의 포인터 연산 관계와 리스트 연결 문제를 슬라이스에 담지 못함

---


## 🧠 추가 분석 정보

---

### 🔎 Slicer 추출 코드

```c
memset(sa, 0, sizeof(*sa));
```

📄 **근거**: \[`slicer_result.json` – idx: 0, Caller: `init_entity_runnable_average`]
해당 슬라이스는 취약점이 존재하는 반복문(`for_each_leaf_cfs_rq_safe`)이나 리스트 순회 구조가 아닌, 단순 초기화 함수 호출(`memset`)만 포함되어 있습니다. 실제 커널 hang을 유발하는 **루프 구조, 리스트 무결성, 포인터 접근 등은 모두 슬라이스에서 누락**되어 있습니다.

> 슬라이서가 반복문 바깥의 안전한 함수만 추출하면서, 위험 흐름을 반영하지 못하는 구조적 결함이 존재합니다.

---

### 🧩 토큰화된 코드 (심볼화)

```c
memset(Var2, 0, sizeof(*Var2));
```

📄 **근거**: \[`slicer_result.symbolized.json` – idx: 0, tokenized field]
코드는 `Var2`, `Var1` 등의 추상화된 변수명으로 심볼화되어 있으며, 위험한 컨텍스트(예: 리스트 삭제, 루프 조건, 매크로 기반 순회)는 존재하지 않습니다. 구조적으로는 일반적인 안전 초기화 패턴처럼 보입니다.

> 이로 인해 AI 모델은 코드를 단순 메모리 초기화 루틴으로 잘못 해석할 가능성이 매우 높습니다.

---

### 🔤 AI 입력 토큰 예시

```plaintext
<s>, memset, (, Var2, ,, 0, ,, sizeof, (, *, Var2, ), ), ;, if, (, FUNC2, (, Var1, ), ), Var2->memberVar1 = ...
```

📄 **근거**: \[`vectors.json` – id: "0", input\_tokens field]
토큰 시퀀스는 `memset()` 호출을 중심으로 구성되어 있으며, 이후 조건문과 멤버 초기화 구문이 이어집니다. 그러나 루프, 매크로, 리스트 조작 등의 **커널 특유의 반복 제어 흐름은 표현되지 않음**.

> 단편적인 함수 호출 중심의 시퀀스로 인해, AI 모델은 실제 취약 패턴을 감지할 수 있는 충분한 구조 정보를 받지 못합니다.

---


## 🧪 개선 방향 제안

1. **취약 함수 기반 우선 슬라이싱**

   * 커널 주요 루틴(`update_blocked_averages`)에 대한 슬라이스를 우선 생성하도록 전략 강화

2. **리스트 순회 기반 루프 탐지 강화**

   * 반복문과 포인터 조작이 결합된 구조(`list_for_each_entry_safe`)의 위험성 인지 강화

3. **커널 자료구조 맥락 학습**

   * `cfs_rq`, `rq`, `leaf_cfs_rq_list` 간 연계관계를 모델이 인지할 수 있도록 학습데이터 개선

4. **함수 간 슬라이스 연결 지원**

   * 반복문 내부에서 루프 종료조건이 외부 포인터 변수와 관련된 경우 이를 추적할 수 있는 분석 강화

---

## 취약점 세부 사항

### 📁 관련 파일 소개

| 파일명      | 설명                  |
| -------- | ------------------- |
| `before_fair.c` | 취약 코드(수정 전) 포함 |
| `after_fair.c` | 취약 코드(수정 후) 포함 |

---


# 🛡️ Linux 커널 스케줄러의 취약 순회 매크로 분석 및 RCU 기반 개선

## ❗️ 취약 코드 분석

```c
for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
    ...
}
```

### 📌 기술적 설명

해당 코드는 Linux Completely Fair Scheduler(CFS)의 leaf runqueue 순회를 위한 매크로 중 하나로, `rq`(runqueue) 내부의 각 `cfs_rq`(CFS runqueue) 리스트 엔트리에 대해 반복 처리를 수행합니다. 그러나 `*_safe` 접미어에도 불구하고, 이는 내부적으로 다음과 같은 심각한 결함을 내포하고 있습니다.

* `pos` 포인터를 사용한 순회 구조는 리스트가 **삭제되거나 손상된 경우**, 다음 노드로의 정상적인 이동을 보장하지 못합니다.
* 특히 CFS 구조 내 리스트(`rq->leaf_cfs_rq_list`)가 중간에 변형되거나 무결성이 깨질 경우, 루프 탈출 조건이 상실되어 **무한 루프**가 발생할 수 있습니다.
* 이는 결과적으로 **커널 hang**이나 **soft lockup**으로 이어질 수 있으며, 실제로 몇몇 CVE(Critical Vulnerabilities and Exposures)에서도 유사한 사례가 보고되었습니다.

> ⚠️ 즉, 해당 매크로는 **RCU(Read-Copy-Update)** 기반의 동시성 제어가 필요한 커널 환경에서는 구조적으로 안전하지 않습니다.

---

## ✅ 개선 코드: RCU 기반 안전 순회

```c
#define for_each_leaf_cfs_rq(rq, cfs_rq) \
    list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
```

### 📌 개선점 및 구조적 안전성 확보

위 개선 코드는 **RCU 기반 리스트 순회 매크로**로, 커널의 리스트 무결성 손상 가능성과 동시성 문제를 다음과 같이 해소합니다:

* `list_for_each_entry_rcu()`는 RCU 보호 하에 안전한 순회를 제공하여, 노드 삭제나 리스트 변형 시에도 **메모리 참조 오류 없이 루프 탈출이 가능**합니다.
* 순회 중 삭제된 엔트리에 접근하지 않도록 RCU grace period를 활용하며, 이는 다중 CPU 환경에서도 **데이터 경합 조건을 방지**합니다.
* 결과적으로 스케줄러 내부의 순회 구조를 **lockless & deadlock-free**로 유지하며, **정지 상태(hang), infinite loop, soft lockup** 등 치명적인 커널 오류를 방지합니다.

---

## 🔍 핵심 비교 요약

| 항목          | 취약 코드 (`*_safe`)       | 개선 코드 (`RCU 기반`)               |
| ----------- | ---------------------- | ------------------------------ |
| 순회 안전성      | 낮음 (리스트 손상 시 무한 루프 가능) | 높음 (RCU grace period로 안정성 확보)  |
| 커널 동시성 대응   | 미흡                     | 강력 (RCU 동기화)                   |
| 커널 hang 가능성 | 존재                     | 제거                             |
| 사용 사례       | 단순 순회에 한정              | 실질적인 커널 스케줄러, 네트워크 스택 등 광범위 적용 |

---

## 탐지 결과

\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출

> 실제 취약 함수인 `update_blocked_averages()` 함수에 해당하는 슬라이스는 **포함되지 않음**
> 아래는 모델이 탐지한 상위 5개 슬라이스입니다:

| FileName | Caller                          | Source | Sink  | idx | CWE-ID | category       | criterion | line | label | token\_length | predict |
| -------- | ------------------------------- | ------ | ----- | --- | ------ | -------------- | --------- | ---- | ----- | ------------- | ------- |
| before.c | init\_entity\_runnable\_average | False  | False | 0   | CWE-   | CallExpression | memset    | 703  | -3    | 85            | 1       |
| before.c | update\_numa\_stats             | False  | False | 1   | CWE-   | CallExpression | memset    | 1476 | -3    | 95            | 1       |
| before.c | update\_task\_scan\_period      | False  | False | 2   | CWE-   | CallExpression | memset    | 1978 | -3    | 409           | 0       |
| before.c | task\_numa\_fault               | False  | False | 3   | CWE-   | CallExpression | memset    | 2375 | -3    | 419           | 0       |
| before.c | update\_sg\_lb\_stats           | False  | False | 4   | CWE-   | CallExpression | memset    | 8172 | -3    | 390           | 0       |


