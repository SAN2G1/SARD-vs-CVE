# CVE-2017-11142 분석 근거 문서

## 1. 취약점 개요 검증

### 1.1 취약점 종류 (CWE-400)
- **간단한 설명**: 이 취약점은 PHP가 POST 데이터를 처리할 때 메모리를 비효율적으로 사용하는 문제입니다.
- **근거 1**: `CVE-2017-11142.diff` 파일의 패치 내용
  ```diff
  + /* Bytes in ptr that have already been scanned for '&' */
  + size_t already_scanned;
  ```
  - 이 패치는 "이미 검사한 부분을 다시 검사하지 않도록" 하는 수정입니다.
  - 마치 책을 읽을 때 이미 읽은 페이지를 다시 읽지 않도록 북마크를 사용하는 것과 같습니다.

- **근거 2**: CVE 데이터베이스 정보
  - CVE-2017-11142는 CWE-400(Resource Exhaustion)으로 분류됨
  - 이는 프로그램이 리소스(여기서는 메모리)를 비효율적으로 사용하는 취약점임을 의미

### 1.2 취약 조건
- **간단한 설명**: 프로그램이 같은 메모리 영역을 계속해서 반복 검사하는 문제입니다.

- **코드 흐름 설명**:
  1. POST 데이터 처리 과정
     ```c
     // 1. POST 데이터가 들어오면 add_post_var() 함수가 호출됨
     static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
     {
         // 2. 문제가 되는 코드: 매번 처음부터 끝까지 검사
         vsep = memchr(var->ptr, '&', var->end - var->ptr);
         
         // 3. 데이터 처리 후 다음 검사를 위해 포인터 이동
         var->ptr = vsep + (vsep != var->end);
     }
     ```

  2. 문제가 발생하는 시나리오
     ```
     POST 데이터: "name=value&age=20&city=seoul"
     
     첫 번째 검사: "name=value&age=20&city=seoul"
                    ^
     두 번째 검사: "name=value&age=20&city=seoul"
                           ^
     세 번째 검사: "name=value&age=20&city=seoul"
                                  ^
     ```
     - 매 검사마다 처음부터 끝까지 다시 검사
     - 이미 검사한 부분을 다시 검사하는 비효율 발생
     - 데이터가 클 경우 성능 저하와 메모리 사용량 증가

- **근거 1**: `before_php_variables.c`의 문제 코드
  ```c
  vsep = memchr(var->ptr, '&', var->end - var->ptr);
  ```
  - 이 코드는 매번 처음부터 끝까지 검사를 수행합니다.
  - 마치 책을 처음부터 끝까지 계속 읽는 것과 같습니다.
  - 실제로는 이미 검사한 부분은 건너뛰어야 합니다.

- **근거 2**: `test_output.csv`의 정적 분석 결과
  ```
  before_php_variables.c,add_post_var,False,False,0,CWE-,CallExpression,memchr,253,-3,290,0
  before_php_variables.c,add_post_var,False,False,1,CWE-,CallExpression,memchr,262,-3,290,0
  ```
  - 이는 정적 분석 도구가 코드를 분석한 결과입니다.
  - 각 행의 의미:
    - `FileName`: 분석된 파일 이름
    - `Caller`: 함수 이름
    - `Source`: 소스 지점 (False는 소스가 아님을 의미)
    - `Sink`: 싱크 지점 (False는 싱크가 아님을 의미)
    - `line`: 코드 라인 번호
    - `predict`: 취약점 예측 결과 (0은 취약하지 않음)
  - `add_post_var` 함수에서 `memchr` 호출이 두 번 발견되었음을 보여줍니다.



### 1.3 Sink (취약점이 발생하는 지점)
- **간단한 설명**: `memchr()` 함수가 취약점의 핵심 지점입니다.
- **근거 1**: `test_output.csv`의 분석 결과
  ```
  before_php_variables.c,add_post_var,False,False,0,CWE-,CallExpression,memchr,253,-3,290,0
  before_php_variables.c,add_post_var,False,False,1,CWE-,CallExpression,memchr,262,-3,290,0
  ```
  - 이 함수가 두 번 호출되는 것을 확인할 수 있습니다.

- **근거 2**: 실제 코드 실행 흐름
  - POST 데이터를 처리할 때마다 `memchr()` 함수가 호출됨
  - 이는 마치 책에서 특정 단어를 찾을 때마다 처음부터 끝까지 검색하는 것과 같습니다.

## 2. 분석 결과 검증

### 2.1 슬라이스 수 (14개)
- **간단한 설명**: 취약한 버전(`before_php_variables.c`)의 코드에서 분석된 코드 조각이 14개 있습니다.
- **근거 1**: `test_output.csv` 파일의 분석 결과
  - 취약한 버전의 코드에서 총 14개의 코드 조각을 분석했습니다.
  - 각 조각은 프로그램의 특정 부분을 나타냅니다.

- **근거 2**: 코드 조각의 분포
  - `add_post_var`: 2개 (POST 데이터 처리 함수)
  - `add_post_vars`: 1개 (POST 변수 처리 함수)
  - `php_auto_globals_create_*`: 10개 (자동 전역 변수 생성 함수들)
  - `check_http_proxy`: 1개 (HTTP 프록시 검사 함수)

### 2.2 취약/정상 탐지 결과
- **간단한 설명**: 취약한 버전의 코드에서 모든 코드 조각이 정상으로 판단되었습니다.
- **근거 1**: `test_output.csv`의 predict 컬럼
  - 모든 행의 predict 값이 0입니다.
  - 0은 "정상"을 의미하지만, 이는 정적 분석 도구의 판단 결과입니다.
  - 실제로는 이 코드에 CWE-400 취약점이 존재합니다.

- **근거 2**: 실제 취약점 존재 증거
  - `before_php_variables.c`의 `add_post_var` 함수에서 메모리 검색이 비효율적으로 수행됨
  - 패치된 버전(`after_php_variables.c`)에서 `already_scanned` 필드가 추가된 것을 통해 취약점이 존재했음을 확인
  - 정적 분석 도구가 취약점을 탐지하지 못했지만, 실제 코드 검토를 통해 취약점이 확인됨

## 3. 취약점 세부 사항 검증

### 3.1 취약 코드
- **간단한 설명**: POST 데이터 처리 과정에서 발생하는 메모리 검색 비효율성 문제입니다.

- **코드 흐름 설명**:
  1. POST 데이터 처리 과정
     ```c
     // 1. POST 데이터가 들어오면 add_post_var() 함수가 호출됨
     static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
     {
         // 2. 문제가 되는 코드: 매번 처음부터 끝까지 검사
         vsep = memchr(var->ptr, '&', var->end - var->ptr);
         
         // 3. 데이터 처리 후 다음 검사를 위해 포인터 이동
         var->ptr = vsep + (vsep != var->end);
     }
     ```

  2. 문제가 발생하는 시나리오
     ```
     POST 데이터: "name=value&age=20&city=seoul"
     
     첫 번째 검사: "name=value&age=20&city=seoul"
                    ^
     두 번째 검사: "name=value&age=20&city=seoul"
                           ^
     세 번째 검사: "name=value&age=20&city=seoul"
                                  ^
     ```
     - 매 검사마다 처음부터 끝까지 다시 검사
     - 이미 검사한 부분을 다시 검사하는 비효율 발생
     - 데이터가 클 경우 성능 저하와 메모리 사용량 증가

- **근거 1**: `before_php_variables.c`의 문제 코드
  ```c
  vsep = memchr(var->ptr, '&', var->end - var->ptr);
  ```
  - 이 코드는 매번 처음부터 끝까지 검사를 수행합니다.
  - 마치 책을 처음부터 끝까지 계속 읽는 것과 같습니다.
  - 실제로는 이미 검사한 부분은 건너뛰어야 합니다.

- **근거 2**: 파일 크기 변화
  - `before_php_variables.c`: 950줄
  - `after_php_variables.c`: 956줄
  - 6줄이 추가되어 패치가 적용됨

### 3.2 개선 방법
- **간단한 설명**: `CVE-2017-11142.diff` 파일을 기반으로 한 실제 개선 방법입니다.

- **근거 1**: 패치 내용 (`CVE-2017-11142.diff`)
  ```diff
  typedef struct post_var_data {
      smart_str str;
      char *ptr;
      char *end;
      uint64_t cnt;
  + /* Bytes in ptr that have already been scanned for '&' */
  + size_t already_scanned;
  } post_var_data_t;

  static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
  {
      char *ksep, *vsep, *val;
      size_t klen, vlen;
      /* FIXME: string-size_t */
      unsigned int new_vlen;
  + char *start;

      if (var->ptr >= var->end) {
          return 0;
      }

  - vsep = memchr(var->ptr, '&', var->end - var->ptr);
  + start = var->ptr + var->already_scanned;
  + vsep = memchr(start, '&', var->end - start);
      if (!vsep) {
          if (!eof) {
              return 0;
          } else {
              vsep = var->end;
          }
      }

      ksep = memchr(var->ptr, '=', vsep - var->ptr);
      if (ksep) {
          *ksep = '\0';
          /* "foo=bar&" or "foo=&" */
          klen = ksep - var->ptr;
          vlen = vsep - ++ksep;
      } else {
          ksep = "";
          /* "foo&" */
          klen = vsep - var->ptr;
          vlen = 0;
      }

      php_url_decode(var->ptr, klen);

      val = estrndup(ksep, vlen);
      if (vlen) {
          vlen = php_url_decode(val, vlen);
      }

      if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {
          php_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);
      }
      efree(val);

  - var->ptr = vsep + (vsep != var->end);
  + var->ptr = vsep + (vsep != var->end);
  + var->already_scanned = vsep - var->ptr;
      return 1;
  }
  ```

- **근거 2**: 개선 효과
  1. 메모리 검색 최적화
     - `already_scanned` 필드를 통해 이미 검사한 위치를 추적
     - 다음 검사 시 이전에 검사한 부분을 건너뛰어 검색 범위 감소
  2. 성능 향상
     - 불필요한 메모리 검색 제거로 처리 속도 개선
     - 대용량 POST 데이터 처리 시 성능 향상
  3. 리소스 사용 효율화
     - 메모리 사용량 감소
     - CPU 사용량 감소

## 4. 파일 구조 검증

### 4.1 소스 코드 파일
- **간단한 설명**: 취약한 버전과 수정된 버전의 코드를 비교할 수 있습니다.
- **근거 1**: 파일 비교
  - `before_php_variables.c`: 문제가 있는 버전
  - `after_php_variables.c`: 수정된 버전
  - 두 파일을 비교하면 변경 사항을 확인할 수 있습니다.

- **근거 2**: 파일 크기
  - 두 파일 모두 26KB
  - 수정된 버전이 6줄 더 많음
  - 이는 패치로 인한 변경을 보여줍니다.

### 4.2 분석 결과 파일
- **간단한 설명**: 취약점 분석에 사용된 다양한 파일들이 있습니다.
- **근거 1**: 분석 파일 목록
  - `test_output.csv`: 분석 결과 요약
  - `slicer_result.json`: 상세 분석 정보
  - `slicer_result.symbolized.json`: 심볼 정보
  - `vectors.json`: 테스트 데이터

- **근거 2**: 파일 용도
  - 각 파일은 분석의 다른 측면을 보여줍니다.
  - 이를 통해 취약점을 다각도로 검증할 수 있습니다.

## 5. 결론
이 문서는 README.md의 내용을 쉽게 이해할 수 있도록 설명하고, 각 주장에 대한 명확한 근거를 제공합니다. 실제 코드와 분석 결과를 통해 취약점의 존재와 해결 방법을 검증했습니다. 

## 6. 정적 분석 결과 검증

### 6.1 정적 분석 결과 검증
- **간단한 설명**: SARD 도구가 취약한 버전의 코드를 분석한 결과를 검증합니다.

- **근거 1**: `test_output.csv`의 분석 결과
  ```
  before_php_variables.c,add_post_var,False,False,0,CWE-,CallExpression,memchr,253,-3,290,0
  before_php_variables.c,add_post_var,False,False,1,CWE-,CallExpression,memchr,262,-3,290,0
  ```
  - Source와 Sink가 모두 False로 표시됨
  - predict 값이 0으로, 취약점이 없다고 판단
  - 이는 정적 분석 도구가 메모리 검색의 비효율성을 취약점으로 인식하지 못했음을 의미

### 6.2 after 파일 분석의 의미
- **간단한 설명**: after 파일을 정적 분석 도구로 분석하는 것은 제한적인 의미만 가짐

- **근거 1**: 도구의 목적 관점
  - 정적 분석 도구는 취약점을 찾는 것이 주 목적
  - after 파일은 이미 패치가 적용된 안전한 코드
  - 취약점이 제거된 코드를 분석하는 것은 도구의 본래 목적과 맞지 않음

- **근거 2**: 실제 사용 시나리오
  - 개발자가 작성한 코드의 취약점을 찾는 것이 주 목적
  - 패치된 코드를 분석하는 것은 실제 사용 사례와 맞지 않음
  - 리소스와 시간을 효율적으로 사용하기 위해서는 취약점이 의심되는 코드에 집중하는 것이 바람직

### 6.3 실제 취약점과 탐지 결과의 차이
- **간단한 설명**: 정적 분석 결과와 실제 취약점의 차이점을 설명합니다.

- **근거 1**: 취약점 패치 내용
  ```diff
  typedef struct post_var_data {
      smart_str str;
      char *ptr;
      char *end;
      uint64_t cnt;
  + /* Bytes in ptr that have already been scanned for '&' */
  + size_t already_scanned;
  } post_var_data_t;
  ```
  - 실제로는 메모리 검색의 비효율성이 문제였음
  - `already_scanned` 필드 추가를 통한 개선
  - 이는 정적 분석 도구가 탐지하지 못한 실제 취약점임

- **근거 2**: 성능 영향
  - 대용량 POST 데이터 처리 시 성능 저하 발생
  - 메모리 사용량 증가로 인한 리소스 소진 가능성
  - 이러한 런타임 문제는 정적 분석으로는 탐지하기 어려움

### 6.4 정적 분석의 한계점
- **간단한 설명**: SARD 도구의 한계와 실제 취약점 탐지의 차이를 설명합니다.

- **근거 1**: 분석 범위의 한계
  - 정적 분석은 코드의 구조적 특성만 분석
  - 런타임 성능 문제는 탐지하기 어려움
  - 메모리 사용 패턴의 비효율성은 정적 분석으로는 파악이 어려움

- **근거 2**: 취약점 판단 기준
  - SARD는 주로 명시적인 보안 취약점에 초점
  - CWE-400과 같은 리소스 소진 취약점은 탐지가 어려움
  - 성능 관련 문제는 보안 취약점으로 인식되지 않을 수 있음

### 6.5 결론
- **간단한 설명**: SARD와 CVE 탐지 결과의 차이와 그 원인을 정리합니다.

- **근거 1**: 탐지 결과 차이의 원인
  - SARD 데이터셋과 실제 CVE 코드의 특성 차이
  - 정적 분석 도구의 한계로 인한 성능 관련 취약점 탐지 실패
  - 복잡한 코드 구조에서의 취약점 탐지 어려움

- **근거 2**: 향후 개선 방향
  - 정적 분석 도구의 성능 문제 탐지 능력 향상 필요
  - 런타임 분석과의 결합을 통한 더 정확한 취약점 탐지 필요
  - CWE-400과 같은 리소스 소진 취약점에 대한 탐지 기준 개선 필요
  - 성능 관련 취약점에 대한 탐지 기준 추가 필요
  - 실제 프로젝트의 복잡한 코드 구조를 고려한 분석 방법 개발 필요

## 7. SARD와 CVE 탐지 차이 분석

### 7.1 SARD 데이터셋의 특성
- **간단한 설명**: SARD 데이터셋의 특성과 탐지가 용이한 이유를 분석합니다.

- **근거 1**: 코드 구조의 특성
  - 명시적인 취약점 패턴을 가진 코드로 구성
  - 각 취약점이 독립적으로 존재하여 탐지가 용이
  - 취약점 패턴이 단순하고 명확함
  - 테스트 케이스가 명확하게 정의되어 있음
  - 취약점이 발생하는 조건이 명시적으로 표현됨

- **근거 2**: 탐지 용이성
  - 독립적인 취약점으로 인해 분석이 용이
  - 정적 분석 도구의 한계가 덜 두드러짐
  - 높은 탐지율을 보임

### 7.2 CVE의 특성
- **간단한 설명**: CVE의 특성과 탐지가 어려운 이유를 분석합니다.

- **근거 1**: 코드 구조의 복잡성
  - 실제 프로젝트의 복잡한 코드 구조
  - 취약점이 여러 함수나 파일에 걸쳐 존재
  - 성능 관련 취약점(CWE-400)은 패턴이 불명확
  - 취약점이 발생하는 조건이 런타임에 따라 달라짐
  - 코드의 맥락과 실행 환경에 따라 영향이 달라짐

- **근거 2**: 탐지의 어려움
  - 복잡한 코드 구조로 인해 낮은 탐지율
  - 런타임 성능 문제는 정적 분석으로 탐지 어려움
  - 정적 분석 도구의 한계가 명확히 드러남

### 7.3 탐지 결과의 차이
- **간단한 설명**: SARD와 CVE의 탐지 결과 차이를 분석합니다.

- **근거 1**: SARD 데이터셋 분석 결과
  - 명확한 취약점 패턴으로 인해 높은 탐지율
  - 독립적인 취약점으로 인해 분석이 용이
  - 정적 분석 도구의 한계가 덜 두드러짐

- **근거 2**: CVE 분석 결과
  - 복잡한 코드 구조로 인해 낮은 탐지율
  - 런타임 성능 문제는 정적 분석으로 탐지 어려움
  - 정적 분석 도구의 한계가 명확히 드러남

### 7.4 탐지 실패 원인
- **간단한 설명**: CVE 취약점 탐지가 실패하는 원인을 분석합니다.

- **근거 1**: 정적 분석의 한계
  - 런타임 성능 문제는 코드 실행 없이 파악하기 어려움
  - 메모리 사용 패턴의 비효율성은 정적 분석으로는 탐지 불가

- **근거 2**: 코드 구조의 복잡성
  - 취약점이 여러 함수에 걸쳐 존재
  - 취약점의 영향이 런타임에 따라 달라짐

- **근거 3**: 취약점 패턴의 불명확성
  - CWE-400은 명확한 패턴이 없음
  - 성능 관련 문제는 보안 취약점으로 인식되기 어려움

### 7.5 결론
- **간단한 설명**: SARD와 CVE 탐지 차이의 의미와 향후 개선 방향을 제시합니다.

- **근거 1**: 탐지 차이의 의미
  - SARD 데이터셋은 정적 분석 도구의 한계를 완전히 반영하지 못함
  - 실제 프로젝트의 복잡한 취약점은 탐지가 어려움
  - 성능 관련 취약점은 정적 분석으로는 탐지가 제한적

- **근거 2**: 향후 개선 방향
  - 정적 분석 도구의 성능 문제 탐지 능력 향상 필요
  - 런타임 분석과의 결합을 통한 더 정확한 취약점 탐지 필요
  - CWE-400과 같은 리소스 소진 취약점에 대한 탐지 기준 개선 필요
  - 성능 관련 취약점에 대한 탐지 기준 추가 필요
  - 실제 프로젝트의 복잡한 코드 구조를 고려한 분석 방법 개발 필요

## 8. README.md 분석 결과 검증

### 8.1 분석 결과 요약 검증
- **간단한 설명**: README.md의 분석 결과 요약이 정확한지 검증합니다.

- **근거 1**: 슬라이스 수 검증
  - `test_output.csv`에서 취약한 함수(Caller)와 Sink 관련 슬라이스만 추출
  - 총 14개의 슬라이스가 발견됨
  - 이는 README.md의 "총 14개의 슬라이스가 발견되었습니다"와 일치

- **근거 2**: 탐지 결과 검증
  - 모든 슬라이스의 predict 값이 0으로, 정상으로 탐지됨
  - 취약으로 탐지된 슬라이스는 없음
  - 이는 README.md의 "취약으로 탐지: 0개, 정상으로 탐지: 14개"와 일치

### 8.2 취약 함수와 Sink 분석
- **간단한 설명**: 취약한 함수와 Sink 관련 슬라이스의 특성을 분석합니다.

- **근거 1**: 취약 함수 분석
  - `add_post_var`: POST 데이터 처리 함수 (2개 슬라이스)
  - `add_post_vars`: POST 변수 처리 함수 (1개 슬라이스)
  - `php_auto_globals_create_*`: 자동 전역 변수 생성 함수들 (10개 슬라이스)
  - `check_http_proxy`: HTTP 프록시 검사 함수 (1개 슬라이스)

- **근거 2**: Sink 분석
  - `memchr`: 메모리 검색 함수 (2개 슬라이스)
  - `memmove`: 메모리 이동 함수 (1개 슬라이스)
  - `strchr`: 문자열 검색 함수 (10개 슬라이스)
  - `getenv`: 환경 변수 검색 함수 (1개 슬라이스)

### 8.3 분석 결과의 의미
- **간단한 설명**: 분석 결과가 의미하는 바를 설명합니다.

- **근거 1**: 정적 분석의 한계
  - 모든 슬라이스가 정상으로 탐지됨
  - 이는 정적 분석 도구가 런타임 성능 문제를 탐지하지 못함을 보여줌
  - CWE-400과 같은 리소스 소진 취약점은 정적 분석으로는 탐지가 어려움

- **근거 2**: 취약점의 특성
  - 취약점이 여러 함수에 걸쳐 존재
  - 메모리 검색의 비효율성이 주요 문제
  - 이러한 성능 관련 문제는 정적 분석으로는 파악이 어려움

### 8.4 결론
- **간단한 설명**: README.md의 분석 결과 요약이 정확하며, 이는 정적 분석의 한계를 보여줍니다.

- **근거 1**: 분석 결과의 정확성
  - 슬라이스 수와 탐지 결과가 정확히 기록됨
  - 취약 함수와 Sink 관련 슬라이스가 올바르게 추출됨
  - 분석 결과가 실제 코드와 일치함

- **근거 2**: 정적 분석의 한계
  - 런타임 성능 문제는 정적 분석으로는 탐지가 어려움
  - CWE-400과 같은 리소스 소진 취약점은 정적 분석의 한계를 보여줌
  - 실제 취약점이 존재하지만 정적 분석으로는 탐지되지 않음

[이후 내용 유지...] 