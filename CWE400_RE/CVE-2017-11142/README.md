# 📁 CVE-2017-11142

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/php/php-src/commit/6da79bddc334f)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2017-11142)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/400.html)**

> PHP의 `main/php_variables.c`의 `add_post_vars()` 함수에서 발생한 Resource Exhaustion(CWE-400) 취약점입니다.

* **Source**: `post_var_data` 구조체의 `str` 변수 (`before_php_variables.c:232-237`)
```c
typedef struct post_var_data {
    smart_str str;    // POST 데이터를 저장하는 문자열 버퍼
    char *ptr;        // 현재 처리 중인 위치
    char *end;        // 데이터의 끝 위치
    uint64_t cnt;     // 처리된 변수 개수
    
    /* Bytes in ptr that have already been scanned for '&' */
    size_t already_scanned;  // 이미 스캔된 바이트 수를 추적
} post_var_data_t;
```

* **취약 조건**: `add_post_vars()` 함수 (`before_php_variables.c:291-311`)에서:
  1. POST 데이터 처리 시 메모리 재할당 과정에서 무한 루프 발생 가능
  2. `memmove()` 함수 호출로 인한 과도한 CPU 리소스 소모
  3. 입력 변수 개수 제한만 체크하고 각 변수의 크기 제한이 없음

* **Sink**: `add_post_vars()` 함수의 `memmove()` 호출 (`before_php_variables.c:308`)
```c
if (!eof) {
    memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
}
```
이 부분에서 메모리 이동이 발생하면서 CPU 리소스를 과도하게 소모하여 서비스 거부(DoS) 발생

---

## 탐지 결과 요약
---
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스만 고려했을 때,
| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 1개       | 0개 | 1개 |

add_post_vars()에서 추출한 슬라이스 중, Sink(memmove() 함수) 관련 슬라이스는 1건 있었으나, 정상으로 탐지됨

| FileName | Caller | Source | Sink | idx | CWE-ID | category | criterion | line | label | token_length | predict |
|---------|-------|------|-----|---|------|---------|---------|----|-----|------------|-------|
| before_php_variables.c | add_post_vars | False | False | 2 | CWE- | CallExpression | memmove | 308 | -3 | 152 | 0 |

---

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **슬라이싱 범위 불완전**
   - 현재 슬라이스는 `add_post_vars` 함수의 핵심 부분을 포함:
     ```c
     static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
     {
         uint64_t max_vars = PG(max_input_vars);
         vars->ptr = vars->str.c;
         vars->end = vars->str.c + vars->str.len;
         if (++vars->cnt > max_vars) {
             // ...
         }
         if (!eof) {
             memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
         }
     }
     ```
   - 그러나 이 슬라이스는 메모리 재할당 과정에서 발생하는 무한 루프의 전체 컨텍스트를 완전히 반영하지 못함

### ❗️ 취약 코드

#### Source: `before_php_variables.c:235-240`
```c
typedef struct post_var_data {
    smart_str str;    // POST 데이터를 저장하는 문자열 버퍼
    char *ptr;        // 현재 처리 중인 위치
    char *end;        // 데이터의 끝 위치
    uint64_t cnt;     // 처리된 변수 개수
} post_var_data_t;
```

**Source 설명**:
- `str` 변수: 외부에서 제어 가능한 POST 데이터가 저장되는 버퍼
- `ptr`: 현재 처리 중인 위치를 가리키는 포인터로, 취약점의 핵심
- `end`: 데이터의 끝 위치를 가리키는 포인터
- 이 구조체는 POST 데이터 처리의 시작점이 되며, 외부 입력이 시스템 내부로 유입되는 지점

#### Sink: `before_php_variables.c:308`
```c
if (!eof) {
    memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
}
```

**Sink 설명**:
- `memmove` 함수 호출: 처리되지 않은 데이터를 버퍼 시작으로 이동
- 문제점: 이미 처리된 데이터를 다시 처리하게 되어 무한 루프 발생
- 결과: CPU 리소스가 과도하게 소모되어 서비스 거부(DoS) 발생

**취약점 발생 원인**:
1. `ptr` 포인터의 문제:
   - `ptr`은 현재 처리 중인 위치를 추적하는데 사용됨
   - 하지만 이미 처리된 데이터와 처리되지 않은 데이터를 구분할 수 없음
   - 이로 인해 동일한 데이터를 반복적으로 처리하게 됨

2. 메모리 이동의 문제:
   - `memmove`는 `ptr`부터 `end`까지의 데이터를 버퍼 시작으로 이동
   - 이미 처리된 데이터도 함께 이동되어 다시 처리됨
   - 이 과정이 반복되어 CPU 리소스가 고갈됨

3. 데이터 처리의 문제:
   - POST 데이터의 크기 제한이 없어 큰 데이터도 처리 가능
   - 처리되지 않은 데이터를 구분할 방법이 없어 무한 루프 발생
   - 결과적으로 CPU 리소스가 과도하게 소모됨

### ✅ 개선 코드

**패치 내용**: `after_php_variables.c:235-243, 297-317`
```c
// 구조체 정의 (after_php_variables.c:235-243)
typedef struct post_var_data {
    smart_str str;
    char *ptr;
    char *end;
    uint64_t cnt;
    /* Bytes in ptr that have already been scanned for '&' */
    size_t already_scanned;  // 이미 스캔된 바이트 수를 추적
} post_var_data_t;

// add_post_vars 함수 (after_php_variables.c:291-317)
static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
{
    uint64_t max_vars = PG(max_input_vars);

    vars->ptr = vars->str.c;
    vars->end = vars->str.c + vars->str.len;
    while (add_post_var(arr, vars, eof TSRMLS_CC)) {
        if (++vars->cnt > max_vars) {
            php_error_docref(NULL TSRMLS_CC, E_WARNING,
                    "Input variables exceeded %" PRIu64 ". "
                    "To increase the limit change max_input_vars in php.ini.",
                    max_vars);
            return FAILURE;
        }
    }

    if (!eof && vars->str.c != vars->ptr) {  // ptr이 시작 위치와 다른 경우에만 이동
        memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
    }
    return SUCCESS;
}
```

**개선 방법**:
1. 핵심 수정: `add_post_vars` 함수의 메모리 이동 조건 개선
   - `vars->str.c != vars->ptr` 조건 추가
   - 이미 처리된 데이터는 다시 이동하지 않도록 함
   - 이를 통해 무한 루프 발생 방지

2. 보조 수정: `already_scanned` 필드 추가
   - 메모리 이동 시 스캔 위치를 보존하기 위한 보조적인 수정
   - `add_post_var` 함수에서 스캔 진행 상황을 추적

**수정 효과**:
1. 불필요한 메모리 이동 방지
   - `ptr`이 시작 위치와 다른 경우에만 메모리 이동 수행
   - 이미 처리된 데이터는 다시 처리하지 않음

2. CPU 리소스 소모 방지
   - 무한 루프 발생 가능성 제거
   - 메모리 이동 횟수 최소화

---

## 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출

| FileName | Caller | Source | Sink | idx | CWE-ID | category | criterion | line | label | token_length | predict |
|---------|-------|------|-----|---|------|---------|---------|----|-----|------------|-------|
| before_php_variables.c | add_post_vars | False | False | 2 | CWE- | CallExpression | memmove | 308 | -3 | 152 | 0 |