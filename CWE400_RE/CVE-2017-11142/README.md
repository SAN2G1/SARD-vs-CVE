# 📁 CVE-2017-11142

## 🔍 취약점 개요

**🔗 [커밋 링크](https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2017-11142)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/400.html)**

> PHP의 `main/php_variables.c`의 `add_post_vars()` 함수에서 발생한 Resource Exhaustion(CWE-400) 취약점입니다.

* **Source**: `post_var_data` 구조체의 `str` 변수 (`before_php_variables.c:232-237`)
```c
typedef struct post_var_data {
    smart_str str;    // POST 데이터를 저장하는 문자열 버퍼
    char *ptr;        // 현재 처리 중인 위치
    char *end;        // 데이터의 끝 위치
    uint64_t cnt;     // 처리된 변수 개수
    
    /* Bytes in ptr that have already been scanned for '&' */
    size_t already_scanned;  // 이미 스캔된 바이트 수를 추적
} post_var_data_t;
```

**취약 조건**: `add_post_vars()` 함수 (`before_php_variables.c:291-311`)에서:
1. POST 데이터를 처리할 때, 처리 포인터(`vars->ptr`)가 적절히 갱신되지 않아 이미 처리한
    데이터와 처리하지 않은 데이터의 경계가 불분명해집니다.  
    memmove로 처리되지 않은 데이터를 버퍼 앞으로 이동시킨 후에도, 다음 루프에서 `vars->ptr`가 항상 버퍼의 시작 위치(`vars->str.c`)로 재설정되어,  
    이미 처리한 데이터까지 다시 반복적으로 처리하게 됩니다.  
    이로 인해 같은 데이터가 계속 처리되는 현상이 발생하며, 루프가 종료되지 않고 무한히 반복될 수 있습니다.  
    - **문제 발생 코드:**  `before_php_variables.c:307-309`
    ```c
    if (!eof) {
        memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
    }
    ```
  2. 위 memmove() 함수 호출이 반복적으로 발생하는 이유는,  
     무한 루프가 발생하면서 같은 데이터가 계속 처리되고,  
     매 반복마다 처리 포인터(`vars->ptr`)가 갱신되지 않은 채로 memmove가 계속 호출되기 때문입니다.  
     즉, 루프가 종료되지 않아 memmove가 끝없이 실행되며,  
     이로 인해 CPU 리소스가 과도하게 소모됩니다.

  3. 입력 변수의 "개수" 제한은 PHP의 전역 설정 값인 `PG(max_input_vars)`를 통해 이루어집니다.  
     이 값은 php.ini에서 `max_input_vars`로 설정할 수 있으며, 한 번의 요청에서 허용되는 입력 변수(POST/GET/COOKIE 등)의 최대 개수를 의미합니다. 만약 입력 변수 개수가 이 값을 초과하면, 더 이상 입력 변수를 처리하지 않고 함수가 실패(Failure)로 종료됩니다. 
     아래 코드에서 `vars->cnt`가 `max_vars`(= `PG(max_input_vars)`)를 초과하면 더 이상 입력 변수를 처리하지 않고, 경고 메시지를 출력하며 처리를 중단합니다.  
     - **개수 제한 코드:**  `before_php_variables.c:297-305`
       ```c
       while (add_post_var(arr, vars, eof TSRMLS_CC)) {
           if (++vars->cnt > max_vars) {
               php_error_docref(NULL TSRMLS_CC, E_WARNING,
                   "Input variables exceeded %" PRIu64 ". "
                   "To increase the limit change max_input_vars in php.ini.",
                   max_vars);
               return FAILURE;
           }
       }
       ```
       하지만 각 변수의 크기(메모리 사용량)는 제한하지 않으므로, 한 개의 변수에 매우 큰 데이터를 담아 전송하면 변수 개수 제한을 우회하여 여전히 서비스 거부(DoS) 공격이 가능합니다.  
       즉, 개수 제한은 있지만 크기 제한이 없어 대용량 데이터가 들어올 경우 시스템 리소스가 고갈될 수 있습니다.

* **Sink**: `add_post_vars()` 함수의 `memmove()` 호출 (`before_php_variables.c:308`)
```c
if (!eof) {
    memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
}
```
이 부분에서 메모리 이동이 발생하면서 CPU 리소스를 과도하게 소모하여 서비스 거부(DoS) 발생

---

## 탐지 결과 요약
---
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스만 고려했을 때,
| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 1개       | 0개 | 1개 |

add_post_vars()에서 추출한 슬라이스 중, Sink(memmove() 함수) 관련 슬라이스는 1건 있었으나, 정상으로 탐지됨

| FileName | Caller | Source | Sink | idx | CWE-ID | category | criterion | line | label | token_length | predict |
|---------|-------|------|-----|---|------|---------|---------|----|-----|------------|-------|
| before_php_variables.c | add_post_vars | False | False | 2 | CWE- | CallExpression | memmove | 308 | -3 | 152 | 0 |

이 CVE 취약점을 유발하는 코드(sink:php_variables.c:253, memset)는 아래와 같다.
```
static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC){
	if (var->ptr >= var->end) {
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
```
이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.
```c
/* main/php_variables.c:335 */
SAPI_API SAPI_POST_HANDLER_FUNC(php_std_post_handler) {
    zval *arr = (zval *) arg;
    php_stream *s = SG(request_info).request_body;
    post_var_data_t post_data;

    if (s && SUCCESS == php_stream_rewind(s)) {
        memset(&post_data, 0, sizeof(post_data));

        while (!php_stream_eof(s)) {
            char buf[SAPI_POST_HANDLER_BUFSIZ] = {0};
            size_t len = php_stream_read(s, buf, SAPI_POST_HANDLER_BUFSIZ);

            if (len && len != (size_t) -1) {
                smart_str_appendl(&post_data.str, buf, len);

                if (SUCCESS != add_post_vars(arr, &post_data, 0 TSRMLS_CC)) {
                    if (post_data.str.c) {
                        efree(post_data.str.c);
                    }
                    return;
                }
            }

            if (len != SAPI_POST_HANDLER_BUFSIZ) {
                break;
            }
        }

        add_post_vars(arr, &post_data, 1 TSRMLS_CC);
        if (post_data.str.c) {
            efree(post_data.str.c);
        }
    }
}

/* main/php_variables.c:298 */
static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC) {
    uint64_t max_vars = PG(max_input_vars);

    vars->ptr = vars->str.c;
    vars->end = vars->str.c + vars->str.len;

    while (add_post_var(arr, vars, eof TSRMLS_CC)) {
        if (++vars->cnt > max_vars) {
            php_error_docref(NULL TSRMLS_CC, E_WARNING,
                "Input variables exceeded %" PRIu64 ". "
                "To increase the limit change max_input_vars in php.ini.",
                max_vars);
            return FAILURE;
        }
    }

    if (!eof) {
        memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
    }
    return SUCCESS;
}

/* main/php_variables.c:253 */
static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC) {
    char *ksep, *vsep, *val;

    if (var->ptr >= var->end) {
        vsep = memchr(var->ptr, '&', var->end - var->ptr);
        if (!vsep) {
            if (!eof) {
                return 0;
            }
        }
    }
    return 1;
}
```

이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **슬라이싱 범위 불완전**
   - 아래는 `slicer_result.json`에서 idx 2번(criterion: memmove, line: 308)에 해당하는 실제 슬라이스 전체입니다.
```
{
    "FileName": "before_php_variables.c",
    "Caller": "add_post_vars",
    "Source": false,
    "Sink": false,
    "idx": 2,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 308,
    "label": -3,
    "slices": [
        "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n",
        "\tuint64_t max_vars = PG(max_input_vars);\n",
        "\tvars->ptr = vars->str.c;\n",
        "\tvars->end = vars->str.c + vars->str.len;\n",
        "\t\tif (++vars->cnt > max_vars) {\n",
        "\tif (!eof) {\n",
        "\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n"
    ]
}
```

- **이 슬라이스가 전체 컨텍스트를 완전히 반영하지 못하는 이유**
    - 이 슬라이스는 함수 내부의 한 번의 실행 흐름만 보여주고 있습니다.
    - 실제 취약점의 핵심은 add_post_vars가 여러 번 반복 호출되면서 처리 포인터(`vars->ptr`)가 항상 버퍼의 시작 위치로 재설정되고, memmove 이후에도 이미 처리한 데이터가 반복적으로 처리된다는 점입니다.
    - 하지만 슬라이스에는 이 함수가 반복적으로 호출되는 상위 컨텍스트(예: POST 데이터가 여러 번 나눠서 들어올 때마다 add_post_vars가 호출되는 구조)가 포함되어 있지 않습니다.
    - 또한, vars->ptr이 memmove 이후 어떻게 변화하고, 다음 호출에서 어떻게 다시 초기화되는지 드러나지 않습니다.
    - 즉, 함수 내부의 단일 실행만 보여주고, 실제로는 여러 번 호출되면서 상태가 누적되는 맥락이 드러나지 않습니다.

    - **이상적인 슬라이스 예시**(before_php_variables.c:318~352, 291~311)
    ```c
    SAPI_API SAPI_POST_HANDLER_FUNC(php_std_post_handler)
    {
        zval *arr = (zval *) arg;
        php_stream *s = SG(request_info).request_body;
        post_var_data_t post_data;

        if (s && SUCCESS == php_stream_rewind(s)) {
            memset(&post_data, 0, sizeof(post_data));

            while (!php_stream_eof(s)) {
                char buf[SAPI_POST_HANDLER_BUFSIZ] = {0};
                size_t len = php_stream_read(s, buf, SAPI_POST_HANDLER_BUFSIZ);

                if (len && len != (size_t) -1) {
                    smart_str_appendl(&post_data.str, buf, len);

                    // === [슬라이스 핵심] ===
                    if (SUCCESS != add_post_vars(arr, &post_data, 0 TSRMLS_CC)) {
                        if (post_data.str.c) {
                            efree(post_data.str.c);
                        }
                        return;
                    }
                    // ======================
                }

                if (len != SAPI_POST_HANDLER_BUFSIZ){
                    break;
                }
            }

            add_post_vars(arr, &post_data, 1 TSRMLS_CC);
            if (post_data.str.c) {
                efree(post_data.str.c);
            }
        }
    }

    static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
    {
        uint64_t max_vars = PG(max_input_vars);

        vars->ptr = vars->str.c;
        vars->end = vars->str.c + vars->str.len;
        while (add_post_var(arr, vars, eof TSRMLS_CC)) {
            if (++vars->cnt > max_vars) {
                php_error_docref(NULL TSRMLS_CC, E_WARNING,
                    "Input variables exceeded %" PRIu64 ". "
                    "To increase the limit change max_input_vars in php.ini.",
                    max_vars);
                return FAILURE;
            }
        }

        if (!eof) {
            memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
        }
        return SUCCESS;
    }
    ```

- **이 슬라이스가 이상적인 이유**
    - 상위 반복 구조(POST 데이터가 여러 번에 걸쳐 들어오고, 각 chunk마다 add_post_vars가 호출되는 구조)를 포함하여 실제 취약점이 발생하는 전체 맥락을 보여줍니다.
    - 처리 포인터(`vars->ptr`)의 상태 변화와 누적, memmove 이후의 흐름까지 모두 드러나 있어, 왜 같은 데이터가 반복 처리되고 무한 루프가 발생하는지 명확히 이해할 수 있습니다.


### ❗️ 취약 코드

#### Source: `before_php_variables.c:235-240`
```c
typedef struct post_var_data {
    smart_str str;    // POST 데이터를 저장하는 문자열 버퍼
    char *ptr;        // 현재 처리 중인 위치
    char *end;        // 데이터의 끝 위치
    uint64_t cnt;     // 처리된 변수 개수
} post_var_data_t;
```

**Source 설명**:
- `str` 변수: 외부에서 제어 가능한 POST 데이터가 저장되는 버퍼
- `ptr`: 현재 처리 중인 위치를 가리키는 포인터로, 취약점의 핵심
- `end`: 데이터의 끝 위치를 가리키는 포인터
- 이 구조체는 POST 데이터 처리의 시작점이 되며, 외부 입력이 시스템 내부로 유입되는 지점

#### 🔁 Trace: `php_std_post_handler` → `add_post_vars` (before_php_variables.c:318~352, 291~311)

```c
SAPI_API SAPI_POST_HANDLER_FUNC(php_std_post_handler)
{
    zval *arr = (zval *) arg;
    php_stream *s = SG(request_info).request_body;
    post_var_data_t post_data;

    if (s && SUCCESS == php_stream_rewind(s)) {
        memset(&post_data, 0, sizeof(post_data));

        while (!php_stream_eof(s)) {
            char buf[SAPI_POST_HANDLER_BUFSIZ] = {0};
            size_t len = php_stream_read(s, buf, SAPI_POST_HANDLER_BUFSIZ);

            if (len && len != (size_t) -1) {
                smart_str_appendl(&post_data.str, buf, len);

                // 🔥 취약 흐름 시작
                // - 버퍼에 쌓인 POST 데이터를 파싱
                // - 내부적으로 add_post_var()를 통해 key=value를 파싱
                // - BUT: '='나 '&' 없는 데이터가 들어오면 처리하지 않고 return (ptr 이동 없음)

                if (SUCCESS != add_post_vars(arr, &post_data, 0 TSRMLS_CC)) {
                    if (post_data.str.c) {
                        efree(post_data.str.c);
                    }
                    return;
                }
            }

            if (len != SAPI_POST_HANDLER_BUFSIZ){
                break;
            }
        }

        // 마지막 chunk일 경우 eof = 1
        // 그래도 ptr이 갱신되지 않았다면 동일 문제 반복 가능
        add_post_vars(arr, &post_data, 1 TSRMLS_CC);
        if (post_data.str.c) {
            efree(post_data.str.c);
        }
    }
}
```

```c
static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
{
    uint64_t max_vars = PG(max_input_vars);

    // 매 호출마다 포인터를 버퍼 처음으로 되돌림
    vars->ptr = vars->str.c;
    vars->end = vars->str.c + vars->str.len;

    // 🔁 key=value 하나씩 파싱 시도
    while (add_post_var(arr, vars, eof TSRMLS_CC)) {
        if (++vars->cnt > max_vars) {
            php_error_docref(NULL TSRMLS_CC, E_WARNING,
                "Input variables exceeded %" PRIu64 ". "
                "To increase the limit change max_input_vars in php.ini.",
                max_vars);
            return FAILURE;
        }
    }

    // ❗️ ptr이 갱신되지 않아도 memmove는 항상 호출됨
    //     → 즉, memmove(ptr, ptr, 0) 형태가 반복될 수 있음
    if (!eof) {
        memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
    }
    return SUCCESS;
}
```

**Trace 설명**:
- 상위 함수 `php_std_post_handler()`는 POST 본문 데이터를 chunk 단위로 읽고, 각 chunk를 `smart_str_appendl()`로 버퍼에 누적한 뒤 `add_post_vars()`를 호출해 파싱합니다.
- 이때 `add_post_vars()`는 매번 `vars->ptr = vars->str.c`로 포인터를 버퍼 시작으로 되돌린 후, 내부적으로 `add_post_var()`를 호출해 key=value 쌍을 추출합니다.
- 하지만 `add_post_var()`는 `'&'` 나 `'='`가 없는 불완전한 데이터가 들어올 경우, `eof == 0`이라면 다음 데이터를 기다리기 위해 `return 0`으로 종료합니다.  
  **이때 `vars->ptr`은 갱신되지 않으며**, 처리되지 않은 상태로 다음 단계로 넘어갑니다.
- 이후 `add_post_vars()`는 파싱이 완료된 것으로 간주하고, 처리되지 않은 데이터를 버퍼 앞으로 당기기 위해 `memmove(vars->str.c, vars->ptr, ...)`를 호출합니다.
- 이때 `vars->str.c == vars->ptr` 상태이면, 사실상 **자기 자신을 0바이트 이동시키는 제자리 memmove()**가 되고, 다음 루프에서 또 동일한 데이터로 반복 파싱 시도가 이루어집니다.
- 결과적으로 **동일한 버퍼 데이터가 무한히 반복 처리**되며, CPU 자원이 소모되어 서비스 거부(CWE-400) 상태가 발생합니다.

#### Sink: `before_php_variables.c:308`
```c
if (!eof) {
    memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
}
```

**Sink 설명**:
- 위 Trace에서 설명한 무한 루프 구조로 인해, memmove가 length를 넘어서 지속적으로 반복 호출되며 CPU 리소스가 고갈됩니다.
- 결과적으로 서비스 거부(DoS) 공격이 발생할 수 있습니다.

### ✅ 개선 코드

**패치 내용**: `after_php_variables.c:235-243, 297-317`
```c
// 구조체 정의 (after_php_variables.c:235-243)
typedef struct post_var_data {
    smart_str str;
    char *ptr;
    char *end;
    uint64_t cnt;
    /* Bytes in ptr that have already been scanned for '&' */
    size_t already_scanned;  // 이미 스캔된 바이트 수를 추적
} post_var_data_t;

// add_post_vars 함수 (after_php_variables.c:291-317)
static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
{
    uint64_t max_vars = PG(max_input_vars);

    vars->ptr = vars->str.c;
    vars->end = vars->str.c + vars->str.len;
    while (add_post_var(arr, vars, eof TSRMLS_CC)) {
        if (++vars->cnt > max_vars) {
            php_error_docref(NULL TSRMLS_CC, E_WARNING,
                    "Input variables exceeded %" PRIu64 ". "
                    "To increase the limit change max_input_vars in php.ini.",
                    max_vars);
            return FAILURE;
        }
    }

    if (!eof && vars->str.c != vars->ptr) {  // ptr이 시작 위치와 다른 경우에만 이동
        memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
    }
    return SUCCESS;
}
```

**개선 방법**:
1. 핵심 수정: `add_post_vars` 함수의 메모리 이동 조건 개선
   - `vars->str.c != vars->ptr` 조건 추가
   - 이미 처리된 데이터는 다시 이동하지 않도록 함
   - 이를 통해 무한 루프 발생 방지

2. 보조 수정: `already_scanned` 필드 추가
   - 메모리 이동 시 스캔 위치를 보존하기 위한 보조적인 수정
   - `add_post_var` 함수에서 스캔 진행 상황을 추적

**수정 효과**:
1. 불필요한 메모리 이동 방지
   - `ptr`이 시작 위치와 다른 경우에만 메모리 이동 수행
   - 이미 처리된 데이터는 다시 처리하지 않음

2. CPU 리소스 소모 방지
   - 무한 루프 발생 가능성 제거
   - 메모리 이동 횟수 최소화

---

## 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출

| FileName | Caller | Source | Sink | idx | CWE-ID | category | criterion | line | label | token_length | predict |
|---------|-------|------|-----|---|------|---------|---------|----|-----|------------|-------|
| before_php_variables.c | add_post_vars | False | False | 2 | CWE- | CallExpression | memmove | 308 | -3 | 152 | 0 |