# 📁 CVE-2017-15108

## 🔍 취약점 개요

**🔗 [커밋 링크](https://cgit.freedesktop.org/spice/linux/vd_agent/commit/?id=8ba174816d245757e743e636df357910e1d5eb61)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2017-15108/)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/78.html)**

> spice-vdagent 0.17.0 이하 버전에서 save directory를 쉘에 전달하기 전에 적절히 이스케이프하지 않아, 세션에 접근 권한이 있는 로컬 공격자가 임의의 명령어를 주입하여 실행할 수 있는 OS Command Injection 취약점입니다.

※ SPICE(Simple Protocol for Independent Computing Environments) 환경에서 사용하는 게스트 에이전트 프로그램입니다. 주로 가상 머신(VM) 내부에 설치되며, SPICE 프로토콜을 사용하는 가상화 솔루션(예: QEMU/KVM)의 게스트와 호스트 간 통신을 향상시키는 역할을 합니다.

* **취약 조건**: `xfers->save_dir`을 쉘에 전달하기 전에 이스케이프하지 않음
* **Sink**: 입력값을 검증하지 않고 `system()` 함수에 직접 사용

---

## 탐지 결과 요약
CVE 설명에 나온 취약한 함수(vdagent_file_xfers_data())에 대한 슬라이스만 고려했을 때,

| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 15개       | 0개 | 15개 |

vdagent_file_xfers_data()에서 추출한 슬라이스 중, Sink(`system()` 함수) 관련 슬라이스는 1건 있었으나, **정상으로 탐지됨**

|FileName           |Caller                 |Source|Sink |idx|CWE-ID|category      |criterion|line|label|token_length|predict|
|-------------------|-----------------------|------|-----|---|------|--------------|---------|----|-----|------------|-------|
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|51 |CWE-  |CallExpression|system   |341 |-3   |161         |0      |

이 CVE 취약점을 유발하는 코드(sink:src/vdagent/file-xfers.c:341)는 아래와 같다.
```
void vdagent_file_xfers_data(struct vdagent_file_xfers *xfers,
    VDAgentFileXferDataMessage *msg)
{
    AgentFileXferTask *task;
    int len, status = -1;

    g_return_if_fail(xfers != NULL);

    task = vdagent_file_xfers_get_task(xfers, msg->id);
    if (!task)
        return;

    len = write(task->file_fd, msg->data, msg->size);
    if (len == msg->size) {
        task->read_bytes += msg->size;
        if (task->read_bytes >= task->file_size) {
            if (task->read_bytes == task->file_size) {
                if (xfers->debug)
                    syslog(LOG_DEBUG, "file-xfer: task %u %s has completed",
                           task->id, task->file_name);
                close(task->file_fd);
                task->file_fd = -1;
                if (xfers->open_save_dir &&
                        task->file_xfer_nr == task->file_xfer_total &&
                        g_hash_table_size(xfers->xfers) == 1) {
                    char buf[PATH_MAX];
                    snprintf(buf, PATH_MAX, "xdg-open '%s'&", xfers->save_dir);
                    status = system(buf);
```

이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.

```c
/* src/vdagent/vdagent.c:354 */
static gboolean vdagent_init_async_cb(gpointer user_data)
{
    VDAgent *agent = user_data;
    GError *err = NULL;

    agent->conn = udscs_connect(
        vdagentd_socket,
        daemon_read_complete,
        daemon_error_cb,
        debug,
        &err
    );
}

/* src/vdagent/vdagent.c:222 */
static void daemon_read_complete(UdscsConnection *conn,
    struct udscs_message_header *header, uint8_t *data)
{
    VDAgent *agent = g_object_get_data(G_OBJECT(conn), "agent");

    switch (header->type) {
        case VDAGENTD_FILE_XFER_DATA:
            if (agent->xfers != NULL) {
                vdagent_file_xfers_data(
                    agent->xfers,
                    (VDAgentFileXferDataMessage *)data
                );
            }
            break;
        default:
            break;
    }
}
/* src/vdagent/file-xfers.c:341 */
void vdagent_file_xfers_data(struct vdagent_file_xfers *xfers,
    VDAgentFileXferDataMessage *msg)
{
    AgentFileXferTask *task;
    int len, status = -1;

    task = vdagent_file_xfers_get_task(xfers, msg->id);
    len = write(task->file_fd, msg->data, msg->size);

    if (len == msg->size) {
        task->read_bytes += msg->size;

        if (task->read_bytes >= task->file_size) {
            if (task->read_bytes == task->file_size) {
                if (xfers->debug) {
                    syslog(
                        LOG_DEBUG,
                        "file-xfer: task %u %s has completed",
                        task->id,
                        task->file_name
                    );
                }

                close(task->file_fd);
                task->file_fd = -1;

                if (xfers->open_save_dir &&
                    task->file_xfer_nr == task->file_xfer_total &&
                    g_hash_table_size(xfers->xfers) == 1) {
                    char buf[PATH_MAX];
                    snprintf(buf, PATH_MAX, "xdg-open '%s'&", xfers->save_dir);
                    status = system(buf);
                }
            }
        }
    }
}
```

이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.


vdagent_init_async_cb() 에서 udscs_connect()를 호출에서 콜백 함수 daemon_read_complete()를 등록하여 네트워크 연결이 이루어질때, 이 콜백 함수를 호출하도록 한다.
daemon_read_complete() 함수가 호출이 되면, `VDAgent *agent = g_object_get_data(G_OBJECT(conn), "agent");` xfers->saved_dir이 보낸 메시지에 의해서 설정이 된다.
설정된 xfers->saved_dir에 저장된 값으로 인해 `snprintf(buf, PATH_MAX, "xdg-open '%s'&", xfers->save_dir);` 코드로 인해 buf내용을 조작할 수 있다.
조작된 buf로 `status = system(buf);` system() 호출한다.

joern에서 빌드하는 pdg(program dependence graph, cdg + ddg)에 callback을 등록해서 호출하는 플로우는 표현할 수 없다.
그결과 슬라이서를 추출하는데 어려움이 있을 수 있다.

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

1. **부적절한 criterion**
    - CWE78의 SARD/README.md에 따르면 
        > ```bash
        > sojeon@swlab-u2404:~/Documents/research/SARD-vs-CVE/CWE78_OS_CI/SARD$ xsv search -s predict 1 test_output.csv | xsv select criterion | uniq
        >    criterion
        >    system
        > ```
    - 이 취약점의 경우 criterion으로 `system`이 잡혔지만 모델이 학습한 패턴과 달라 정상으로 판단된 것으로 보임.

---

## 취약점 세부 사항

### 📁 관련 파일 소개
| 파일명            | 설명              |
| -------------- | --------------- |
| `before_file-xfers.c` | 취약 코드 (수정 전) 포함 |
| `after_file-xfers.c`  | 개선 코드 (수정 후) 포함 |

---

### ❗️ 취약 코드

**문제점**:
1. `vdagent_file_xfers_data()`에서 `xfers->save_dir`을 쉘에 전달하기 전에 이스케이프하지 않음
2. `snprintf()` 반환값을 검증하지 않아, `xfers->save_dir`이 너무 길면 `&`, `'` 등의 문자가 누락될 수 있음

#### Sink: `before_file-xfers.c:340-341`
```c
char buf[PATH_MAX];
snprintf(buf, PATH_MAX, "xdg-open '%s'&", xfers->save_dir);
status = system(buf); /* POTENTIAL FLAW */
```

---

### ✅ 개선 코드

**패치 위치**: `after_file-xfers.c:340-348`

```c
GError *error = NULL;
gchar *argv[] = { "xdg-open", xfers->save_dir, NULL };
if (!g_spawn_async(NULL, argv, NULL,
                       G_SPAWN_SEARCH_PATH,
                       NULL, NULL, NULL, &error)) {
    syslog(LOG_WARNING,
           "file-xfer: failed to open save directory: %s",
           error->message);
    g_error_free(error);
}
```

**개선 방법**:

이 패치는 근본적인 아키텍처 변경을 통해 명령어 인젝션을 완전히 차단합니다:

* `system()` 함수 대신 `g_spawn_async()` 사용으로 쉘을 거치지 않고 직접 프로세스 실행
* `argv[]` 배열을 통해 명령어와 인자를 명확히 분리하여 인젝션 불가능
* `snprintf()` 사용하지 않아 버퍼 오버플로우 위험 제거
* 실행 실패 시 적절한 에러 처리 및 로깅 추가

---

## 탐지 결과

|FileName           |Caller                 |Source|Sink |idx|CWE-ID|category      |criterion|line|label|token_length|predict|
|-------------------|-----------------------|------|-----|---|------|--------------|---------|----|-----|------------|-------|
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|20 |CWE-  |CallExpression|write    |326 |-3   |385         |0      |
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|21 |CWE-  |CallExpression|syslog   |332 |-3   |311         |0      |
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|22 |CWE-  |CallExpression|close    |334 |-3   |311         |0      |
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|23 |CWE-  |CallExpression|syslog   |344 |-3   |219         |0      |
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|24 |CWE-  |CallExpression|syslog   |352 |-3   |92          |0      |
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|25 |CWE-  |CallExpression|syslog   |357 |-3   |311         |0      |
|after_file-xfers.c |vdagent_file_xfers_data|FALSE |FALSE|26 |CWE-  |CallExpression|strerror |357 |-3   |311         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|47 |CWE-  |CallExpression|write    |326 |-3   |309         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|48 |CWE-  |CallExpression|syslog   |332 |-3   |246         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|49 |CWE-  |CallExpression|close    |334 |-3   |246         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|50 |CWE-  |CallExpression|snprintf |340 |-3   |277         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|51 |CWE-  |CallExpression|system   |341 |-3   |161         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|52 |CWE-  |CallExpression|syslog   |345 |-3   |92          |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|53 |CWE-  |CallExpression|syslog   |350 |-3   |246         |0      |
|before_file-xfers.c|vdagent_file_xfers_data|FALSE |FALSE|54 |CWE-  |CallExpression|strerror |350 |-3   |246         |0      |
