[{"FileName": "before_gsdevice.c", "Caller": "gs_getdefaultlibdevice", "Source": false, "Sink": false, "idx": 0, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 308, "label": -3, "slices": ["gs_getdefaultlibdevice(gs_memory_t *mem)\n", "    int count = gs_lib_device_list(&list, NULL);\n", "    const char *name, *end, *fin;\n", "    int i;\n", "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n", "        name = mem->gs_lib_ctx->default_device_list;\n", "        fin = name + strlen(name);\n", "    while (name < fin) {\n", "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n", "        name++;\n", "      end = name;\n", "      for (i = 0; i < count; i++)\n", "        if ((end - name) == strlen(list[i]->dname))\n", "          if (!memcmp(name, list[i]->dname, end - name))\n"], "tokenized": "FUNC1(STRUCT1 *Var1)\nint  Var2=FUNC2(&Var3,NULL ); \nconst char *Var4,*Var5,*Var6; \nint  Var7; \nif (Var1&&Var1->memberVar1&&Var1->memberVar1->memberVar1){\nVar4=Var1->memberVar1->memberVar1; \nVar6=Var4+strlen(Var4); \nwhile (Var4<Var6){\nwhile ((Var4<Var6)&&(*Var4 == ||*Var4 ==  Var8))\nVar4  Var9; \nVar5=Var4; \nfor (Var7=0; Var7<Var2; Var7  Var9)\nif ((Var5-Var4) == strlen(Var3[Var7]->memberVar1))\nif (!memcmp(Var4,Var3[Var7]->memberVar1,Var5-Var4))\n"}, {"FileName": "before_gsdevice.c", "Caller": "gs_getdefaultlibdevice", "Source": false, "Sink": false, "idx": 1, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 312, "label": -3, "slices": ["    int count = gs_lib_device_list(&list, NULL);\n", "    const char *name, *end, *fin;\n", "    int i;\n", "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n", "else\n", "        name = gs_dev_defaults;\n", "        fin = name + strlen(name);\n", "    while (name < fin) {\n", "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n", "        name++;\n", "      end = name;\n", "      for (i = 0; i < count; i++)\n", "        if ((end - name) == strlen(list[i]->dname))\n", "          if (!memcmp(name, list[i]->dname, end - name))\n"], "tokenized": "int  Var1=FUNC1(&Var2,NULL ); \nconst char *Var3,*Var4,*Var5; \nint  Var6; \nif (Var7&&Var7->memberVar1&&Var7->memberVar1->memberVar1){\nelse \nVar3=Var8; \nVar5=Var3+strlen(Var3); \nwhile (Var3<Var5){\nwhile ((Var3<Var5)&&(*Var3 == ||*Var3 ==  Var9))\nVar3  Var10; \nVar4=Var3; \nfor (Var6=0; Var6<Var1; Var6  Var10)\nif ((Var4-Var3) == strlen(Var2[Var6]->memberVar1))\nif (!memcmp(Var3,Var2[Var6]->memberVar1,Var4-Var3))\n"}, {"FileName": "before_gsdevice.c", "Caller": "gs_getdefaultlibdevice", "Source": false, "Sink": false, "idx": 2, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 327, "label": -3, "slices": ["gs_getdefaultlibdevice(gs_memory_t *mem)\n", "    int count = gs_lib_device_list(&list, NULL);\n", "    const char *name, *end, *fin;\n", "    int i;\n", "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n", "        name = mem->gs_lib_ctx->default_device_list;\n", "        fin = name + strlen(name);\n", "else\n", "        name = gs_dev_defaults;\n", "        fin = name + strlen(name);\n", "    while (name < fin) {\n", "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n", "        name++;\n", "      end = name;\n", "      while ((end < fin) && (*end != ' ') && (*end != '\\t'))\n", "        end++;\n", "      for (i = 0; i < count; i++)\n", "        if ((end - name) == strlen(list[i]->dname))\n", "          if (!memcmp(name, list[i]->dname, end - name))\n", "            return gs_getdevice(i);\n", "      name = end;\n"], "tokenized": "FUNC1(STRUCT1 *Var1)\nint  Var2=FUNC2(&Var3,NULL ); \nconst char *Var4,*Var5,*Var6; \nint  Var7; \nif (Var1&&Var1->memberVar1&&Var1->memberVar1->memberVar1){\nVar4=Var1->memberVar1->memberVar1; \nVar6=Var4+strlen(Var4); \nelse \nVar4=Var8; \nVar6=Var4+strlen(Var4); \nwhile (Var4<Var6){\nwhile ((Var4<Var6)&&(*Var4 == ||*Var4 ==  Var9))\nVar4  Var10; \nVar5=Var4; \nwhile ((Var5<Var6)&&(*Var5 != )&&(*Var5 !=  Var9))\nVar5  Var10; \nfor (Var7=0; Var7<Var2; Var7  Var10)\nif ((Var5-Var4) == strlen(Var3[Var7]->memberVar1))\nif (!memcmp(Var4,Var3[Var7]->memberVar1,Var5-Var4))\nreturn FUNC3(Var7); \nVar4=Var5; \n"}, {"FileName": "before_gsdevice.c", "Caller": "gs_getdefaultlibdevice", "Source": false, "Sink": false, "idx": 3, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcmp", "line": 328, "label": -3, "slices": ["gs_getdefaultlibdevice(gs_memory_t *mem)\n", "    int count = gs_lib_device_list(&list, NULL);\n", "    const char *name, *end, *fin;\n", "    int i;\n", "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n", "        name = mem->gs_lib_ctx->default_device_list;\n", "        fin = name + strlen(name);\n", "else\n", "        name = gs_dev_defaults;\n", "        fin = name + strlen(name);\n", "    while (name < fin) {\n", "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n", "        name++;\n", "      end = name;\n", "      while ((end < fin) && (*end != ' ') && (*end != '\\t'))\n", "        end++;\n", "      for (i = 0; i < count; i++)\n", "        if ((end - name) == strlen(list[i]->dname))\n", "          if (!memcmp(name, list[i]->dname, end - name))\n", "            return gs_getdevice(i);\n", "      name = end;\n"], "tokenized": "FUNC1(STRUCT1 *Var1)\nint  Var2=FUNC2(&Var3,NULL ); \nconst char *Var4,*Var5,*Var6; \nint  Var7; \nif (Var1&&Var1->memberVar1&&Var1->memberVar1->memberVar1){\nVar4=Var1->memberVar1->memberVar1; \nVar6=Var4+strlen(Var4); \nelse \nVar4=Var8; \nVar6=Var4+strlen(Var4); \nwhile (Var4<Var6){\nwhile ((Var4<Var6)&&(*Var4 == ||*Var4 ==  Var9))\nVar4  Var10; \nVar5=Var4; \nwhile ((Var5<Var6)&&(*Var5 != )&&(*Var5 !=  Var9))\nVar5  Var10; \nfor (Var7=0; Var7<Var2; Var7  Var10)\nif ((Var5-Var4) == strlen(Var3[Var7]->memberVar1))\nif (!memcmp(Var4,Var3[Var7]->memberVar1,Var5-Var4))\nreturn FUNC3(Var7); \nVar4=Var5; \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_init", "Source": false, "Sink": false, "idx": 4, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 612, "label": -3, "slices": ["gx_device_init(gx_device * dev, const gx_device * proto, gs_memory_t * mem,\n               bool internal)\n", "    memcpy(dev, proto, proto->params_size);\n", "    dev->memory = mem;\n", "    dev->retained = !internal;\n", "    rc_init(dev, mem, (internal ? 0 : 1));\n", "    rc_increment(dev->icc_struct);\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const STRUCT1 *Var2,STRUCT2 *Var3,\nbool  Var4)\nmemcpy(Var1,Var2,Var2->memberVar1); \nVar1->memberVar1=Var3; \nVar1->memberVar2=!Var4; \nFUNC2(Var1,Var3,(Var4 01)); \nFUNC3(Var1->memberVar3); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_init_on_stack", "Source": false, "Sink": false, "idx": 5, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "memcpy", "line": 623, "label": -3, "slices": ["gx_device_init_on_stack(gx_device * dev, const gx_device * proto,\n                        gs_memory_t * mem)\n", "    memcpy(dev, proto, proto->params_size);\n", "    dev->memory = mem;\n", "    dev->retained = 0;\n", "    dev->pad = proto->pad;\n", "    dev->log2_align_mod = proto->log2_align_mod;\n", "    dev->is_planar = proto->is_planar;\n", "    rc_init(dev, NULL, 0);\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const STRUCT1 *Var2,\nSTRUCT2 *Var3)\nmemcpy(Var1,Var2,Var2->memberVar1); \nVar1->memberVar1=Var3; \nVar1->memberVar2=0; \nVar1->memberVar3=Var2->memberVar2; \nVar1->memberVar4=Var2->memberVar3; \nVar1->memberVar5=Var2->memberVar4; \nFUNC2(Var1,NULL ,0); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_parse_output_format", "Source": false, "Sink": false, "idx": 6, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1016, "label": -3, "slices": ["    uint i;\n"], "tokenized": "uint  Var1; \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_parse_output_format", "Source": false, "Sink": false, "idx": 7, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1022, "label": -3, "slices": ["gx_parse_output_format(gs_parsed_file_name_t *pfn, const char **pfmt)\n", "    bool have_format = false, field;\n", "    int width[2], int_width = sizeof(int) * 3, w = 0;\n", "    uint i;\n", "    for (i = 0; i < pfn->len; ++i)\n", "        if (pfn->fname[i] == '%') {\n", "            if (i + 1 < pfn->len && pfn->fname[i + 1] == '%') {\n", "                i++;\n", "                if (++i == pfn->len)\n", "else\n", "                    switch (field) {\n", "                            if (strchr(\" #+-\", pfn->fname[i]))\n", "                            if (strchr(\"0123456789\", pfn->fname[i])) {\n", "                                width[field] = width[field] * 10 + pfn->fname[i] - '0';\n", "else\n", "                            } else if (0 == field && '.' == pfn->fname[i]) {\n", "                            if ('l' == pfn->fname[i]) {\n", "                            if (strchr(\"diuoxX\", pfn->fname[i])) {\n", "                                *pfmt = &pfn->fname[i];\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char **Var2)\nbool  Var3=false ,Var4; \nint  Var5[2],Var6=sizeof (int )*3,Var7=0; \nuint  Var8; \nfor (Var8=0; Var8<Var1->memberVar1; STRUCT2  Var8)\nif (Var1->memberVar2[Var8]== %){\nif (Var8+1<Var1->memberVar1&&Var1->memberVar2[Var8+1]== %){\nVar8  STRUCT2; \nif (STRUCT2  Var8 ==  Var1->memberVar1)\nelse \nswitch (Var4){\nif (strchr(STRING,Var1->memberVar2[Var8]))\nif (strchr(STRING,Var1->memberVar2[Var8])){\nVar5[Var4]=Var5[Var4]*10+Var1->memberVar2[Var8]-0; \nelse \n}else if (0==  Var4&&.==  Var1->memberVar2[Var8]){\nif (Var9 ==  Var1->memberVar2[Var8]){\nif (strchr(STRING,Var1->memberVar2[Var8])){\n*Var2=&Var1->memberVar2[Var8]; \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_parse_output_format", "Source": false, "Sink": false, "idx": 8, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1039, "label": -3, "slices": ["gx_parse_output_format(gs_parsed_file_name_t *pfn, const char **pfmt)\n", "    bool have_format = false, field;\n", "    int width[2], int_width = sizeof(int) * 3, w = 0;\n", "    uint i;\n", "    for (i = 0; i < pfn->len; ++i)\n", "        if (pfn->fname[i] == '%') {\n", "            if (i + 1 < pfn->len && pfn->fname[i + 1] == '%') {\n", "                i++;\n", "                if (++i == pfn->len)\n", "else\n", "                    switch (field) {\n", "                            if (strchr(\" #+-\", pfn->fname[i]))\n", "                            if (strchr(\"0123456789\", pfn->fname[i])) {\n", "                                width[field] = width[field] * 10 + pfn->fname[i] - '0';\n", "else\n", "                            } else if (0 == field && '.' == pfn->fname[i]) {\n", "                            if ('l' == pfn->fname[i]) {\n", "                            if (strchr(\"diuoxX\", pfn->fname[i])) {\n", "                                *pfmt = &pfn->fname[i];\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char **Var2)\nbool  Var3=false ,Var4; \nint  Var5[2],Var6=sizeof (int )*3,Var7=0; \nuint  Var8; \nfor (Var8=0; Var8<Var1->memberVar1; STRUCT2  Var8)\nif (Var1->memberVar2[Var8]== %){\nif (Var8+1<Var1->memberVar1&&Var1->memberVar2[Var8+1]== %){\nVar8  STRUCT2; \nif (STRUCT2  Var8 ==  Var1->memberVar1)\nelse \nswitch (Var4){\nif (strchr(STRING,Var1->memberVar2[Var8]))\nif (strchr(STRING,Var1->memberVar2[Var8])){\nVar5[Var4]=Var5[Var4]*10+Var1->memberVar2[Var8]-0; \nelse \n}else if (0==  Var4&&.==  Var1->memberVar2[Var8]){\nif (Var9 ==  Var1->memberVar2[Var8]){\nif (strchr(STRING,Var1->memberVar2[Var8])){\n*Var2=&Var1->memberVar2[Var8]; \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_parse_output_file_name", "Source": false, "Sink": false, "idx": 9, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1108, "label": -3, "slices": ["gx_parse_output_file_name(gs_parsed_file_name_t *pfn, const char **pfmt,\n                          const char *fname, uint fnlen, gs_memory_t *memory)\n", "                          const char *fname, uint fnlen, gs_memory_t *memory)\n", "    int code;\n", "    pfn->memory = 0;\n", "    pfn->iodev = NULL;\n", "    pfn->fname = NULL;\t\t/* irrelevant since length = 0 */\n", "    pfn->len = 0;\n", "    if (fnlen == 0)  \t\t/* allow null name */\n", "    code = gs_parse_file_name(pfn, fname, fnlen, memory);\n", "    if (code < 0) {\n", "        if (fname[0] == '%') {\n", "            pfn->len = fnlen;\n", "            pfn->fname = fname;\n", "            code = gx_parse_output_format(pfn, pfmt);\n", "        if (code < 0)\n", "            return code;\n", "    if (!pfn->iodev) {\n", "        if ( (pfn->len == 1) && (pfn->fname[0] == '-') ) {\n", "            pfn->iodev = gs_findiodevice(memory, (const byte *)\"%stdout\", 7);\n", "else\n", "        } else if (pfn->fname[0] == '|') {\n", "            pfn->iodev = gs_findiodevice(memory, (const byte *)\"%pipe\", 5);\n", "            pfn->fname++, pfn->len--;\n", "else\n", "            pfn->iodev = iodev_default(memory);\n", "    if (!pfn->fname)\n", "    code = gx_parse_output_format(pfn, pfmt);\n", "    if (code < 0)\n", "        return code;\n"], "tokenized": "FUNC1(STRUCT1 *Var1,const char **Var2,\nconst char *Var3,uint  Var4,STRUCT2 *Var5)\nconst char *Var3,uint  Var4,STRUCT2 *Var5)\nint  Var6; \nVar1->memberVar1=0; \nVar1->memberVar2=NULL ; \nVar1->memberVar3=NULL ; /*Var7  STRUCT3  Var8=0*/\nVar1->memberVar4=0; \nif (Var4 == 0)/*Var9  STRUCT4 STRUCT5 */\nVar6=FUNC2(Var1,memberVar3,Var4,memberVar1); \nif (Var6<0){\nif (memberVar3[0]== %){\nVar1->memberVar4=Var4; \nVar1->memberVar3=memberVar3; \nVar6=FUNC3(Var1,Var2); \nif (Var6<0)\nreturn  Var6; \nif (!Var1->memberVar2){\nif ((Var1->memberVar4 == 1)&&(Var1->memberVar3[0]== -)){\nVar1->memberVar2=FUNC4(memberVar1,(const byte *) STRING,7); \nelse \n}else if (Var1->memberVar3[0]== |){\nVar1->memberVar2=FUNC4(memberVar1,(const byte *) STRING,5); \nVar1->memberVar3  Var10,Var1->memberVar4  Var11; \nelse \nVar1->memberVar2=FUNC5(memberVar1); \nif (!Var1->memberVar3)\nVar6=FUNC3(Var1,Var2); \nif (Var6<0)\nreturn  Var6; \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_outputfile_is_separate_pages", "Source": false, "Sink": false, "idx": 10, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1119, "label": -3, "slices": ["gx_outputfile_is_separate_pages(const char *fname, gs_memory_t *memory)\n", "    const char *fmt;\n", "    int code = gx_parse_output_file_name(&parsed, &fmt, fname,\n                                         strlen(fname), memory);\n", "    return (code >= 0 && fmt != 0);\n"], "tokenized": "FUNC1(const char *Var1,STRUCT1 *Var2)\nconst char *Var3; \nint  Var4=FUNC2(&Var5,&Var3,Var1,\nstrlen(Var1),Var2); \nreturn (Var4 >= 0&&Var3 != 0); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_delete_output_file", "Source": false, "Sink": false, "idx": 11, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1138, "label": -3, "slices": ["int gx_device_delete_output_file(const gx_device * dev, const char *fname)\n", "    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname),\n                                         dev->memory);\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "    if (pfname != NULL)\n", "        gs_free_object(dev->memory, pfname, \"gx_device_delete_output_file(pfname)\");\n", "    return(code);\n"], "tokenized": "int FUNC1(const STRUCT1 *Var1,const char *Var2)\nSTRUCT2  Var3; \nconst char *Var4; \nchar *Var5=(char *) FUNC2(Var1->memberVar1,Var6,STRING); \nint  Var7; \nif (Var5 == NULL ){\nVar7=FUNC3(&Var3,&Var4,Var2,strlen(Var2),\nVar1->memberVar1); \nif (Var7<0){\nif (Var3.memberVar1&&!strcmp(Var3.memberVar1->memberVar1,STRING))\nif (Var4){/*Var8  STRUCT3 STRING*/\nlong  Var9=Var1->memberVar2+1; \nif (Var5 != NULL )\nFUNC4(Var1->memberVar1,Var5,STRING); \nreturn (Var7); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_delete_output_file", "Source": false, "Sink": false, "idx": 12, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 1144, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (parsed.iodev)\n", "        code = parsed.iodev->procs.delete_file((gx_io_device *)(&parsed.iodev), (const char *)parsed.fname);\n"], "tokenized": "STRUCT1  Var1; \nconst char *Var2; \nchar *Var3=(char *) FUNC1(Var4->memberVar1,Var5,STRING); \nint  Var6; \nif (Var3 == NULL ){\nif (Var6<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING))\nif (Var2){/*Var7  STRUCT2 STRING*/\nlong  Var8=Var4->memberVar2+1; \nif (*Var2 ==  Var9)\nFUNC2(Var3,Var1.memberVar2,Var8); \nelse \nelse \n}else if (Var1.memberVar3&&strchr(Var1.memberVar2,%))/*Var7  Var10 STRING Var11  STRUCT3 STRING*/\nFUNC2(Var3,Var1.memberVar2); \nif (Var3[0]){\nVar1.memberVar2=Var3; \nVar1.memberVar3=strlen(Var1.memberVar2); \nif (Var1.memberVar1)\nVar6=Var1.memberVar1->memberVar2.FUNC3((STRUCT4 *)(&Var1.memberVar1),(const char *) Var1.memberVar2); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_delete_output_file", "Source": false, "Sink": false, "idx": 13, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1156, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (parsed.iodev)\n", "        code = parsed.iodev->procs.delete_file((gx_io_device *)(&parsed.iodev), (const char *)parsed.fname);\n"], "tokenized": "STRUCT1  Var1; \nconst char *Var2; \nchar *Var3=(char *) FUNC1(Var4->memberVar1,Var5,STRING); \nint  Var6; \nif (Var3 == NULL ){\nif (Var6<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING))\nif (Var2){/*Var7  STRUCT2 STRING*/\nlong  Var8=Var4->memberVar2+1; \nif (*Var2 ==  Var9)\nFUNC2(Var3,Var1.memberVar2,Var8); \nelse \nelse \n}else if (Var1.memberVar3&&strchr(Var1.memberVar2,%))/*Var7  Var10 STRING Var11  STRUCT3 STRING*/\nFUNC2(Var3,Var1.memberVar2); \nif (Var3[0]){\nVar1.memberVar2=Var3; \nVar1.memberVar3=strlen(Var1.memberVar2); \nif (Var1.memberVar1)\nVar6=Var1.memberVar1->memberVar2.FUNC3((STRUCT4 *)(&Var1.memberVar1),(const char *) Var1.memberVar2); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_delete_output_file", "Source": false, "Sink": false, "idx": 14, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1162, "label": -3, "slices": ["int gx_device_delete_output_file(const gx_device * dev, const char *fname)\n", "    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (parsed.iodev)\n", "        code = parsed.iodev->procs.delete_file((gx_io_device *)(&parsed.iodev), (const char *)parsed.fname);\n", "    return(code);\n"], "tokenized": "int FUNC1(const STRUCT1 *Var1,const char *Var2)\nSTRUCT2  Var3; \nconst char *Var4; \nchar *Var5=(char *) FUNC2(Var1->memberVar1,Var6,STRING); \nint  Var7; \nif (Var5 == NULL ){\nif (Var7<0){\nif (Var3.memberVar1&&!strcmp(Var3.memberVar1->memberVar1,STRING))\nif (Var4){/*Var8  STRUCT3 STRING*/\nlong  Var9=Var1->memberVar2+1; \nif (*Var4 ==  Var10)\nFUNC3(Var5,Var3.memberVar2,Var9); \nelse \nelse \n}else if (Var3.memberVar3&&strchr(Var3.memberVar2,%))/*Var8  Var11 STRING Var12  STRUCT4 STRING*/\nFUNC3(Var5,Var3.memberVar2); \nif (Var5[0]){\nVar3.memberVar2=Var5; \nVar3.memberVar3=strlen(Var3.memberVar2); \nif (Var3.memberVar1)\nVar7=Var3.memberVar1->memberVar2.FUNC4((STRUCT5 *)(&Var3.memberVar1),(const char *) Var3.memberVar2); \nreturn (Var7); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 15, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1191, "label": -3, "slices": ["gx_device_open_output_file(const gx_device * dev, char *fname,\n                           bool binary, bool positionable, FILE ** pfile)\n", "    gs_parsed_file_name_t parsed;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "        long count1 = dev->PageCount + 1;\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "else\n", "        *pfile = gp_open_printer(dev->memory, (pfname[0] ? pfname : fname), binary);\n", "        if (!(*pfile)) {\n", "            emprintf1(dev->memory, \"**** Could not open the file '%s'.\\n\", (pfname[0] ? pfname : fname));\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,char *Var2,\nbool  Var3,bool  Var4,STRUCT2 **Var5)\nSTRUCT3  Var6; \nchar *Var7=(char *) FUNC2(Var1->memberVar1,Var8,STRING); \nint  Var9; \nif (Var7 == NULL ){\nif (strlen(Var2) == 0){\nVar9=FUNC3(&Var6,&Var10,Var2,strlen(Var2),Var1->memberVar1); \nif (Var9<0){\nif (Var6.memberVar1&&!strcmp(Var6.memberVar1->memberVar1,STRING)){\nlong  Var11=Var1->memberVar2+1; \nif (Var4||(Var6.memberVar1&&Var6.memberVar1 != FUNC4(Var1->memberVar1))){\nelse \n*Var5=FUNC5(Var1->memberVar1,(Var7[0]Var7  Var2),Var3); \nif (!(*Var5)){\nFUNC6(Var1->memberVar1,STRING,(Var7[0]Var7  Var2)); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 16, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1196, "label": -3, "slices": ["gx_device_open_output_file(const gx_device * dev, char *fname,\n                           bool binary, bool positionable, FILE ** pfile)\n", "    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "        emprintf1(dev->memory, \"Device '%s' requires an output file but no file was specified.\\n\", dev->dname);\n", "    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "        if (parsed.fname) {\n", "        *pfile = dev->memory->gs_lib_ctx->fstdout;\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        if (!parsed.fname) {\n", "        if (code)\n", "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n", "else\n", "        *pfile = gp_open_printer(dev->memory, (pfname[0] ? pfname : fname), binary);\n", "        if (!(*pfile)) {\n", "            emprintf1(dev->memory, \"**** Could not open the file '%s'.\\n\", (pfname[0] ? pfname : fname));\n", "    if (pfname != NULL)\n", "        gs_free_object(dev->memory, pfname, \"gx_device_open_output_file(pfname)\");\n", "    return(code);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,char *Var2,\nbool  Var3,bool  Var4,STRUCT2 **Var5)\nSTRUCT3  Var6; \nconst char *Var7; \nchar *Var8=(char *) FUNC2(Var1->memberVar1,Var9,STRING); \nint  Var10; \nif (Var8 == NULL ){\nif (strlen(Var2) == 0){\nFUNC3(Var1->memberVar1,STRING,Var1->memberVar2); \nVar10=FUNC4(&Var6,&Var7,Var2,strlen(Var2),Var1->memberVar1); \nif (Var10<0){\nif (Var6.memberVar1&&!strcmp(Var6.memberVar1->memberVar1,STRING)){\nif (Var6.memberVar2){\n*Var5=Var1->memberVar1->memberVar1->memberVar1; \nif (Var7){/*Var11  STRUCT4 STRING*/\nlong  Var12=Var1->memberVar3+1; \nif (Var4||(Var6.memberVar1&&Var6.memberVar1 != FUNC5(Var1->memberVar1))){\nif (!Var6.memberVar2){\nif (Var10)\nFUNC3(Var1->memberVar1,\nSTRING,\nVar6.memberVar2); \nelse \n*Var5=FUNC6(Var1->memberVar1,(Var8[0]Var8  memberVar2),Var3); \nif (!(*Var5)){\nFUNC3(Var1->memberVar1,STRING,(Var8[0]Var8  memberVar2)); \nif (Var8 != NULL )\nFUNC7(Var1->memberVar1,Var8,STRING); \nreturn (Var10); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 17, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 1201, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        char fmode[4];\n", "        if (!parsed.fname) {\n", "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n", "        if (code)\n", "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n"], "tokenized": "STRUCT1  Var1; \nconst char *Var2; \nchar *Var3=(char *) FUNC1(Var4->memberVar1,Var5,STRING); \nint  Var6; \nif (Var3 == NULL ){\nif (strlen(Var7) == 0){\nif (Var6<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING)){\nif (Var2){/*Var8  STRUCT2 STRING*/\nlong  Var9=Var4->memberVar2+1; \nif (*Var2 ==  Var10)\nFUNC2(Var3,Var1.memberVar2,Var9); \nelse \nelse \n}else if (Var1.memberVar3&&strchr(Var1.memberVar2,%))/*Var8  Var11 STRING Var12  STRUCT3 STRING*/\nFUNC2(Var3,Var1.memberVar2); \nif (Var3[0]){\nVar1.memberVar2=Var3; \nVar1.memberVar3=strlen(Var1.memberVar2); \nif (Var13||(Var1.memberVar1&&Var1.memberVar1 != FUNC3(Var4->memberVar1))){\nchar  Var14[4]; \nif (!Var1.memberVar2){\nVar6=Var1.memberVar1->memberVar2.FUNC4(Var1.memberVar1,Var1.memberVar2,Var14,\nVar15,NULL ,0); \nif (Var6)\nFUNC5(Var4->memberVar1,\nSTRING,\nVar1.memberVar2); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 18, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 1210, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        char fmode[4];\n", "        if (!parsed.fname) {\n", "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n", "        if (code)\n", "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n"], "tokenized": "STRUCT1  Var1; \nconst char *Var2; \nchar *Var3=(char *) FUNC1(Var4->memberVar1,Var5,STRING); \nint  Var6; \nif (Var3 == NULL ){\nif (strlen(Var7) == 0){\nif (Var6<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING)){\nif (Var2){/*Var8  STRUCT2 STRING*/\nlong  Var9=Var4->memberVar2+1; \nif (*Var2 ==  Var10)\nFUNC2(Var3,Var1.memberVar2,Var9); \nelse \nelse \n}else if (Var1.memberVar3&&strchr(Var1.memberVar2,%))/*Var8  Var11 STRING Var12  STRUCT3 STRING*/\nFUNC2(Var3,Var1.memberVar2); \nif (Var3[0]){\nVar1.memberVar2=Var3; \nVar1.memberVar3=strlen(Var1.memberVar2); \nif (Var13||(Var1.memberVar1&&Var1.memberVar1 != FUNC3(Var4->memberVar1))){\nchar  Var14[4]; \nif (!Var1.memberVar2){\nVar6=Var1.memberVar1->memberVar2.FUNC4(Var1.memberVar1,Var1.memberVar2,Var14,\nVar15,NULL ,0); \nif (Var6)\nFUNC5(Var4->memberVar1,\nSTRING,\nVar1.memberVar2); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 19, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strchr", "line": 1222, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        char fmode[4];\n", "        if (!parsed.fname) {\n", "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n", "        if (code)\n", "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n"], "tokenized": "STRUCT1  Var1; \nconst char *Var2; \nchar *Var3=(char *) FUNC1(Var4->memberVar1,Var5,STRING); \nint  Var6; \nif (Var3 == NULL ){\nif (strlen(Var7) == 0){\nif (Var6<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING)){\nif (Var2){/*Var8  STRUCT2 STRING*/\nlong  Var9=Var4->memberVar2+1; \nif (*Var2 ==  Var10)\nFUNC2(Var3,Var1.memberVar2,Var9); \nelse \nelse \n}else if (Var1.memberVar3&&strchr(Var1.memberVar2,%))/*Var8  Var11 STRING Var12  STRUCT3 STRING*/\nFUNC2(Var3,Var1.memberVar2); \nif (Var3[0]){\nVar1.memberVar2=Var3; \nVar1.memberVar3=strlen(Var1.memberVar2); \nif (Var13||(Var1.memberVar1&&Var1.memberVar1 != FUNC3(Var4->memberVar1))){\nchar  Var14[4]; \nif (!Var1.memberVar2){\nVar6=Var1.memberVar1->memberVar2.FUNC4(Var1.memberVar1,Var1.memberVar2,Var14,\nVar15,NULL ,0); \nif (Var6)\nFUNC5(Var4->memberVar1,\nSTRING,\nVar1.memberVar2); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 20, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1228, "label": -3, "slices": ["gx_device_open_output_file(const gx_device * dev, char *fname,\n                           bool binary, bool positionable, FILE ** pfile)\n", "    gs_parsed_file_name_t parsed;\n", "    const char *fmt;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n", "        long count1 = dev->PageCount + 1;\n", "        if (*fmt == 'l')\n", "            gs_sprintf(pfname, parsed.fname, count1);\n", "else\n", "else\n", "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n", "        gs_sprintf(pfname, parsed.fname);\n", "    if (pfname[0]) {\n", "        parsed.fname = pfname;\n", "        parsed.len = strlen(parsed.fname);\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        char fmode[4];\n", "        if (!parsed.fname) {\n", "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n", "        if (code)\n", "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n", "    return(code);\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,char *Var2,\nbool  Var3,bool  Var4,STRUCT2 **Var5)\nSTRUCT3  Var6; \nconst char *Var7; \nchar *Var8=(char *) FUNC2(Var1->memberVar1,Var9,STRING); \nint  Var10; \nif (Var8 == NULL ){\nif (strlen(Var2) == 0){\nif (Var10<0){\nif (Var6.memberVar1&&!strcmp(Var6.memberVar1->memberVar1,STRING)){\nif (Var7){/*Var11  STRUCT4 STRING*/\nlong  Var12=Var1->memberVar2+1; \nif (*Var7 ==  Var13)\nFUNC3(Var8,Var6.memberVar2,Var12); \nelse \nelse \n}else if (Var6.memberVar3&&strchr(Var6.memberVar2,%))/*Var11  Var14 STRING Var15  STRUCT5 STRING*/\nFUNC3(Var8,Var6.memberVar2); \nif (Var8[0]){\nVar6.memberVar2=Var8; \nVar6.memberVar3=strlen(Var6.memberVar2); \nif (Var4||(Var6.memberVar1&&Var6.memberVar1 != FUNC4(Var1->memberVar1))){\nchar  Var16[4]; \nif (!Var6.memberVar2){\nVar10=Var6.memberVar1->memberVar2.FUNC5(Var6.memberVar1,Var6.memberVar2,Var16,\nVar5,NULL ,0); \nif (Var10)\nFUNC6(Var1->memberVar1,\nSTRING,\nVar6.memberVar2); \nreturn (Var10); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 21, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcpy", "line": 1237, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "        long count1 = dev->PageCount + 1;\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        char fmode[4];\n", "        if (!parsed.fname) {\n", "        strcpy(fmode, gp_fmode_wb);\n", "        if (positionable)\n", "            strcat(fmode, \"+\");\n", "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n"], "tokenized": "STRUCT1  Var1; \nchar *Var2=(char *) FUNC1(Var3->memberVar1,Var4,STRING); \nint  Var5; \nif (Var2 == NULL ){\nif (strlen(Var6) == 0){\nif (Var5<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING)){\nlong  Var7=Var3->memberVar2+1; \nif (Var8||(Var1.memberVar1&&Var1.memberVar1 != FUNC2(Var3->memberVar1))){\nchar  Var9[4]; \nif (!Var1.memberVar2){\nstrcpy(Var9,Var10); \nif (Var8)\nstrcat(Var9,STRING); \nVar5=Var1.memberVar1->memberVar2.FUNC3(Var1.memberVar1,Var1.memberVar2,Var9,\nVar11,NULL ,0); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_open_output_file", "Source": false, "Sink": false, "idx": 22, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcat", "line": 1239, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n", "    int code;\n", "    if (pfname == NULL) {\n", "    if (strlen(fname) == 0) {\n", "    if (code < 0) {\n", "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n", "        long count1 = dev->PageCount + 1;\n", "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n", "        char fmode[4];\n", "        if (!parsed.fname) {\n", "        strcpy(fmode, gp_fmode_wb);\n", "        if (positionable)\n", "            strcat(fmode, \"+\");\n", "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n"], "tokenized": "STRUCT1  Var1; \nchar *Var2=(char *) FUNC1(Var3->memberVar1,Var4,STRING); \nint  Var5; \nif (Var2 == NULL ){\nif (strlen(Var6) == 0){\nif (Var5<0){\nif (Var1.memberVar1&&!strcmp(Var1.memberVar1->memberVar1,STRING)){\nlong  Var7=Var3->memberVar2+1; \nif (Var8||(Var1.memberVar1&&Var1.memberVar1 != FUNC2(Var3->memberVar1))){\nchar  Var9[4]; \nif (!Var1.memberVar2){\nstrcpy(Var9,Var10); \nif (Var8)\nstrcat(Var9,STRING); \nVar5=Var1.memberVar1->memberVar2.FUNC3(Var1.memberVar1,Var1.memberVar2,Var9,\nVar11,NULL ,0); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_close_output_file", "Source": false, "Sink": false, "idx": 23, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strlen", "line": 1270, "label": -3, "slices": ["gx_device_close_output_file(const gx_device * dev, const char *fname,\n                            FILE *file)\n", "    gs_parsed_file_name_t parsed;\n", "    int code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname),\n                                         dev->memory);\n", "    if (code < 0)\n", "        return code;\n", "    if (parsed.iodev) {\n", "        if (!strcmp(parsed.iodev->dname, \"%stdout%\"))\n", "        if (parsed.iodev != iodev_default(dev->memory))\n", "    gp_close_printer(dev->memory, file, (parsed.fname ? parsed.fname : fname));\n"], "tokenized": "FUNC1(const STRUCT1 *Var1,const char *Var2,\nSTRUCT2 *Var3)\nSTRUCT3  Var4; \nint  Var5=FUNC2(&Var4,&Var6,Var2,strlen(Var2),\nVar1->memberVar1); \nif (Var5<0)\nreturn  Var5; \nif (Var4.memberVar1){\nif (!strcmp(Var4.memberVar1->memberVar1,STRING))\nif (Var4.memberVar1 != FUNC3(Var1->memberVar1))\nFUNC4(Var1->memberVar1,Var3,(Var4.Var2  Var4.Var2  Var2)); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_device_close_output_file", "Source": false, "Sink": false, "idx": 24, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 1276, "label": -3, "slices": ["    gs_parsed_file_name_t parsed;\n", "    int code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname),\n                                         dev->memory);\n", "    if (code < 0)\n", "    if (parsed.iodev) {\n", "        if (!strcmp(parsed.iodev->dname, \"%stdout%\"))\n", "        if (parsed.iodev != iodev_default(dev->memory))\n", "            return parsed.iodev->procs.fclose(parsed.iodev, file);\n", "    gp_close_printer(dev->memory, file, (parsed.fname ? parsed.fname : fname));\n"], "tokenized": "STRUCT1  Var1; \nint  Var2=FUNC1(&Var1,&Var3,Var4,strlen(Var4),\nVar5->memberVar1); \nif (Var2<0)\nif (Var1.memberVar1){\nif (!strcmp(Var1.memberVar1->memberVar1,STRING))\nif (Var1.memberVar1 != FUNC2(Var5->memberVar1))\nreturn  Var1.memberVar1->memberVar2.fclose(Var1.memberVar1,Var6); \nFUNC3(Var5->memberVar1,Var6,(Var1.Var4  Var1.Var4  Var4)); \n"}, {"FileName": "before_gsdevice.c", "Caller": "gx_color_info_equal", "Source": false, "Sink": false, "idx": 25, "CWE-ID": "CWE-", "category": "CallExpression", "criterion": "strcmp", "line": 1294, "label": -3, "slices": ["bool gx_color_info_equal(const gx_device_color_info * p1, const gx_device_color_info * p2)\n", "    if (p1->anti_alias.graphics_bits != p2->anti_alias.graphics_bits)\n", "    if (p1->anti_alias.text_bits != p2->anti_alias.text_bits)\n", "    if (p1->black_component != p2->black_component)\n", "    if (strcmp(p1->cm_name, p2->cm_name) != 0)\n", "    if (p1->depth != p2->depth)\n", "    if (p1->dither_colors != p2->dither_colors)\n", "    if (p1->dither_grays != p2->dither_grays)\n", "    if (p1->gray_index != p2->gray_index)\n", "    if (p1->max_color != p2->max_color)\n", "    if (p1->max_components != p2->max_components)\n", "    if (p1->opmode != p2->opmode)\n", "    if (p1->polarity != p2->polarity)\n", "    if (p1->process_comps != p2->process_comps)\n", "    if (p1->separable_and_linear != p2->separable_and_linear)\n"], "tokenized": "bool FUNC1(const STRUCT1 *Var1,const STRUCT1 *Var2)\nif (Var1->memberVar1.memberVar1 !=  Var2->memberVar1.memberVar1)\nif (Var1->memberVar1.memberVar2 !=  Var2->memberVar1.memberVar2)\nif (Var1->memberVar2 !=  Var2->memberVar2)\nif (strcmp(Var1->memberVar3,Var2->memberVar3) != 0)\nif (Var1->memberVar4 !=  Var2->memberVar4)\nif (Var1->memberVar5 !=  Var2->memberVar5)\nif (Var1->memberVar6 !=  Var2->memberVar6)\nif (Var1->memberVar7 !=  Var2->memberVar7)\nif (Var1->memberVar8 !=  Var2->memberVar8)\nif (Var1->memberVar9 !=  Var2->memberVar9)\nif (Var1->memberVar10 !=  Var2->memberVar10)\nif (Var1->memberVar11 !=  Var2->memberVar11)\nif (Var1->memberVar12 !=  Var2->memberVar12)\nif (Var1->memberVar13 !=  Var2->memberVar13)\n"}]