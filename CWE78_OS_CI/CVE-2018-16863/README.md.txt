# 📁 CVE-2018-16863

## 🔍 취약점 개요

**🔗 [커밋 링크](https://invent.kde.org/plasma/plasma-workspace/-/commit/9db872df82c258315c6ebad800af59e81ffb9212)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2018-16863/)**  

> RHSA-2018:2918이 CVE-2018-16509를 완전히 수정하지 않은 것으로 확인되었다. 공격자는 이 결함의 또 다른 변종을 악용하고 -dSAFER 보호를 우회하여 예를 들어 특별히 제작된 PostScript 문서를 통해 임의의 셸 명령을 실행할 수 있다.

**취약점 종류**: [[CWE-78](https://cwe.mitre.org/data/definitions/78.html)] OS Command Injection

* **취약 조건**: 입력값 검증 없이(이 코드의 경우, 디바이스 초기화를 진행한 후에 설치가 이루어져야하는데 초기화하는 코드가 없었음) 명령 실행 경로에 직접 사용됨

* **Sink**: 취약점을 발휘하는 함수가 있는것은 아님. 초기 환경 설치시에 발생하는 문제로 null인지 확인하는 코드가 미비 (null이 아니라면 해당 설치 공간에 임의의 명령이 담겨있다면 취약점이 발현되는 상황)

---

## 탐지 결과 요약
cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스만 고려했을 때,

| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 0개       | 0개 | 0개 |

\* cve 설명에 나온 취약한 함수(Caller) && Sink와 관련된 슬라이스 데이터만 추출
없다.


#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유

현재 취약점이 발생하는 함수 gs_nulldevice() 안에는 l_funcs 리스트에 있는 함수가 없어 criterion이 없기 때문에 잡히는게 없다.

---

### ⚠️ 탐지 결과 문제점

현재 탐지 결과에서 모든 슬라이스가 정상(라벨 0)으로 판정되었으나, 이는 다음과 같은 기술적 한계로 인한 오탐으로 판단됩니다:

1. **crietrion이 될만한 함수가 caller에 없음**

## 취약점 세부 사항

### 📁 관련 파일 소개

| 파일명            | 설명              |
| -------------- | --------------- |
| `before_device.c` | 취약 코드 (수정 전) 포함 |
| `after_gsdevice.c`  | 개선 코드 (수정 후) 포함 |

---

### ❗️ 취약 코드

#### Source: `before_device.c` 
CVE에서 Source 파악이 어려우면 생략 가능
```c
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    gs_gstate *spgs;
    bool saveLockSafety = false;
    if (pgs->device == NULL || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if (gs_setdevice_no_erase(pgs, ndev) < 0) {
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
            spgs = pgs->saved;
            if (spgs != NULL) {
                while (spgs->saved) spgs = spgs->saved;
                gs_currentdevice_inline(pgs) = gs_currentdevice_inline(spgs);
                rc_increment(gs_currentdevice_inline(pgs));
            }
            code = gs_note_error(gs_error_Fatal);
        }
        if (gs_currentdevice_inline(pgs) != NULL)
            gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**문제점**:
LockSafetyParams는 디바이스가 보안 관련 설정을 따르는지를 제어한다.
복구 과정에서 이 플래그가 초기화되지 않거나 잘못된 값으로 설정되면, 시스템이 보안 검사를 우회하거나 불안정한 상태로 동작할 수 있음

---

### ✅ 개선 코드

**패치 위치**: `after_gsdevice.c`

```c
/* Select a null device. */
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    bool saveLockSafety = false;
    if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        /*
         * Internal devices have a reference count of 0, not 1,
         * aside from references from graphics states.
         */
        /* There is some strange use of the null device in the code.  I need
           to sort out how the icc profile is best handled with this device.
           It seems to inherit properties from the current device if there
           is one */
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
        gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**개선 방법**:
1. gs_currentdevice_inline(pgs)->LockSafetyParams 값을 saveLockSafety 변수에 백업함
```c
if (gs_currentdevice_inline(pgs) != NULL)
    saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
```
2. 새로운 null 디바이스를 생성 및 설정 시도

3. 디바이스 설정 후, 현재 디바이스의 LockSafetyParams를 복원
```c
gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
```
---

## 탐지 결과
없습니다.