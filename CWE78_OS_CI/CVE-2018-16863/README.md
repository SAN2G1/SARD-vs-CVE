# 📁 CVE-2018-16863

## 🔍 취약점 개요
**🔗 [커밋 링크](https://github.com/ArtifexSoftware/ghostpdl/commit/79cccf6)** | **🔗 [CVE 링크](https://www.cve.org/CVERecord?id=CVE-2018-16863)** | **[CWE 링크](https://cwe.mitre.org/data/definitions/78.html)** 

> Red Hat Enterprise Linux 7 프로그램의 NULL 디바이스를 탐색하고 선택한 다음 초기화하는는 기능에 있는 gs_nulldevice 함수에서 발생한 -dSAFER 보호를 우회하여 예를 들어 특별히 제작된 PostScript 문서를 통해 임의의 셸 명령을 실행할 수 있는 취약점

> **nulldevice** : PostScript에서 사용하는 특수 장치로, 출력 작업을 아무 것도 하지 않고 무시하는 장치

* **취약 조건**: 보안을 위한 잠금을 무효화함으로써 공격자가 명령어를 실행할 수 있는 환경을 만들기 때문에 **CWE-78 (OS Command Injection)**으로 분류

* **Sink**: 취약점을 발휘하는 함수가 있는것은 아님. 초기 환경 세팅시시에 발생하는 문제로 보안관련 인자의 값을 받아오는 코드가 미비하여 보안 취약한 상태로 만듦.

## 분석 결과 요약
cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스만 고려했을 때, 

| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 0개       | 0개 | 0개 |

/* https://bugs.ghostscript.com/show_bug.cgi?id=699654 */

이 CVE 취약점을 유발하는 코드(base/gdevpipe.c:60)는 아래와 같다.

```c
/* Sink: pipe_fopen */
/* function pointer 들을 필드로 갖고 있는 strcuture를 joern에서 잘 처리하는지 확인 필요 */ 

static int
pipe_fopen(gx_io_device * iodev, const char *fname, const char *access,
           FILE ** pfile, char *rfname, uint rnamelen)
{
#ifdef GS_NO_FILESYSTEM
    return 0;
#else
    errno = 0;
    /*
     * Some platforms allow opening a pipe with a '+' in the access
     * mode, even though pipes are not positionable.  Detect this here.
     */
    if (strchr(access, '+'))
        return_error(gs_error_invalidfileaccess);
    /*
     * The OSF/1 1.3 library doesn't include const in the
     * prototype for popen, so we have to break const here.
     */
    *pfile = popen((char *)fname, (char *)access);
```

이 코드에서 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.
```c
/*
link: https://bugs.ghostscript.com/show_bug.cgi?id=699654
/invalidaccess checks stop working after a failed restore, so you can just execute shell commands if you handle the error. Exploitation is very trivial. Repro:

$ gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/null 
GS>legal
GS>{ null restore } stopped { pop } if
GS>legal
GS>mark /OutputFile (%pipe%id) currentdevice putdeviceprops
GS<1>showpage
uid=1000(taviso) gid=1000(taviso) groups=1000(taviso),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

const gx_io_device gs_iodev_pipe = {
    "%pipe%", "Special",
    {iodev_no_init, iodev_no_finit, iodev_no_open_device,
     NULL , pipe_fopen, pipe_fclose,
     iodev_no_delete_file, iodev_no_rename_file, iodev_no_file_status,
     iodev_no_enumerate_files, NULL, NULL,
     iodev_no_get_params, iodev_no_put_params
    }
};
*/

/* Source: gx_device_open_output_file */
/* base/gsdevice.c:1193 */
int
gx_device_open_output_file(const gx_device * dev, char *fname,
                           bool binary, bool positionable, FILE ** pfile)
{
    gs_parsed_file_name_t parsed;
    const char *fmt;
    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, "gx_device_open_output_file(pfname)");
    int code;

    if (pfname == NULL) {
        code = gs_note_error(gs_error_VMerror);
	goto done;
     }

    if (strlen(fname) == 0) {
        code = gs_note_error(gs_error_undefinedfilename);
        emprintf1(dev->memory, "Device '%s' requires an output file but no file was specified.\n", dev->dname);
        goto done;
    }
    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);

/* base/gsdevice.c:1094 */
int
gx_parse_output_file_name(gs_parsed_file_name_t *pfn, const char **pfmt,
                          const char *fname, uint fnlen, gs_memory_t *memory)
{
    int code;

    *pfmt = 0;
    pfn->memory = 0;
    pfn->iodev = NULL;
    pfn->fname = NULL;		/* irrelevant since length = 0 */
    pfn->len = 0;
    if (fnlen == 0)  		/* allow null name */
        return 0;
    /*
     * If the file name begins with a %, it might be either an IODevice
     * or a %nnd format.  Check (carefully) for this case.
     */
    code = gs_parse_file_name(pfn, fname, fnlen, memory);
    if (code < 0) {
        if (fname[0] == '%') {
            /* not a recognized iodev -- may be a leading format descriptor */
            pfn->len = fnlen;
            pfn->fname = fname;
            code = gx_parse_output_format(pfn, pfmt);
        }
        if (code < 0)
            return code;
    }
    if (!pfn->iodev) {
        if ( (pfn->len == 1) && (pfn->fname[0] == '-') ) {
            pfn->iodev = gs_findiodevice(memory, (const byte *)"%stdout", 7);
            pfn->fname = NULL;
        } else if (pfn->fname[0] == '|') {
            pfn->iodev = gs_findiodevice(memory, (const byte *)"%pipe", 5);

/* base/gsdevice.c:1237 */
/* Open the output file for a device. */
int
gx_device_open_output_file(const gx_device * dev, char *fname,
                           bool binary, bool positionable, FILE ** pfile)
{
    gs_parsed_file_name_t parsed;
    const char *fmt;
    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, "gx_device_open_output_file(pfname)");
    int code;

    if (pfname == NULL) {
        code = gs_note_error(gs_error_VMerror);
	goto done;
     }

    if (strlen(fname) == 0) {
        code = gs_note_error(gs_error_undefinedfilename);
        emprintf1(dev->memory, "Device '%s' requires an output file but no file was specified.\n", dev->dname);
        goto done;
    }
    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);
    if (code < 0) {
        goto done;
    }

    if (parsed.iodev && !strcmp(parsed.iodev->dname, "%stdout%")) {
        if (parsed.fname) {
            code = gs_note_error(gs_error_undefinedfilename);
	    goto done;
	}
        *pfile = dev->memory->gs_lib_ctx->fstdout;
        /* Force stdout to binary. */
        code = gp_setmode_binary(*pfile, true);
	goto done;
    } else if (parsed.iodev && !strcmp(parsed.iodev->dname, "%pipe%")) {
        positionable = false;
    }
    if (fmt) {						/* filename includes "%nnd" */
        long count1 = dev->PageCount + 1;

        while (*fmt != 'l' && *fmt != '%')
            --fmt;
        if (*fmt == 'l')
            gs_sprintf(pfname, parsed.fname, count1);
        else
            gs_sprintf(pfname, parsed.fname, (int)count1);
    } else if (parsed.len && strchr(parsed.fname, '%'))	/* filename with "%%" but no "%nnd" */
        gs_sprintf(pfname, parsed.fname);
    else
        pfname[0] = 0; /* 0 to use "fname", not "pfname" */
    if (pfname[0]) {
        parsed.fname = pfname;
        parsed.len = strlen(parsed.fname);
    }
    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {
        char fmode[4];

        if (!parsed.fname) {
            code = gs_note_error(gs_error_undefinedfilename);
	    goto done;
	}
        strcpy(fmode, gp_fmode_wb);
        if (positionable)
            strcat(fmode, "+");
        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,
                                         pfile, NULL, 0); // gdevpipe.c에 pipe_fopen()을 호출

/* str이 OutputFile인거고 gx_io_device *iodev = libctx->io_device_table[i]; 에서 적절한 device를 찾은 다음에 if (dname && strlen(dname) == len + 1 && !memcmp(str, dname, len))에서 device의 첫번째 인자 "%PIPE%"와 str 값을 비교 */
/* base/gsiodev.c:378 */
/* Look up an IODevice name. */
/* The name may be either %device or %device%. */
gx_io_device *
gs_findiodevice(const gs_memory_t *mem, const byte * str, uint len) 
{
    int i;
    gs_lib_ctx_t *libctx = gs_lib_ctx_get_interp_instance(mem);

    if (libctx->io_device_table == 0)
    	return 0;
    if (len > 1 && str[len - 1] == '%')
        len--;
    for (i = 0; i < libctx->io_device_table_count; ++i) {
        gx_io_device *iodev = libctx->io_device_table[i];
        const char *dname = iodev->dname;

        if (dname && strlen(dname) == len + 1 && !memcmp(str, dname, len))
            return iodev;
    }
    return 0;
}

/* base/gdevpipe.c:33 */
const gx_io_device gs_iodev_pipe = {
    "%pipe%", "Special",
    {iodev_no_init, iodev_no_finit, iodev_no_open_device,
     NULL /*iodev_os_open_file */ , pipe_fopen, pipe_fclose,
     iodev_no_delete_file, iodev_no_rename_file, iodev_no_file_status,
     iodev_no_enumerate_files, NULL, NULL,
     iodev_no_get_params, iodev_no_put_params
    }
};


/* Sink: pipe_fopen */
/* base/gdevpipe.c:60 */
/* function pointer 들을 필드로 갖고 있는 strcuture를 joern에서 잘 처리하는지 확인 필요 */ 

static int
pipe_fopen(gx_io_device * iodev, const char *fname, const char *access,
           FILE ** pfile, char *rfname, uint rnamelen)
{
#ifdef GS_NO_FILESYSTEM
    return 0;
#else
    errno = 0;
    /*
     * Some platforms allow opening a pipe with a '+' in the access
     * mode, even though pipes are not positionable.  Detect this here.
     */
    if (strchr(access, '+'))
        return_error(gs_error_invalidfileaccess);
    /*
     * The OSF/1 1.3 library doesn't include const in the
     * prototype for popen, so we have to break const here.
     */
    *pfile = popen((char *)fname, (char *)access);
```

이 슬라이스를 수동으로 AI 기반 취약점 탐지 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유
현재 취약점이 발생하는 함수 gs_nulldevice() 안에는 l_funcs 리스트에 있는 함수가 없어 criterion이 없기 때문에 잡히는게 없다.

### 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출

없음

## 취약점 세부 사항

### 📁 관련 파일 소개

| 파일명            | 설명              |
| -------------- | --------------- |
| `before_device.c` | 취약 코드 (수정 전) 포함 |
| `after_gsdevice.c`  | 개선 코드 (수정 후) 포함 |

---

### ❗️ 취약 코드

**문제점**
- nulldevice는 setpagedevice를 통해 설정되는 것이 아니라 nulldevice 연산자를 통해 직접 설정되기 때문에, 이전 장치의 설정(예: LockSafetyParams)을 유지 불가능
- 보통 nulldevice는 아무 것도 하지 않기 때문에 이런 설정이 보존되지 않아도 문제가 없으나,
LockSafetyParams 설정은 예외
- 이 설정이 초기 장치에서 활성화되어 있었는데, nulldevice를 사용한 뒤 원래 장치로 복원할 경우, LockSafetyParams 설정이 비활성화된 상태로 복원되기 때문에 문제가 발생

#### Sink: `before_gsdive.c:731`
```c
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;

    if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
    }
    return code;
}
```

### ✅ 개선 코드

**패치 위치**: `before_gsdevice.c:690`

```c
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    gs_gstate *spgs;
    bool saveLockSafety = false;
    if (pgs->device == NULL || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if (gs_setdevice_no_erase(pgs, ndev) < 0) {
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");

            spgs = pgs->saved;
            if (spgs != NULL) {
                while (spgs->saved) spgs = spgs->saved;
                gs_currentdevice_inline(pgs) = gs_currentdevice_inline(spgs);
                rc_increment(gs_currentdevice_inline(pgs));
            }
            code = gs_note_error(gs_error_Fatal);
        }
        if (gs_currentdevice_inline(pgs) != NULL)
            gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**개선 방법**:
* LockSafetyParams 값을 기본적으로 false(비활성화)로 초기화하되, 장치를 복원할 때 이 값이 유지되도록 명시적으로 복사/유지

--
### 부연설명
**공격시나리오**
1. 시스템은 보안을 위해 LockSafetyParams를 true로 설정함.
2. 어떤 이유로 nulldevice가 사용됨.
3. 복원 후 LockSafetyParams가 false로 바뀜.
4. 이 시점부터는 공격자가 PostScript나 PDF 내에서 **명령어 실행 기능(system call)**을 사용할 수 있게 됨.
5. 이로 인해 OS 명령어가 삽입/실행 가능해짐 → CWE-78의 정의에 해당