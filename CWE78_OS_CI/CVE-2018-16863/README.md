# 📁 CVE-2018-16863

## 🔍 취약점 개요
**🔗 [커밋 링크](https://github.com/ArtifexSoftware/ghostpdl/blob/master/base/gsdevice.c)** | **🔗 [CVE 링크](https://www.cve.org/CVERecord?id=CVE-2018-16863)** | **[취약점 종류: [CWE-78] OS Command Injection](https://cwe.mitre.org/data/definitions/78.html)** 

> Red Hat Enterprise Linux 7 프로그램의 NULL 디바이스를 탐색하고 선택한 다음 초기화하는는 기능에 있는 gs_nulldevice 함수에서 발생한 -dSAFER 보호를 우회하여 예를 들어 특별히 제작된 PostScript 문서를 통해 임의의 셸 명령을 실행할 수 있는 취약점

> **nulldevice** : PostScript에서 사용하는 특수 장치로, 출력 작업을 아무 것도 하지 않고 무시하는 장치

* **취약 조건**: 보안을 위한 잠금을 무효화함으로써 공격자가 명령어를 실행할 수 있는 환경을 만들기 때문에 **CWE-78 (OS Command Injection)**으로 분류

* **Sink**: 취약점을 발휘하는 함수가 있는것은 아님. 초기 환경 세팅시시에 발생하는 문제로 보안관련 인자의 값을 받아오는 코드가 미비하여 보안 취약한 상태로 만듦.

## 분석 결과 요약
cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스만 고려했을 때, 

| 총 슬라이스 수 |  취약으로 탐지 | 정상으로 탐지 |
| --------  | -- | -- |
| 0개       | 0개 | 0개 |

#### SARD는 잘 탐지하는데 이 CVE는 탐지 못했던 이유
현재 취약점이 발생하는 함수 gs_nulldevice() 안에는 l_funcs 리스트에 있는 함수가 없어 criterion이 없기 때문에 잡히는게 없다.

### 탐지 결과
\* cve 설명에 나온 취약한 함수(Caller)에 대한 슬라이스 관련 데이터만 추출

없음

## 취약점 세부 사항

### 📁 관련 파일 소개

| 파일명            | 설명              |
| -------------- | --------------- |
| `before_device.c` | 취약 코드 (수정 전) 포함 |
| `after_gsdevice.c`  | 개선 코드 (수정 후) 포함 |

---

### ❗️ 취약 코드

**문제점**
- nulldevice는 setpagedevice를 통해 설정되는 것이 아니라 nulldevice 연산자를 통해 직접 설정되기 때문에, 이전 장치의 설정(예: LockSafetyParams)을 유지 불가능
- 보통 nulldevice는 아무 것도 하지 않기 때문에 이런 설정이 보존되지 않아도 문제가 없으나,
LockSafetyParams 설정은 예외
- 이 설정이 초기 장치에서 활성화되어 있었는데, nulldevice를 사용한 뒤 원래 장치로 복원할 경우, LockSafetyParams 설정이 비활성화된 상태로 복원되기 때문에 문제가 발생

#### Sink: `before_gsdive.c:731`
```c
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;

    if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
    }
    return code;
}
```

### ✅ 개선 코드

**패치 위치**: `before_gsdevice.c:690`

```c
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    gs_gstate *spgs;
    bool saveLockSafety = false;
    if (pgs->device == NULL || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if (gs_setdevice_no_erase(pgs, ndev) < 0) {
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");

            spgs = pgs->saved;
            if (spgs != NULL) {
                while (spgs->saved) spgs = spgs->saved;
                gs_currentdevice_inline(pgs) = gs_currentdevice_inline(spgs);
                rc_increment(gs_currentdevice_inline(pgs));
            }
            code = gs_note_error(gs_error_Fatal);
        }
        if (gs_currentdevice_inline(pgs) != NULL)
            gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**개선 방법**:
* LockSafetyParams 값을 기본적으로 false(비활성화)로 초기화하되, 장치를 복원할 때 이 값이 유지되도록 명시적으로 복사/유지

--
### 부연설명
**공격시나리오**
1. 시스템은 보안을 위해 LockSafetyParams를 true로 설정함.
2. 어떤 이유로 nulldevice가 사용됨.
3. 복원 후 LockSafetyParams가 false로 바뀜.
4. 이 시점부터는 공격자가 PostScript나 PDF 내에서 **명령어 실행 기능(system call)**을 사용할 수 있게 됨.
5. 이로 인해 OS 명령어가 삽입/실행 가능해짐 → CWE-78의 정의에 해당