# ğŸ“ CVE-2018-16863

## ğŸ” ì·¨ì•½ì  ê°œìš”
**ğŸ”— [ì»¤ë°‹ ë§í¬](https://github.com/ArtifexSoftware/ghostpdl/commit/79cccf6)** | **ğŸ”— [CVE ë§í¬](https://www.cve.org/CVERecord?id=CVE-2018-16863)** | **[CWE ë§í¬](https://cwe.mitre.org/data/definitions/78.html)** 

> Red Hat Enterprise Linux 7 í”„ë¡œê·¸ë¨ì˜ NULL ë””ë°”ì´ìŠ¤ë¥¼ íƒìƒ‰í•˜ê³  ì„ íƒí•œ ë‹¤ìŒ ì´ˆê¸°í™”í•˜ëŠ”ëŠ” ê¸°ëŠ¥ì— ìˆëŠ” gs_nulldevice í•¨ìˆ˜ì—ì„œ ë°œìƒí•œ -dSAFER ë³´í˜¸ë¥¼ ìš°íšŒí•˜ì—¬ ì˜ˆë¥¼ ë“¤ì–´ íŠ¹ë³„íˆ ì œì‘ëœ PostScript ë¬¸ì„œë¥¼ í†µí•´ ì„ì˜ì˜ ì…¸ ëª…ë ¹ì„ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ì·¨ì•½ì 

> **nulldevice** : PostScriptì—ì„œ ì‚¬ìš©í•˜ëŠ” íŠ¹ìˆ˜ ì¥ì¹˜ë¡œ, ì¶œë ¥ ì‘ì—…ì„ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•Šê³  ë¬´ì‹œí•˜ëŠ” ì¥ì¹˜

* **ì·¨ì•½ ì¡°ê±´**: ë³´ì•ˆì„ ìœ„í•œ ì ê¸ˆì„ ë¬´íš¨í™”í•¨ìœ¼ë¡œì¨ ê³µê²©ìê°€ ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” í™˜ê²½ì„ ë§Œë“¤ê¸° ë•Œë¬¸ì— **CWE-78 (OS Command Injection)**ìœ¼ë¡œ ë¶„ë¥˜

* **Sink**: ì·¨ì•½ì ì„ ë°œíœ˜í•˜ëŠ” í•¨ìˆ˜ê°€ ìˆëŠ”ê²ƒì€ ì•„ë‹˜. ì´ˆê¸° í™˜ê²½ ì„¸íŒ…ì‹œì‹œì— ë°œìƒí•˜ëŠ” ë¬¸ì œë¡œ ë³´ì•ˆê´€ë ¨ ì¸ìì˜ ê°’ì„ ë°›ì•„ì˜¤ëŠ” ì½”ë“œê°€ ë¯¸ë¹„í•˜ì—¬ ë³´ì•ˆ ì·¨ì•½í•œ ìƒíƒœë¡œ ë§Œë“¦.

## ë¶„ì„ ê²°ê³¼ ìš”ì•½
cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller)ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ë§Œ ê³ ë ¤í–ˆì„ ë•Œ, 

| ì´ ìŠ¬ë¼ì´ìŠ¤ ìˆ˜ |  ì·¨ì•½ìœ¼ë¡œ íƒì§€ | ì •ìƒìœ¼ë¡œ íƒì§€ |
| --------  | -- | -- |
| 0ê°œ       | 0ê°œ | 0ê°œ |

/* https://bugs.ghostscript.com/show_bug.cgi?id=699654 */

ì´ CVE ì·¨ì•½ì ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œ(base/gdevpipe.c:60)ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

```c
/* Sink: pipe_fopen */
/* function pointer ë“¤ì„ í•„ë“œë¡œ ê°–ê³  ìˆëŠ” strcutureë¥¼ joernì—ì„œ ì˜ ì²˜ë¦¬í•˜ëŠ”ì§€ í™•ì¸ í•„ìš” */ 

static int
pipe_fopen(gx_io_device * iodev, const char *fname, const char *access,
           FILE ** pfile, char *rfname, uint rnamelen)
{
#ifdef GS_NO_FILESYSTEM
    return 0;
#else
    errno = 0;
    /*
     * Some platforms allow opening a pipe with a '+' in the access
     * mode, even though pipes are not positionable.  Detect this here.
     */
    if (strchr(access, '+'))
        return_error(gs_error_invalidfileaccess);
    /*
     * The OSF/1 1.3 library doesn't include const in the
     * prototype for popen, so we have to break const here.
     */
    *pfile = popen((char *)fname, (char *)access);
```

ì´ ì½”ë“œì—ì„œ ìŠ¬ë¼ì´ì„œ ë„êµ¬ê°€ ì¶”ì¶œí–ˆì–´ì•¼ í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
```c
/*
link: https://bugs.ghostscript.com/show_bug.cgi?id=699654
/invalidaccess checks stop working after a failed restore, so you can just execute shell commands if you handle the error. Exploitation is very trivial. Repro:

$ gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/null 
GS>legal
GS>{ null restore } stopped { pop } if
GS>legal
GS>mark /OutputFile (%pipe%id) currentdevice putdeviceprops
GS<1>showpage
uid=1000(taviso) gid=1000(taviso) groups=1000(taviso),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

const gx_io_device gs_iodev_pipe = {
    "%pipe%", "Special",
    {iodev_no_init, iodev_no_finit, iodev_no_open_device,
     NULL , pipe_fopen, pipe_fclose,
     iodev_no_delete_file, iodev_no_rename_file, iodev_no_file_status,
     iodev_no_enumerate_files, NULL, NULL,
     iodev_no_get_params, iodev_no_put_params
    }
};
*/

/* Source: gx_device_open_output_file */
/* base/gsdevice.c:1193 */
int
gx_device_open_output_file(const gx_device * dev, char *fname,
                           bool binary, bool positionable, FILE ** pfile)
{
    gs_parsed_file_name_t parsed;
    const char *fmt;
    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, "gx_device_open_output_file(pfname)");
    int code;

    if (pfname == NULL) {
        code = gs_note_error(gs_error_VMerror);
	goto done;
     }

    if (strlen(fname) == 0) {
        code = gs_note_error(gs_error_undefinedfilename);
        emprintf1(dev->memory, "Device '%s' requires an output file but no file was specified.\n", dev->dname);
        goto done;
    }
    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);

/* base/gsdevice.c:1094 */
int
gx_parse_output_file_name(gs_parsed_file_name_t *pfn, const char **pfmt,
                          const char *fname, uint fnlen, gs_memory_t *memory)
{
    int code;

    *pfmt = 0;
    pfn->memory = 0;
    pfn->iodev = NULL;
    pfn->fname = NULL;		/* irrelevant since length = 0 */
    pfn->len = 0;
    if (fnlen == 0)  		/* allow null name */
        return 0;
    /*
     * If the file name begins with a %, it might be either an IODevice
     * or a %nnd format.  Check (carefully) for this case.
     */
    code = gs_parse_file_name(pfn, fname, fnlen, memory);
    if (code < 0) {
        if (fname[0] == '%') {
            /* not a recognized iodev -- may be a leading format descriptor */
            pfn->len = fnlen;
            pfn->fname = fname;
            code = gx_parse_output_format(pfn, pfmt);
        }
        if (code < 0)
            return code;
    }
    if (!pfn->iodev) {
        if ( (pfn->len == 1) && (pfn->fname[0] == '-') ) {
            pfn->iodev = gs_findiodevice(memory, (const byte *)"%stdout", 7);
            pfn->fname = NULL;
        } else if (pfn->fname[0] == '|') {
            pfn->iodev = gs_findiodevice(memory, (const byte *)"%pipe", 5);

/* base/gsdevice.c:1237 */
/* Open the output file for a device. */
int
gx_device_open_output_file(const gx_device * dev, char *fname,
                           bool binary, bool positionable, FILE ** pfile)
{
    gs_parsed_file_name_t parsed;
    const char *fmt;
    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, "gx_device_open_output_file(pfname)");
    int code;

    if (pfname == NULL) {
        code = gs_note_error(gs_error_VMerror);
	goto done;
     }

    if (strlen(fname) == 0) {
        code = gs_note_error(gs_error_undefinedfilename);
        emprintf1(dev->memory, "Device '%s' requires an output file but no file was specified.\n", dev->dname);
        goto done;
    }
    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);
    if (code < 0) {
        goto done;
    }

    if (parsed.iodev && !strcmp(parsed.iodev->dname, "%stdout%")) {
        if (parsed.fname) {
            code = gs_note_error(gs_error_undefinedfilename);
	    goto done;
	}
        *pfile = dev->memory->gs_lib_ctx->fstdout;
        /* Force stdout to binary. */
        code = gp_setmode_binary(*pfile, true);
	goto done;
    } else if (parsed.iodev && !strcmp(parsed.iodev->dname, "%pipe%")) {
        positionable = false;
    }
    if (fmt) {						/* filename includes "%nnd" */
        long count1 = dev->PageCount + 1;

        while (*fmt != 'l' && *fmt != '%')
            --fmt;
        if (*fmt == 'l')
            gs_sprintf(pfname, parsed.fname, count1);
        else
            gs_sprintf(pfname, parsed.fname, (int)count1);
    } else if (parsed.len && strchr(parsed.fname, '%'))	/* filename with "%%" but no "%nnd" */
        gs_sprintf(pfname, parsed.fname);
    else
        pfname[0] = 0; /* 0 to use "fname", not "pfname" */
    if (pfname[0]) {
        parsed.fname = pfname;
        parsed.len = strlen(parsed.fname);
    }
    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {
        char fmode[4];

        if (!parsed.fname) {
            code = gs_note_error(gs_error_undefinedfilename);
	    goto done;
	}
        strcpy(fmode, gp_fmode_wb);
        if (positionable)
            strcat(fmode, "+");
        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,
                                         pfile, NULL, 0); // gdevpipe.cì— pipe_fopen()ì„ í˜¸ì¶œ

/* strì´ OutputFileì¸ê±°ê³  gx_io_device *iodev = libctx->io_device_table[i]; ì—ì„œ ì ì ˆí•œ deviceë¥¼ ì°¾ì€ ë‹¤ìŒì— if (dname && strlen(dname) == len + 1 && !memcmp(str, dname, len))ì—ì„œ deviceì˜ ì²«ë²ˆì§¸ ì¸ì "%PIPE%"ì™€ str ê°’ì„ ë¹„êµ */
/* base/gsiodev.c:378 */
/* Look up an IODevice name. */
/* The name may be either %device or %device%. */
gx_io_device *
gs_findiodevice(const gs_memory_t *mem, const byte * str, uint len) 
{
    int i;
    gs_lib_ctx_t *libctx = gs_lib_ctx_get_interp_instance(mem);

    if (libctx->io_device_table == 0)
    	return 0;
    if (len > 1 && str[len - 1] == '%')
        len--;
    for (i = 0; i < libctx->io_device_table_count; ++i) {
        gx_io_device *iodev = libctx->io_device_table[i];
        const char *dname = iodev->dname;

        if (dname && strlen(dname) == len + 1 && !memcmp(str, dname, len))
            return iodev;
    }
    return 0;
}

/* base/gdevpipe.c:33 */
const gx_io_device gs_iodev_pipe = {
    "%pipe%", "Special",
    {iodev_no_init, iodev_no_finit, iodev_no_open_device,
     NULL /*iodev_os_open_file */ , pipe_fopen, pipe_fclose,
     iodev_no_delete_file, iodev_no_rename_file, iodev_no_file_status,
     iodev_no_enumerate_files, NULL, NULL,
     iodev_no_get_params, iodev_no_put_params
    }
};


/* Sink: pipe_fopen */
/* base/gdevpipe.c:60 */
/* function pointer ë“¤ì„ í•„ë“œë¡œ ê°–ê³  ìˆëŠ” strcutureë¥¼ joernì—ì„œ ì˜ ì²˜ë¦¬í•˜ëŠ”ì§€ í™•ì¸ í•„ìš” */ 

static int
pipe_fopen(gx_io_device * iodev, const char *fname, const char *access,
           FILE ** pfile, char *rfname, uint rnamelen)
{
#ifdef GS_NO_FILESYSTEM
    return 0;
#else
    errno = 0;
    /*
     * Some platforms allow opening a pipe with a '+' in the access
     * mode, even though pipes are not positionable.  Detect this here.
     */
    if (strchr(access, '+'))
        return_error(gs_error_invalidfileaccess);
    /*
     * The OSF/1 1.3 library doesn't include const in the
     * prototype for popen, so we have to break const here.
     */
    *pfile = popen((char *)fname, (char *)access);
```

ì´ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ AI ê¸°ë°˜ ì·¨ì•½ì  íƒì§€ ëª¨ë¸ì— ì ìš©í•´ì„œ ê²°ê³¼ë¥¼ íƒì§€í•´ë³´ì•˜ë”ë‹ˆ ì •ìƒìœ¼ë¡œ ì˜ˆì¸¡í–ˆë‹¤.

#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 
í˜„ì¬ ì·¨ì•½ì ì´ ë°œìƒí•˜ëŠ” í•¨ìˆ˜ gs_nulldevice() ì•ˆì—ëŠ” l_funcs ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” í•¨ìˆ˜ê°€ ì—†ì–´ criterionì´ ì—†ê¸° ë•Œë¬¸ì— ì¡íˆëŠ”ê²Œ ì—†ë‹¤.

### íƒì§€ ê²°ê³¼
\* cve ì„¤ëª…ì— ë‚˜ì˜¨ ì·¨ì•½í•œ í•¨ìˆ˜(Caller)ì— ëŒ€í•œ ìŠ¬ë¼ì´ìŠ¤ ê´€ë ¨ ë°ì´í„°ë§Œ ì¶”ì¶œ

ì—†ìŒ

## ì·¨ì•½ì  ì„¸ë¶€ ì‚¬í•­

### ğŸ“ ê´€ë ¨ íŒŒì¼ ì†Œê°œ

| íŒŒì¼ëª…            | ì„¤ëª…              |
| -------------- | --------------- |
| `before_device.c` | ì·¨ì•½ ì½”ë“œ (ìˆ˜ì • ì „) í¬í•¨ |
| `after_gsdevice.c`  | ê°œì„  ì½”ë“œ (ìˆ˜ì • í›„) í¬í•¨ |

---

### â—ï¸ ì·¨ì•½ ì½”ë“œ

**ë¬¸ì œì **
- nulldeviceëŠ” setpagedeviceë¥¼ í†µí•´ ì„¤ì •ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ nulldevice ì—°ì‚°ìë¥¼ í†µí•´ ì§ì ‘ ì„¤ì •ë˜ê¸° ë•Œë¬¸ì—, ì´ì „ ì¥ì¹˜ì˜ ì„¤ì •(ì˜ˆ: LockSafetyParams)ì„ ìœ ì§€ ë¶ˆê°€ëŠ¥
- ë³´í†µ nulldeviceëŠ” ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì´ëŸ° ì„¤ì •ì´ ë³´ì¡´ë˜ì§€ ì•Šì•„ë„ ë¬¸ì œê°€ ì—†ìœ¼ë‚˜,
LockSafetyParams ì„¤ì •ì€ ì˜ˆì™¸
- ì´ ì„¤ì •ì´ ì´ˆê¸° ì¥ì¹˜ì—ì„œ í™œì„±í™”ë˜ì–´ ìˆì—ˆëŠ”ë°, nulldeviceë¥¼ ì‚¬ìš©í•œ ë’¤ ì›ë˜ ì¥ì¹˜ë¡œ ë³µì›í•  ê²½ìš°, LockSafetyParams ì„¤ì •ì´ ë¹„í™œì„±í™”ëœ ìƒíƒœë¡œ ë³µì›ë˜ê¸° ë•Œë¬¸ì— ë¬¸ì œê°€ ë°œìƒ

#### Sink: `before_gsdive.c:731`
```c
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;

    if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
    }
    return code;
}
```

### âœ… ê°œì„  ì½”ë“œ

**íŒ¨ì¹˜ ìœ„ì¹˜**: `before_gsdevice.c:690`

```c
int
gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;
    gs_gstate *spgs;
    bool saveLockSafety = false;
    if (pgs->device == NULL || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        if (gs_currentdevice_inline(pgs) != NULL)
            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if (gs_setdevice_no_erase(pgs, ndev) < 0) {
            gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");

            spgs = pgs->saved;
            if (spgs != NULL) {
                while (spgs->saved) spgs = spgs->saved;
                gs_currentdevice_inline(pgs) = gs_currentdevice_inline(spgs);
                rc_increment(gs_currentdevice_inline(pgs));
            }
            code = gs_note_error(gs_error_Fatal);
        }
        if (gs_currentdevice_inline(pgs) != NULL)
            gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}
```

**ê°œì„  ë°©ë²•**:
* LockSafetyParams ê°’ì„ ê¸°ë³¸ì ìœ¼ë¡œ false(ë¹„í™œì„±í™”)ë¡œ ì´ˆê¸°í™”í•˜ë˜, ì¥ì¹˜ë¥¼ ë³µì›í•  ë•Œ ì´ ê°’ì´ ìœ ì§€ë˜ë„ë¡ ëª…ì‹œì ìœ¼ë¡œ ë³µì‚¬/ìœ ì§€

--
### ë¶€ì—°ì„¤ëª…
**ê³µê²©ì‹œë‚˜ë¦¬ì˜¤**
1. ì‹œìŠ¤í…œì€ ë³´ì•ˆì„ ìœ„í•´ LockSafetyParamsë¥¼ trueë¡œ ì„¤ì •í•¨.
2. ì–´ë–¤ ì´ìœ ë¡œ nulldeviceê°€ ì‚¬ìš©ë¨.
3. ë³µì› í›„ LockSafetyParamsê°€ falseë¡œ ë°”ë€œ.
4. ì´ ì‹œì ë¶€í„°ëŠ” ê³µê²©ìê°€ PostScriptë‚˜ PDF ë‚´ì—ì„œ **ëª…ë ¹ì–´ ì‹¤í–‰ ê¸°ëŠ¥(system call)**ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë¨.
5. ì´ë¡œ ì¸í•´ OS ëª…ë ¹ì–´ê°€ ì‚½ì…/ì‹¤í–‰ ê°€ëŠ¥í•´ì§ â†’ CWE-78ì˜ ì •ì˜ì— í•´ë‹¹