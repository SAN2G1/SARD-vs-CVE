[
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gs_getdefaultlibdevice",
    "Source": false,
    "Sink": false,
    "idx": 0,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 308,
    "label": -3,
    "slices": [
      "gs_getdefaultlibdevice(gs_memory_t *mem)\n",
      "    int count = gs_lib_device_list(&list, NULL);\n",
      "    const char *name, *end, *fin;\n",
      "    int i;\n",
      "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n",
      "        name = mem->gs_lib_ctx->default_device_list;\n",
      "        fin = name + strlen(name);\n",
      "    while (name < fin) {\n",
      "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n",
      "        name++;\n",
      "      end = name;\n",
      "      for (i = 0; i < count; i++)\n",
      "        if ((end - name) == strlen(list[i]->dname))\n",
      "          if (!memcmp(name, list[i]->dname, end - name))\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gs_getdefaultlibdevice",
    "Source": false,
    "Sink": false,
    "idx": 1,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 312,
    "label": -3,
    "slices": [
      "    int count = gs_lib_device_list(&list, NULL);\n",
      "    const char *name, *end, *fin;\n",
      "    int i;\n",
      "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n",
      "else\n",
      "        name = gs_dev_defaults;\n",
      "        fin = name + strlen(name);\n",
      "    while (name < fin) {\n",
      "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n",
      "        name++;\n",
      "      end = name;\n",
      "      for (i = 0; i < count; i++)\n",
      "        if ((end - name) == strlen(list[i]->dname))\n",
      "          if (!memcmp(name, list[i]->dname, end - name))\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gs_getdefaultlibdevice",
    "Source": false,
    "Sink": false,
    "idx": 2,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 327,
    "label": -3,
    "slices": [
      "gs_getdefaultlibdevice(gs_memory_t *mem)\n",
      "    int count = gs_lib_device_list(&list, NULL);\n",
      "    const char *name, *end, *fin;\n",
      "    int i;\n",
      "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n",
      "        name = mem->gs_lib_ctx->default_device_list;\n",
      "        fin = name + strlen(name);\n",
      "else\n",
      "        name = gs_dev_defaults;\n",
      "        fin = name + strlen(name);\n",
      "    while (name < fin) {\n",
      "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n",
      "        name++;\n",
      "      end = name;\n",
      "      while ((end < fin) && (*end != ' ') && (*end != '\\t'))\n",
      "        end++;\n",
      "      for (i = 0; i < count; i++)\n",
      "        if ((end - name) == strlen(list[i]->dname))\n",
      "          if (!memcmp(name, list[i]->dname, end - name))\n",
      "            return gs_getdevice(i);\n",
      "      name = end;\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gs_getdefaultlibdevice",
    "Source": false,
    "Sink": false,
    "idx": 3,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 328,
    "label": -3,
    "slices": [
      "gs_getdefaultlibdevice(gs_memory_t *mem)\n",
      "    int count = gs_lib_device_list(&list, NULL);\n",
      "    const char *name, *end, *fin;\n",
      "    int i;\n",
      "    if (mem && mem->gs_lib_ctx && mem->gs_lib_ctx->default_device_list) {\n",
      "        name = mem->gs_lib_ctx->default_device_list;\n",
      "        fin = name + strlen(name);\n",
      "else\n",
      "        name = gs_dev_defaults;\n",
      "        fin = name + strlen(name);\n",
      "    while (name < fin) {\n",
      "      while ((name < fin) && (*name == ' ' || *name == '\\t'))\n",
      "        name++;\n",
      "      end = name;\n",
      "      while ((end < fin) && (*end != ' ') && (*end != '\\t'))\n",
      "        end++;\n",
      "      for (i = 0; i < count; i++)\n",
      "        if ((end - name) == strlen(list[i]->dname))\n",
      "          if (!memcmp(name, list[i]->dname, end - name))\n",
      "            return gs_getdevice(i);\n",
      "      name = end;\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_init",
    "Source": false,
    "Sink": false,
    "idx": 4,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 612,
    "label": -3,
    "slices": [
      "gx_device_init(gx_device * dev, const gx_device * proto, gs_memory_t * mem,\n               bool internal)\n",
      "    memcpy(dev, proto, proto->params_size);\n",
      "    dev->memory = mem;\n",
      "    dev->retained = !internal;\n",
      "    rc_init(dev, mem, (internal ? 0 : 1));\n",
      "    rc_increment(dev->icc_struct);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_init_on_stack",
    "Source": false,
    "Sink": false,
    "idx": 5,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 623,
    "label": -3,
    "slices": [
      "gx_device_init_on_stack(gx_device * dev, const gx_device * proto,\n                        gs_memory_t * mem)\n",
      "    memcpy(dev, proto, proto->params_size);\n",
      "    dev->memory = mem;\n",
      "    dev->retained = 0;\n",
      "    dev->pad = proto->pad;\n",
      "    dev->log2_align_mod = proto->log2_align_mod;\n",
      "    dev->is_planar = proto->is_planar;\n",
      "    rc_init(dev, NULL, 0);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_parse_output_format",
    "Source": false,
    "Sink": false,
    "idx": 6,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1016,
    "label": -3,
    "slices": ["    uint i;\n"]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_parse_output_format",
    "Source": false,
    "Sink": false,
    "idx": 7,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1022,
    "label": -3,
    "slices": [
      "gx_parse_output_format(gs_parsed_file_name_t *pfn, const char **pfmt)\n",
      "    bool have_format = false, field;\n",
      "    int width[2], int_width = sizeof(int) * 3, w = 0;\n",
      "    uint i;\n",
      "    for (i = 0; i < pfn->len; ++i)\n",
      "        if (pfn->fname[i] == '%') {\n",
      "            if (i + 1 < pfn->len && pfn->fname[i + 1] == '%') {\n",
      "                i++;\n",
      "                if (++i == pfn->len)\n",
      "else\n",
      "                    switch (field) {\n",
      "                            if (strchr(\" #+-\", pfn->fname[i]))\n",
      "                            if (strchr(\"0123456789\", pfn->fname[i])) {\n",
      "                                width[field] = width[field] * 10 + pfn->fname[i] - '0';\n",
      "else\n",
      "                            } else if (0 == field && '.' == pfn->fname[i]) {\n",
      "                            if ('l' == pfn->fname[i]) {\n",
      "                            if (strchr(\"diuoxX\", pfn->fname[i])) {\n",
      "                                *pfmt = &pfn->fname[i];\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_parse_output_format",
    "Source": false,
    "Sink": false,
    "idx": 8,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1039,
    "label": -3,
    "slices": [
      "gx_parse_output_format(gs_parsed_file_name_t *pfn, const char **pfmt)\n",
      "    bool have_format = false, field;\n",
      "    int width[2], int_width = sizeof(int) * 3, w = 0;\n",
      "    uint i;\n",
      "    for (i = 0; i < pfn->len; ++i)\n",
      "        if (pfn->fname[i] == '%') {\n",
      "            if (i + 1 < pfn->len && pfn->fname[i + 1] == '%') {\n",
      "                i++;\n",
      "                if (++i == pfn->len)\n",
      "else\n",
      "                    switch (field) {\n",
      "                            if (strchr(\" #+-\", pfn->fname[i]))\n",
      "                            if (strchr(\"0123456789\", pfn->fname[i])) {\n",
      "                                width[field] = width[field] * 10 + pfn->fname[i] - '0';\n",
      "else\n",
      "                            } else if (0 == field && '.' == pfn->fname[i]) {\n",
      "                            if ('l' == pfn->fname[i]) {\n",
      "                            if (strchr(\"diuoxX\", pfn->fname[i])) {\n",
      "                                *pfmt = &pfn->fname[i];\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_parse_output_file_name",
    "Source": false,
    "Sink": false,
    "idx": 9,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1108,
    "label": -3,
    "slices": [
      "gx_parse_output_file_name(gs_parsed_file_name_t *pfn, const char **pfmt,\n                          const char *fname, uint fnlen, gs_memory_t *memory)\n",
      "                          const char *fname, uint fnlen, gs_memory_t *memory)\n",
      "    int code;\n",
      "    pfn->memory = 0;\n",
      "    pfn->iodev = NULL;\n",
      "    pfn->fname = NULL;\t\t/* irrelevant since length = 0 */\n",
      "    pfn->len = 0;\n",
      "    if (fnlen == 0)  \t\t/* allow null name */\n",
      "    code = gs_parse_file_name(pfn, fname, fnlen, memory);\n",
      "    if (code < 0) {\n",
      "        if (fname[0] == '%') {\n",
      "            pfn->len = fnlen;\n",
      "            pfn->fname = fname;\n",
      "            code = gx_parse_output_format(pfn, pfmt);\n",
      "        if (code < 0)\n",
      "            return code;\n",
      "    if (!pfn->iodev) {\n",
      "        if ( (pfn->len == 1) && (pfn->fname[0] == '-') ) {\n",
      "            pfn->iodev = gs_findiodevice(memory, (const byte *)\"%stdout\", 7);\n",
      "else\n",
      "        } else if (pfn->fname[0] == '|') {\n",
      "            pfn->iodev = gs_findiodevice(memory, (const byte *)\"%pipe\", 5);\n",
      "            pfn->fname++, pfn->len--;\n",
      "else\n",
      "            pfn->iodev = iodev_default(memory);\n",
      "    if (!pfn->fname)\n",
      "    code = gx_parse_output_format(pfn, pfmt);\n",
      "    if (code < 0)\n",
      "        return code;\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_outputfile_is_separate_pages",
    "Source": false,
    "Sink": false,
    "idx": 10,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1119,
    "label": -3,
    "slices": [
      "gx_outputfile_is_separate_pages(const char *fname, gs_memory_t *memory)\n",
      "    const char *fmt;\n",
      "    int code = gx_parse_output_file_name(&parsed, &fmt, fname,\n                                         strlen(fname), memory);\n",
      "    return (code >= 0 && fmt != 0);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_delete_output_file",
    "Source": false,
    "Sink": false,
    "idx": 11,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1138,
    "label": -3,
    "slices": [
      "int gx_device_delete_output_file(const gx_device * dev, const char *fname)\n",
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname),\n                                         dev->memory);\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "    if (pfname != NULL)\n",
      "        gs_free_object(dev->memory, pfname, \"gx_device_delete_output_file(pfname)\");\n",
      "    return(code);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_delete_output_file",
    "Source": false,
    "Sink": false,
    "idx": 12,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1144,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (parsed.iodev)\n",
      "        code = parsed.iodev->procs.delete_file((gx_io_device *)(&parsed.iodev), (const char *)parsed.fname);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_delete_output_file",
    "Source": false,
    "Sink": false,
    "idx": 13,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1156,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (parsed.iodev)\n",
      "        code = parsed.iodev->procs.delete_file((gx_io_device *)(&parsed.iodev), (const char *)parsed.fname);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_delete_output_file",
    "Source": false,
    "Sink": false,
    "idx": 14,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1162,
    "label": -3,
    "slices": [
      "int gx_device_delete_output_file(const gx_device * dev, const char *fname)\n",
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_delete_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\"))\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (parsed.iodev)\n",
      "        code = parsed.iodev->procs.delete_file((gx_io_device *)(&parsed.iodev), (const char *)parsed.fname);\n",
      "    return(code);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 15,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1191,
    "label": -3,
    "slices": [
      "gx_device_open_output_file(const gx_device * dev, char *fname,\n                           bool binary, bool positionable, FILE ** pfile)\n",
      "    gs_parsed_file_name_t parsed;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "        long count1 = dev->PageCount + 1;\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "else\n",
      "        *pfile = gp_open_printer(dev->memory, (pfname[0] ? pfname : fname), binary);\n",
      "        if (!(*pfile)) {\n",
      "            emprintf1(dev->memory, \"**** Could not open the file '%s'.\\n\", (pfname[0] ? pfname : fname));\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 16,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1196,
    "label": -3,
    "slices": [
      "gx_device_open_output_file(const gx_device * dev, char *fname,\n                           bool binary, bool positionable, FILE ** pfile)\n",
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "        emprintf1(dev->memory, \"Device '%s' requires an output file but no file was specified.\\n\", dev->dname);\n",
      "    code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname), dev->memory);\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "        if (parsed.fname) {\n",
      "        *pfile = dev->memory->gs_lib_ctx->fstdout;\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        if (!parsed.fname) {\n",
      "        if (code)\n",
      "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n",
      "else\n",
      "        *pfile = gp_open_printer(dev->memory, (pfname[0] ? pfname : fname), binary);\n",
      "        if (!(*pfile)) {\n",
      "            emprintf1(dev->memory, \"**** Could not open the file '%s'.\\n\", (pfname[0] ? pfname : fname));\n",
      "    if (pfname != NULL)\n",
      "        gs_free_object(dev->memory, pfname, \"gx_device_open_output_file(pfname)\");\n",
      "    return(code);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 17,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1201,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        char fmode[4];\n",
      "        if (!parsed.fname) {\n",
      "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n",
      "        if (code)\n",
      "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 18,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1210,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        char fmode[4];\n",
      "        if (!parsed.fname) {\n",
      "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n",
      "        if (code)\n",
      "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 19,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1222,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        char fmode[4];\n",
      "        if (!parsed.fname) {\n",
      "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n",
      "        if (code)\n",
      "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 20,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1228,
    "label": -3,
    "slices": [
      "gx_device_open_output_file(const gx_device * dev, char *fname,\n                           bool binary, bool positionable, FILE ** pfile)\n",
      "    gs_parsed_file_name_t parsed;\n",
      "    const char *fmt;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "    if (fmt) {\t\t\t\t\t\t/* filename includes \"%nnd\" */\n",
      "        long count1 = dev->PageCount + 1;\n",
      "        if (*fmt == 'l')\n",
      "            gs_sprintf(pfname, parsed.fname, count1);\n",
      "else\n",
      "else\n",
      "    } else if (parsed.len && strchr(parsed.fname, '%'))\t/* filename with \"%%\" but no \"%nnd\" */\n",
      "        gs_sprintf(pfname, parsed.fname);\n",
      "    if (pfname[0]) {\n",
      "        parsed.fname = pfname;\n",
      "        parsed.len = strlen(parsed.fname);\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        char fmode[4];\n",
      "        if (!parsed.fname) {\n",
      "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n",
      "        if (code)\n",
      "            emprintf1(dev->memory,\n                      \"**** Could not open the file %s .\\n\",\n                      parsed.fname);\n",
      "    return(code);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 21,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcpy",
    "line": 1237,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "        long count1 = dev->PageCount + 1;\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        char fmode[4];\n",
      "        if (!parsed.fname) {\n",
      "        strcpy(fmode, gp_fmode_wb);\n",
      "        if (positionable)\n",
      "            strcat(fmode, \"+\");\n",
      "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_open_output_file",
    "Source": false,
    "Sink": false,
    "idx": 22,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcat",
    "line": 1239,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    char *pfname = (char *)gs_alloc_bytes(dev->memory, gp_file_name_sizeof, \"gx_device_open_output_file(pfname)\");\n",
      "    int code;\n",
      "    if (pfname == NULL) {\n",
      "    if (strlen(fname) == 0) {\n",
      "    if (code < 0) {\n",
      "    if (parsed.iodev && !strcmp(parsed.iodev->dname, \"%stdout%\")) {\n",
      "        long count1 = dev->PageCount + 1;\n",
      "    if (positionable || (parsed.iodev && parsed.iodev != iodev_default(dev->memory))) {\n",
      "        char fmode[4];\n",
      "        if (!parsed.fname) {\n",
      "        strcpy(fmode, gp_fmode_wb);\n",
      "        if (positionable)\n",
      "            strcat(fmode, \"+\");\n",
      "        code = parsed.iodev->procs.gp_fopen(parsed.iodev, parsed.fname, fmode,\n                                         pfile, NULL, 0);\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_close_output_file",
    "Source": false,
    "Sink": false,
    "idx": 23,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1270,
    "label": -3,
    "slices": [
      "gx_device_close_output_file(const gx_device * dev, const char *fname,\n                            FILE *file)\n",
      "    gs_parsed_file_name_t parsed;\n",
      "    int code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname),\n                                         dev->memory);\n",
      "    if (code < 0)\n",
      "        return code;\n",
      "    if (parsed.iodev) {\n",
      "        if (!strcmp(parsed.iodev->dname, \"%stdout%\"))\n",
      "        if (parsed.iodev != iodev_default(dev->memory))\n",
      "    gp_close_printer(dev->memory, file, (parsed.fname ? parsed.fname : fname));\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_device_close_output_file",
    "Source": false,
    "Sink": false,
    "idx": 24,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1276,
    "label": -3,
    "slices": [
      "    gs_parsed_file_name_t parsed;\n",
      "    int code = gx_parse_output_file_name(&parsed, &fmt, fname, strlen(fname),\n                                         dev->memory);\n",
      "    if (code < 0)\n",
      "    if (parsed.iodev) {\n",
      "        if (!strcmp(parsed.iodev->dname, \"%stdout%\"))\n",
      "        if (parsed.iodev != iodev_default(dev->memory))\n",
      "            return parsed.iodev->procs.fclose(parsed.iodev, file);\n",
      "    gp_close_printer(dev->memory, file, (parsed.fname ? parsed.fname : fname));\n"
    ]
  },
  {
    "FileName": "before_gsdevice.c",
    "Caller": "gx_color_info_equal",
    "Source": false,
    "Sink": false,
    "idx": 25,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1294,
    "label": -3,
    "slices": [
      "bool gx_color_info_equal(const gx_device_color_info * p1, const gx_device_color_info * p2)\n",
      "    if (p1->anti_alias.graphics_bits != p2->anti_alias.graphics_bits)\n",
      "    if (p1->anti_alias.text_bits != p2->anti_alias.text_bits)\n",
      "    if (p1->black_component != p2->black_component)\n",
      "    if (strcmp(p1->cm_name, p2->cm_name) != 0)\n",
      "    if (p1->depth != p2->depth)\n",
      "    if (p1->dither_colors != p2->dither_colors)\n",
      "    if (p1->dither_grays != p2->dither_grays)\n",
      "    if (p1->gray_index != p2->gray_index)\n",
      "    if (p1->max_color != p2->max_color)\n",
      "    if (p1->max_components != p2->max_components)\n",
      "    if (p1->opmode != p2->opmode)\n",
      "    if (p1->polarity != p2->polarity)\n",
      "    if (p1->process_comps != p2->process_comps)\n",
      "    if (p1->separable_and_linear != p2->separable_and_linear)\n"
    ]
  }
]
