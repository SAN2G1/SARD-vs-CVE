# ğŸ“ CVE-2019-13638

## ğŸ“Œ ê°œìš”  

**ğŸ”— [ì»¤ë°‹ ë§í¬](https://github.com/mirror/patch/commit/3fcd042d26d70856e826a42b5f93dc4854d80bf0)** | **ğŸ”— [CVE ë§í¬](https://nvd.nist.gov/vuln/detail/CVE-2019-13638)**| **ğŸ”— [CWE ë§í¬](https://cwe.mitre.org/data/definitions/78.html)** 

> âš ï¸ ì´ CVEëŠ” joernìœ¼ë¡œ íŒŒì‹± ì—ëŸ¬ë¡œ ë¶„ì„ì„ ì‹¤íŒ¨í•˜ì˜€ìŠµë‹ˆë‹¤.
> ```bash
>(.ksign_slicer) root@0c13b466fbd1:/KSignSlicer# tools/ReVeal/code-slicer/joern/>joern-parse da
>ta/converged/CVE-2019-13638/ \
>    && mv parsed/data/converged/CVE-2019-13638/ data/cpg.csv/ \
>    && rm data/cpg.csv/CVE-2019-13638/*.csv \
>    && rm -rf parsed
>data/converged/CVE-2019-13638/after_pch.c
>Error parsing function pch_normalize. skipping.
>data/converged/CVE-2019-13638/before_pch.c
>Error parsing function pch_normalize. skipping.
>mv: cannot overwrite 'data/cpg.csv/CVE-2019-13638': Directory not empty
>```

> ì´ ì·¨ì•½ì ì€ `patch` ìœ í‹¸ë¦¬í‹°ì˜ `do_ed_script` í•¨ìˆ˜ì—ì„œ ë°œìƒí–ˆìŠµë‹ˆë‹¤.  
ì›ë˜ êµ¬í˜„ì—ì„œëŠ” `sprintf()`ë¥¼ í†µí•´ shell ëª…ë ¹ ë¬¸ìì—´ì„ êµ¬ì„±í•˜ê³  ì´ë¥¼ `sh -c`ë¡œ ì‹¤í–‰í•˜ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤.  ê·¸ëŸ¬ë‚˜ `outname` ê²½ë¡œì— ì‰˜ ë©”íƒ€ë¬¸ì(ì˜ˆ: `;`, `&`, `|`, `!`, `-`)ê°€ í¬í•¨ë˜ë©´ ê³µê²©ìê°€ ì„ì˜ì˜ ëª…ë ¹ì„ ì‚½ì…í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

* **Source**: patch í”„ë¡œê·¸ë¨ ì¸ì ê°’
* **ì·¨ì•½ ì¡°ê±´**: ì…ë ¥ê°’ ê²€ì¦ ì—†ì´ ëª…ë ¹ ì‹¤í–‰ ê²½ë¡œì— ì§ì ‘ ì‚¬ìš©ë¨
* **Sink**: ì…ë ¥ê°’ì„ ê²€ì¦í•˜ì§€ ì•Šê³  execl()ì— ì‚¬ìš©

## íƒì§€ ê²°ê³¼ ìš”ì•½
âš ï¸ joernìœ¼ë¡œ íŒŒì‹± ì—ëŸ¬ë¡œ ë¶„ì„ ì‹¤íŒ¨

ì´ CVE ì·¨ì•½ì ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œ(sink:src/pch.c:2473)ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.
```
void
do_ed_script (char const *inname, char const *outname,
	      bool *outname_needs_removal, FILE *ofp)
{
    static char const editor_program[] = EDITOR_PROGRAM;
    ...
	sprintf (buf, "%s %s%s", editor_program,
		 verbosity == VERBOSE ? "" : "- ",
		 outname);
	fflush (stdout);

	pid = fork();
	if (pid == -1)
	else if (pid == 0)
	  {
	    dup2 (tmpfd, 0);
	    execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```
ì´ ì½”ë“œì—ì„œ ìŠ¬ë¼ì´ì„œ ë„êµ¬ê°€ ì¶”ì¶œí–ˆì–´ì•¼ í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
```c

/* í¬ì¸í„° ë¶„ì„ì„ ì˜í•´ì•¼ í•¨. make_tempfile()ì—ì„œ TMPOUTNAMEì´ outnameìœ¼ë¡œë¶€í„° ì—…ë°ì´íŠ¸ ëœ ë‹¤ëŠ” ì‚¬ì‹¤ì„ interprocedure analysisë¡œëŠ” ì‹ë³„í•  ìˆ˜ ì—†ë‹¤. */
/* src/patch.c:959 */
static void
get_some_switches (void)
{
    int optc;

    free (rejname);
    rejname = 0;
    if (optind == Argc)
	return;
    while ((optc = getopt_long (Argc, Argv, shortopts, longopts, (int *) 0))
	   != -1) {
	switch (optc) {
	    case 'o':
		outfile = xstrdup (optarg);

/* src/patch.c:253 */
int
main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool skip_reject_file = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv ("QUOTING_STYLE");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv ("POSIXLY_CORRECT") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv ("PATCH_GET"))
		 ? numeric_string (val, true, "PATCH_GET value")
		 : 0);

    val = getenv ("SIMPLE_BACKUP_SUFFIX");
    simple_backup_suffix = val && *val ? val : ".orig";

    if ((version_control = getenv ("PATCH_VERSION_CONTROL")))
      version_control_context = "$PATCH_VERSION_CONTROL";
    else if ((version_control = getenv ("VERSION_CONTROL")))
      version_control_context = "$VERSION_CONTROL";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv ("TZ", "UTC", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    /* When the file to patch is specified on the command line, allow that file
       to lie outside the current working tree.  Still doesn't allow to follow
       symlinks.  */
    if (inname)
      unsafe = true;

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  skip_reject_file = false,
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
      bool mismatch = false;
      char const *outname = NULL;

      if (skip_rest_of_patch)
	somefailed = true;

      if (have_git_diff != pch_git_diff ())
	{
	  if (have_git_diff)
	    {
	      output_files (NULL);
	      inerrno = -1;
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say ("File %s: can't change file type from 0%o to 0%o.\n",
	       quotearg (inname),
	       (unsigned int) (pch_mode (reverse) & S_IFMT),
	       (unsigned int) (pch_mode (! reverse) & S_IFMT));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;

/* src/util.c:1669 */
int
make_tempfile (char const **name, char letter, char const *real_name,
	       int flags, mode_t mode)
{
  char *template;
  struct try_safe_open_args args = {
    .flags = flags,
    .mode = mode,
  };
  int fd;

  if (real_name && ! dry_run)
    {
      char *dirname, *basename;

      dirname = dir_name (real_name);
      basename = base_name (real_name);

      template = xmalloc (strlen (dirname) + 1 + strlen (basename) + 9);
      sprintf (template, "%s/%s.%cXXXXXX", dirname, basename, letter);
      free (dirname);
      free (basename);
    }
  else
  fd = try_tempname(template, 0, &args, try_safe_open);
  *name = template;

/* src/patch.c:317 */
int
main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool skip_reject_file = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv ("QUOTING_STYLE");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv ("POSIXLY_CORRECT") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv ("PATCH_GET"))
		 ? numeric_string (val, true, "PATCH_GET value")
		 : 0);

    val = getenv ("SIMPLE_BACKUP_SUFFIX");
    simple_backup_suffix = val && *val ? val : ".orig";

    if ((version_control = getenv ("PATCH_VERSION_CONTROL")))
      version_control_context = "$PATCH_VERSION_CONTROL";
    else if ((version_control = getenv ("VERSION_CONTROL")))
      version_control_context = "$VERSION_CONTROL";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv ("TZ", "UTC", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    /* When the file to patch is specified on the command line, allow that file
       to lie outside the current working tree.  Still doesn't allow to follow
       symlinks.  */
    if (inname)
      unsafe = true;

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  skip_reject_file = false,
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
      bool mismatch = false;
      char const *outname = NULL;

      if (skip_rest_of_patch)
	somefailed = true;

      if (have_git_diff != pch_git_diff ())
	{
	  if (have_git_diff)
	    {
	      output_files (NULL);
	      inerrno = -1;
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say ("File %s: can't change file type from 0%o to 0%o.\n",
	       quotearg (inname),
	       (unsigned int) (pch_mode (reverse) & S_IFMT),
	       (unsigned int) (pch_mode (! reverse) & S_IFMT));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! reverse);
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && safe_access (inname, W_OK) != 0)
	{
	  say ("File %s is read-only; ", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say ("trying to patch anyway\n");
	  else
	    {
	      say ("refusing to patch\n");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname, 
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);

/* src/common.h:95 */
XTERN char const * TMPOUTNAME;

/* src/patch.c:21 */
#define XTERN
#include <common.h>
#undef XTERN
#define XTERN extern
...

/* src/patch.c:337 */
int
main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool skip_reject_file = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv ("QUOTING_STYLE");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv ("POSIXLY_CORRECT") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv ("PATCH_GET"))
		 ? numeric_string (val, true, "PATCH_GET value")
		 : 0);

    val = getenv ("SIMPLE_BACKUP_SUFFIX");
    simple_backup_suffix = val && *val ? val : ".orig";

    if ((version_control = getenv ("PATCH_VERSION_CONTROL")))
      version_control_context = "$PATCH_VERSION_CONTROL";
    else if ((version_control = getenv ("VERSION_CONTROL")))
      version_control_context = "$VERSION_CONTROL";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv ("TZ", "UTC", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    /* When the file to patch is specified on the command line, allow that file
       to lie outside the current working tree.  Still doesn't allow to follow
       symlinks.  */
    if (inname)
      unsafe = true;

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  skip_reject_file = false,
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
      bool mismatch = false;
      char const *outname = NULL;

      if (skip_rest_of_patch)
	somefailed = true;

      if (have_git_diff != pch_git_diff ())
	{
	  if (have_git_diff)
	    {
	      output_files (NULL);
	      inerrno = -1;
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say ("File %s: can't change file type from 0%o to 0%o.\n",
	       quotearg (inname),
	       (unsigned int) (pch_mode (reverse) & S_IFMT),
	       (unsigned int) (pch_mode (! reverse) & S_IFMT));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! reverse);
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && safe_access (inname, W_OK) != 0)
	{
	  say ("File %s is read-only; ", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say ("trying to patch anyway\n");
	  else
	    {
	      say ("refusing to patch\n");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname, 
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);
      if (outfd == -1)
	{
	  if (errno == ELOOP || errno == EXDEV)
	    {
	      say ("Invalid file name %s -- skipping patch\n", quotearg (outname));
	      skip_rest_of_patch = true;
	      skip_reject_file = true;
	      somefailed = true;
	    }
	  else
	    pfatal ("Can't create temporary file %s", TMPOUTNAME);
	}
      else
        TMPOUTNAME_needs_removal = true;
      if (diff_type == ED_DIFF) {
	outstate.zero_output = false;
	somefailed |= skip_rest_of_patch;
	do_ed_script (inname, TMPOUTNAME, &TMPOUTNAME_needs_removal, // 337
		      outstate.ofp);

/* src/pch.c:2473 */
void
do_ed_script (char const *inname, char const *outname,
	      bool *outname_needs_removal, FILE *ofp)
{
    static char const editor_program[] = EDITOR_PROGRAM;
	sprintf (buf, "%s %s%s", editor_program,
			verbosity == VERBOSE ? "" : "- ",
			outname);
	fflush (stdout);

	pid = fork();
	if (pid == -1)
	else if (pid == 0)
		execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```
ì´ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ AI ê¸°ë°˜ ì·¨ì•½ì  íƒì§€ ëª¨ë¸ì— ì ìš©í•´ì„œ ê²°ê³¼ë¥¼ íƒì§€í•´ë³´ì•˜ë”ë‹ˆ ì •ìƒìœ¼ë¡œ ì˜ˆì¸¡í–ˆë‹¤.

#### SARDëŠ” ì˜ íƒì§€í•˜ëŠ”ë° ì´ CVEëŠ” íƒì§€ ëª»í–ˆë˜ ì´ìœ 
ì„¸ê°€ì§€ë¥¼ ê¼­ ì „ë¶€ í•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤. 1 -> 2 -> 3 ìˆœìœ¼ë¡œ ì›ì¸ ê·œëª…ì„ í•´ë‚˜ê°€ë©´ ë  ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤.

1. **ë¶€ì ì ˆí•œ criterion**
    - CWE78ì˜ SARD/README.mdì— ë”°ë¥´ë©´ 
        > ```bash
        > sojeon@swlab-u2404:~/Documents/research/SARD-vs-CVE/CWE78_OS_CI/SARD$ xsv search -s predict 1 test_output.csv | xsv select criterion | uniq
        >    criterion
        >    strcat
        > ```
    - ì´ ì·¨ì•½ì ì˜ ê²½ìš° criterionìœ¼ë¡œ strcat()ì´ ì¡íˆì§€ ì•Šì•„ ì •ìƒìœ¼ë¡œ íŒë‹¨ëœ ê²ƒìœ¼ë¡œ ë³´ì„.

2. **(ì˜ˆì‹œ) ìŠ¬ë¼ì´ì‹± ë²”ìœ„ ë¶ˆì™„ì „**
   - ìŠ¬ë¼ì´ìŠ¤ê°€ `system()` í˜¸ì¶œ ë‹¨ë… ë˜ëŠ” ì£¼ë³€ ë¬¸ìì—´ ì²˜ë¦¬ í•¨ìˆ˜(`strlen`, `snprintf`)ë§Œ í¬í•¨ë¨
   - ìŠ¬ë¼ì´ìŠ¤ì— ëª…ë ¹ì–´ ì¡°í•© ê³¼ì •ì´ í¬í•¨ë˜ì§€ ì•Šì•„ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì¶©ë¶„íˆ ë°˜ì˜í•˜ì§€ ëª»í•¨
   - sinkì— ë„ë‹¬í•˜ëŠ” ë³€ìˆ˜ê°€ ë‘ ê°œ ì´ìƒì˜ í•¨ìˆ˜ì—ì„œ ì¡°í•©ë˜ë‹¤ ë³´ë‹ˆ, ìŠ¬ë¼ì´ìŠ¤ì— í•´ë‹¹ ë¶€ë¶„ì´ ë°˜ì˜ë˜ì§€ ì•ŠìŒ.
        ê¸°ëŒ€í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤
        ```
        source(input);
        input = input+1;
        system(input);
        ```
        ì›ë³¸ ìŠ¬ë¼ì´ìŠ¤

        ```c
        // slicerê°€ ì¶”ì¶œí•œ ì›ë³¸ì„ ë„£ì„ ê²ƒ
        system(input);
        ```

3. **ë²¡í„° ë‹¨ì ˆ**
   - ìŠ¬ë¼ì´ìŠ¤ì—ëŠ” ì·¨ì•½í•œ ì½”ë“œê°€ ëª¨ë‘ í¬í•¨ë˜ì–´ ìˆìŒ.
        idx: xë²ˆì§¸ ìŠ¬ë¼ì´ìŠ¤
     
        ``` 
            ìŠ¬ë¼ì´ìŠ¤ ì›ë³¸
        ```
   - ê·¸ëŸ¬ë‚˜ ë²¡í„° ê¸¸ì´ ìµœëŒ€ 512ë¡œ ì·¨ì•½ ì½”ë“œì— ê¼­ í•„ìš”í•œ íŒŒíŠ¸ê°€ ì§¤ë¦¼.
        ```
            idx xë²ˆì§¸ ë²¡í„° ì›ë³¸ ex) <s>, system, (, Var1, ), ;, </s>
        ```

## ğŸš¨ ì·¨ì•½ ì½”ë“œ (BadSink)
#### Sink: `src/pch.c:2473`
```c
sprintf (buf, "%s %s%s", editor_program,
         verbosity == VERBOSE ? "" : "- ",
         outname);
...
execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```

**ë¬¸ì œì **:
- ì‚¬ìš©ì ì œì–´ê°€ ê°€ëŠ¥í•œ `outname`ì´ ì‰˜ ëª…ë ¹ì–´ë¡œ í•´ì„ë¨
- `sh -c` ì‚¬ìš© ì‹œ ëª…ë ¹ì–´ ì „ì²´ë¥¼ ì‰˜ì—ì„œ í•´ì„í•˜ë¯€ë¡œ,
  ì•…ì˜ì  ì…ë ¥ (`; rm -rf /`, `&& cat /etc/passwd` ë“±) ì‚½ì… ê°€ëŠ¥

---

### âœ… ê°œì„  ì½”ë“œ
```c
assert (outname[0] != '!' && outname[0] != '-');
execlp (editor_program, editor_program, "-", outname, (char  *) NULL);
```

**ê°œì„  ë°©ë²•**:

- ì‰˜ì„ ê±°ì¹˜ì§€ ì•Šê³  `execlp`ë¥¼ í†µí•´ ì§ì ‘ ì‹¤í–‰
- ì¸ìˆ˜ëŠ” ë°°ì—´ë¡œ ì•ˆì „í•˜ê²Œ ì „ë‹¬ë¨
- `outname`ì— ëŒ€í•œ sanity check (`!`, `-` ë°©ì§€) ì¶”ê°€ë¨


## íƒì§€ ê²°ê³¼
\* joernìœ¼ë¡œ íŒŒì‹± ì—ëŸ¬