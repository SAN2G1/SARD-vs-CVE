# CWE-78: OS ëª…ë ¹ì–´ ì‚½ì… (OS Command Injection)

## ğŸ“Œ ê°œìš”  

> âš ï¸ ì´ CVEëŠ” joernìœ¼ë¡œ íŒŒì‹± ì—ëŸ¬ë¡œ ë¶„ì„ì„ ì‹¤íŒ¨í•˜ì˜€ìŠµë‹ˆë‹¤.
> ```bash
>(.ksign_slicer) root@0c13b466fbd1:/KSignSlicer# tools/ReVeal/code-slicer/joern/>joern-parse da
>ta/converged/CVE-2019-13638/ \
>    && mv parsed/data/converged/CVE-2019-13638/ data/cpg.csv/ \
>    && rm data/cpg.csv/CVE-2019-13638/*.csv \
>    && rm -rf parsed
>data/converged/CVE-2019-13638/after_pch.c
>Error parsing function pch_normalize. skipping.
>data/converged/CVE-2019-13638/before_pch.c
>Error parsing function pch_normalize. skipping.
>mv: cannot overwrite 'data/cpg.csv/CVE-2019-13638': Directory not empty
>```

ì´ ì·¨ì•½ì ì€ `patch` ìœ í‹¸ë¦¬í‹°ì˜ `do_ed_script` í•¨ìˆ˜ì—ì„œ ë°œìƒí–ˆìŠµë‹ˆë‹¤.  
ì›ë˜ êµ¬í˜„ì—ì„œëŠ” `sprintf()`ë¥¼ í†µí•´ shell ëª…ë ¹ ë¬¸ìì—´ì„ êµ¬ì„±í•˜ê³  ì´ë¥¼ `sh -c`ë¡œ ì‹¤í–‰í•˜ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤.  
ê·¸ëŸ¬ë‚˜ `outname` ê²½ë¡œì— ì‰˜ ë©”íƒ€ë¬¸ì(ì˜ˆ: `;`, `&`, `|`, `!`, `-`)ê°€ í¬í•¨ë˜ë©´ ê³µê²©ìê°€ ì„ì˜ì˜ ëª…ë ¹ì„ ì‚½ì…í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

ì´ëŠ” ì™¸ë¶€ ì…ë ¥ê°’ì´ ì œëŒ€ë¡œ ì´ìŠ¤ì¼€ì´í”„ ë˜ì§€ ì•Šì€ ì±„ OS ì‰˜ë¡œ ì „ë‹¬ë˜ë©´ì„œ  
**CWE-78: OS Command Injection** ì·¨ì•½ì ì´ ë°œìƒí•œ ì „í˜•ì ì¸ ì‚¬ë¡€ì…ë‹ˆë‹¤.


ì´ CVE ì·¨ì•½ì ì„ ìœ ë°œí•˜ëŠ” ì½”ë“œ(sink:src/pch.c:2473)ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.
```
void
do_ed_script (char const *inname, char const *outname,
	      bool *outname_needs_removal, FILE *ofp)
{
    static char const editor_program[] = EDITOR_PROGRAM;
    ...
	sprintf (buf, "%s %s%s", editor_program,
		 verbosity == VERBOSE ? "" : "- ",
		 outname);
	fflush (stdout);

	pid = fork();
	if (pid == -1)
	else if (pid == 0)
	  {
	    dup2 (tmpfd, 0);
	    execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```
ì´ ì½”ë“œì—ì„œ Ksign ìŠ¬ë¼ì´ì„œ ë„êµ¬ê°€ ì¶”ì¶œí–ˆì–´ì•¼ í•˜ëŠ” ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì§ì ‘ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
```c

/* í¬ì¸í„° ë¶„ì„ì„ ì˜í•´ì•¼ í•¨. make_tempfile()ì—ì„œ TMPOUTNAMEì´ outnameìœ¼ë¡œë¶€í„° ì—…ë°ì´íŠ¸ ëœ ë‹¤ëŠ” ì‚¬ì‹¤ì„ interprocedure analysisë¡œëŠ” ì‹ë³„í•  ìˆ˜ ì—†ë‹¤. */
/* src/patch.c:959 */
static void
get_some_switches (void)
{
    int optc;

    free (rejname);
    rejname = 0;
    if (optind == Argc)
	return;
    while ((optc = getopt_long (Argc, Argv, shortopts, longopts, (int *) 0))
	   != -1) {
	switch (optc) {
	    case 'o':
		outfile = xstrdup (optarg);

/* src/patch.c:253 */
int
main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool skip_reject_file = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv ("QUOTING_STYLE");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv ("POSIXLY_CORRECT") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv ("PATCH_GET"))
		 ? numeric_string (val, true, "PATCH_GET value")
		 : 0);

    val = getenv ("SIMPLE_BACKUP_SUFFIX");
    simple_backup_suffix = val && *val ? val : ".orig";

    if ((version_control = getenv ("PATCH_VERSION_CONTROL")))
      version_control_context = "$PATCH_VERSION_CONTROL";
    else if ((version_control = getenv ("VERSION_CONTROL")))
      version_control_context = "$VERSION_CONTROL";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv ("TZ", "UTC", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    /* When the file to patch is specified on the command line, allow that file
       to lie outside the current working tree.  Still doesn't allow to follow
       symlinks.  */
    if (inname)
      unsafe = true;

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  skip_reject_file = false,
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
      bool mismatch = false;
      char const *outname = NULL;

      if (skip_rest_of_patch)
	somefailed = true;

      if (have_git_diff != pch_git_diff ())
	{
	  if (have_git_diff)
	    {
	      output_files (NULL);
	      inerrno = -1;
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say ("File %s: can't change file type from 0%o to 0%o.\n",
	       quotearg (inname),
	       (unsigned int) (pch_mode (reverse) & S_IFMT),
	       (unsigned int) (pch_mode (! reverse) & S_IFMT));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;

/* src/util.c:1669 */
int
make_tempfile (char const **name, char letter, char const *real_name,
	       int flags, mode_t mode)
{
  char *template;
  struct try_safe_open_args args = {
    .flags = flags,
    .mode = mode,
  };
  int fd;

  if (real_name && ! dry_run)
    {
      char *dirname, *basename;

      dirname = dir_name (real_name);
      basename = base_name (real_name);

      template = xmalloc (strlen (dirname) + 1 + strlen (basename) + 9);
      sprintf (template, "%s/%s.%cXXXXXX", dirname, basename, letter);
      free (dirname);
      free (basename);
    }
  else
  fd = try_tempname(template, 0, &args, try_safe_open);
  *name = template;

/* src/patch.c:317 */
int
main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool skip_reject_file = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv ("QUOTING_STYLE");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv ("POSIXLY_CORRECT") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv ("PATCH_GET"))
		 ? numeric_string (val, true, "PATCH_GET value")
		 : 0);

    val = getenv ("SIMPLE_BACKUP_SUFFIX");
    simple_backup_suffix = val && *val ? val : ".orig";

    if ((version_control = getenv ("PATCH_VERSION_CONTROL")))
      version_control_context = "$PATCH_VERSION_CONTROL";
    else if ((version_control = getenv ("VERSION_CONTROL")))
      version_control_context = "$VERSION_CONTROL";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv ("TZ", "UTC", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    /* When the file to patch is specified on the command line, allow that file
       to lie outside the current working tree.  Still doesn't allow to follow
       symlinks.  */
    if (inname)
      unsafe = true;

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  skip_reject_file = false,
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
      bool mismatch = false;
      char const *outname = NULL;

      if (skip_rest_of_patch)
	somefailed = true;

      if (have_git_diff != pch_git_diff ())
	{
	  if (have_git_diff)
	    {
	      output_files (NULL);
	      inerrno = -1;
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say ("File %s: can't change file type from 0%o to 0%o.\n",
	       quotearg (inname),
	       (unsigned int) (pch_mode (reverse) & S_IFMT),
	       (unsigned int) (pch_mode (! reverse) & S_IFMT));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! reverse);
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && safe_access (inname, W_OK) != 0)
	{
	  say ("File %s is read-only; ", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say ("trying to patch anyway\n");
	  else
	    {
	      say ("refusing to patch\n");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname, 
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);

/* src/common.h:95 */
XTERN char const * TMPOUTNAME;

/* src/patch.c:21 */
#define XTERN
#include <common.h>
#undef XTERN
#define XTERN extern
...

/* src/patch.c:337 */
int
main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool skip_reject_file = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv ("QUOTING_STYLE");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv ("POSIXLY_CORRECT") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv ("PATCH_GET"))
		 ? numeric_string (val, true, "PATCH_GET value")
		 : 0);

    val = getenv ("SIMPLE_BACKUP_SUFFIX");
    simple_backup_suffix = val && *val ? val : ".orig";

    if ((version_control = getenv ("PATCH_VERSION_CONTROL")))
      version_control_context = "$PATCH_VERSION_CONTROL";
    else if ((version_control = getenv ("VERSION_CONTROL")))
      version_control_context = "$VERSION_CONTROL";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv ("TZ", "UTC", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    /* When the file to patch is specified on the command line, allow that file
       to lie outside the current working tree.  Still doesn't allow to follow
       symlinks.  */
    if (inname)
      unsafe = true;

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  skip_reject_file = false,
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
      bool mismatch = false;
      char const *outname = NULL;

      if (skip_rest_of_patch)
	somefailed = true;

      if (have_git_diff != pch_git_diff ())
	{
	  if (have_git_diff)
	    {
	      output_files (NULL);
	      inerrno = -1;
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say ("File %s: can't change file type from 0%o to 0%o.\n",
	       quotearg (inname),
	       (unsigned int) (pch_mode (reverse) & S_IFMT),
	       (unsigned int) (pch_mode (! reverse) & S_IFMT));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! reverse);
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && safe_access (inname, W_OK) != 0)
	{
	  say ("File %s is read-only; ", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say ("trying to patch anyway\n");
	  else
	    {
	      say ("refusing to patch\n");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname, 
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);
      if (outfd == -1)
	{
	  if (errno == ELOOP || errno == EXDEV)
	    {
	      say ("Invalid file name %s -- skipping patch\n", quotearg (outname));
	      skip_rest_of_patch = true;
	      skip_reject_file = true;
	      somefailed = true;
	    }
	  else
	    pfatal ("Can't create temporary file %s", TMPOUTNAME);
	}
      else
        TMPOUTNAME_needs_removal = true;
      if (diff_type == ED_DIFF) {
	outstate.zero_output = false;
	somefailed |= skip_rest_of_patch;
	do_ed_script (inname, TMPOUTNAME, &TMPOUTNAME_needs_removal, // 337
		      outstate.ofp);

/* src/pch.c:2473 */
void
do_ed_script (char const *inname, char const *outname,
	      bool *outname_needs_removal, FILE *ofp)
{
    static char const editor_program[] = EDITOR_PROGRAM;
	sprintf (buf, "%s %s%s", editor_program,
			verbosity == VERBOSE ? "" : "- ",
			outname);
	fflush (stdout);

	pid = fork();
	if (pid == -1)
	else if (pid == 0)
		execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```
ì´ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ Ksign ëª¨ë¸ì— ì ìš©í•´ì„œ ê²°ê³¼ë¥¼ íƒì§€í•´ë³´ì•˜ë”ë‹ˆ ì •ìƒìœ¼ë¡œ ì˜ˆì¸¡í–ˆë‹¤.

---

## ğŸ›  ì£¼ìš” ì›ì¸

- `sprintf(buf, "...", outname)`ìœ¼ë¡œ ëª…ë ¹ ë¬¸ìì—´ì„ ì§ì ‘ ìƒì„±
- í•´ë‹¹ ë¬¸ìì—´ì„ `sh -c`ë¥¼ í†µí•´ ì‹¤í–‰ â†’ ì‰˜ í•´ì„ê¸°ì—ì„œ ëª…ë ¹ì–´ ì¸ì ì…˜ ë°œìƒ ê°€ëŠ¥
- `outname` ê°’ì´ ì ì ˆíˆ í•„í„°ë§ë˜ì§€ ì•ŠìŒ (`!`, `;`, `&` ë“± í¬í•¨ ê°€ëŠ¥)

---

## ğŸ“‚ ê´€ë ¨ íŒŒì¼

| íŒŒì¼ëª… | ì„¤ëª… |
|--------|------|
| `src/pch.c` | `do_ed_script()` í•¨ìˆ˜ê°€ ì •ì˜ëœ íŒŒì¼ |

---

## ğŸš¨ ì·¨ì•½ ì½”ë“œ (BadSink)

ğŸ“Œ **í•¨ìˆ˜**: `do_ed_script()`  
ğŸ“Œ **ì·¨ì•½ ì½”ë“œ ìš”ì•½**:
```c
sprintf (buf, "%s %s%s", editor_program,
         verbosity == VERBOSE ? "" : "- ",
         outname);
...
execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```

ğŸ“Œ **ë¬¸ì œì **:
- ì‚¬ìš©ì ì œì–´ê°€ ê°€ëŠ¥í•œ `outname`ì´ ì‰˜ ëª…ë ¹ì–´ë¡œ í•´ì„ë¨
- `sh -c` ì‚¬ìš© ì‹œ ëª…ë ¹ì–´ ì „ì²´ë¥¼ ì‰˜ì—ì„œ í•´ì„í•˜ë¯€ë¡œ,
  ì•…ì˜ì  ì…ë ¥ (`; rm -rf /`, `&& cat /etc/passwd` ë“±) ì‚½ì… ê°€ëŠ¥

---

## âœ… íŒ¨ì¹˜ ì´í›„

ğŸ“Œ **ì•ˆì „í•œ ì‹¤í–‰ ë°©ì‹ìœ¼ë¡œ ë³€ê²½**:
```c
assert (outname[0] != '!' && outname[0] != '-');
execlp (editor_program, editor_program, "-", outname, (char  *) NULL);
```

ğŸ“Œ **ê°œì„ ì **:
- ì‰˜ì„ ê±°ì¹˜ì§€ ì•Šê³  `execlp`ë¥¼ í†µí•´ ì§ì ‘ ì‹¤í–‰
- ì¸ìˆ˜ëŠ” ë°°ì—´ë¡œ ì•ˆì „í•˜ê²Œ ì „ë‹¬ë¨
- `outname`ì— ëŒ€í•œ sanity check (`!`, `-` ë°©ì§€) ì¶”ê°€ë¨

---

## ğŸ” ìš”ì•½

| í•­ëª© | ë‚´ìš© |
|------|------|
| CWE-ID | CWE-78: OS Command Injection |
| CVE-ID | CVE-2019-13638 |
| ì·¨ì•½ í•¨ìˆ˜ | `do_ed_script()` in `src/pch.c` |
| ì·¨ì•½ ì¡°ê±´ | `outname`ì— ì‰˜ íŠ¹ìˆ˜ë¬¸ì í¬í•¨ + `sh -c` ì‚¬ìš© |
| íŒ¨ì¹˜ ë°©ì‹ | ì‰˜ì„ ê±°ì¹˜ì§€ ì•Šê³  `execlp()`ë¡œ ì•ˆì „í•˜ê²Œ ì‹¤í–‰ |

---

## ğŸ“š ì°¸ê³  ë§í¬

- ğŸ”— [ê¹ƒí—™ ë¯¸ëŸ¬ ì»¤ë°‹](https://github.com/mirror/patch/commit/3fcd042d26d70856e826a42b5f93dc4854d80bf0?diff=split#diff-51dc8c6b2e604ed6e828131231c43353ea81b6dfba88826a55d53507431997fdR2441)
- ğŸ“– [CVE-2019-13638 ìƒì„¸ì •ë³´ (NVD)](https://nvd.nist.gov/vuln/detail/CVE-2019-13638)

---

## ğŸ“Œ ë¹„ê³ 

- í•´ë‹¹ ì·¨ì•½ì ì€ GNU patchì˜ ì˜¤ë˜ëœ `ed` ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ë£¨í‹´ì—ì„œ ë°œê²¬ë¨
- ì‰˜ì„ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ì½”ë“œ ê²½ë¡œì—ì„œ ì‚¬ìš©ì ì…ë ¥ì„ ì§ì ‘ ì¡°í•©í•´ì„œëŠ” ì•ˆ ëœë‹¤ëŠ” êµí›ˆì„ ì¤Œ