# CWE-78: OS 명령어 삽입 (OS Command Injection)

## 📌 개요  

> ⚠️ 이 CVE는 joern으로 파싱 에러로 분석을 실패하였습니다.
> ```bash
>(.ksign_slicer) root@0c13b466fbd1:/KSignSlicer# tools/ReVeal/code-slicer/joern/>joern-parse da
>ta/converged/CVE-2019-13638/ \
>    && mv parsed/data/converged/CVE-2019-13638/ data/cpg.csv/ \
>    && rm data/cpg.csv/CVE-2019-13638/*.csv \
>    && rm -rf parsed
>data/converged/CVE-2019-13638/after_pch.c
>Error parsing function pch_normalize. skipping.
>data/converged/CVE-2019-13638/before_pch.c
>Error parsing function pch_normalize. skipping.
>mv: cannot overwrite 'data/cpg.csv/CVE-2019-13638': Directory not empty
>```

이 취약점은 `patch` 유틸리티의 `do_ed_script` 함수에서 발생했습니다.  
원래 구현에서는 `sprintf()`를 통해 shell 명령 문자열을 구성하고 이를 `sh -c`로 실행하는 방식이었습니다.  
그러나 `outname` 경로에 쉘 메타문자(예: `;`, `&`, `|`, `!`, `-`)가 포함되면 공격자가 임의의 명령을 삽입할 수 있게 됩니다.

이는 외부 입력값이 제대로 이스케이프 되지 않은 채 OS 쉘로 전달되면서  
**CWE-78: OS Command Injection** 취약점이 발생한 전형적인 사례입니다.


이 CVE 취약점을 유발하는 코드(sink:src/pch.c:2473)는 아래와 같다.
```
void
do_ed_script (char const *inname, char const *outname,
	      bool *outname_needs_removal, FILE *ofp)
{
    static char const editor_program[] = EDITOR_PROGRAM;
    ...
	sprintf (buf, "%s %s%s", editor_program,
		 verbosity == VERBOSE ? "" : "- ",
		 outname);
	fflush (stdout);

	pid = fork();
	if (pid == -1)
	else if (pid == 0)
	  {
	    dup2 (tmpfd, 0);
	    execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```
이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.
```
/* src/pch.c:2473 */
XTERN char *buf;
XTERN enum { DEFAULT_VERBOSITY, SILENT, VERBOSE } verbosity;
sprintf (buf, "%s %s%s", editor_program,
        verbosity == VERBOSE ? "" : "- ",
        outname);
fflush (stdout);

pid = fork();
if (pid == -1)
else if (pid == 0)
    execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```
이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

---

## 🛠 주요 원인

- `sprintf(buf, "...", outname)`으로 명령 문자열을 직접 생성
- 해당 문자열을 `sh -c`를 통해 실행 → 쉘 해석기에서 명령어 인젝션 발생 가능
- `outname` 값이 적절히 필터링되지 않음 (`!`, `;`, `&` 등 포함 가능)

---

## 📂 관련 파일

| 파일명 | 설명 |
|--------|------|
| `src/pch.c` | `do_ed_script()` 함수가 정의된 파일 |

---

## 🚨 취약 코드 (BadSink)

📌 **함수**: `do_ed_script()`  
📌 **취약 코드 요약**:
```c
sprintf (buf, "%s %s%s", editor_program,
         verbosity == VERBOSE ? "" : "- ",
         outname);
...
execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
```

📌 **문제점**:
- 사용자 제어가 가능한 `outname`이 쉘 명령어로 해석됨
- `sh -c` 사용 시 명령어 전체를 쉘에서 해석하므로,
  악의적 입력 (`; rm -rf /`, `&& cat /etc/passwd` 등) 삽입 가능

---

## ✅ 패치 이후

📌 **안전한 실행 방식으로 변경**:
```c
assert (outname[0] != '!' && outname[0] != '-');
execlp (editor_program, editor_program, "-", outname, (char  *) NULL);
```

📌 **개선점**:
- 쉘을 거치지 않고 `execlp`를 통해 직접 실행
- 인수는 배열로 안전하게 전달됨
- `outname`에 대한 sanity check (`!`, `-` 방지) 추가됨

---

## 🔍 요약

| 항목 | 내용 |
|------|------|
| CWE-ID | CWE-78: OS Command Injection |
| CVE-ID | CVE-2019-13638 |
| 취약 함수 | `do_ed_script()` in `src/pch.c` |
| 취약 조건 | `outname`에 쉘 특수문자 포함 + `sh -c` 사용 |
| 패치 방식 | 쉘을 거치지 않고 `execlp()`로 안전하게 실행 |

---

## 📚 참고 링크

- 🔗 [깃헙 미러 커밋](https://github.com/mirror/patch/commit/3fcd042d26d70856e826a42b5f93dc4854d80bf0?diff=split#diff-51dc8c6b2e604ed6e828131231c43353ea81b6dfba88826a55d53507431997fdR2441)
- 📖 [CVE-2019-13638 상세정보 (NVD)](https://nvd.nist.gov/vuln/detail/CVE-2019-13638)

---

## 📌 비고

- 해당 취약점은 GNU patch의 오래된 `ed` 스크립트 실행 루틴에서 발견됨
- 쉘을 사용하는 모든 코드 경로에서 사용자 입력을 직접 조합해서는 안 된다는 교훈을 줌