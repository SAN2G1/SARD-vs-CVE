[
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 0,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 361,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (FUNC3(Var3->memberVar1,Var4)){\nFUNC4(Var3,STRING,Var4); \nelse \nchar *Var5=FUNC5(Var4); \nif (Var5){\nFUNC6(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 1,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 379,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (!Var4){\nVar4=STRING; \nif (FUNC3(Var3->memberVar1,Var4)){\nelse \nchar *Var5=FUNC4(Var4); \nif (Var5){\nFUNC5(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 2,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 390,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\n*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var12=FUNC6(Var6,Var4); \nif (Var12){\nFUNC7(Var12); \nfree(Var12); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 3,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 391,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\n*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var12=FUNC6(Var6,Var4); \nif (Var12){\nFUNC7(Var12); \nfree(Var12); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 4,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 395,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\n*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var12=FUNC6(Var6,Var4); \nif (Var12){\nFUNC7(Var12); \nfree(Var12); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 5,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 399,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\tlines = atoi (arg);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\nVar4=FUNC3(Var6); \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var9=FUNC6(Var6,Var4); \nif (Var9){\nFUNC7(Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 6,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 417,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (!Var6){\nVar6=STRING; \nif (FUNC4(Var3->memberVar1,Var6)){\nelse \nchar *Var9=FUNC5(Var6,Var4); \nif (Var9){\nFUNC6(Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 7,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 422,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nchar *Var3=strdup(Var2); \nchar *Var4=strchr(Var3,); \nelse \nchar *Var5=FUNC2(Var4,Var6); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 8,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 435,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n",
      "\t\tr_core_cmdf (data, \"s-%s\", input + 1);\n",
      "\t\tr_core_cmdf (data, \"wc%s\", input + 1);\n",
      "\t\tif (input[1] == 'i' && input[2] == 'q') {\n",
      "\t\t\tcmd_uniq (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nchar *Var4=strdup(Var2+2); \nchar *Var5=strchr(Var4,,); \nif (Var5){\n*Var5  Var6=0; \nSTRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); \nFUNC3(Var3,Var7); \nfree(Var4); \nFUNC4(Var1,STRING,Var2+1); \nFUNC4(Var1,STRING,Var2+1); \nif (Var2[1]==  Var8&&Var2[2]==  Var9){\nFUNC5(Var3,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 9,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 436,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nchar *Var4=strdup(Var2+2); \nchar *Var5=strchr(Var4,,); \nif (Var5){\n*Var5  Var6=0; \nSTRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); \nFUNC3(Var3,Var7); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 10,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 444,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nchar *Var4=strdup(Var2+2); \nchar *Var5=strchr(Var4,,); \nif (Var5){\nSTRUCT2 *Var6=FUNC2(Var3->memberVar1,Var4,Var5); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 11,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 504,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\n*Var11  Var13=0; \nsize_t  Var14=strlen(Var11); \nif (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){\nVar11[Var14-1]=0; \nVar11  Var13; \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var16=FUNC3(NULL ,Var15); \nif (Var16){\nFUNC4(Var3->memberVar1,Var5,Var16,0); \nfree(Var16); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\n*Var12=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nFUNC6(Var15); \nfree(Var5); \nelse \nFUNC7(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nfor (Var4=0; Var4<Var17; Var4  Var13){\nchar *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); \nchar *Var10=FUNC9(Var15,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nelse \nif (Var10){\n*Var10=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nif (*Var15 == ){\nFUNC10(Var15+1); \nelse \n}else if (Var10){\nchar *Var19=FUNC11(STRING,Var15,Var10+1); \nFUNC12(Var3,Var19); \nfree(Var19); \nelse \nFUNC12(Var3,Var15); \nelse \nFUNC7(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 12,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 505,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\n*Var11  Var13=0; \nsize_t  Var14=strlen(Var11); \nif (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){\nVar11[Var14-1]=0; \nVar11  Var13; \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var16=FUNC3(NULL ,Var15); \nif (Var16){\nFUNC4(Var3->memberVar1,Var5,Var16,0); \nfree(Var16); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\n*Var12=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nFUNC6(Var15); \nfree(Var5); \nelse \nFUNC7(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nfor (Var4=0; Var4<Var17; Var4  Var13){\nchar *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); \nchar *Var10=FUNC9(Var15,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nelse \nif (Var10){\n*Var10=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nif (*Var15 == ){\nFUNC10(Var15+1); \nelse \n}else if (Var10){\nchar *Var19=FUNC11(STRING,Var15,Var10+1); \nFUNC12(Var3,Var19); \nfree(Var19); \nelse \nFUNC12(Var3,Var15); \nelse \nFUNC7(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 13,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 510,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 14,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 511,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nelse \nif (Var10){\n*Var10=0; \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nif (*Var14 == ){\nelse \n}else if (Var10){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nFUNC10(Var3,Var19); \nfree(Var19); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 15,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 512,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\n*Var11  Var13=0; \nsize_t  Var14=strlen(Var11); \nif (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){\nVar11[Var14-1]=0; \nVar11  Var13; \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var16=FUNC3(NULL ,Var15); \nif (Var16){\nFUNC4(Var3->memberVar1,Var5,Var16,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var17=0; \nchar **Var18=FUNC7(Var3->memberVar1,&Var17); \nfor (Var4=0; Var4<Var17; Var4  Var13){\nchar *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); \nchar *Var10=FUNC8(Var15,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var17=0; \nchar **Var18=FUNC7(Var3->memberVar1,&Var17); \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nchar *Var19=FUNC9(STRING,Var15,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 16,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 513,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\n*Var12=0; \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 17,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 518,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\n*Var7  Var9=0; \nsize_t  Var10=strlen(Var7); \nif (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){\nVar7[Var10-1]=0; \nVar7  Var9; \nif (!Var6||(Var6&&Var6>Var7)){\nif (*Var7){\nif (!strcmp(Var7,STRING)){\nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nelse \nFUNC3(Var3->memberVar1,Var5,Var7,0); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var11,-1); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var14=FUNC6(STRING,Var11,Var6+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 18,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 526,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\n*Var7  Var9=0; \nsize_t  Var10=strlen(Var7); \nif (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){\nVar7[Var10-1]=0; \nVar7  Var9; \nif (!Var6||(Var6&&Var6>Var7)){\nif (*Var7){\nif (!strcmp(Var7,STRING)){\nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nelse \nFUNC3(Var3->memberVar1,Var5,Var7,0); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var11,-1); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var14=FUNC6(STRING,Var11,Var6+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 19,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 531,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\nsize_t  Var9=strlen(Var7); \nif (!Var6||(Var6&&Var6>Var7)){\nif (*Var7){\nif (!strcmp(Var7,STRING)){\nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var11=FUNC3(NULL ,Var10); \nif (Var11){\nFUNC4(Var3->memberVar1,Var5,Var11,0); \nfree(Var11); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nint  Var4,Var12=0; \nchar **Var13=FUNC5(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC6(Var10,-1); \nint  Var4,Var12=0; \nchar **Var13=FUNC5(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var14=FUNC7(STRING,Var10,Var6+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 20,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 546,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 21,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 563,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\t\tif (buf[2] == '*') {\n",
      "else\n",
      "\t\t\t\tr_cons_printf (\"%s=base64:%s\\n\", keys[i], q);\n",
      "\t\t\tfree (q);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\nsize_t  Var9=strlen(Var7); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var11=FUNC3(NULL ,Var10); \nelse \n}else if (Var8&&!Var6){\nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nfor (Var4=0; Var4<Var12; Var4  Var14){\nchar *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var10,-1); \nif (Var5[2]== *){\nelse \nFUNC6(STRING,Var13[Var4],Var6); \nfree(Var6); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC7(STRING,Var10,Var6+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 22,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 584,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\nsize_t  Var9=strlen(Var7); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var11=FUNC3(NULL ,Var10); \nelse \n}else if (Var8&&!Var6){\nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var10,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nif (Var10){\nif (*Var10 == ){\nelse \n}else if (Var6){\nchar *Var14=FUNC6(STRING,Var10,Var6+1); \nFUNC7(Var3,Var14); \nfree(Var14); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 23,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 592,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_rap",
    "Source": false,
    "Sink": false,
    "idx": 24,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 648,
    "label": -3,
    "slices": [
      "static int cmd_rap(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '=') {\n",
      "else\n",
      "\t\t\tchar *res = r_io_system (core->io, input + 1);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\tconst char *arg = r_str_trim_ro (input + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nif (Var2[1]== =){\nelse \nchar *Var4=FUNC2(Var3->memberVar1,Var2+1); \nif (Var4){\nFUNC3(STRING,Var4); \nfree(Var4); \nelse \nconst char *Var5=FUNC4(Var2+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 25,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 705,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n",
      "\t\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nchar *Var4=FUNC2(Var3->memberVar1,Var2); \nif (Var4){\nint  Var5=FUNC3(Var4); \nfree(Var4); \nreturn  Var5; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 26,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 706,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nchar *Var4=FUNC2(Var3->memberVar1,Var2); \nif (Var4){\nint  Var5=FUNC3(Var4); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 27,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 738,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tcore->num->value = r_buf_size (core->yank_buf);\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_paste (core, n, 0);\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n",
      "\t\tr_core_cmd_help (core, help_msg_y);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1  Var3; \nSTRUCT2 *Var4=(STRUCT2 *) Var1; \nswitch (Var2[0]){\nFUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nVar4->memberVar2->memberVar1=FUNC4(Var4->memberVar3); \nwhile (Var2[1]== ){\nVar2  Var5; \nVar3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; \nFUNC5(Var4,Var3,0); \nFUNC6(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC7(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nswitch (Var2[1]){\nFUNC8(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); \nif (Var2[2]== ){\nchar *Var6=strdup(Var2+3); \nint  Var7=FUNC9(Var2+3,(STRUCT3 *) Var6); \nif (Var7>0){\nFUNC8(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); \nFUNC10(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC11(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nif (Var2[1]==  Var8){//STRING\nconst char *Var9=FUNC12(Var2+2); \nconst STRUCT3 *Var10=FUNC13(Var4->memberVar3,&Var11); \nelse \n}else if (Var2[1]== ){\nFUNC14(Var4,Var2+1); \nswitch (Var2[1]){\nFUNC15(Var4,Var2+1); \nFUNC16(Var4,Var2+2); \nFUNC17(Var4,Var2+2); \nchar *Var12=FUNC18(Var4,STRING); \nchar *Var1=FUNC19(Var4,NULL ,Var12); \nFUNC20(Var4,STRING,Var1); \nFUNC21(Var4,0,Var2[0]); \nFUNC22(Var4,Var13); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 28,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 742,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1  Var3; \nSTRUCT2 *Var4=(STRUCT2 *) Var1; \nswitch (Var2[0]){\nFUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nwhile (Var2[1]== ){\nVar2  Var5; \nVar3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; \nFUNC4(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC5(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nswitch (Var2[1]){\nFUNC6(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); \nif (Var2[2]== ){\nchar *Var6=strdup(Var2+3); \nint  Var7=FUNC7(Var2+3,(STRUCT3 *) Var6); \nif (Var7>0){\nFUNC6(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); \nfree(Var6); \nFUNC8(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC9(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nif (Var2[1]==  Var8){//STRING\nconst char *Var9=FUNC10(Var2+2); \nconst STRUCT3 *Var10=FUNC11(Var4->memberVar3,&Var11); \nelse \n}else if (Var2[1]== ){\nFUNC12(Var4,Var2+1); \nswitch (Var2[1]){\nFUNC13(Var4,Var2+1); \nFUNC14(Var4,Var2+2); \nFUNC15(Var4,Var2+2); \nchar *Var12=FUNC16(Var4,STRING); \nchar *Var1=FUNC17(Var4,NULL ,Var12); \nFUNC18(Var4,0,Var2[0]); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 29,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 749,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nif (Var2[2]== ){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nif (Var5>0){\nFUNC3(Var3,Var3->memberVar1,(const STRUCT2 *) Var4,Var5); \nfree(Var4); \nconst char *Var6=FUNC4(Var2+2); \nconst STRUCT2 *Var7=FUNC5(Var3->memberVar2,&Var8); \nchar *Var9=FUNC6(Var3,STRING); \nchar *Var1=FUNC7(Var3,NULL ,Var9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 30,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 803,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nfree(Var9); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 31,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 804,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (sig);\n",
      "\t\t\tfree (data);\n"
    ],
    "tokenized": "STRUCT1 *Var1=(STRUCT1 *) Var2; \nswitch (Var3[0]){\nchar *Var4=strdup(Var3+3); \nint  Var5=FUNC1(Var3+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC2(Var3+2); \nconst STRUCT2 *Var7=FUNC3(Var1->memberVar1,&Var8); \nchar *Var9=FUNC4(Var1,STRING); \nif (!Var9||!*Var9){\nVar9=strdup(STRING); \nchar *Var2=FUNC5(Var1,NULL ,Var9); \n(void ) strtok(Var2,STRING); \nFUNC6(Var1,STRING,Var2); \nfree(Var9); \nfree(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 32,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strtok",
    "line": 807,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nVar9=strdup(STRING); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \n(void ) strtok(Var1,STRING); \nFUNC7(Var3,STRING,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 33,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 809,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nfree(Var9); \nVar9=strdup(STRING); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 34,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 810,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nVar9=strdup(STRING); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \n(void ) strtok(Var1,STRING); \nFUNC7(Var3,STRING,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 35,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 839,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ],
    "tokenized": "int  Var1=FUNC1(Var2,Var3,0); \nif (Var1 != -1){\nchar  Var4[128]={0}; \nint  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); \nVar4[Var5]=0; \nif (!FUNC3(Var4,STRING,3)){\nchar *Var6=strchr(Var4,Var7); \nif (Var6){\n*Var6=0; \nVar6=strchr(Var4,); \nif (Var6){\n*Var6=0; \nreturn strdup(Var4+2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 36,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 843,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ],
    "tokenized": "int  Var1=FUNC1(Var2,Var3,0); \nif (Var1 != -1){\nchar  Var4[128]={0}; \nint  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); \nVar4[Var5]=0; \nif (!FUNC3(Var4,STRING,3)){\nchar *Var6=strchr(Var4,Var7); \nif (Var6){\n*Var6=0; \nVar6=strchr(Var4,); \nif (Var6){\n*Var6=0; \nreturn strdup(Var4+2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 37,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 847,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ],
    "tokenized": "int  Var1=FUNC1(Var2,Var3,0); \nif (Var1 != -1){\nchar  Var4[128]={0}; \nint  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); \nVar4[Var5]=0; \nif (!FUNC3(Var4,STRING,3)){\nchar *Var6=strchr(Var4,Var7); \nVar6=strchr(Var4,); \nreturn strdup(Var4+2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 38,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 861,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(STRING,Var3); \nFUNC3(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC4(Var2,NULL ,NULL ); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nchar *Var10=FUNC8(Var3); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC9(Var2,STRING,Var3); \nelse \n}else if (FUNC10(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); \nelse \nVar5=FUNC12(Var2->memberVar4,Var3); \nif (Var5){\nVar4=FUNC13(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC14(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC16(STRING,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC13(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC17(STRING); \nif (Var14){\nchar *Var13=FUNC16(STRING,Var14,Var3); \nchar *Var13=FUNC15(STRING); \nchar *Var13=FUNC15(STRING); \nelse \nchar *Var15=FUNC18(Var3); \nchar *memberVar4=FUNC19(Var2,Var3); \nif (memberVar4){\nchar *Var13=FUNC16(STRING,memberVar4,Var3); \nif (!Var4){\nVar4=FUNC20(Var2,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 39,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 866,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(STRING,Var3); \nFUNC3(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC4(Var2,NULL ,NULL ); \nif (Var7){\nVar4=FUNC5(Var2,Var7); \nelse \n}else if (FUNC6(Var3,STRING)){\nconst bool  Var8=FUNC7(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC8(Var2->memberVar2,STRING)); \nFUNC9(Var2->memberVar2,STRING,0); \nchar *Var10=FUNC10(Var3); \nFUNC11(Var2->memberVar2,STRING,Var10); \nFUNC12(Var2,STRING); \nFUNC9(Var2->memberVar2,STRING,Var8); \nFUNC11(Var2->memberVar2,STRING,Var9); \nelse \n}else if (FUNC6(Var3,STRING)){\nFUNC13(Var2,STRING,Var3); \nelse \n}else if (FUNC14(Var3)){\nconst char *Var11=FUNC8(Var2->memberVar2,STRING); \nchar *Var7=FUNC15(Var2->memberVar3,Var3,Var11,NULL ); \nif (Var7){\nFUNC16(Var2->memberVar3->memberVar1,Var7); \nelse \nVar5=FUNC17(Var2->memberVar4,Var3); \nif (Var5){\nFUNC18(Var2->memberVar4,Var5->memberVar1); \nVar4=FUNC19(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC20(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC22(STRING,Var3); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC23(STRING); \nif (Var14){\nFUNC18(Var2->memberVar4,STRING); \nchar *Var13=FUNC22(STRING,Var14,Var3); \nif (Var13){\nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \nchar *Var15=FUNC24(Var3); \nchar *memberVar4=FUNC25(Var2,Var3); \nif (memberVar4){\nFUNC18(Var2->memberVar4,STRING); \nchar *Var13=FUNC22(STRING,memberVar4,Var3); \nFUNC19(Var2,Var2->memberVar4,Var13); \nif (!Var4){\nVar4=FUNC26(Var2,Var3); \nfree(FUNC27(Var2->memberVar1)); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 40,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 868,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(STRING,Var3); \nFUNC3(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC4(Var2,NULL ,NULL ); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nchar *Var10=FUNC8(Var3); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC9(Var2,STRING,Var3); \nelse \n}else if (FUNC10(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); \nelse \nVar5=FUNC12(Var2->memberVar4,Var3); \nif (Var5){\nVar4=FUNC13(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC14(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC16(STRING,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC13(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC17(STRING); \nif (Var14){\nchar *Var13=FUNC16(STRING,Var14,Var3); \nchar *Var13=FUNC15(STRING); \nchar *Var13=FUNC15(STRING); \nelse \nchar *Var15=FUNC18(Var3); \nchar *memberVar4=FUNC19(Var2,Var3); \nif (memberVar4){\nchar *Var13=FUNC16(STRING,memberVar4,Var3); \nif (!Var4){\nVar4=FUNC20(Var2,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 41,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 872,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nif (Var6){\nVar4=FUNC3(Var2,Var6); \nfree(Var6); \nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC7(Var2->memberVar2,Var3,Var10,NULL ); \nconst char *Var11=FUNC8(Var3,.); \nchar *Var12=FUNC9(STRING,Var3); \nchar *Var12=FUNC9(STRING,Var13,Var3); \nelse \nchar *Var14=FUNC10(Var3); \nchar *Var15=FUNC11(Var2,Var3); \nchar *Var12=FUNC9(STRING,Var15,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 42,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 876,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC3(Var2,NULL ,NULL ); \nif (Var7){\nVar4=FUNC4(Var2,Var7); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nFUNC8(Var2->memberVar2,STRING,0); \nchar *Var10=FUNC9(Var3); \nFUNC10(Var2->memberVar2,STRING,Var10); \nFUNC11(Var2,STRING); \nFUNC8(Var2->memberVar2,STRING,Var8); \nFUNC10(Var2->memberVar2,STRING,Var9); \nfree(Var9); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC12(Var2,STRING,Var3); \nelse \n}else if (FUNC13(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); \nif (Var7){\nFUNC15(Var2->memberVar3->memberVar1,Var7); \nelse \nVar5=FUNC16(Var2->memberVar4,Var3); \nif (Var5){\nFUNC17(Var2->memberVar4,Var5->memberVar1); \nVar4=FUNC18(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC19(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING,Var3); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC22(STRING); \nif (Var14){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,Var14,Var3); \nif (Var13){\nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \nchar *Var15=FUNC23(Var3); \nchar *memberVar4=FUNC24(Var2,Var3); \nif (memberVar4){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,memberVar4,Var3); \nFUNC18(Var2,Var2->memberVar4,Var13); \nif (!Var4){\nVar4=FUNC25(Var2,Var3); \nfree(FUNC26(Var2->memberVar1)); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 43,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 880,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tfree (absfile);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4; \nif (!strcmp(Var3,Var4)){\nif (!strcmp(Var3,STRING)){\nchar *Var5=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var6=FUNC4(Var2->memberVar1,STRING); \nchar *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var8=FUNC6(Var3); \nFUNC7(Var2->memberVar1,STRING,Var8); \nfree(Var8); \nconst char *Var9=FUNC5(Var2->memberVar1,STRING); \nchar *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); \nconst char *Var10=FUNC9(Var3,.); \nchar *Var11=FUNC10(STRING,Var3); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \nchar *Var13=FUNC11(Var3); \nchar *Var14=FUNC12(Var2,Var3); \nchar *Var11=FUNC10(STRING,Var14,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 44,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 884,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4; \nif (!strcmp(Var3,Var4)){\nif (!strcmp(Var3,STRING)){\nchar *Var5=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var6=FUNC4(Var2->memberVar1,STRING); \nchar *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var8=FUNC6(Var3); \nFUNC7(Var2->memberVar1,STRING,Var7); \nfree(Var7); \nconst char *Var9=FUNC5(Var2->memberVar1,STRING); \nchar *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); \nconst char *Var10=FUNC9(Var3,.); \nchar *Var11=FUNC10(STRING,Var3); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \nchar *Var13=FUNC11(Var3); \nchar *Var14=FUNC12(Var2,Var3); \nchar *Var11=FUNC10(STRING,Var14,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 45,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 895,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_strcat (out);\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tret = out? true: false;\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var6){\nFUNC9(Var6); \nFUNC10(Var2->memberVar2->memberVar1,Var6); \nfree(Var6); \nVar4=Var6 true false ; \nconst char *Var11=FUNC11(Var3,.); \nchar *Var12=FUNC12(STRING,Var3); \nchar *Var12=FUNC12(STRING,Var13,Var3); \nelse \nchar *Var14=FUNC13(Var3); \nchar *Var15=FUNC14(Var2,Var3); \nchar *Var12=FUNC12(STRING,Var15,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 46,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 914,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 47,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 918,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC10(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC11(STRING,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC11(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC11(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 48,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 920,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 49,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 928,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nif (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC11(STRING,Var3); \nFUNC12(Var2,Var2->memberVar3,Var12); \nfree(Var12); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var13,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC13(Var3); \nchar *memberVar3=FUNC14(Var2,Var3); \nchar *Var12=FUNC11(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 50,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 930,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 51,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 934,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 52,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 936,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 53,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 940,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 54,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 942,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 55,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 946,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 56,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 948,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 57,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 952,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 58,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 954,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 59,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 958,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 60,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 960,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 61,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 964,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 62,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 966,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 63,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 970,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 64,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 973,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var12=FUNC11(STRING); \nif (!Var12){\nVar12=strdup(STRING); \nif (Var12){\nchar *Var11=FUNC10(STRING,Var12,Var3); \nif (Var11){\nFUNC12(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nfree(Var12); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC13(Var3); \nchar *memberVar3=FUNC14(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 65,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 980,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nif (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC11(STRING,Var3); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var13=FUNC12(STRING); \nif (!Var13){\nVar13=strdup(STRING); \nif (Var13){\nchar *Var12=FUNC11(STRING,Var13,Var3); \nif (Var12){\nFUNC13(Var2,Var2->memberVar3,Var12); \nfree(Var12); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC14(Var3); \nchar *memberVar3=FUNC15(Var2,Var3); \nchar *Var12=FUNC11(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 66,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 982,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC1(Var3,STRING)){\nchar *Var4=strdup(FUNC2(Var5->memberVar1,STRING)); \nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC1(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var5->memberVar2,Var3,Var8,NULL ); \nif (Var1){\nconst char *Var1=FUNC6(Var3,.); \nif (Var1){\nconst char *Var9=Var1+1; \nif (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC8(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var11=FUNC9(STRING); \nif (!Var11){\nVar11=strdup(STRING); \nif (Var11){\nchar *Var10=FUNC8(STRING,Var11,Var3); \nfree(Var11); \nchar *Var10=FUNC7(STRING); \nchar *Var10=FUNC7(STRING); \nelse \nchar *Var12=FUNC10(Var3); \nchar *Var13=FUNC11(Var5,Var3); \nchar *Var10=FUNC8(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 67,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 985,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 68,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 989,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 69,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 991,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 70,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 995,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 71,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1005,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tfree (lang);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var13,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC12(Var3); \nchar *Var15=FUNC13(Var2,Var3); \nif (Var15){\nchar *Var12=FUNC11(STRING,Var15,Var3); \nfree(Var15); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 72,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1006,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var13,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC12(Var3); \nchar *Var15=FUNC13(Var2,Var3); \nif (Var15){\nchar *Var12=FUNC11(STRING,Var15,Var3); \nFUNC14(Var2,Var2->memberVar3,Var12); \nfree(Var12); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 73,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1009,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\tfree (abspath);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nchar *Var10=FUNC7(STRING,Var3); \nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \nfree(Var12); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 74,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1016,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC3(Var2,NULL ,NULL ); \nif (Var7){\nVar4=FUNC4(Var2,Var7); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nFUNC8(Var2->memberVar2,STRING,0); \nchar *Var10=FUNC9(Var3); \nFUNC10(Var2->memberVar2,STRING,Var10); \nFUNC11(Var2,STRING); \nFUNC8(Var2->memberVar2,STRING,Var8); \nFUNC10(Var2->memberVar2,STRING,Var9); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC12(Var2,STRING,Var3); \nelse \n}else if (FUNC13(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); \nif (Var7){\nFUNC15(Var2->memberVar3->memberVar1,Var7); \nelse \nVar5=FUNC16(Var2->memberVar4,Var3); \nif (Var5){\nFUNC17(Var2->memberVar4,Var5->memberVar1); \nVar4=FUNC18(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC19(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING,Var3); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC22(STRING); \nif (Var14){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,Var14,Var3); \nif (Var13){\nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \nchar *Var15=FUNC23(Var3); \nchar *memberVar4=FUNC24(Var2,Var3); \nif (memberVar4){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,memberVar4,Var3); \nFUNC18(Var2,Var2->memberVar4,Var13); \nif (!Var4){\nVar4=FUNC25(Var2,Var3); \nfree(FUNC26(Var2->memberVar1)); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 75,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1022,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (arg) {\n",
      "\t\t\tr_core_cmdf (core, \"cat %s~..\", arg);\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (Var4){\nFUNC3(Var3,STRING,Var4); \nif (FUNC4(Var3->memberVar1,Var4)){\nFUNC3(Var3,STRING,Var4); \nelse \nchar *Var5=FUNC5(Var4); \nif (Var5){\nFUNC6(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 76,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1047,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (!Var4){\nVar4=STRING; \nif (FUNC3(Var3->memberVar1,Var4)){\nelse \nchar *Var5=FUNC4(Var4); \nif (Var5){\nFUNC5(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 77,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1057,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\n*Var6=0; \nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \nFUNC6(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 78,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1058,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\n*Var6=0; \nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \nFUNC6(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 79,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1063,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\n*Var6=0; \nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 80,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1087,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg1) {\n",
      "\t\t\targ1 = \"\";\n",
      "\t\tif (!arg2) {\n",
      "\t\t\targ2 = \"\";\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!Var5){\nVar5=STRING; \nif (!Var7){\nVar7=STRING; \nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 81,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1118,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\t*ptr = 0;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar11=Var4+1; \n*Var4=0; \nVar5=strchr(Var2+1,); \nif (Var5){\nVar9=Var2+1; \nVar10=Var2+((Var2[1]== ) 21); \nVar6=FUNC2(Var12,Var9,Var10,Var11); \nif (Var6){\nFUNC3(Var6); \nfree(Var6); \nelse \nFUNC4(Var12,Var2+1); \nif (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC5(Var12,FUNC6(Var2)); \nconst char *Var17=FUNC6(Var2+1); \nchar *Var18=strdup(Var17); \nchar *Var19=strchr(Var18,); \nconst char *Var20=FUNC6(Var2+1); \nFUNC7(Var12,Var2+1); \nFUNC8(&Var12->memberVar1->memberVar1,Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nchar *Var21=FUNC9(strdup(Var4),Var7); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 82,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1123,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\t*eol = 0;\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar5=strchr(Var2+1,); \nif (Var5){\n*Var5=0; \nVar9=Var2+1; \nVar10=Var5+1; \nVar10=Var2+((Var2[1]== ) 21); \nVar6=FUNC2(Var12,Var9,Var10,Var11); \nif (Var6){\nFUNC3(Var6); \nfree(Var6); \nelse \nFUNC4(Var12,Var2+1); \nif (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC5(Var12,FUNC6(Var2)); \nconst char *Var17=FUNC6(Var2+1); \nchar *Var18=strdup(Var17); \nchar *Var19=strchr(Var18,); \nconst char *Var20=FUNC6(Var2+1); \nFUNC7(Var12,Var2+1); \nFUNC8(&Var12->memberVar1->memberVar1,Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nchar *Var21=FUNC9(strdup(Var4),Var7); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 83,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1135,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "else\n",
      "\t\t\t\thost = \"localhost\";\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar11=Var4+1; \nVar5=strchr(Var2+1,); \nif (Var5){\nVar9=Var2+1; \nVar10=Var5+1; \nelse \nVar9=STRING; \nVar10=Var2+((Var2[1]== ) 21); \nVar6=FUNC2(Var12,Var9,Var10,Var11); \nif (Var6){\nFUNC3(Var6); \nfree(Var6); \nchar *Var3=FUNC4(Var12,FUNC5(Var2)); \nconst char *Var13=FUNC5(Var2+1); \nchar *Var14=strchr(Var15,); \nconst char *Var16=FUNC5(Var2+1); \nchar *Var17=FUNC6(strdup(Var4),Var7); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 84,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1149,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\tr_core_cmd (core, str, 0);\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nif (Var2[1]== .){//STRING Var10  Var11  Var12  STRUCT2  Var13\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nif (Var3){\nFUNC4(Var9,Var3,0); \nfree(Var3); \nconst char *Var14=FUNC3(Var2+1); \nconst char *Var15=FUNC3(Var2+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 85,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1158,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var4=FUNC2(Var3,FUNC3(Var2)); \nconst char *Var5=FUNC3(Var2+1); \nchar *Var6=strdup(Var5); \nchar *Var7=strchr(Var6,); \nif (Var7){\n*Var7=0; \nif (FUNC4(Var6)){\nFUNC5(Var3,Var6); \nfree(Var6); \nconst char *Var8=FUNC3(Var2+1); \nchar *Var9=FUNC6(strdup(Var10),Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 86,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1159,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var4=FUNC2(Var3,FUNC3(Var2)); \nconst char *Var5=FUNC3(Var2+1); \nchar *Var6=strdup(Var5); \nchar *Var7=strchr(Var6,); \nif (Var7){\n*Var7=0; \nif (FUNC4(Var6)){\nFUNC5(Var3,Var6); \nfree(Var6); \nconst char *Var8=FUNC3(Var2+1); \nchar *Var9=FUNC6(strdup(Var10),Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 87,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1166,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var4=FUNC2(Var3,FUNC3(Var2)); \nconst char *Var5=FUNC3(Var2+1); \nchar *Var6=strdup(Var5); \nchar *Var7=strchr(Var6,); \nif (FUNC4(Var6)){\nFUNC5(Var3,Var6); \nfree(Var6); \nconst char *Var8=FUNC3(Var2+1); \nchar *Var9=FUNC6(strdup(Var10),Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 88,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1206,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n",
      "\t\tfree (str);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar5=strchr(Var2+1,); \nif (Var5){\nVar9=Var2+1; \nVar10=Var2+((Var2[1]== ) 21); \nelse \nFUNC2(Var12,Var2+1); \nif (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC3(Var12,FUNC4(Var2)); \nconst char *Var17=FUNC4(Var2+1); \nchar *Var18=strdup(Var17); \nchar *Var19=strchr(Var18,); \nconst char *Var20=FUNC4(Var2+1); \nFUNC5(Var12,Var2+1); \nFUNC6(&Var12->memberVar1->memberVar1,Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nif (Var7){\n*Var7=0; \nVar4=Var3=FUNC7(Var12,Var8); \nif (Var7){\n*Var7=; \nif (Var4){\nif (FUNC8()){\nVar5=strchr(Var4,Var21); \nif (Var5){\n*Var5=0; \nif (*Var4){\nchar *Var22=FUNC9(strdup(Var4),Var7); \nFUNC10(Var12,Var22); \nfree(Var22); \nif (!Var5){\nVar4=Var5+1; \nfree(Var3); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 89,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1207,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nif (Var7){\n*Var7=0; \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var7){\n*Var7=; \nif (Var4){\nif (FUNC5()){\nif (*Var4){\nchar *Var14=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var14); \nfree(Var14); \nif (!Var5){\nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 90,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1225,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var4){\nif (FUNC5()){\nVar5=strchr(Var4,Var14); \nif (Var5){\n*Var5=0; \nif (*Var4){\nchar *Var15=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var15); \nfree(Var15); \nif (!Var5){\nVar4=Var5+1; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 91,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1230,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nif (Var7){\n*Var7=0; \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var7){\n*Var7=; \nif (Var4){\nif (FUNC5()){\nVar5=strchr(Var4,Var14); \nif (*Var4){\nchar *Var15=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var15); \nfree(Var15); \nif (!Var5){\nVar4=Var5+1; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 92,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1232,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var4){\nif (FUNC5()){\nVar5=strchr(Var4,Var14); \nif (*Var4){\nchar *Var15=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var15); \nfree(Var15); \nif (!Var5){\nVar4=Var5+1; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 93,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1241,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (str);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nconst char *Var12=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar4=Var3=FUNC4(Var9,Var8); \nchar *Var13=FUNC5(strdup(Var4),Var7); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 94,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1242,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nVar4=Var3=FUNC4(Var9,Var8); \nchar *Var14=FUNC5(strdup(Var4),Var7); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 95,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1258,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 96,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1259,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 97,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1268,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 98,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1269,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 99,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1295,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tr_cons_printf (\"\\n\\n\\\"%s\\\" : [\", cur_cmd);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nFUNC4(STRING%Var6 STRING,Var8); \nVar9=FUNC5(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nwhile (*Var12){\nVar10=strchr(Var12,Var13); \nif (!Var10){\nVar11=FUNC3(Var12,Var10-Var12); \nFUNC4(STRING%Var6 STRING,Var11); \nVar12  STRUCT3  Var10-Var12+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var9); \nfree(Var12); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC6(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 100,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1314,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nVar9=FUNC4(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nwhile (*Var12){\nVar10=strchr(Var12,Var13); \nif (!Var10){\nVar11=FUNC3(Var12,Var10-Var12); \nFUNC5(STRING%Var6 STRING,Var11); \nVar12  STRUCT3  Var10-Var12+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var12); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC6(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 101,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1329,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nVar9=FUNC4(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var9); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC5(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 102,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1330,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nVar9=FUNC4(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nwhile (*Var12){\nVar10=strchr(Var12,Var13); \nif (!Var10){\nVar11=FUNC3(Var12,Var10-Var12); \nVar12  STRUCT3  Var10-Var12+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var12); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC5(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 103,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1338,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\tfree (out);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,Var2+1); \nif (Var4){\nFUNC3(Var4); \nfree(Var4); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT3 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nSTRUCT2 *Var18=FUNC4(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nSTRUCT2 *Var19=FUNC5(Var5->memberVar1,Var20,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 104,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1354,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nconst int  Var8=sizeof (Var3)-1; \nSTRUCT2 *Var9=Var5->memberVar1; \nchar *Var10,*Var11,*Var12=NULL ; \nchar *Var13,*Var14,*Var15=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var9,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var16,*Var17,*Var7=strdup(Var2+2); \nfor (Var16=Var17=Var7; Var16; Var17=Var16){\nVar16=strchr(Var17,/); //STRUCT3  Var18\nif (Var16){\n*Var16  Var19=0; \nVar9=FUNC4(Var9,Var17,1); \nfree(Var7); \nSTRUCT4 *Var20=Var5->memberVar3->memberVar1; \nFUNC5(Var7); \nif (FUNC6(Var3,Var8,0,NULL )<1){\nif (!*Var3){\nVar4=FUNC2(Var9,NULL ,0,Var3); \nif (Var4){\nFUNC7(Var4); \nif (FUNC8(0)){\nif (Var2[1]== ){\nchar *Var21=strdup(Var2+2); \nif (!Var21){\nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var23=FUNC9(NULL ,Var21,0); \nif (FUNC8(0)){\nif (Var2[1]== ){\nchar *Var21=strdup(Var2+2); \nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var24=FUNC10(Var5->memberVar1,Var22,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var25=strdup(Var2); \nVar25[(size_t )(Var6-Var2)]=0; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 105,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1357,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nconst int  Var8=sizeof (Var3)-1; \nSTRUCT2 *Var9=Var5->memberVar1; \nchar *Var10,*Var11,*Var12=NULL ; \nchar *Var13,*Var14,*Var15=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nif (Var2[1]== ){\nchar *Var16,*Var17,*Var7=strdup(Var2+2); \nfor (Var16=Var17=Var7; Var16; Var17=Var16){\nVar16=strchr(Var17,/); //STRUCT3  Var18\nif (Var16){\n*Var16  Var19=0; \nVar9=FUNC3(Var9,Var17,1); \nSTRUCT4 *Var20=Var5->memberVar3->memberVar1; \nif (FUNC4(Var3,Var8,0,NULL )<1){\nif (!*Var3){\nVar4=FUNC5(Var9,NULL ,0,Var3); \nif (Var4){\nFUNC6(Var4); \nchar *Var21=strdup(Var2+2); \nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var23=FUNC7(NULL ,Var21,0); \nchar *Var21=strdup(Var2+2); \nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var24=FUNC8(Var5->memberVar1,Var22,0); \nchar *Var25=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 106,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1363,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nconst int  Var8=sizeof (Var3)-1; \nSTRUCT2 *Var9=Var5->memberVar1; \nchar *Var10,*Var11,*Var12=NULL ; \nchar *Var13,*Var14,*Var15=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nif (Var2[1]== ){\nchar *Var16,*Var17,*Var7=strdup(Var2+2); \nfor (Var16=Var17=Var7; Var16; Var17=Var16){\nfree(Var7); \nSTRUCT3 *Var18=Var5->memberVar3->memberVar1; \nFUNC3(Var7); \nif (FUNC4(Var3,Var8,0,NULL )<1){\nif (!*Var3){\nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var20=FUNC5(NULL ,Var19,0); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var21=FUNC6(Var5->memberVar1,Var22,0); \nchar *Var23=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 107,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1384,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst int  Var6=sizeof (Var3)-1; \nSTRUCT2 *Var7=Var5->memberVar1; \nchar *Var8,*Var9,*Var10=NULL ; \nchar *Var11,*Var12,*Var13=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nchar *Var14,*Var15,*Var16=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (!memberVar1->memberVar1){\nmemberVar1->memberVar1=FUNC3(free); \nSTRUCT4 *Var18=memberVar1->memberVar1; \nif (FUNC4(Var3,Var6,0,NULL )<1){\nif (!*Var3){\nif (Var18){\nif ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){\nFUNC7(Var18,1,strdup(Var3)); \nmemberVar1->memberVar2=Var18->memberVar1; \nVar4=FUNC8(Var7,NULL ,0,Var3); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var20=FUNC9(NULL ,Var19,0); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); \nchar *Var23=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 108,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1385,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst int  Var6=sizeof (Var3)-1; \nSTRUCT2 *Var7=Var5->memberVar1; \nchar *Var8,*Var9,*Var10=NULL ; \nchar *Var11,*Var12,*Var13=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nchar *Var14,*Var15,*Var16=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (!memberVar1->memberVar1){\nmemberVar1->memberVar1=FUNC3(free); \nSTRUCT4 *Var18=memberVar1->memberVar1; \nif (FUNC4(Var3,Var6,0,NULL )<1){\nif (!*Var3){\nif (Var18){\nif ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){\nFUNC7(Var18,1,strdup(Var3)); \nmemberVar1->memberVar2=Var18->memberVar1; \nVar4=FUNC8(Var7,NULL ,0,Var3); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var20=FUNC9(NULL ,Var19,0); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); \nchar *Var23=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 109,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1403,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nif (Var19){\nSTRUCT2 *Var20; \n*Var19  Var21=0; \nif (FUNC5(Var18)){\nVar20=FUNC6(Var5->memberVar1,Var19,1); \nif (Var20){\nSTRUCT2 *Var22=FUNC7(NULL ,Var18,0); \nif (Var22){\nFUNC8(Var20,Var22); \nelse \nFUNC9(STRING,Var18); \nelse \nFUNC9(STRING,Var19); \nfree(Var18); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nif (Var19){\nSTRUCT2 *Var20=FUNC6(Var5->memberVar1,Var19,0); \nif (Var20){\nFUNC10(Var20,Var18); \nfree(Var18); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var23=strdup(Var2); \nVar23[(size_t )(Var6-Var2)]=0; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 110,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1408,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2 *Var4=Var3->memberVar1; \nchar *Var5,*Var6,*Var7=NULL ; \nchar *Var8,*Var9,*Var10=NULL ; \nswitch (Var2[0]){\nchar *Var11,*Var12,*Var13=strdup(Var2+2); \nSTRUCT3 *Var14=Var3->memberVar2->memberVar1; \nif (FUNC2(0)){\nif (Var2[1]== ){\nchar *Var15=strdup(Var2+2); \nif (!Var15){\nchar *Var16=strchr(Var15,); \nif (Var16){\nSTRUCT2 *Var17; \n*Var16  Var18=0; \nif (FUNC3(Var15)){\nVar17=FUNC4(Var3->memberVar1,Var16,1); \nif (Var17){\nSTRUCT2 *Var19=FUNC5(NULL ,Var15,0); \nif (Var19){\nFUNC6(Var17,Var19); \nelse \nFUNC7(STRING,Var15); \nelse \nFUNC7(STRING,Var16); \nfree(Var15); \nchar *Var15=strdup(Var2+2); \nchar *Var16=strchr(Var15,); \nSTRUCT2 *Var17=FUNC4(Var3->memberVar1,Var16,0); \nchar *Var20=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 111,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1430,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5=NULL ; \nchar *Var6,*Var7,*Var8=NULL ; \nswitch (Var2[0]){\nchar *Var9,*Var10,*Var11=strdup(Var2+2); \nif (FUNC2(0)){\nif (Var2[1]== ){\nchar *Var12=strdup(Var2+2); \nif (!Var12){\nchar *Var13=strchr(Var12,); \nif (Var13){\nSTRUCT1 *Var14; \nif (FUNC3(Var12)){\nif (Var14){\nSTRUCT1 *Var15=FUNC4(NULL ,Var12,0); \nif (Var15){\nelse \nFUNC5(STRING,Var12); \nfree(Var12); \nchar *Var12=strdup(Var2+2); \nchar *Var13=strchr(Var12,); \nSTRUCT1 *Var14=FUNC6(Var16->memberVar1,Var13,0); \nchar *Var17=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 112,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1441,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nif (Var19){\nSTRUCT2 *Var20; \nif (FUNC5(Var18)){\nif (Var20){\nSTRUCT2 *Var21=FUNC6(NULL ,Var18,0); \nif (Var21){\nelse \nFUNC7(STRING,Var18); \nfree(Var18); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nif (Var19){\n*Var19  Var22=0; \nSTRUCT2 *Var20=FUNC8(Var5->memberVar1,Var19,0); \nif (Var20){\nFUNC9(Var20,Var18); \nFUNC10(Var20); \nelse \nFUNC7(STRING,Var19); \nfree(Var18); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var23=strdup(Var2); \nVar23[(size_t )(Var6-Var2)]=0; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 113,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1442,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2 *Var4=Var3->memberVar1; \nswitch (Var2[0]){\nchar *Var5,*Var6,*Var7=strdup(Var2+2); \nSTRUCT3 *Var8=Var3->memberVar2->memberVar1; \nchar *Var9=strdup(Var2+2); \nchar *Var10=strchr(Var9,); \nSTRUCT2 *Var11; \nSTRUCT2 *Var12=FUNC2(NULL ,Var9,0); \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var9=strdup(Var2+2); \nchar *Var10=strchr(Var9,); \nif (Var10){\n*Var10  Var13=0; \nSTRUCT2 *Var11=FUNC4(Var3->memberVar1,Var10,0); \nif (Var11){\nFUNC5(Var11,Var9); \nFUNC6(Var11); \nelse \nFUNC7(STRING,Var10); \nfree(Var9); \nchar *Var14=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 114,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1455,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nswitch (Var2[0]){\nchar *Var3,*Var4,*Var5=strdup(Var2+2); \nchar *Var6=strdup(Var2+2); \nchar *Var7=strchr(Var6,); \nSTRUCT1 *Var8; \nSTRUCT1 *Var9=FUNC2(NULL ,Var6,0); \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var6=strdup(Var2+2); \nchar *Var7=strchr(Var6,); \nif (Var7){\nSTRUCT1 *Var8=FUNC4(Var10->memberVar1,Var7,0); \nif (Var8){\nFUNC5(Var8,Var6); \nfree(Var6); \nchar *Var11=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 115,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1470,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var20=FUNC5(NULL ,Var18,0); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var22=strdup(Var2); \nVar22[(size_t )(Var6-Var2)]=0; \nVar4=FUNC2(Var8,NULL ,0,Var6+1); \nif (Var4){\nFUNC7(Var4); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 116,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1472,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var20=FUNC5(NULL ,Var18,0); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var22=strdup(Var2); \nVar22[(size_t )(Var6-Var2)]=0; \nVar8=FUNC7(Var5->memberVar1,Var22+1,1); \nVar4=FUNC2(Var8,NULL ,0,Var6+1); \nif (Var4){\nFUNC8(Var4); \nfree(Var4); \nfree(Var22); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 117,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1478,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var20=FUNC4(NULL ,Var18,0); \nif (FUNC3(0)){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var21=FUNC5(Var5->memberVar1,Var19,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var22=strdup(Var2); \nVar8=FUNC6(Var5->memberVar1,Var22+1,1); \nVar4=FUNC7(Var8,NULL ,0,Var6+1); \nif (Var4){\nFUNC8(Var4); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 118,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1480,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4,*Var5=STRING; \nSTRUCT2 *Var6=Var3->memberVar1; \nswitch (Var2[0]){\nif (Var3->memberVar2){\nif (!FUNC2()){\nchar *Var7,*Var8,*Var5=strdup(Var2+2); \nSTRUCT3 *Var9=Var3->memberVar3->memberVar1; \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var10=strdup(Var2+2); \nif (!Var10){\nchar *Var11=strchr(Var10,); \nSTRUCT2 *Var12=FUNC4(NULL ,Var10,0); \nif (FUNC3(0)){\nchar *Var10=strdup(Var2+2); \nchar *Var11=strchr(Var10,); \nSTRUCT2 *Var13=FUNC5(Var3->memberVar1,Var11,0); \nif (Var2[0]== 0){\nif (Var4){\nchar *Var14=strdup(Var2); \nVar14[(size_t )(Var4-Var2)]=0; \nVar6=FUNC6(Var3->memberVar1,Var14+1,1); \nfree(Var14); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 119,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1544,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tint argc = 0;\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (args);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1  Var1,const char *Var2){\nchar *Var3=FUNC2(Var2); \nint  Var4=0; \nchar **Var5=FUNC3(Var3,&Var4); \nint  Var6=Var1(Var4,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 120,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1545,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (a);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1  Var1,const char *Var2){\nchar *Var3=FUNC2(Var2); \nchar **Var4=FUNC3(Var3,&Var5); \nint  Var6=Var1(Var5,Var4); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 121,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1578,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=FUNC2(STRING,Var2); \nint  Var4=0; \nif (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nVar4=FUNC5(Var1->memberVar1,Var3); \nelse \nconst char *Var5[]={\nint  Var6; \nfor (Var6=0; Var5[Var6]; Var6  Var7){\nif (FUNC3(Var3,Var5[Var6])){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 122,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1584,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=FUNC2(STRING,Var2); \nint  Var4=0; \nif (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nVar4=FUNC5(Var1->memberVar1,Var3); \nelse \nconst char *Var5[]={\nint  Var6; \nfor (Var6=0; Var5[Var6]; Var6  Var7){\nif (FUNC3(Var3,Var5[Var6])){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 123,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ],
    "tokenized": "STRUCT1 *Var1=(STRUCT1 *) Var2; \nif (FUNC1(Var1,Var3)){\nSTRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; \nswitch (*Var3){\nconst char *memberVar1=FUNC3(Var3+2); \nwrite(1,Var5,strlen(Var5)); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 124,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ],
    "tokenized": "STRUCT1 *Var1=(STRUCT1 *) Var2; \nif (FUNC1(Var1,Var3)){\nSTRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; \nswitch (*Var3){\nconst char *memberVar1=FUNC3(Var3+2); \nwrite(1,Var5,strlen(Var5)); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 125,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1727,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4=FUNC2(Var3); \nFUNC3(Var3,Var4); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 126,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1730,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4=FUNC2(Var3); \nFUNC3(Var3,Var4); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 127,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1823,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "else\n",
      "\t\tret = r_core_cmdf (core, \"?v [%s]\", input);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=true ; \nchar *Var5,*Var6; \nVar2=FUNC2(Var2); \nwhile (*Var2 == ){\nVar2  Var7; \nif (!*Var2||*Var2 == ){\nVar5=strdup(Var2); \nVar6=strchr(Var5,=); \nif (Var6){\n*Var6  Var7=0; \nif (!FUNC3(Var6,STRING,2)){\nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var2); \nfree(Var5); \nreturn  Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 128,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1824,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=true ; \nchar *Var5,*Var6; \nVar2=FUNC2(Var2); \nwhile (*Var2 == ){\nVar2  Var7; \nif (!*Var2||*Var2 == ){\nVar5=strdup(Var2); \nVar6=strchr(Var5,=); \nif (Var6){\n*Var6  Var7=0; \nif (!FUNC3(Var6,STRING,2)){\nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var6,Var5); \nfree(Var5); \nreturn  Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 129,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1835,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=true ; \nchar *Var5,*Var6; \nVar2=FUNC2(Var2); \nwhile (*Var2 == ){\nVar2  Var7; \nif (!*Var2||*Var2 == ){\nVar5=strdup(Var2); \nVar6=strchr(Var5,=); \nif (Var6){\nif (!FUNC3(Var6,STRING,2)){\nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var6,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_autocomplete",
    "Source": false,
    "Sink": false,
    "idx": 130,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 1950,
    "label": -3,
    "slices": [
      "static void cmd_autocomplete(RCore *core, const char *input) {\n",
      "\tRCoreAutocomplete* b = core->autocomplete;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\tchar arg[256];\n",
      "\tif (!*input) {\n",
      "\tif (*input == '?') {\n",
      "\tif (*input == '-') {\n",
      "\t\tconst char *arg = input + 1;\n",
      "\t\tif (!*input) {\n",
      "\t\tr_core_autocomplete_remove (b, arg);\n",
      "\twhile (b) {\n",
      "\t\tconst char* end = r_str_trim_wp (input);\n",
      "\t\tif (!end) {\n",
      "\t\tif ((end - input) >= sizeof (arg)) {\n",
      "\t\tif (end == input) {\n",
      "\t\tmemcpy (arg, input, end - input);\n",
      "\t\targ[end - input] = 0;\n",
      "\t\tRCoreAutocomplete* a = r_core_autocomplete_find (b, arg, true);\n",
      "\t\tinput = r_str_trim_ro (end);\n",
      "\t\tif (input && *input && !a) {\n",
      "\t\t\tif (b->type == R_CORE_AUTOCMPLT_DFLT && !(b = r_core_autocomplete_add (b, arg, R_CORE_AUTOCMPLT_DFLT, false))) {\n",
      "else\n",
      "\t\t\t} else if (b->type != R_CORE_AUTOCMPLT_DFLT) {\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && !a) {\n",
      "\t\t\tif (arg[0] == '$') {\n",
      "\t\t\t\tint type = autocomplete_type (arg);\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && a) {\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2){\nSTRUCT2 *Var3=Var1->memberVar1; \nVar2=FUNC2(Var2); \nchar  Var4[256]; \nif (!*Var2){\nif (*Var2 == ){\nif (*Var2 == -){\nconst char *Var4=Var2+1; \nif (!*Var2){\nFUNC3(Var3,Var4); \nwhile (Var3){\nconst char *Var5=FUNC4(Var2); \nif (!Var5){\nif ((Var5-Var2) >= sizeof (Var4)){\nif (Var5 ==  Var2){\nmemcpy(Var4,Var2,Var5-Var2); \nVar4[Var5-Var2]=0; \nSTRUCT2 *Var6=FUNC5(Var3,Var4,true ); \nVar2=FUNC2(Var5); \nif (Var2&&*Var2&&!Var6){\nif (Var3->memberVar1 ==  Var7&&!(Var3=FUNC6(Var3,Var4,Var7,false ))){\nelse \n}else if (Var3->memberVar1 !=  Var7){\nelse \n}else if ((!Var2||!*Var2)&&!Var6){\nif (Var4[0]== ){\nint  memberVar1=FUNC7(Var4); \nelse \n}else if ((!Var2||!*Var2)&&Var6){\n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 131,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2032,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t(void)r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nif (Var2[1]== !){//!!!&!!!-\nelse \n}else if (Var2[1]== ){\nelse \n}else if (Var2[1]== *){\nchar *Var4=FUNC2(Var2+1); \n(void ) FUNC3(Var3,STRING!Var5%STRUCT2 STRING,Var4); \nfree(Var4); \nchar *Var4=FUNC4(Var3,Var2); \nchar *Var4=FUNC2(Var2+1); \nconst char *Var4=FUNC5(Var6); \nelse \nchar *Var4=FUNC4(Var3,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 132,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2048,
    "label": -3,
    "slices": [
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tint olen;\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_cons_memcat (out, olen);\n",
      "\t\t\t\t\tfree (out);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "switch (*Var1){\nif (Var1[1]== !){//!!!&!!!-\nelse \n}else if (Var1[1]== ){\nelse \n}else if (Var1[1]== *){\nchar *Var2=FUNC1(Var1+1); \nelse \nif (FUNC2(0)){\nif (Var1[1]){\nint  Var3; \nchar *Var4=NULL ; \nchar *Var2=FUNC3(Var5,Var1); \nif (Var2){\nFUNC4(Var4,Var3); \nfree(Var4); \nchar *Var2=FUNC1(Var1+1); \nconst char *Var2=FUNC5(Var6); \nelse \nchar *Var2=FUNC3(Var5,Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 133,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2049,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=0; \nswitch (*Var2){\nif (Var2[1]== !){//!!!&!!!-\nelse \n}else if (Var2[1]== ){\nelse \n}else if (Var2[1]== *){\nchar *Var5=FUNC2(Var2+1); \nelse \nif (FUNC3(0)){\nif (Var2[1]){\nchar *Var6=NULL ; \nchar *Var5=FUNC4(Var3,Var2); \nif (Var5){\nVar4=FUNC5(Var5+1,NULL ,&Var6,&Var7,NULL ); \nfree(Var5); \nchar *Var5=FUNC2(Var2+1); \nconst char *Var5=FUNC6(Var8); \nelse \nchar *Var5=FUNC4(Var3,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 134,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2071,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tcmd = r_str_replace (cmd, \" \", \"\\\\ \", true);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\\ \", \" \", false);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\"\", \"'\", false);\n",
      "\t\tret = r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\tfree (cmd);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=0; \nswitch (*Var2){\nchar *Var5=FUNC2(Var2+1); \nchar *Var5=FUNC3(Var3,Var2); \nchar *Var5=FUNC2(Var2+1); \nVar5=FUNC4(Var5,STRING,STRING,true ); \nVar5=FUNC4(Var5,STRING,STRING,false ); \nVar5=FUNC4(Var5,STRINGSTRING,false ); \nVar4=FUNC5(Var3,STRING!Var6%STRUCT2 STRING,Var5); \nfree(Var5); \nconst char *Var5=FUNC6(Var7); \nelse \nchar *Var5=FUNC3(Var3,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 135,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 2075,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '?') {\n",
      "else\n",
      "\t\t\tif (!r_sandbox_enable (0)) {\n",
      "\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_core_sysenv_end (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tn = atoi (input);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_sysenv_end (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2  Var4; \nswitch (*Var2){\nif (Var2[1]== ){\nelse \nif (!FUNC2(0)){\nVar3->memberVar1=Var2[1]10; \nif (Var2[1]== !){//!!!&!!!-\nelse \n}else if (Var2[1]== ){\nelse \n}else if (Var2[1]== *){\nchar *Var5=FUNC3(Var2+1); \nelse \nif (FUNC2(0)){\nif (Var2[1]){\nchar *Var5=FUNC4(Var3,Var2); \nif (Var5){\nFUNC5(Var3,Var2); \nchar *Var5=FUNC3(Var2+1); \nVar4=FUNC6(Var2); \nif (*Var2 == 0||Var4>0){\nconst char *Var5=FUNC7(Var4); \nif (Var5){\nFUNC8(Var3,Var5); \nelse \nchar *Var5=FUNC4(Var3,Var2); \nif (Var5){\nFUNC5(Var3,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 136,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2089,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tret = r_sys_cmd (cmd);\n",
      "\t\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2  Var4; \nint  Var5=0; \nswitch (*Var2){\nchar *Var6=FUNC2(Var2+1); \nchar *Var6=FUNC3(Var3,Var2); \nchar *Var6=FUNC2(Var2+1); \nif (*Var2 == 0||Var4>0){\nconst char *Var6=FUNC4(Var4); \nelse \nchar *Var6=FUNC3(Var3,Var2); \nif (Var6){\nVar5=FUNC5(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 137,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2138,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\tfree (tmp);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){\nSTRUCT2  Var4[2]={NULL ,NULL }; \nchar *Var5=NULL ; \nif (!FUNC2(&Var4[0],&Var4[1],&Var6,0)){\nif (!FUNC3(Var4[1],Var7,0)){\nchar *Var8=FUNC4(STRING%STRUCT3 STRING,Var3); \nif (!Var8){\nVar5=Var8; \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 138,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "calloc",
    "line": 2142,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nchar *Var2=NULL ; \nSTRUCT2  Var3=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){\nif (!FUNC2(Var1[1],Var5,0)){\nchar *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); \nif (!Var6){\nif (!Var3){\nSTRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); \nif (!Var8){\nint  Var10=FUNC4(Var8,Var9); \nif (!Var10){\nFUNC5(Var8,Var9,FUNC6(STRING)); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 139,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2167,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tclose (1);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nif (Var2 == -1){\nclose(1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 140,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2168,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nVar2=FUNC6((Var16) Var1[1],Var17|Var18); \nif (Var2 == -1){\nFUNC7(Var2,1); \nclose(Var2); \nif (Var2 != -1){\nclose(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 141,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2185,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tfd_out = -1;\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nVar2=FUNC6((Var16) Var1[1],Var17|Var18); \nif (Var2 == -1){\nFUNC7(Var2,1); \nclose(Var2); \nVar2=-1; \nif (Var2 != -1){\nclose(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 142,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2189,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tcons_out = dup (1);\n",
      "\tif (cons_out != -1) {\n",
      "\t\tdup2 (cons_out, 1);\n",
      "\t\tclose (cons_out);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nif (Var2 == -1){\nVar3=FUNC6(1); \nif (Var3 != -1){\nFUNC7(Var3,1); \nclose(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 143,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2191,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nchar *Var2=NULL ; \nSTRUCT2  Var3=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){\nif (!FUNC2(Var1[1],Var5,0)){\nchar *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); \nif (!Var6){\nif (!Var3){\nSTRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); \nif (!Var8){\nint  Var10=FUNC4(Var8,Var9); \nif (!Var10){\nFUNC5(Var8,Var9,FUNC6(STRING)); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 144,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2192,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\t_shell_cmd_ = r_sys_conv_utf8_to_win (_shell_cmd);\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tfree (_shell_cmd_);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){\nSTRUCT2  Var4[2]={NULL ,NULL }; \nchar *Var5=NULL ; \nSTRUCT3  Var6=NULL ; \nif (!FUNC2(&Var4[0],&Var4[1],&Var7,0)){\nif (!FUNC3(Var4[1],Var8,0)){\nchar *Var9=FUNC4(STRING%STRUCT4 STRING,Var3); \nif (!Var9){\nVar5=Var9; \nVar6=FUNC5(Var5); \nif (!Var6){\nSTRUCT5 *Var10=calloc(Var11,sizeof (STRUCT5)); \nif (!Var10){\nint  Var12=FUNC6(Var10,Var11); \nif (!Var12){\nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 145,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2222,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tstr = r_core_cmd_str (core, radare_cmd);\n",
      "\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n",
      "\t\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nif (FUNC2(0)){\nif (*Var4 == !){\nVar5=FUNC3(Var2,Var3); \nFUNC4(Var4+1,Var5,&Var6,&Var7,NULL ); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 146,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2224,
    "label": -3,
    "slices": [
      "\tint si, olen, ret = -1, pipecolor = -1;\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tout = NULL;\n",
      "\t\tr_cons_memcat (out, olen);\n",
      "\t\tfree (out);\n"
    ],
    "tokenized": "int  Var1,Var2,Var3=-1,Var4=-1; \nchar *Var5,*Var6=NULL ; \nif (FUNC1(0)){\nif (*STRUCT1 == !){\nVar6=NULL ; \nFUNC2(Var6,Var2); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 147,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 2231,
    "label": -3,
    "slices": [
      "\tif (r_sandbox_enable (0)) {\n",
      "\tsignal (SIGPIPE, SIG_IGN);\n"
    ],
    "tokenized": "if (FUNC1(0)){\nsignal(Var1,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 148,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2238,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nVar1=FUNC2(1); \nif (Var1 != -1){\nif (FUNC3(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC4(Var1,1); \nclose(Var1); \nclose(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 149,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2241,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC3(Var2[1],1); \nclose(Var2[1]); \nclose(Var2[0]); \nelse \nclose(Var2[1]); \nFUNC3(Var2[0],0); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 150,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2242,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC3(Var2[1],1); \nclose(Var2[1]); \nclose(Var2[0]); \nelse \nclose(Var2[1]); \nFUNC3(Var2[0],0); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 151,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2245,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tclose (1);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nclose(1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 152,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2248,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nVar1=FUNC2(1); \nif (Var1 != -1){\nif (FUNC3(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC4(Var1,1); \nclose(Var1); \nclose(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 153,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2250,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC3(Var2[1],1); \nclose(Var2[1]); \nclose(Var2[0]); \nelse \nclose(Var2[1]); \nFUNC3(Var2[0],0); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 154,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2254,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nVar1=FUNC2(1); \nif (Var1 != -1){\nif (FUNC3(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC4(Var1,1); \nclose(Var1); \nclose(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 155,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2278,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n",
      "\tfree (s);\n",
      "\treturn res;\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nVar8=strchr(Var9,=); \nif (Var8){\n*Var8=0; \nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var6); \nVar6=FUNC6(Var6,Var11); \nfree(Var11); \nFUNC7(Var1->memberVar1,Var9,Var8+1); \n*Var8==; \nelse \nFUNC8(STRING,Var9); \nfree(Var3); \nreturn  Var6; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 156,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2280,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ],
    "tokenized": "char *Var1=strdup(Var2); \nint  Var3,Var4=FUNC1(Var1,,); \nchar *Var5=strdup(STRING); \nif (!Var1||!Var5){\nfree(Var5); \nfor (Var3=0; Var3<Var4; Var3  Var6){\nchar *Var7,*Var8=(char *) FUNC2(Var1,Var3); \nif (!Var8){\nif (Var7){\nconst char *Var9=FUNC3(Var10->memberVar1,Var8); \nif (!Var9){\nchar *Var11=FUNC4(STRING,Var8,Var9); \nif (!Var11){\nfree(Var5); \nVar5=FUNC5(Var5,Var11); \nreturn  Var5; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 157,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2282,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 158,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2283,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ],
    "tokenized": "char *Var1=strdup(Var2); \nint  Var3,Var4=FUNC1(Var1,,); \nchar *Var5=strdup(STRING); \nif (!Var1||!Var5){\nfree(Var5); \nfor (Var3=0; Var3<Var4; Var3  Var6){\nchar *Var7,*Var8=(char *) FUNC2(Var1,Var3); \nif (!Var8){\nif (Var7){\nconst char *Var9=FUNC3(Var10->memberVar1,Var8); \nif (!Var9){\nchar *Var11=FUNC4(STRING,Var8,Var9); \nif (!Var11){\nfree(Var5); \nVar5=FUNC5(Var5,Var11); \nreturn  Var5; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 159,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2291,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nVar8=strchr(Var9,=); \nif (Var8){\n*Var8=0; \nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nFUNC6(Var1->memberVar1,Var9,Var8+1); \n*Var8==; \nelse \nFUNC7(STRING,Var9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 160,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2300,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 161,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2301,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var6); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var6); \nVar6=FUNC6(Var6,Var11); \nreturn  Var6; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 162,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2305,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nVar6=FUNC6(Var6,Var11); \nfree(Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 163,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2312,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 164,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nchar *Var4,*Var5=NULL ,*Var6=NULL ; \nbool  Var7=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var8=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var9=Var1->memberVar2; \nVar6=strdup(Var2); \nconst char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nchar *Var12=strdup(Var10); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 165,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nchar *Var4,*Var5=NULL ,*Var6=NULL ; \nbool  Var7=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var8=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var9=Var1->memberVar2; \nVar6=strdup(Var2); \nconst char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nchar *Var12=strdup(Var10); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 166,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2325,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\tif (http) {\n",
      "\t\t\t*http = 0;\n",
      "\t\t\thttp--;\n",
      "\t\t\tif (*http == ' ') {\n",
      "\t\t\t\t*http = 0;\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nchar *Var4,*Var5=NULL ,*Var6=NULL ; \nbool  Var7=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var8=strstr(Var2,STRING); \nif (Var8){\n*Var8=0; \nVar8  Var9; \nif (*Var8 == ){\n*Var8=0; \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var10=Var1->memberVar2; \nVar6=strdup(Var2); \nconst char *Var11=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var12=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nchar *Var13=strdup(Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 167,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2342,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n",
      "\t\t*cmt = 0;\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\tfree (icmd);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var10=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC5(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nVar6=*Var8(char *) FUNC6(Var8,,STRING) NULL ; \nif (Var6&&(Var6[1]== ||Var6[1]==  Var12)){\n*Var6=0; \nif (*Var2 != ){\nif (!strchr(Var2,)){//Var13|Var14{Var15; Var16}//Var17; if  Var18  Var19  Var20  STRUCT3  Var21\nif ((Var7=strchr(Var2,; ))){\n*Var7=0; \nif (Var3>0){\nwhile (FUNC7(*Var2)){\nVar2  Var22; \nif (!*Var2){\nif (Var3>1&&FUNC8(0)){\nFUNC9(STRING,Var2); \nelse \nif (Var3>Var23){\nif (FUNC10()){\nconst char *Var24=Var1->STRUCT4  Var1->STRUCT4 STRING; \nint  Var25=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var26&&*Var2){\nif (FUNC11()){\nchar *Var27=strdup(Var24); \nVar4=FUNC12(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); \nif (Var4&&*Var2 ==  Var28){\nif (Var1->memberVar4){\nif (Var7&&Var7[1]){\nfor (Var22  Var7; *Var7 == ; ; Var7  Var22){\nFUNC1(Var1,Var7); \nfree(Var8); \nreturn  Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 168,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2364,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var10=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC5(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (*Var2 != ){\nif (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20\nif (Var3>0){\nwhile (FUNC6(*Var2)){\nVar2  Var21; \nif (!*Var2){\nif (Var3>1&&FUNC7(0)){\nFUNC8(STRING,Var2); \nelse \nif (Var3>Var22){\nif (FUNC9()){\nconst char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; \nint  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var25&&*Var2){\nif (FUNC10()){\nchar *Var26=strdup(Var23); \nVar4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); \nif (Var4&&*Var2 ==  Var27){\nif (Var1->memberVar4){\n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 169,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2365,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var10=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC5(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (*Var2 != ){\nif (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20\nif ((Var7=strchr(Var2,; ))){\n*Var7=0; \nif (Var3>0){\nwhile (FUNC6(*Var2)){\nVar2  Var21; \nif (!*Var2){\nif (Var3>1&&FUNC7(0)){\nFUNC8(STRING,Var2); \nelse \nif (Var3>Var22){\nif (FUNC9()){\nconst char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; \nint  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var25&&*Var2){\nif (FUNC10()){\nchar *Var26=strdup(Var23); \nVar4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); \nif (Var4&&*Var2 ==  Var27){\nif (Var1->memberVar4){\nif (Var7&&Var7[1]){\nfor (Var21  Var7; *Var7 == ; ; Var7  Var21){\nFUNC1(Var1,Var7); \nreturn  Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 170,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2416,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 171,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2420,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 172,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2424,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 173,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2434,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 174,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2457,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\tfree (icmd);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC4(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nVar6=*Var8(char *) FUNC5(Var8,,STRING) NULL ; \nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC6(0)){\nelse \nif (Var3>Var12){\nif (FUNC7()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC8()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nif (Var1->memberVar4){\nif (Var7&&Var7[1]){\nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 175,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2474,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\t\treturn q;\n",
      "\treturn strchr (p, '-');\n"
    ],
    "tokenized": "static char *FUNC1(char *Var1){\nchar *Var2=strchr(Var1,+); \nif (Var2){\nreturn  Var2; \nreturn strchr(Var1,-); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 176,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2478,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\treturn strchr (p, '-');\n"
    ],
    "tokenized": "static char *FUNC1(char *Var1){\nchar *Var2=strchr(Var1,+); \nif (Var2){\nreturn strchr(Var1,-); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "tmpenvs_free",
    "Source": false,
    "Sink": false,
    "idx": 177,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2483,
    "label": -3,
    "slices": [
      "static void tmpenvs_free(void *item) {\n",
      "\tr_sys_setenv (item, NULL);\n",
      "\tfree (item);\n"
    ],
    "tokenized": "static void FUNC1(void *Var1){\nFUNC2(Var1,NULL ); \nfree(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "set_tmp_arch",
    "Source": false,
    "Sink": false,
    "idx": 178,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2490,
    "label": -3,
    "slices": [
      "static bool set_tmp_arch(RCore *core, char *arch, char **tmparch) {\n",
      "\t*tmparch = strdup (r_config_get (core->config, \"asm.arch\"));\n",
      "\tr_config_set (core->config, \"asm.arch\", arch);\n",
      "\tcore->fixedarch = true;\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,char *Var2,char **Var3){\n*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); \nFUNC3(Var1->memberVar1,STRING,Var2); \nVar1->memberVar2=true ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "set_tmp_bits",
    "Source": false,
    "Sink": false,
    "idx": 179,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2500,
    "label": -3,
    "slices": [
      "static bool set_tmp_bits(RCore *core, int bits, char **tmpbits) {\n",
      "\t*tmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n",
      "\tr_config_set_i (core->config, \"asm.bits\", bits);\n",
      "\tcore->fixedbits = true;\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,int  Var2,char **Var3){\n*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); \nFUNC3(Var1->memberVar1,STRING,Var2); \nVar1->memberVar2=true ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 180,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2533,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 181,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2535,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tchar *$1 = strchr ($0 + 2, ')');\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n"
    ],
    "tokenized": "if (!Var1){\nif (0){\nchar *1=strchr(0+2,)); \nelse \nchar *Var2=strchr(Var1,; ); \nchar *Var3=strchr(Var4+1,); \nchar *Var5=strchr(Var1,); \nchar *Var6=FUNC1(Var7,Var1); \nconst char *Var8=strstr(Var1,STRING); \nchar *Var9,*Var5=strchr(Var10+1,!); \nchar *Var11=strchr(Var12,=); \nchar *Var1=FUNC2(Var7,Var10+2); \nchar *Var3=strchr(Var10+2,); \nchar *Var4=strchr(Var13,); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 182,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ],
    "tokenized": "if (!Var1){\nif (0){\nif (1){\nmemmove(0+1,0+2,strlen(0+2)+1); \nelse \nchar *Var2=strchr(Var1,; ); \nchar *Var3=strchr(Var1,); \nchar *Var4=FUNC1(Var5,Var1); \nconst char *Var6=strstr(Var1,STRING); \nchar *Var1=FUNC2(Var5,Var7+2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 183,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ],
    "tokenized": "if (!Var1){\nif (0){\nif (1){\nmemmove(0+1,0+2,strlen(0+2)+1); \nelse \nchar *Var2=strchr(Var1,; ); \nchar *Var3=strchr(Var1,); \nchar *Var4=FUNC1(Var5,Var1); \nconst char *Var6=strstr(Var1,STRING); \nchar *Var1=FUNC2(Var5,Var7+2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 184,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2572,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \n*Var25  Var26=0; \nelse \nchar *Var28=strchr(Var2,; ); \nif (Var28){\n*Var28=0; \nFUNC7(Var1,Var2); \nif (!Var28){\nVar2=Var28+1; \nif (*Var25){\nif (Var25[0]== ){\nVar25  Var29; \nwhile (Var25[1]== ; ||FUNC8(Var25[1])){\nVar25  Var26; \nif (Var25[1]== ||(Var25[1]&&Var25[2]== )){\nchar *Var30=strchr(Var25+1,); \nif (Var30){\n*Var30=0; \nVar19=Var30 != NULL ; \nFUNC9(Var1,FUNC10(Var1->memberVar6,Var25+2),1); \nif (Var30){\n*Var25=; \nVar25=Var30; \nelse \nVar25=strchr(Var25+1,; ); \nif (Var25&&*Var25&&Var25[1]== >){\nVar9=Var25+2; \nwhile (*Var9 == >){\nVar9  Var26; \nVar9=(char *) FUNC11(Var9); \nconst bool  Var31=Var25[2]== >; \nVar16=FUNC12(Var9,1,Var31); \nVar24=strdup(Var2); \nVar24=FUNC13(Var24,STRINGSTRINGSTRING,true ); \nif (Var25&&*Var25&&Var25[1]== |){\nVar9=Var25+2; \nwhile (FUNC8(*Var9)){\nVar9  Var26; \nFUNC14(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var24); \nfree(Var24); \nif (Var16 != -1){\nFUNC15(Var16); \nif (!Var25){\nif (Var18){\nif (Var19){\nif (*Var25 == ; ){\nVar2=Var25+1; \nelse \nif (*Var25 == ){\nVar2=Var25+1; \nelse \n*Var25=; \nVar2=Var25; \nelse \nVar2=Var25+1; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC16(Var2,,STRING); //Var32  Var33  Var5  Var34\nif (*Var2 != ){\nVar7=(char *) FUNC17(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC17(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC18(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC19(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC20(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC14(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC21(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC17(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC22(Var1,Var38,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC23()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC16(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var39=1; \nint  Var40=FUNC24(Var1->memberVar8,STRING); \nint  Var41=false ; \nint  Var42=FUNC24(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC25(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var45=FUNC26(Var1,Var2); \nchar *Var46=FUNC27(Var1->memberVar5,Var9,1); \nchar *Var47=FUNC28(STRING,Var46,Var45); \nelse \nchar *Var48=FUNC28(STRING,Var45); \nelse \nchar *Var48=FUNC28(STRING,Var45); \nelse \n}else if (Var39>0){\nif (Var16 != -1){\nVar15=FUNC29(Var1,Var2); \nconst char *Var49=FUNC30(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var42=FUNC24(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC31(strdup(Var2),Var9); \nVar15=FUNC29(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC32(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var63=strdup(Var7+2); \nchar *Var64=strchr(Var63,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC33(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var65=(int ) FUNC10(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var66=FUNC34(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var67=FUNC35(Var1->memberVar1,Var68,Var69,0); \nchar *Var70=strdup(Var7+2); \nchar  Var35=*Var71; \nSTRUCT3  Var54=FUNC10(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC36(Var1,Var7+2); \nSTRUCT2 *Var67=FUNC35(Var1->memberVar1,Var68,Var69,0); \nchar *Var72=FUNC37(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var30=strchr(Var7+2,); \nint  Var73=FUNC10(Var1->memberVar6,Var30); \nconst STRUCT6 *Var74=(const STRUCT6 *) FUNC11(Var7+2); \nSTRUCT2 *Var67=FUNC35(Var1->memberVar1,Var68,Var69,0); \nchar *Var75=Var7-2; \nwhile (Var75>Var2){\nif (!FUNC8(*Var75)){\nVar2=FUNC18(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC38((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC39(Var1->memberVar12,Var7+1)){\nelse \nchar  Var35=*Var57; \nSTRUCT2 *Var67=Var12; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nVar15=FUNC40(Var1,Var2,Var76); \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC10(Var1->memberVar6,Var79); \nSTRUCT3  Var81=FUNC10(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC42(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC42(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC42(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 185,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2592,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nbool  Var17=false ; \nbool  Var18=Var1->memberVar2; \nbool  Var19=Var1->memberVar3; \nSTRUCT3  Var20=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nfor (; *Var2; ){\nint  Var15=-1; \nchar *Var21,*Var22; \nVar17=*Var2 == ; \nif (Var17){\nVar2  Var23; \nVar22=*Var2 FUNC3(Var2) NULL ; \nif (!Var22||!*Var22){\nFUNC4(STRINGFUNC5(%Var24).,Var2); \n*Var22  Var23=0; \nelse \nchar *Var25=strchr(Var2,; ); \nif (Var25){\n*Var25=0; \nFUNC6(Var1,Var2); \nif (!Var25){\nVar2=Var25+1; \nif (*Var22){\nif (Var22[0]== ){\nVar22  Var26; \nwhile (Var22[1]== ; ||FUNC7(Var22[1])){\nVar22  Var23; \nif (Var22[1]== ||(Var22[1]&&Var22[2]== )){\nchar *Var27=strchr(Var22+1,); \nif (Var27){\n*Var27=0; \nVar17=Var27 != NULL ; \nFUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); \nif (Var27){\n*Var22=; \nVar22=Var27; \nelse \nVar22=strchr(Var22+1,; ); \nif (Var22&&*Var22&&Var22[1]== >){\nVar8=Var22+2; \nwhile (*Var8 == >){\nVar8  Var23; \nVar8=(char *) FUNC10(Var8); \nconst bool  Var28=Var22[2]== >; \nVar15=FUNC11(Var8,1,Var28); \nVar21=strdup(Var2); \nVar21=FUNC12(Var21,STRINGSTRINGSTRING,true ); \nif (Var22&&*Var22&&Var22[1]== |){\nVar8=Var22+2; \nwhile (FUNC7(*Var8)){\nVar8  Var23; \nFUNC13(Var1,Var2,Var8); \nelse \nFUNC14(Var1->memberVar6,Var21); \nfree(Var21); \nif (Var15 != -1){\nFUNC15(Var15); \nif (!Var22){\nif (Var16){\nif (Var17){\nif (*Var22 == ; ){\nVar2=Var22+1; \nelse \nif (*Var22 == ){\nVar2=Var22+1; \nelse \n*Var22=; \nVar2=Var22; \nelse \nVar2=Var22+1; \nchar *Var7=strchr(Var2,); \nint  Var29=Var1->memberVar5->memberVar1; \nelse \nchar *Var30=FUNC16(Var1->memberVar1,Var6+1); \nint  Var31=FUNC17(Var1->memberVar7,STRING); \nint  Var32=FUNC17(Var1->memberVar7,STRING); \nchar *Var33=FUNC18(Var1,Var2); \nchar *Var34=FUNC19(Var1->memberVar6,Var8,1); \nconst char *Var35=FUNC20(Var1->memberVar7,STRING); \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var32=FUNC17(Var1->memberVar7,STRING); \nconst char *Var24=strstr(Var2,STRING); \nchar *Var36,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var37=Var1->memberVar8; \nchar *Var38=NULL ; \nconst char *Var39=NULL ; \nchar *Var40=NULL ; \nchar *Var41=NULL ; \nchar *Var42=strdup(Var6+2); \nchar *Var43=strchr(Var42,=); \nSTRUCT3  Var37=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); \nint  Var44=(int ) FUNC9(Var1->memberVar5,Var6+2); \nSTRUCT4 *Var45=FUNC22(Var1->memberVar9,Var1->memberVar8); \nSTRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); \nchar *Var49=strdup(Var6+2); \nSTRUCT3  Var37=FUNC9(Var1->memberVar5,Var6+2); \nchar *Var2=FUNC24(Var1,Var6+2); \nSTRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); \nchar *Var50=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); \nchar *Var27=strchr(Var6+2,); \nint  Var51=FUNC9(Var1->memberVar5,Var27); \nconst STRUCT5 *Var52=(const STRUCT5 *) FUNC10(Var6+2); \nSTRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); \nSTRUCT2 *Var46=Var11; \nconst char *Var53[]={STRING,STRING,STRING,\nconst char *Var54[]={STRING,STRING,STRING,\nchar *Var22=strchr(Var55,); \nSTRUCT3  Var56=FUNC9(Var1->memberVar5,Var55); \nSTRUCT3  Var57=FUNC9(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 186,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2603,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nbool  Var17=false ; \nbool  Var18=Var1->memberVar2; \nbool  Var19=Var1->memberVar3; \nSTRUCT3  Var20=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nfor (; *Var2; ){\nint  Var15=-1; \nchar *Var21,*Var22; \nVar17=*Var2 == ; \nif (Var17){\nVar2  Var23; \nVar22=*Var2 FUNC3(Var2) NULL ; \nif (!Var22||!*Var22){\nFUNC4(STRINGFUNC5(%Var24).,Var2); \n*Var22  Var23=0; \nelse \nchar *Var25=strchr(Var2,; ); \nif (Var25){\n*Var25=0; \nFUNC6(Var1,Var2); \nif (!Var25){\nVar2=Var25+1; \nif (*Var22){\nif (Var22[0]== ){\nVar22  Var26; \nwhile (Var22[1]== ; ||FUNC7(Var22[1])){\nVar22  Var23; \nif (Var22[1]== ||(Var22[1]&&Var22[2]== )){\nchar *Var27=strchr(Var22+1,); \nif (Var27){\n*Var27=0; \nVar17=Var27 != NULL ; \nFUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); \nif (Var27){\n*Var22=; \nVar22=Var27; \nelse \nVar22=strchr(Var22+1,; ); \nif (Var22&&*Var22&&Var22[1]== >){\nVar8=Var22+2; \nwhile (*Var8 == >){\nVar8  Var23; \nVar8=(char *) FUNC10(Var8); \nconst bool  Var28=Var22[2]== >; \nVar15=FUNC11(Var8,1,Var28); \nVar21=strdup(Var2); \nVar21=FUNC12(Var21,STRINGSTRINGSTRING,true ); \nif (Var22&&*Var22&&Var22[1]== |){\nVar8=Var22+2; \nwhile (FUNC7(*Var8)){\nVar8  Var23; \nFUNC13(Var1,Var2,Var8); \nelse \nFUNC14(Var1->memberVar6,Var21); \nfree(Var21); \nif (Var15 != -1){\nFUNC15(Var15); \nif (!Var22){\nif (Var16){\nif (Var17){\nif (*Var22 == ; ){\nVar2=Var22+1; \nelse \nif (*Var22 == ){\nVar2=Var22+1; \nelse \n*Var22=; \nVar2=Var22; \nelse \nVar2=Var22+1; \nchar *Var7=strchr(Var2,); \nint  Var29=Var1->memberVar5->memberVar1; \nelse \nchar *Var30=FUNC16(Var1->memberVar1,Var6+1); \nint  Var31=FUNC17(Var1->memberVar7,STRING); \nint  Var32=FUNC17(Var1->memberVar7,STRING); \nchar *Var33=FUNC18(Var1,Var2); \nchar *Var34=FUNC19(Var1->memberVar6,Var8,1); \nconst char *Var35=FUNC20(Var1->memberVar7,STRING); \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var32=FUNC17(Var1->memberVar7,STRING); \nconst char *Var24=strstr(Var2,STRING); \nchar *Var36,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var37=Var1->memberVar8; \nchar *Var38=NULL ; \nconst char *Var39=NULL ; \nchar *Var40=NULL ; \nchar *Var41=NULL ; \nchar *Var42=strdup(Var6+2); \nchar *Var43=strchr(Var42,=); \nSTRUCT3  Var37=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); \nint  Var44=(int ) FUNC9(Var1->memberVar5,Var6+2); \nSTRUCT4 *Var45=FUNC22(Var1->memberVar9,Var1->memberVar8); \nSTRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); \nchar *Var49=strdup(Var6+2); \nSTRUCT3  Var37=FUNC9(Var1->memberVar5,Var6+2); \nchar *Var2=FUNC24(Var1,Var6+2); \nSTRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); \nchar *Var50=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); \nchar *Var27=strchr(Var6+2,); \nint  Var51=FUNC9(Var1->memberVar5,Var27); \nconst STRUCT5 *Var52=(const STRUCT5 *) FUNC10(Var6+2); \nSTRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); \nSTRUCT2 *Var46=Var11; \nconst char *Var53[]={STRING,STRING,STRING,\nconst char *Var54[]={STRING,STRING,STRING,\nchar *Var22=strchr(Var55,); \nSTRUCT3  Var56=FUNC9(Var1->memberVar5,Var55); \nSTRUCT3  Var57=FUNC9(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 187,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2617,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \n*Var25  Var26=0; \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nVar2=Var28+1; \nif (*Var25){\nif (Var25[0]== ){\nVar25  Var29; \nwhile (Var25[1]== ; ||FUNC8(Var25[1])){\nVar25  Var26; \nif (Var25[1]== ||(Var25[1]&&Var25[2]== )){\nchar *Var30=strchr(Var25+1,); \nif (Var30){\nVar25=Var30; \nelse \nVar25=strchr(Var25+1,; ); \nconst bool  Var31=Var25[2]== >; \nVar24=strdup(Var2); \nVar24=FUNC9(Var24,STRINGSTRINGSTRING,true ); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC10(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var24); \nfree(Var24); \nif (!Var25){\nif (Var18){\nif (Var19){\nif (*Var25 == ; ){\nVar2=Var25+1; \nelse \nif (*Var25 == ){\nVar2=Var25+1; \nVar2=Var25; \nelse \nVar2=Var25+1; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC11(Var2,,STRING); //Var32  Var33  Var5  Var34\nif (*Var2 != ){\nVar7=(char *) FUNC12(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC12(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC13(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC10(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC16(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC12(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC17(Var1,Var38,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC18()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC11(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var39=1; \nint  Var40=FUNC19(Var1->memberVar8,STRING); \nint  Var41=false ; \nint  Var42=FUNC19(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC20(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var45=FUNC21(Var1,Var2); \nchar *Var46=FUNC22(Var1->memberVar5,Var9,1); \nchar *Var47=FUNC23(STRING,Var46,Var45); \nelse \nchar *Var48=FUNC23(STRING,Var45); \nelse \nchar *Var48=FUNC23(STRING,Var45); \nelse \n}else if (Var39>0){\nif (Var16 != -1){\nVar15=FUNC24(Var1,Var2); \nconst char *Var49=FUNC25(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var42=FUNC19(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC26(strdup(Var2),Var9); \nVar15=FUNC24(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC27(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var63=strdup(Var7+2); \nchar *Var64=strchr(Var63,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC28(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var65=(int ) FUNC29(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var66=FUNC30(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); \nchar *Var70=strdup(Var7+2); \nchar  Var35=*Var71; \nSTRUCT3  Var54=FUNC29(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC32(Var1,Var7+2); \nSTRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); \nchar *Var72=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var30=strchr(Var7+2,); \nint  Var73=FUNC29(Var1->memberVar6,Var30); \nconst STRUCT6 *Var74=(const STRUCT6 *) FUNC34(Var7+2); \nSTRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); \nchar *Var75=Var7-2; \nwhile (Var75>Var2){\nif (!FUNC8(*Var75)){\nVar2=FUNC13(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC35((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC36(Var1->memberVar12,Var7+1)){\nelse \nchar  Var35=*Var57; \nSTRUCT2 *Var67=Var12; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nVar15=FUNC37(Var1,Var2,Var76); \nelse \nVar15=FUNC38(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC29(Var1->memberVar6,Var79); \nSTRUCT3  Var81=FUNC29(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 188,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2628,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nSTRUCT2 *Var8=NULL ; \nint  Var9=!Var1->memberVar1->memberVar1; \nbool  Var10=false ; \nbool  Var11=false ; \nbool  Var12=Var1->memberVar2; \nbool  Var13=Var1->memberVar3; \nSTRUCT3  Var14=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nfor (; *Var2; ){\nchar *Var15,*Var16; \nif (Var11){\nVar2  Var17; \nVar16=*Var2 FUNC3(Var2) NULL ; \nif (!Var16||!*Var16){\n*Var16  Var17=0; \nelse \nchar *Var18=strchr(Var2,; ); \nif (!Var18){\nVar2=Var18+1; \nif (*Var16){\nif (Var16[0]== ){\nVar16  Var19; \nwhile (Var16[1]== ; ||FUNC4(Var16[1])){\nVar16  Var17; \nif (Var16[1]== ||(Var16[1]&&Var16[2]== )){\nchar *Var20=strchr(Var16+1,); \nif (Var20){\nVar16=Var20; \nelse \nVar16=strchr(Var16+1,; ); \nconst bool  Var21=Var16[2]== >; \nVar15=strdup(Var2); \nVar15=FUNC5(Var15,STRINGSTRINGSTRING,true ); \nif (Var16&&*Var16&&Var16[1]== |){\nelse \nFUNC6(Var1->memberVar5,Var15); \nfree(Var15); \nif (!Var16){\nif (Var10){\nif (Var11){\nif (*Var16 == ; ){\nVar2=Var16+1; \nelse \nif (*Var16 == ){\nVar2=Var16+1; \nVar2=Var16; \nelse \nVar2=Var16+1; \nchar *Var22=strchr(Var2,); \nint  Var23=Var1->memberVar6->memberVar1; \nelse \nchar *Var24=FUNC7(Var1->memberVar1,Var25+1); \nint  Var26=FUNC8(Var1->memberVar7,STRING); \nint  Var27=FUNC8(Var1->memberVar7,STRING); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar5,Var30,1); \nconst char *Var31=FUNC11(Var1->memberVar7,STRING); \nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var27=FUNC8(Var1->memberVar7,STRING); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var22=strchr(Var25+1,!); \nSTRUCT3  Var34=Var1->memberVar8; \nchar *Var35=NULL ; \nconst char *Var36=NULL ; \nchar *Var37=NULL ; \nchar *Var38=NULL ; \nchar *Var39=strdup(Var25+2); \nchar *Var40=strchr(Var39,=); \nSTRUCT3  Var34=FUNC12(Var1->memberVar6,Var1->memberVar8,Var25+4); \nint  Var41=(int ) FUNC13(Var1->memberVar6,Var25+2); \nSTRUCT4 *Var42=FUNC14(Var1->memberVar9,Var1->memberVar8); \nSTRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); \nchar *Var46=strdup(Var25+2); \nSTRUCT3  Var34=FUNC13(Var1->memberVar6,Var25+2); \nchar *Var2=FUNC16(Var1,Var25+2); \nSTRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); \nchar *Var47=FUNC17(Var1->memberVar10,NULL ,0,Var25+((Var25[1]) 21)); \nchar *Var20=strchr(Var25+2,); \nint  Var48=FUNC13(Var1->memberVar6,Var20); \nSTRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); \nSTRUCT2 *Var43=Var8; \nconst char *Var49[]={STRING,STRING,STRING,\nconst char *Var50[]={STRING,STRING,STRING,\nchar *Var16=strchr(Var51,); \nSTRUCT3  Var52=FUNC13(Var1->memberVar6,Var51); \nSTRUCT3  Var53=FUNC13(Var1->memberVar6,Var16+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 189,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2660,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 190,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2711,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 191,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2711,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 192,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2715,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 193,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2720,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 194,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2727,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 195,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2731,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 196,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2743,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\t\tif (res) {\n",
      "\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\t\t\t\tfree (res);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nelse \nchar *Var17=FUNC5(Var1->memberVar1,Var7+1); \nif (Var17){\nFUNC6(STRING,Var17); \nfree(Var17); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 197,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2781,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\t\treturn ret;\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\t\t\t*fdnum = 0;\n",
      "else\n",
      "\t\t\t\tif (IS_DIGIT (*fdnum)) {\n",
      "\t\t\t\t\tfdn = *fdnum - '0';\n",
      "\t\t\t\t*fdnum = 0;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tfree (str);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tr_cons_grep_process (grep);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nint  Var28=-1; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var29,*Var30; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var31; \nVar30=*Var2 FUNC5(Var2) NULL ; \nif (!Var30||!*Var30){\nFUNC6(STRINGFUNC7(%Var32).,Var2); \nelse \nchar *Var33=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var33){\nchar *Var34=strchr(Var30+1,); \nconst bool  Var35=Var30[2]== >; \nVar29=strdup(Var2); \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var30){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38\nif (Var9&&(Var9[1]== ||Var9[1]==  Var39)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var41=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var42=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nreturn  Var17; \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var43=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var43,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var31){\nFUNC6(STRING,Var11); \nchar  Var44[1024]; \nint  Var17; \nif (FUNC20(stdin)){\nif (Var1->memberVar7){\nif (!strcmp(Var44,Var11)){\nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var31){\nif (!*Var11){\nFUNC6(STRING,Var11); \nVar1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); \nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nreturn FUNC22(Var1,(const char *) Var1->memberVar7); \nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var45=1; \nint  Var46=FUNC23(Var1->memberVar9,STRING); \nint  Var47=false ; \nint  Var48=FUNC23(Var1->memberVar9,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC24(Var9[-2])){\nchar *Var49=Var9-1; \nif (*Var49 ==  Var50){//STRING\nVar20=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,true ); \n*Var49=0; \nelse \nif (FUNC26(*Var49)){\nVar45=*Var49-0; \n*Var49=0; \nif (!strcmp(Var11,STRING)){\nFUNC25(Var1->memberVar9,STRING,Var51); \nconst bool  Var52=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var53=FUNC27(Var1,Var2); \nif (Var52){\nchar *Var54=FUNC28(Var1->memberVar5,Var11,1); \nif (Var54){\nchar *Var55=FUNC29(STRING,Var54,Var53); \nif (Var55){\nFUNC30(Var1->memberVar5,Var11,Var55,1); \nfree(Var55); \nelse \nchar *Var56=FUNC29(STRING,Var53); \nFUNC30(Var1->memberVar5,Var11,Var56,1); \nfree(Var56); \nelse \nchar *Var56=FUNC29(STRING,Var53); \nFUNC30(Var1->memberVar5,Var11,Var56,1); \nfree(Var56); \nelse \n}else if (Var45>0){\nVar18=FUNC31(Var11,Var45,Var52); \nif (Var18 != -1){\nif (!Var46){\nFUNC25(Var1->memberVar9,STRING,Var51); \nVar17=FUNC12(Var1,Var2); \nFUNC32(Var18); \nif (!Var46){\nFUNC25(Var1->memberVar9,STRING,Var48); \nif (Var47){\nconst char *Var57=FUNC33(Var1->memberVar9,STRING); \nif (Var57&&*Var57){\nFUNC34(STRING,Var57,Var11); \nFUNC35(Var11); \nFUNC25(Var1->memberVar9,STRING,Var48); \nfree(Var11); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nVar1->memberVar10->memberVar1=false ; \nreturn  Var17; \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nbool  Var58=false ; \nint  Var59=1; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var58){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \n*Var10=0; \nif (Var9[1]== !){\nVar11=FUNC36(Var1,Var9+1); \nelse \nint  Var48=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,0); \nVar11=FUNC27(Var1,Var9+1); \nFUNC25(Var1->memberVar9,STRING,Var48); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nfree(Var11); \nif (Var59&&Var11){\nfor (Var16=0; Var11[Var16]; Var16  Var31){\nif (Var11[Var16]==  Var56){\nVar11[Var16]=; \nVar11=FUNC37(Var11,Var10+1); \nVar2=FUNC37(strdup(Var2),Var11); \nVar1->memberVar6->memberVar1=memberVar1; \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nfree(Var11); \nreturn  Var17; \nif (*Var2 != &&*Var2){\nconst char *Var32=strstr(Var2,STRING); \nif (Var32){\nbool  Var60=false ; \nif (Var2 ==  Var32){\nif (Var60){\nif (*Var2 != .){\nVar13=FUNC38(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar11=Var9 true false ; \nint  Var61=0; \nif (Var9){\nchar *Var62,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var63=Var1->memberVar12; \nbool  Var64=false ; \nchar *Var65=NULL ; \nconst char *Var66=NULL ; \nbool  Var67=false ; \nbool  Var68=false ; \nchar *Var69=NULL ; \nchar *Var70=NULL ; \nbool  Var71=false ; \nint  Var72=-1; \nint  Var73,Var74; \nSTRUCT6 *Var44; \n*Var9  Var31=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var31){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var75; \nVar9=FUNC39(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var76=strdup(Var9+2); \nchar *Var77=strchr(Var76,=); \nif (Var77){\n*Var77  Var31=0; \nFUNC40(Var76,Var77); \nFUNC41(Var5,Var76); \nelse \nfree(Var76); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+4); \nFUNC43(Var1,FUNC44((Var78) Var63-(Var78) Var1->memberVar12)); \nelse \nVar63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+3); \nFUNC45(Var1,Var63,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar71=FUNC46(Var1->memberVar13,Var9+2); \nint  Var79=(int ) FUNC47(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var80=FUNC48(Var1->memberVar14,Var1->memberVar12); \nif (Var80){\nif (Var79<0){\nVar79=Var80->memberVar1+Var79; \nif (Var79 >= 0&&Var79<Var80->memberVar1){\nSTRUCT8  Var81=FUNC49(Var80,Var79); \nFUNC45(Var1,Var80->memberVar2+Var81,1); \nelse \nFUNC6(STRING,Var80->memberVar1); \nVar62=FUNC21(Var9+2,&Var73); \nif (Var62){\nSTRUCT9 *Var82=FUNC50((const STRUCT6 *) Var62,Var73); \nSTRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); \nif (Var83){\nif (Var14){\nFUNC52(Var14); \nVar14=Var83; \nif (Var15){\nFUNC25(Var1->memberVar9,STRING,1); \nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); \nif (Var44){\nfree(Var1->memberVar15); \nmemcpy(Var1->memberVar15,Var62,Var73); \nfree(Var62); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var85; \nchar *Var86=strdup(Var9+2); \nchar *Var87=FUNC55(Var86); \nif (Var87){\nchar  Var40=*Var87; \n*Var87=0; \nVar85=FUNC56(Var1->memberVar16,Var86); \n*Var87=Var40; \nVar85=FUNC47(Var1->memberVar6,Var88); \nelse \nVar85=FUNC56(Var1->memberVar16,Var9+2); \nFUNC45(Var1,Var85,1); \nfree(Var86); \nVar67=FUNC57(Var1,FUNC47(Var1->memberVar6,Var9+2),&Var65); \nVar28=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,1); \nSTRUCT4  memberVar2=FUNC47(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC58(Var1,Var9+2); \nif (!Var69){\nVar69=Var2; \nelse \nVar69=FUNC59(Var69,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar44=malloc(strlen(Var9+2)+1); \nif (Var44){\nVar74=FUNC60(Var9+2,Var44); \nFUNC43(Var1,FUNC44(Var74)); \nif (Var74>0){\nSTRUCT9 *Var82=FUNC50(Var44,Var74); \nSTRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); \nif (Var83){\nif (Var14){\nFUNC52(Var14); \nVar14=Var83; \nif (Var15){\nFUNC25(Var1->memberVar9,STRING,1); \nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); \nFUNC43(Var1,Var74); \nfree(Var44); \nchar *Var89=FUNC61(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var89){\nFUNC45(Var1,FUNC47(Var1->memberVar6,Var89),1); \nfree(Var89); \nif (Var9[1]== ){\nVar72=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC62(Var1->memberVar1,FUNC63(Var9+2)); \nif (Var9[1]== ){\nchar *Var34=strchr(Var9+2,); \nif (Var34){\n*Var34  Var31=0; \nint  Var90=FUNC47(Var1->memberVar6,Var34); \nVar67=FUNC57(Var1,Var90,&Var65); \nVar68=FUNC64(Var1,Var9+2,&Var70); \nVar74=strlen(Var9+2); \nFUNC43(Var1,Var74); \nconst STRUCT6 *Var44=(const STRUCT6 *) FUNC65(Var9+2); \nif (Var74>0){\nSTRUCT9 *Var82=FUNC50(Var44,Var74); \nSTRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC25(Var1->memberVar9,STRING,1); \nif (Var83){\nif (Var14){\nFUNC52(Var14); \nVar14=Var83; \nif (Var15){\nFUNC25(Var1->memberVar9,STRING,1); \nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); \nFUNC43(Var1,Var74); \n*Var9=; \nchar *Var91=Var9-2; \nwhile (Var91>Var2){\nif (!FUNC66(*Var91)){\n*Var91=0; \nVar91  Var75; \nVar9=FUNC67(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nelse \n*Var10=0; \nif (!Var10[1]){\nFUNC43(\nVar1,FUNC47(Var1->memberVar6,Var10+1)); \nVar66=FUNC67(Var9+1); \nmemberVar2=FUNC47(Var1->memberVar6,Var66); \nif (FUNC68((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC69(Var1->memberVar13,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var40=*Var66; \nif (Var40 == -||Var40 == +){\nmemberVar2=Var1->memberVar12+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var83=Var14; \nif (Var83){\nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,memberVar2,FUNC70(Var83)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar18=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var92=Var9+3; \nwhile (*Var92&&*Var92 == ){\nVar92  Var31; \nVar17=FUNC71(Var1,Var2,Var92); \nelse \nVar17=FUNC72(Var1,Var2,Var9+2); \nelse \nbool  memberVar11=false ; \nconst char *Var93[]={STRING,STRING,STRING,\nconst char *Var94[]={STRING,STRING,STRING,\nSTRUCT4  Var95[FUNC73(Var93)-1],Var96[FUNC73(Var94)-1]; \nif (Var9[1]== (){\nchar *Var97=Var9+3; \nchar *Var30=strchr(Var97,); \nif (!Var30){\nfree(Var69); \n*Var30=Var98; \nSTRUCT4  Var99=FUNC47(Var1->memberVar6,Var97); \nSTRUCT4  Var100=FUNC47(Var1->memberVar6,Var30+1); \nfor (Var16=0; Var93[Var16]; Var16  Var31){\nVar95[Var16]=FUNC23(Var1->memberVar9,Var93[Var16]); \nfor (Var16=0; Var94[Var16]; Var16  Var31){\nVar96[Var16]=FUNC23(Var1->memberVar9,Var94[Var16]); \nfor (Var16=0; Var93[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var93[Var16],Var99); \nfor (Var16=0; Var94[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var94[Var16],Var100); \nif (Var19){\nif (Var64){\nVar1->memberVar12=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC67(Var2)); \nelse \nif (Var64){\nif (Var9[1]){\nFUNC45(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC67(Var2)); \nif (memberVar11){\nfor (Var16=0; Var93[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var93[Var16],Var95[Var16]); \nfor (Var16=0; Var94[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var94[Var16],Var96[Var16]); \nif (Var10){\n*Var10=!; \nif (Var72 != -1){\nFUNC62(Var1->memberVar1,Var72); \nif (Var14){\nif (Var15){\nFUNC25(Var1->memberVar9,STRING,0); \nFUNC52(Var14); \nif (Var67){\nFUNC74(Var1->memberVar9,STRING,Var65); \nif (Var69){\nFUNC8(Var1,Var69); \nFUNC75(Var69); \nif (Var71){\nFUNC76(Var1->memberVar13); \n*Var9=; \nVar61=Var17; \nVar61=Var2 FUNC4(Var1->memberVar5,FUNC67(Var2)) false ; \nFUNC77(Var13); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nif (Var14){\nFUNC52(Var14); \nif (memberVar11){\n*memberVar11=Var26; \nif (Var28 != -1){\nFUNC25(Var1->memberVar9,STRING,Var28); \nreturn  Var61; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 198,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2787,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var28,*Var29; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var30; \nVar29=*Var2 FUNC5(Var2) NULL ; \nif (!Var29||!*Var29){\nFUNC6(STRINGFUNC7(%Var31).,Var2); \nelse \nchar *Var32=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var32){\nchar *Var33=strchr(Var29+1,); \nconst bool  Var34=Var29[2]== >; \nVar28=strdup(Var2); \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var29){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37\nif (Var9&&(Var9[1]== ||Var9[1]==  Var38)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var40=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var41=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var42=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var42,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var30){\nchar  Var43[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var30){\nif (!*Var11){\nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var44=1; \nint  Var45=FUNC20(Var1->memberVar8,STRING); \nint  Var46=false ; \nint  Var47=FUNC20(Var1->memberVar8,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC21(Var9[-2])){\nchar *Var48=Var9-1; \nconst bool  Var49=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var50=FUNC22(Var1,Var2); \nchar *Var51=FUNC23(Var1->memberVar5,Var11,1); \nchar *Var52=FUNC24(STRING,Var51,Var50); \nelse \nchar *Var53=FUNC24(STRING,Var50); \nelse \nchar *Var53=FUNC24(STRING,Var50); \nelse \n}else if (Var44>0){\nif (Var18 != -1){\nVar17=FUNC12(Var1,Var2); \nconst char *Var54=FUNC25(Var1->memberVar8,STRING); \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nbool  Var55=false ; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var55){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \nif (Var9[1]== !){\nVar11=FUNC26(Var1,Var9+1); \nelse \nint  Var47=FUNC20(Var1->memberVar8,STRING); \nVar11=FUNC22(Var1,Var9+1); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nVar2=FUNC27(strdup(Var2),Var11); \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var31=strstr(Var2,STRING); \nif (Var31){\nbool  Var56=false ; \nif (Var56){\nif (*Var2 != .){\nVar13=FUNC28(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar9=Var9 true false ; \nint  Var57=0; \nif (Var9){\nchar *Var58,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var59=Var1->memberVar10; \nbool  Var60=false ; \nchar *Var61=NULL ; \nconst char *Var62=NULL ; \nbool  Var63=false ; \nbool  Var64=false ; \nchar *Var65=NULL ; \nchar *Var66=NULL ; \nbool  Var67=false ; \nint  Var68=-1; \nint  Var69,Var70; \nSTRUCT6 *Var43; \n*Var9  Var30=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var30){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var71; \nVar9=FUNC29(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var72=strdup(Var9+2); \nchar *Var73=strchr(Var72,=); \nif (Var73){\n*Var73  Var30=0; \nFUNC30(Var72,Var73); \nFUNC31(Var5,Var72); \nelse \nfree(Var72); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); \nFUNC33(Var1,FUNC34((Var74) Var59-(Var74) Var1->memberVar10)); \nelse \nVar59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); \nFUNC35(Var1,Var59,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar67=FUNC36(Var1->memberVar11,Var9+2); \nint  Var75=(int ) FUNC37(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var76=FUNC38(Var1->memberVar12,Var1->memberVar10); \nif (Var76){\nif (Var75<0){\nVar75=Var76->memberVar1+Var75; \nif (Var75 >= 0&&Var75<Var76->memberVar1){\nSTRUCT8  Var77=FUNC39(Var76,Var75); \nFUNC35(Var1,Var76->memberVar2+Var77,1); \nVar58=FUNC40(Var9+2,&Var69); \nif (Var58){\nSTRUCT9 *Var78=FUNC41((const STRUCT6 *) Var58,Var69); \nSTRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var14){\nFUNC43(Var14); \nVar14=Var79; \nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); \nif (Var43){\nmemcpy(Var1->memberVar13,Var58,Var69); \nfree(Var58); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var81; \nchar *Var82=strdup(Var9+2); \nchar *Var83=FUNC46(Var82); \nif (Var83){\nchar  Var39=*Var83; \n*Var83=0; \nVar81=FUNC47(Var1->memberVar14,Var82); \n*Var83=Var39; \nelse \nVar81=FUNC47(Var1->memberVar14,Var9+2); \nFUNC35(Var1,Var81,1); \nfree(Var82); \nVar63=FUNC48(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var61); \nSTRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC49(Var1,Var9+2); \nif (!Var65){\nVar65=Var2; \nelse \nVar65=FUNC50(Var65,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar43=malloc(strlen(Var9+2)+1); \nif (Var43){\nVar70=FUNC51(Var9+2,Var43); \nFUNC33(Var1,FUNC34(Var70)); \nif (Var70>0){\nSTRUCT9 *Var78=FUNC41(Var43,Var70); \nSTRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var14){\nFUNC43(Var14); \nVar14=Var79; \nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); \nFUNC33(Var1,Var70); \nfree(Var43); \nchar *Var84=FUNC52(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var84){\nFUNC35(Var1,FUNC37(Var1->memberVar6,Var84),1); \nfree(Var84); \nif (Var9[1]== ){\nFUNC53(Var1->memberVar1,FUNC54(Var9+2)); \nif (Var9[1]== ){\nchar *Var33=strchr(Var9+2,); \nif (Var33){\n*Var33  Var30=0; \nint  Var85=FUNC37(Var1->memberVar6,Var33); \nVar63=FUNC48(Var1,Var85,&Var61); \nVar64=FUNC55(Var1,Var9+2,&Var66); \nVar70=strlen(Var9+2); \nFUNC33(Var1,Var70); \nconst STRUCT6 *Var43=(const STRUCT6 *) FUNC56(Var9+2); \nif (Var70>0){\nSTRUCT9 *Var78=FUNC41(Var43,Var70); \nSTRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var14){\nFUNC43(Var14); \nVar14=Var79; \nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); \nFUNC33(Var1,Var70); \n*Var9=; \nchar *Var86=Var9-2; \nwhile (Var86>Var2){\nif (!FUNC57(*Var86)){\n*Var86=0; \nVar86  Var71; \nVar9=FUNC58(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar62=FUNC58(Var9+1); \nmemberVar2=FUNC37(Var1->memberVar6,Var62); \nif (FUNC59((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC60(Var1->memberVar11,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var39=*Var62; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar10+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var79=Var14; \nif (Var79){\nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC61(Var79)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar16=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var87=Var9+3; \nwhile (*Var87&&*Var87 == ){\nVar87  Var30; \nVar17=FUNC62(Var1,Var2,Var87); \nelse \nVar17=FUNC63(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var88[]={STRING,STRING,STRING,\nconst char *Var89[]={STRING,STRING,STRING,\nSTRUCT4  Var90[FUNC64(Var88)-1],Var91[FUNC64(Var89)-1]; \nif (Var9[1]== (){\nchar *Var92=Var9+3; \nchar *Var29=strchr(Var92,); \nif (!Var29){\nfree(Var65); \n*Var29=Var93; \nSTRUCT4  Var94=FUNC37(Var1->memberVar6,Var92); \nSTRUCT4  Var95=FUNC37(Var1->memberVar6,Var29+1); \nfor (Var16=0; Var88[Var16]; Var16  Var30){\nVar90[Var16]=FUNC20(Var1->memberVar8,Var88[Var16]); \nfor (Var16=0; Var89[Var16]; Var16  Var30){\nVar91[Var16]=FUNC20(Var1->memberVar8,Var89[Var16]); \nfor (Var16=0; Var88[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var88[Var16],Var94); \nfor (Var16=0; Var89[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var89[Var16],Var95); \nif (Var19){\nif (Var60){\nVar1->memberVar10=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC58(Var2)); \nelse \nif (Var60){\nif (Var9[1]){\nFUNC35(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC58(Var2)); \nif (memberVar9){\nfor (Var16=0; Var88[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var88[Var16],Var90[Var16]); \nfor (Var16=0; Var89[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var89[Var16],Var91[Var16]); \nif (Var68 != -1){\nFUNC53(Var1->memberVar1,Var68); \nif (Var14){\nif (Var15){\nFUNC65(Var1->memberVar8,STRING,0); \nFUNC43(Var14); \nif (Var63){\nFUNC66(Var1->memberVar8,STRING,Var61); \nif (Var65){\nFUNC8(Var1,Var65); \nFUNC67(Var65); \nif (Var67){\nFUNC68(Var1->memberVar11); \n*Var9=; \nVar57=Var17; \nVar57=Var2 FUNC4(Var1->memberVar5,FUNC58(Var2)) false ; \nif (Var20 != -1){\nFUNC65(Var1->memberVar8,STRING,Var20); \nif (Var21 != -1){\nFUNC65(Var1->memberVar8,STRING,Var21); \nif (Var14){\nFUNC43(Var14); \nreturn  Var57; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 199,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2814,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var28,*Var29; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var30; \nVar29=*Var2 FUNC5(Var2) NULL ; \nif (!Var29||!*Var29){\nFUNC6(STRINGFUNC7(%Var31).,Var2); \nelse \nchar *Var32=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var32){\nchar *Var33=strchr(Var29+1,); \nconst bool  Var34=Var29[2]== >; \nVar28=strdup(Var2); \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var29){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37\nif (Var9&&(Var9[1]== ||Var9[1]==  Var38)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var40=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var41=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var42=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var42,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var30){\nFUNC6(STRING,Var11); \nchar  Var43[1024]; \nint  Var17; \nif (FUNC20(stdin)){\nif (Var1->memberVar7){\nif (!strcmp(Var43,Var11)){\nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var30){\nif (!*Var11){\nFUNC6(STRING,Var11); \nVar1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); \nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nreturn FUNC22(Var1,(const char *) Var1->memberVar7); \nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var44=1; \nint  Var45=FUNC23(Var1->memberVar9,STRING); \nint  Var46=false ; \nint  Var47=FUNC23(Var1->memberVar9,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC24(Var9[-2])){\nchar *Var48=Var9-1; \nif (*Var48 ==  Var49){//STRING\nVar20=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,true ); \nif (!strcmp(Var11,STRING)){\nFUNC25(Var1->memberVar9,STRING,Var50); \nconst bool  Var51=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var52=FUNC26(Var1,Var2); \nif (Var51){\nchar *Var53=FUNC27(Var1->memberVar5,Var11,1); \nif (Var53){\nchar *Var54=FUNC28(STRING,Var53,Var52); \nif (Var54){\nFUNC29(Var1->memberVar5,Var11,Var54,1); \nfree(Var54); \nelse \nchar *Var55=FUNC28(STRING,Var52); \nFUNC29(Var1->memberVar5,Var11,Var55,1); \nelse \nchar *Var55=FUNC28(STRING,Var52); \nFUNC29(Var1->memberVar5,Var11,Var55,1); \nelse \n}else if (Var44>0){\nif (Var18 != -1){\nif (!Var45){\nFUNC25(Var1->memberVar9,STRING,Var50); \nVar17=FUNC12(Var1,Var2); \nif (!Var45){\nFUNC25(Var1->memberVar9,STRING,Var47); \nif (Var46){\nconst char *Var56=FUNC30(Var1->memberVar9,STRING); \nif (Var56&&*Var56){\nFUNC31(STRING,Var56,Var11); \nFUNC25(Var1->memberVar9,STRING,Var47); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nVar1->memberVar10->memberVar1=false ; \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nbool  Var57=false ; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var57){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \nif (Var9[1]== !){\nVar11=FUNC32(Var1,Var9+1); \nelse \nint  Var47=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,0); \nVar11=FUNC26(Var1,Var9+1); \nFUNC25(Var1->memberVar9,STRING,Var47); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nVar2=FUNC33(strdup(Var2),Var11); \nVar1->memberVar6->memberVar1=memberVar1; \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (*Var2 != &&*Var2){\nconst char *Var31=strstr(Var2,STRING); \nif (Var31){\nbool  Var58=false ; \nif (Var58){\nif (*Var2 != .){\nVar13=FUNC34(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar11=Var9 true false ; \nint  Var59=0; \nif (Var9){\nchar *Var60,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var61=Var1->memberVar12; \nbool  Var62=false ; \nchar *Var63=NULL ; \nconst char *Var64=NULL ; \nbool  Var65=false ; \nbool  Var66=false ; \nchar *Var67=NULL ; \nchar *Var68=NULL ; \nbool  Var69=false ; \nint  Var70=-1; \nint  Var71,Var72; \nSTRUCT6 *Var43; \n*Var9  Var30=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var30){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var73; \nVar9=FUNC35(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var74=strdup(Var9+2); \nchar *Var75=strchr(Var74,=); \nif (Var75){\n*Var75  Var30=0; \nFUNC36(Var74,Var75); \nFUNC37(Var5,Var74); \nelse \nfree(Var74); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+4); \nFUNC39(Var1,FUNC40((Var76) Var61-(Var76) Var1->memberVar12)); \nelse \nVar61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+3); \nFUNC41(Var1,Var61,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar69=FUNC42(Var1->memberVar13,Var9+2); \nint  Var77=(int ) FUNC43(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var78=FUNC44(Var1->memberVar14,Var1->memberVar12); \nif (Var78){\nif (Var77<0){\nVar77=Var78->memberVar1+Var77; \nif (Var77 >= 0&&Var77<Var78->memberVar1){\nSTRUCT8  Var79=FUNC45(Var78,Var77); \nFUNC41(Var1,Var78->memberVar2+Var79,1); \nVar60=FUNC21(Var9+2,&Var71); \nif (Var60){\nSTRUCT9 *Var80=FUNC46((const STRUCT6 *) Var60,Var71); \nSTRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); \nif (Var81){\nif (Var14){\nFUNC48(Var14); \nVar14=Var81; \nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); \nif (Var43){\nmemcpy(Var1->memberVar15,Var60,Var71); \nfree(Var60); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var83; \nchar *Var84=strdup(Var9+2); \nchar *Var85=FUNC51(Var84); \nif (Var85){\nchar  Var39=*Var85; \n*Var85=0; \nVar83=FUNC52(Var1->memberVar16,Var84); \n*Var85=Var39; \nelse \nVar83=FUNC52(Var1->memberVar16,Var9+2); \nFUNC41(Var1,Var83,1); \nfree(Var84); \nVar65=FUNC53(Var1,FUNC43(Var1->memberVar6,Var9+2),&Var63); \nSTRUCT4  memberVar2=FUNC43(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC54(Var1,Var9+2); \nif (!Var67){\nVar67=Var2; \nelse \nVar67=FUNC55(Var67,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar43=malloc(strlen(Var9+2)+1); \nif (Var43){\nVar72=FUNC56(Var9+2,Var43); \nFUNC39(Var1,FUNC40(Var72)); \nif (Var72>0){\nSTRUCT9 *Var80=FUNC46(Var43,Var72); \nSTRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); \nif (Var81){\nif (Var14){\nFUNC48(Var14); \nVar14=Var81; \nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); \nFUNC39(Var1,Var72); \nfree(Var43); \nchar *Var86=FUNC57(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var86){\nFUNC41(Var1,FUNC43(Var1->memberVar6,Var86),1); \nfree(Var86); \nif (Var9[1]== ){\nFUNC58(Var1->memberVar1,FUNC59(Var9+2)); \nif (Var9[1]== ){\nchar *Var33=strchr(Var9+2,); \nif (Var33){\n*Var33  Var30=0; \nint  Var87=FUNC43(Var1->memberVar6,Var33); \nVar65=FUNC53(Var1,Var87,&Var63); \nVar66=FUNC60(Var1,Var9+2,&Var68); \nVar72=strlen(Var9+2); \nFUNC39(Var1,Var72); \nconst STRUCT6 *Var43=(const STRUCT6 *) FUNC61(Var9+2); \nif (Var72>0){\nSTRUCT9 *Var80=FUNC46(Var43,Var72); \nSTRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); \nif (Var81){\nif (Var14){\nFUNC48(Var14); \nVar14=Var81; \nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); \nFUNC39(Var1,Var72); \n*Var9=; \nchar *Var88=Var9-2; \nwhile (Var88>Var2){\nif (!FUNC62(*Var88)){\n*Var88=0; \nVar88  Var73; \nVar9=FUNC63(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar64=FUNC63(Var9+1); \nmemberVar2=FUNC43(Var1->memberVar6,Var64); \nif (FUNC64((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC65(Var1->memberVar13,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var39=*Var64; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar12+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var81=Var14; \nif (Var81){\nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,memberVar2,FUNC66(Var81)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar18=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var89=Var9+3; \nwhile (*Var89&&*Var89 == ){\nVar89  Var30; \nVar17=FUNC67(Var1,Var2,Var89); \nelse \nVar17=FUNC68(Var1,Var2,Var9+2); \nelse \nbool  memberVar11=false ; \nconst char *Var90[]={STRING,STRING,STRING,\nconst char *Var91[]={STRING,STRING,STRING,\nSTRUCT4  Var92[FUNC69(Var90)-1],Var93[FUNC69(Var91)-1]; \nif (Var9[1]== (){\nchar *Var94=Var9+3; \nchar *Var29=strchr(Var94,); \nif (!Var29){\nfree(Var67); \n*Var29=Var95; \nSTRUCT4  Var96=FUNC43(Var1->memberVar6,Var94); \nSTRUCT4  Var97=FUNC43(Var1->memberVar6,Var29+1); \nfor (Var16=0; Var90[Var16]; Var16  Var30){\nVar92[Var16]=FUNC23(Var1->memberVar9,Var90[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var30){\nVar93[Var16]=FUNC23(Var1->memberVar9,Var91[Var16]); \nfor (Var16=0; Var90[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var90[Var16],Var96); \nfor (Var16=0; Var91[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var91[Var16],Var97); \nif (Var19){\nif (Var62){\nVar1->memberVar12=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC63(Var2)); \nelse \nif (Var62){\nif (Var9[1]){\nFUNC41(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC63(Var2)); \nif (memberVar11){\nfor (Var16=0; Var90[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var90[Var16],Var92[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var91[Var16],Var93[Var16]); \nif (Var70 != -1){\nFUNC58(Var1->memberVar1,Var70); \nif (Var14){\nif (Var15){\nFUNC25(Var1->memberVar9,STRING,0); \nFUNC48(Var14); \nif (Var65){\nFUNC70(Var1->memberVar9,STRING,Var63); \nif (Var67){\nFUNC8(Var1,Var67); \nFUNC71(Var67); \nif (Var69){\nFUNC72(Var1->memberVar13); \n*Var9=; \nVar59=Var17; \nVar59=Var2 FUNC4(Var1->memberVar5,FUNC63(Var2)) false ; \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nif (Var14){\nFUNC48(Var14); \nreturn  Var59; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 200,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2826,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC26(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC30(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC32(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC37(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC38(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC38(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC40(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC28(Var1,FUNC29(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nFUNC41(Var1); \nchar *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC43(Var1->memberVar1,FUNC44(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC39(Var1,Var83,&Var60); \nVar63=FUNC45(Var1,Var6+2,&Var65); \nFUNC28(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC28(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC47((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC48(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC41(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC50(Var1,Var2,Var85); \nelse \nVar14=FUNC51(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC41(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC28(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC54(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC43(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC54(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC28(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC55(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 201,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 2827,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nfree(Var50); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nif (Var52&&*Var52){\nFUNC26(STRING,Var52,Var8); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC27(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC31(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC33(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC38(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC39(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC39(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC41(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC29(Var1,FUNC30(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nFUNC42(Var1); \nchar *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC44(Var1->memberVar1,FUNC45(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC40(Var1,Var83,&Var60); \nVar63=FUNC46(Var1,Var6+2,&Var65); \nFUNC29(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC29(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC48((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC49(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC42(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC51(Var1,Var2,Var85); \nelse \nVar14=FUNC52(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC42(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC29(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC55(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC44(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC55(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC29(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC56(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 202,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 2835,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\twrite (1, \"> \", 2);\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=Var6->memberVar2; \nbool  Var11=Var6->memberVar3; \nSTRUCT1  Var12=Var6->memberVar4; \nif (!Var13){\nswitch (*Var13){\nif (Var13[1]== ){/*STRUCT2 */\nelse \nchar *Var14=strchr(Var13,; ); \nif (Var13[1]!= *&&!strstr(Var13,STRING)){\nif (Var13[1]== >){\nif (*Var13 != ){\nif (Var15&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var13){\nchar *Var16=Var2-1; \nif (*Var16 == ){\nchar *Var3=strchr(Var13,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var17=Var6->memberVar5->memberVar1; \nelse \nchar *Var18=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var13||Var2[-1]!= )){\nif (*Var13 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var19[1024]; \nint  Var8; \nwrite(1,STRING,2); \nif (FUNC4(stdin)){\nif (Var6->memberVar6){\nif (!strcmp(Var19,Var4)){\nchar *Var16=Var2-1; \nint  Var20=FUNC5(Var6->memberVar7,STRING); \nint  Var21=FUNC5(Var6->memberVar7,STRING); \nchar *Var22=Var2-1; \nconst bool  Var23=(Var2[1]== >); \nchar *Var24=FUNC6(Var6,Var13); \nchar *Var25=FUNC7(Var6->memberVar8,Var4,1); \nconst char *Var26=FUNC8(Var6->memberVar7,STRING); \nchar *Var16=Var2-1; \nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nelse \nint  Var21=FUNC5(Var6->memberVar7,STRING); \nconst char *Var27=strstr(Var13,STRING); \nchar *Var28,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var29=Var6->memberVar9; \nSTRUCT3 *Var19; \nchar *Var30=strdup(Var2+2); \nSTRUCT1  Var29=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); \nint  Var31=(int ) FUNC10(Var6->memberVar5,Var2+2); \nSTRUCT4 *Var32=FUNC11(Var6->memberVar10,Var6->memberVar9); \nSTRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); \nchar *Var36=strdup(Var2+2); \nchar  Var16=*Var37; \nSTRUCT1  Var29=FUNC10(Var6->memberVar5,Var2+2); \nchar *Var13=FUNC13(Var6,Var2+2); \nSTRUCT6 *Var34=FUNC14(Var19,Var38); \nSTRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); \nchar *Var39=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var40=strchr(Var2+2,); \nint  Var41=FUNC10(Var6->memberVar5,Var40); \nconst STRUCT3 *Var19=(const STRUCT3 *) FUNC16(Var2+2); \nSTRUCT6 *Var34=FUNC14(Var19,Var38); \nSTRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); \nchar *Var42=Var2-2; \nelse \nchar  Var16=*Var43; \nchar *Var44=Var2+3; \nchar *Var45=Var2+3; \nSTRUCT1  Var46=FUNC10(Var6->memberVar5,Var45); \nSTRUCT1  Var47=FUNC10(Var6->memberVar5,Var48+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 203,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 2836,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=Var6->memberVar2; \nbool  Var11=Var6->memberVar3; \nSTRUCT1  Var12=Var6->memberVar4; \nif (!Var13){\nswitch (*Var13){\nif (Var13[1]== ){/*STRUCT2 */\nelse \nchar *Var14=strchr(Var13,; ); \nif (Var13[1]!= *&&!strstr(Var13,STRING)){\nif (Var13[1]== >){\nif (*Var13 != ){\nif (Var15&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var13){\nchar *Var16=Var2-1; \nif (*Var16 == ){\nchar *Var3=strchr(Var13,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var17=Var6->memberVar5->memberVar1; \nelse \nchar *Var18=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var13||Var2[-1]!= )){\nif (*Var13 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var19[1024]; \nint  Var8; \nfgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21\nif (FUNC4(stdin)){\nif (*Var19) Var19[strlen(Var19)-1]=0; \nVar8=strlen(Var19); \nif (Var6->memberVar6){\nif (!strcmp(Var19,Var4)){\nstrcat((char *) Var6->memberVar6,Var19); \nchar *Var16=Var2-1; \nint  Var22=FUNC5(Var6->memberVar7,STRING); \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nchar *Var24=Var2-1; \nconst bool  Var25=(Var2[1]== >); \nchar *Var26=FUNC6(Var6,Var13); \nchar *Var27=FUNC7(Var6->memberVar8,Var4,1); \nconst char *Var28=FUNC8(Var6->memberVar7,STRING); \nchar *Var16=Var2-1; \nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nelse \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nconst char *Var29=strstr(Var13,STRING); \nchar *Var30,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var31=Var6->memberVar9; \nSTRUCT4 *Var19; \nchar *Var32=strdup(Var2+2); \nSTRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); \nint  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); \nSTRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var38=strdup(Var2+2); \nchar  Var16=*Var39; \nSTRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); \nchar *Var13=FUNC13(Var6,Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var42=strchr(Var2+2,); \nint  Var43=FUNC10(Var6->memberVar5,Var42); \nconst STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var44=Var2-2; \nelse \nchar  Var16=*Var45; \nchar *Var46=Var2+3; \nchar *Var47=Var2+3; \nSTRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); \nSTRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 204,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2840,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=Var6->memberVar2; \nbool  Var11=Var6->memberVar3; \nSTRUCT1  Var12=Var6->memberVar4; \nif (!Var13){\nswitch (*Var13){\nif (Var13[1]== ){/*STRUCT2 */\nelse \nchar *Var14=strchr(Var13,; ); \nif (Var13[1]!= *&&!strstr(Var13,STRING)){\nif (Var13[1]== >){\nif (*Var13 != ){\nif (Var15&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var13){\nchar *Var16=Var2-1; \nif (*Var16 == ){\nchar *Var3=strchr(Var13,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var17=Var6->memberVar5->memberVar1; \nelse \nchar *Var18=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var13||Var2[-1]!= )){\nif (*Var13 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var19[1024]; \nint  Var8; \nfgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21\nif (FUNC4(stdin)){\nif (*Var19) Var19[strlen(Var19)-1]=0; \nVar8=strlen(Var19); \nif (Var6->memberVar6){\nif (!strcmp(Var19,Var4)){\nstrcat((char *) Var6->memberVar6,Var19); \nchar *Var16=Var2-1; \nint  Var22=FUNC5(Var6->memberVar7,STRING); \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nchar *Var24=Var2-1; \nconst bool  Var25=(Var2[1]== >); \nchar *Var26=FUNC6(Var6,Var13); \nchar *Var27=FUNC7(Var6->memberVar8,Var4,1); \nconst char *Var28=FUNC8(Var6->memberVar7,STRING); \nchar *Var16=Var2-1; \nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nelse \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nconst char *Var29=strstr(Var13,STRING); \nchar *Var30,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var31=Var6->memberVar9; \nSTRUCT4 *Var19; \nchar *Var32=strdup(Var2+2); \nSTRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); \nint  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); \nSTRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var38=strdup(Var2+2); \nchar  Var16=*Var39; \nSTRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); \nchar *Var13=FUNC13(Var6,Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var42=strchr(Var2+2,); \nint  Var43=FUNC10(Var6->memberVar5,Var42); \nconst STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var44=Var2-2; \nelse \nchar  Var16=*Var45; \nchar *Var46=Var2+3; \nchar *Var47=Var2+3; \nSTRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); \nSTRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 205,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2841,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=false ; \nint  Var11=-1; \nint  Var12=-1; \nbool  Var13=false ; \nbool  Var14=false ; \nbool  Var15=Var6->memberVar2; \nbool  Var16=Var6->memberVar3; \nbool  Var17=false ; \nSTRUCT1  Var18=Var6->memberVar4; \nif (!Var19){\nswitch (*Var19){\nif (Var19[1]== ){/*STRUCT2 */\nint  Var9=-1; \nelse \nchar *Var20=strchr(Var19,; ); \nif (Var19[1]!= *&&!strstr(Var19,STRING)){\nif (Var19[1]== >){\nif (*Var19 != ){\nif (Var21&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var19){\nchar *Var22=Var2-1; \nif (*Var22 == ){\nchar *Var3=strchr(Var19,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var23=Var6->memberVar5->memberVar1; \nelse \nchar *Var24=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var19||Var2[-1]!= )){\nif (*Var19 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var25[1024]; \nint  Var8; \nfgets(Var25,sizeof (Var25)-1,stdin); //Var26  STRUCT3  Var27\nif (FUNC4(stdin)){\nif (*Var25) Var25[strlen(Var25)-1]=0; \nVar8=strlen(Var25); \nVar6->memberVar6  STRUCT4  Var8; \nVar6->memberVar7=realloc(Var6->memberVar7,Var6->memberVar6+1); \nif (Var6->memberVar7){\nif (!strcmp(Var25,Var4)){\nstrcat((char *) Var6->memberVar7,Var25); \nif (!*Var4){\nif (!Var6->memberVar7){\nelse \n}else if (Var2 ==  Var19){\nif (Var2){\nif (Var2>Var19){\nchar *Var22=Var2-1; \nif (*Var22 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var28=1; \nint  Var29=FUNC5(Var6->memberVar8,STRING); \nint  Var30=false ; \nint  Var31=FUNC5(Var6->memberVar8,STRING); \nif (!*Var4){\nif (Var2>(Var19+1)&&FUNC6(Var2[-2])){\nchar *Var32=Var2-1; \nif (*Var32 ==  Var33){//STRING\nVar11=FUNC5(Var6->memberVar8,STRING); \nFUNC7(Var6->memberVar8,STRING,true ); \nif (!strcmp(Var4,STRING)){\nFUNC7(Var6->memberVar8,STRING,Var34); \nconst bool  Var35=(Var2[1]== >); \nif (*Var4 == ){\nchar *Var36=FUNC8(Var6,Var19); \nif (Var35){\nchar *Var37=FUNC9(Var6->memberVar9,Var4,1); \nif (Var37){\nchar *Var38=FUNC10(STRING,Var37,Var36); \nif (Var38){\nFUNC11(Var6->memberVar9,Var4,Var38,1); \nfree(Var38); \nelse \nchar *Var39=FUNC10(STRING,Var36); \nFUNC11(Var6->memberVar9,Var4,Var39,1); \nelse \nchar *Var39=FUNC10(STRING,Var36); \nFUNC11(Var6->memberVar9,Var4,Var39,1); \nelse \n}else if (Var28>0){\nif (Var9 != -1){\nif (!Var29){\nFUNC7(Var6->memberVar8,STRING,Var34); \nif (!Var29){\nFUNC7(Var6->memberVar8,STRING,Var31); \nif (Var30){\nconst char *Var40=FUNC12(Var6->memberVar8,STRING); \nif (Var40&&*Var40){\nFUNC13(STRING,Var40,Var4); \nFUNC7(Var6->memberVar8,STRING,Var31); \nif (Var11 != -1){\nFUNC7(Var6->memberVar8,STRING,Var11); \nif (Var12 != -1){\nFUNC7(Var6->memberVar8,STRING,Var12); \nVar6->memberVar10->memberVar1=false ; \nreturn  Var8; \nif (Var2){\nif (Var2>Var19){\nchar *Var22=Var2-1; \nif (*Var22 == ){\nbool  Var41=false ; \nif (Var41){\nelse \n}else if (!Var3){\nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nif (Var2[1]== !){\nelse \nint  Var31=FUNC5(Var6->memberVar8,STRING); \nFUNC7(Var6->memberVar8,STRING,0); \nFUNC7(Var6->memberVar8,STRING,Var31); \nif (!Var4){\nif (*Var4 == |||*Var4 == *){\nVar6->memberVar5->memberVar1=memberVar1; \nif (Var11 != -1){\nFUNC7(Var6->memberVar8,STRING,Var11); \nif (*Var19 != &&*Var19){\nconst char *Var42=strstr(Var19,STRING); \nif (Var42){\nbool  Var43=false ; \nif (Var43){\nchar *Var44,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var45=Var6->memberVar11; \nbool  Var46=false ; \nbool  Var47=false ; \nbool  Var48=false ; \nbool  Var49=false ; \nSTRUCT5 *Var25; \nchar *Var50=strdup(Var2+2); \nSTRUCT1  Var45=FUNC14(Var6->memberVar5,Var6->memberVar11,Var2+4); \nint  Var51=(int ) FUNC15(Var6->memberVar5,Var2+2); \nSTRUCT6 *Var52=FUNC16(Var6->memberVar12,Var6->memberVar11); \nSTRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); \nchar *Var56=strdup(Var2+2); \nchar  Var22=*Var57; \nSTRUCT1  Var45=FUNC15(Var6->memberVar5,Var2+2); \nchar *Var19=FUNC18(Var6,Var2+2); \nSTRUCT8 *Var54=FUNC19(Var25,Var58); \nSTRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); \nchar *Var59=FUNC20(Var6->memberVar13,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var60=strchr(Var2+2,); \nint  Var61=FUNC15(Var6->memberVar5,Var60); \nconst STRUCT5 *Var25=(const STRUCT5 *) FUNC21(Var2+2); \nSTRUCT8 *Var54=FUNC19(Var25,Var58); \nSTRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); \nchar *Var62=Var2-2; \nelse \nchar  Var22=*Var63; \nchar *Var64=Var2+3; \nelse \nbool  Var65=false ; \nchar *Var66=Var2+3; \nSTRUCT1  Var67=FUNC15(Var6->memberVar5,Var66); \nSTRUCT1  Var68=FUNC15(Var6->memberVar5,Var69+1); \nif (Var11 != -1){\nFUNC7(Var6->memberVar8,STRING,Var11); \nif (Var12 != -1){\nFUNC7(Var6->memberVar8,STRING,Var12); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 206,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "realloc",
    "line": 2843,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar14=strlen(Var40); \nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nfree(Var50); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nif (Var52&&*Var52){\nFUNC26(STRING,Var52,Var8); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC27(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC31(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC33(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC38(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC39(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC39(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC41(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC29(Var1,FUNC30(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nFUNC42(Var1); \nchar *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC44(Var1->memberVar1,FUNC45(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC40(Var1,Var83,&Var60); \nVar63=FUNC46(Var1,Var6+2,&Var65); \nFUNC29(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC29(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC48((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC49(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC42(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC51(Var1,Var2,Var85); \nelse \nVar14=FUNC52(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC42(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC29(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC55(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC44(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC55(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC29(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC56(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 207,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2845,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var23){\nFUNC8(STRING,Var9); \nchar  Var24[1024]; \nint  Var12; \nfgets(Var24,sizeof (Var24)-1,stdin); //Var25  STRUCT4  Var26\nif (FUNC9(stdin)){\nif (*Var24) Var24[strlen(Var24)-1]=0; \nVar12=strlen(Var24); \nif (Var1->memberVar6){\nif (!strcmp(Var24,Var9)){\nstrcat((char *) Var1->memberVar6,Var24); \nchar *Var20=Var7-1; \nint  Var27=FUNC10(Var1->memberVar7,STRING); \nint  Var28=FUNC10(Var1->memberVar7,STRING); \nchar *Var29=Var7-1; \nconst bool  Var30=(Var7[1]== >); \nchar *Var31=FUNC11(Var1,Var2); \nchar *Var32=FUNC12(Var1->memberVar8,Var9,1); \nconst char *Var33=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var28=FUNC10(Var1->memberVar7,STRING); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar9; \nSTRUCT5 *Var24; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT8 *Var42=FUNC19(Var24,Var46); \nSTRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var47=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT5 *Var24=(const STRUCT5 *) FUNC21(Var7+2); \nSTRUCT8 *Var42=FUNC19(Var24,Var46); \nSTRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 208,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcat",
    "line": 2848,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nfgets(Var40,sizeof (Var40)-1,stdin); //Var41  STRUCT5  Var42\nif (FUNC17(stdin)){\nif (*Var40) Var40[strlen(Var40)-1]=0; \nVar14=strlen(Var40); \nVar1->memberVar10  STRUCT6  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT7 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var43=1; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nint  Var45=false ; \nint  Var46=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var47=Var6-1; \nif (*Var47 ==  Var48){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var49=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var50=FUNC21(Var1,Var2); \nif (Var49){\nchar *Var51=FUNC22(Var1->memberVar5,Var8,1); \nif (Var51){\nchar *Var52=FUNC23(STRING,Var51,Var50); \nif (Var52){\nFUNC24(Var1->memberVar5,Var8,Var52,1); \nelse \nchar *Var53=FUNC23(STRING,Var50); \nFUNC24(Var1->memberVar5,Var8,Var53,1); \nelse \nchar *Var53=FUNC23(STRING,Var50); \nFUNC24(Var1->memberVar5,Var8,Var53,1); \nelse \n}else if (Var43>0){\nif (Var15 != -1){\nif (!Var44){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var44){\nFUNC11(Var1->memberVar8,STRING,Var46); \nif (Var45){\nconst char *Var54=FUNC25(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var46); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var55=false ; \nif (Var55){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC26(Var1,Var6+1); \nelse \nint  Var46=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var46); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var56=strstr(Var2,STRING); \nif (Var56){\nbool  Var57=false ; \nif (Var57){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var58=0; \nif (Var6){\nchar *Var59,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var60=Var1->memberVar6; \nbool  Var61=false ; \nchar *Var62=NULL ; \nconst char *Var63=NULL ; \nbool  Var64=false ; \nbool  Var65=false ; \nchar *Var66=NULL ; \nchar *Var67=NULL ; \nbool  Var68=false ; \nint  Var69=-1; \nint  Var70,Var71; \nSTRUCT7 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var72=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC28(Var1,FUNC29((Var73) Var60-(Var73) Var1->memberVar6)); \nelse \nVar60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var60,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar68=FUNC30(Var1->memberVar14,Var6+2); \nint  Var74=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT8 *Var75=FUNC31(Var1->memberVar15,Var1->memberVar6); \nif (Var75){\nif (Var74 >= 0&&Var74<Var75->memberVar1){\nSTRUCT9  Var76=FUNC32(Var75,Var74); \nFUNC4(Var1,Var75->memberVar2+Var76,1); \nVar23=Var1->memberVar13=true ; \nif (Var59){\nSTRUCT10 *Var77=FUNC33((const STRUCT7 *) Var59,Var70); \nSTRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); \nif (Var78){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var70; \nmemcpy(Var1->memberVar16,Var59,Var70); \nif (Var6[1]== ){\nSTRUCT3  Var80; \nchar *Var81=strdup(Var6+2); \nchar *Var82=FUNC37(Var81); \nif (Var82){\nchar  Var34=*Var82; \nVar80=FUNC38(Var1->memberVar17,Var81); \nVar80=FUNC5(Var1->memberVar7,Var83); \nelse \nVar80=FUNC38(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var80,1); \nVar23=Var1->memberVar13=true ; \nVar64=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var62); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC40(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC28(Var1,FUNC29(Var71)); \nif (Var71>0){\nSTRUCT10 *Var77=FUNC33(Var40,Var71); \nSTRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); \nif (Var78){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); \nFUNC28(Var1,Var71); \nFUNC41(Var1); \nchar *Var84=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var84){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var84),1); \nif (Var6[1]== ){\nVar69=Var1->memberVar1->STRUCT11  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC43(Var1->memberVar1,FUNC44(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var85=FUNC5(Var1->memberVar7,Var31); \nVar64=FUNC39(Var1,Var85,&Var62); \nVar65=FUNC45(Var1,Var6+2,&Var67); \nFUNC28(Var1,Var71); \nconst STRUCT7 *Var40=(const STRUCT7 *) FUNC46(Var6+2); \nif (Var71>0){\nSTRUCT10 *Var77=FUNC33(Var40,Var71); \nSTRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var78){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); \nFUNC28(Var1,Var71); \nchar *Var86=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC28(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var63); \nif (FUNC47((STRUCT7) Var6[1])&&!memberVar2){\nif (!FUNC48(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var63; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var78=Var11; \nif (Var78){\nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,memberVar2,FUNC49(Var78)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC41(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var87=Var6+3; \nVar14=FUNC50(Var1,Var2,Var87); \nelse \nVar14=FUNC51(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var88[]={STRING,STRING,STRING,\nconst char *Var89[]={STRING,STRING,STRING,\nSTRUCT3  Var90[FUNC52(Var88)-1],Var91[FUNC52(Var89)-1]; \nif (Var6[1]== (){\nchar *Var92=Var6+3; \nchar *Var29=strchr(Var92,); \nif (!Var29){\nSTRUCT3  Var93=FUNC5(Var1->memberVar7,Var92); \nSTRUCT3  Var94=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var88[Var13]; Var13  Var95){\nVar90[Var13]=FUNC10(Var1->memberVar8,Var88[Var13]); \nfor (Var13=0; Var89[Var13]; Var13  Var95){\nVar91[Var13]=FUNC10(Var1->memberVar8,Var89[Var13]); \nfor (Var13=0; Var88[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var88[Var13],Var93); \nfor (Var13=0; Var89[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var89[Var13],Var94); \nif (Var16){\nif (Var61){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nelse \nif (Var61){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC41(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nif (memberVar13){\nfor (Var13=0; Var88[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var88[Var13],Var90[Var13]); \nfor (Var13=0; Var89[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var89[Var13],Var91[Var13]); \nif (Var7){\nFUNC28(Var1,Var24); \nif (Var65){\nVar1->memberVar2=Var21; \nFUNC54(Var1->memberVar8,STRING,Var67); \nif (Var69 != -1){\nFUNC43(Var1->memberVar1,Var69); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var64){\nFUNC54(Var1->memberVar8,STRING,Var62); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC28(Var1,Var24); \nif (Var66){\nFUNC3(Var1,Var66); \nif (Var68){\nFUNC55(Var1->memberVar14); \nVar58=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 209,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2860,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC26(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC30(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC32(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC37(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC38(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC38(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC40(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC28(Var1,FUNC29(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nFUNC41(Var1); \nchar *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC43(Var1->memberVar1,FUNC44(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC39(Var1,Var83,&Var60); \nVar63=FUNC45(Var1,Var6+2,&Var65); \nFUNC28(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC28(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC47((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC48(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC41(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC50(Var1,Var2,Var85); \nelse \nVar14=FUNC51(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC41(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC28(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC54(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC43(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC54(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC28(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC55(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 210,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2883,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC9(Var1->memberVar7,STRING); \nint  Var25=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC10(Var7[-2])){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC11(Var1,Var2); \nchar *Var29=FUNC12(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nconst char *Var31=strstr(Var2,STRING); \nchar *Var32,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var33=Var1->memberVar9; \nchar *Var34=strdup(Var7+2); \nchar *Var35=strchr(Var34,=); \nSTRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var41=strdup(Var7+2); \nchar  Var20=*Var42; \nSTRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var44=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var46=Var7-2; \nelse \nchar  Var20=*Var47; \nchar *Var48=Var7+3; \nchar *Var49=Var7+3; \nchar *Var19=strchr(Var49,); \nSTRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); \nSTRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 211,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2883,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC9(Var1->memberVar7,STRING); \nint  Var25=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC10(Var7[-2])){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC11(Var1,Var2); \nchar *Var29=FUNC12(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nconst char *Var31=strstr(Var2,STRING); \nchar *Var32,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var33=Var1->memberVar9; \nchar *Var34=strdup(Var7+2); \nchar *Var35=strchr(Var34,=); \nSTRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var41=strdup(Var7+2); \nchar  Var20=*Var42; \nSTRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var44=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var46=Var7-2; \nelse \nchar  Var20=*Var47; \nchar *Var48=Var7+3; \nchar *Var49=Var7+3; \nchar *Var19=strchr(Var49,); \nSTRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); \nSTRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 212,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2920,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nint  Var13=-1; \nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=1; \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nint  Var26=false ; \nint  Var27=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nchar *Var28=Var7-1; \nconst bool  Var29=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var30=FUNC10(Var1,Var2); \nif (Var29){\nchar *Var31=FUNC11(Var1->memberVar8,Var9,1); \nif (Var31){\nchar *Var32=FUNC12(STRING,Var31,Var30); \nif (Var32){\nFUNC13(Var1->memberVar8,Var9,Var32,1); \nelse \nchar *Var33=FUNC12(STRING,Var30); \nFUNC13(Var1->memberVar8,Var9,Var33,1); \nelse \nchar *Var33=FUNC12(STRING,Var30); \nFUNC13(Var1->memberVar8,Var9,Var33,1); \nelse \n}else if (Var24>0){\nVar13=FUNC14(Var9,Var24,Var29); \nif (Var26){\nconst char *Var34=FUNC15(Var1->memberVar7,STRING); \nif (Var34&&*Var34){\nFUNC16(STRING,Var34,Var9); \nFUNC17(Var9); \nfree(Var9); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var27=FUNC9(Var1->memberVar7,STRING); \nconst char *Var35=strstr(Var2,STRING); \nchar *Var36,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var37=Var1->memberVar9; \nchar *Var38=strdup(Var7+2); \nchar *Var39=strchr(Var38,=); \nSTRUCT2  Var37=FUNC18(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var40=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var41=FUNC20(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); \nchar *Var45=strdup(Var7+2); \nchar  Var20=*Var46; \nSTRUCT2  Var37=FUNC19(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC22(Var1,Var7+2); \nSTRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); \nchar *Var47=FUNC23(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC19(Var1->memberVar5,Var18); \nconst STRUCT6 *Var49=(const STRUCT6 *) FUNC24(Var7+2); \nSTRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); \nchar *Var50=Var7-2; \nelse \nchar  Var20=*Var51; \nchar *Var52=Var7+3; \nchar *Var53=Var7+3; \nchar *Var19=strchr(Var53,); \nSTRUCT2  Var54=FUNC19(Var1->memberVar5,Var53); \nSTRUCT2  Var55=FUNC19(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 213,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2936,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nVar1->memberVar6=malloc(1); \nVar1->memberVar7=0; \nchar  Var24[1024]; \nint  Var12; \nif (FUNC8(stdin)){\nVar12=strlen(Var24); \nVar1->memberVar7  STRUCT4  Var12; \nVar1->memberVar6=realloc(Var1->memberVar6,Var1->memberVar7+1); \nif (Var1->memberVar6){\nif (!strcmp(Var24,Var9)){\nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var23){\nif (!*Var9){\nVar1->memberVar6=(STRUCT5 *) FUNC9(Var9,&Var1->memberVar7); \nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC10(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var25=FUNC11(Var1->memberVar8,STRING); \nint  Var26=FUNC11(Var1->memberVar8,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nchar *Var27=Var7-1; \nif (!strcmp(Var9,STRING)){\nVar9=FUNC12(STRING); \nconst bool  Var28=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var29=FUNC13(Var1,Var2); \nif (Var28){\nchar *Var30=FUNC14(Var1->memberVar9,Var9,1); \nif (Var30){\nchar *Var31=FUNC15(STRING,Var30,Var29); \nif (Var31){\nFUNC16(Var1->memberVar9,Var9,Var31,1); \nfree(Var31); \nelse \nchar *Var32=FUNC15(STRING,Var29); \nelse \nchar *Var32=FUNC15(STRING,Var29); \nconst char *Var33=FUNC17(Var1->memberVar8,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var26=FUNC11(Var1->memberVar8,STRING); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar10; \nSTRUCT5 *Var24; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC18(Var1->memberVar5,Var1->memberVar10,Var7+4); \nint  Var39=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var40=FUNC20(Var1->memberVar11,Var1->memberVar10); \nSTRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC19(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC22(Var1,Var7+2); \nSTRUCT8 *Var42=FUNC23(Var24,Var46); \nSTRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); \nchar *Var47=FUNC24(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC19(Var1->memberVar5,Var18); \nconst STRUCT5 *Var24=(const STRUCT5 *) FUNC25(Var7+2); \nSTRUCT8 *Var42=FUNC23(Var24,Var46); \nSTRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC19(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC19(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 214,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2941,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var28=FUNC9(Var1,Var2); \nif (Var27){\nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nif (Var29){\nchar *Var30=FUNC11(STRING,Var29,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nFUNC12(Var1->memberVar8,Var9,Var31,1); \nfree(Var31); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nconst char *Var32=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nconst char *Var33=strstr(Var2,STRING); \nchar *Var34,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var35=Var1->memberVar9; \nchar *Var36=strdup(Var7+2); \nchar *Var37=strchr(Var36,=); \nSTRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var43=strdup(Var7+2); \nchar  Var20=*Var44; \nSTRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var46=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var48=Var7-2; \nelse \nchar  Var20=*Var49; \nchar *Var50=Var7+3; \nchar *Var51=Var7+3; \nchar *Var19=strchr(Var51,); \nSTRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 215,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2946,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var28=FUNC9(Var1,Var2); \nif (Var27){\nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nchar *Var30=FUNC11(STRING,Var29,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nFUNC12(Var1->memberVar8,Var9,Var31,1); \nfree(Var31); \nconst char *Var32=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nconst char *Var33=strstr(Var2,STRING); \nchar *Var34,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var35=Var1->memberVar9; \nchar *Var36=strdup(Var7+2); \nchar *Var37=strchr(Var36,=); \nSTRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var43=strdup(Var7+2); \nchar  Var20=*Var44; \nSTRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var46=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var48=Var7-2; \nelse \nchar  Var20=*Var49; \nchar *Var50=Var7+3; \nchar *Var51=Var7+3; \nchar *Var19=strchr(Var51,); \nSTRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 216,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2949,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var28=FUNC9(Var1,Var2); \nif (Var27){\nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nif (Var29){\nchar *Var30=FUNC11(STRING,Var29,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nelse \nconst char *Var32=FUNC12(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nconst char *Var33=strstr(Var2,STRING); \nchar *Var34,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var35=Var1->memberVar9; \nchar *Var36=strdup(Var7+2); \nchar *Var37=strchr(Var36,=); \nSTRUCT2  Var35=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var38=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var39=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); \nchar *Var43=strdup(Var7+2); \nchar  Var20=*Var44; \nSTRUCT2  Var35=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); \nchar *Var45=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var46=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var47=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); \nchar *Var48=Var7-2; \nelse \nchar  Var20=*Var49; \nchar *Var50=Var7+3; \nchar *Var51=Var7+3; \nchar *Var19=strchr(Var51,); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var51); \nSTRUCT2  Var53=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 217,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2975,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nint  Var13=-1; \nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=1; \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nint  Var26=false ; \nint  Var27=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nchar *Var28=Var7-1; \nif (!strcmp(Var9,STRING)){\nVar9=FUNC10(STRING); \nconst bool  Var29=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var30=FUNC11(Var1,Var2); \nif (Var29){\nchar *Var31=FUNC12(Var1->memberVar8,Var9,1); \nif (Var31){\nchar *Var32=FUNC13(STRING,Var31,Var30); \nif (Var32){\nFUNC14(Var1->memberVar8,Var9,Var32,1); \nelse \nchar *Var33=FUNC13(STRING,Var30); \nFUNC14(Var1->memberVar8,Var9,Var33,1); \nelse \nchar *Var33=FUNC13(STRING,Var30); \nFUNC14(Var1->memberVar8,Var9,Var33,1); \nelse \n}else if (Var24>0){\nVar13=FUNC15(Var9,Var24,Var29); \nif (Var26){\nconst char *Var34=FUNC16(Var1->memberVar7,STRING); \nif (Var34&&*Var34){\nFUNC17(STRING,Var34,Var9); \nFUNC18(Var9); \nfree(Var9); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var27=FUNC9(Var1->memberVar7,STRING); \nconst char *Var35=strstr(Var2,STRING); \nchar *Var36,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var37=Var1->memberVar9; \nchar *Var38=strdup(Var7+2); \nchar *Var39=strchr(Var38,=); \nSTRUCT2  Var37=FUNC19(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var40=(int ) FUNC20(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var41=FUNC21(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); \nchar *Var45=strdup(Var7+2); \nchar  Var20=*Var46; \nSTRUCT2  Var37=FUNC20(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC23(Var1,Var7+2); \nSTRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); \nchar *Var47=FUNC24(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC20(Var1->memberVar5,Var18); \nconst STRUCT6 *Var49=(const STRUCT6 *) FUNC25(Var7+2); \nSTRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); \nchar *Var50=Var7-2; \nelse \nchar  Var20=*Var51; \nchar *Var52=Var7+3; \nchar *Var53=Var7+3; \nchar *Var19=strchr(Var53,); \nSTRUCT2  Var54=FUNC20(Var1->memberVar5,Var53); \nSTRUCT2  Var55=FUNC20(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 218,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2990,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \n*Var7=0; \nif (FUNC11(Var1,Var2) == -1){\nVar2=Var7+1; \nVar15=FUNC11(Var1,Var2); \n*Var7=; ; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC12(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC13(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC14(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC15(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC16(Var1,Var38,Var2); \nFUNC17(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC18()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var26){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var26){\nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=1; \nint  Var41=FUNC19(Var1->memberVar8,STRING); \nint  Var42=false ; \nint  Var43=FUNC19(Var1->memberVar8,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC20(Var7[-2])){\nchar *Var44=Var7-1; \nconst bool  Var45=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var46=FUNC21(Var1,Var2); \nchar *Var47=FUNC22(Var1->memberVar5,Var9,1); \nchar *Var48=FUNC23(STRING,Var47,Var46); \nelse \nchar *Var49=FUNC23(STRING,Var46); \nelse \nchar *Var49=FUNC23(STRING,Var46); \nelse \n}else if (Var40>0){\nif (Var16 != -1){\nVar15=FUNC11(Var1,Var2); \nconst char *Var50=FUNC24(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nbool  Var51=false ; \nint  Var52=1; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var51){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var7=0; \n*Var8=0; \nif (Var7[1]== !){\nVar9=FUNC25(Var1,Var7+1); \nelse \nint  Var43=FUNC19(Var1->memberVar8,STRING); \nVar9=FUNC21(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var52&&Var9){\nfor (Var14=0; Var9[Var14]; Var14  Var26){\nif (Var9[Var14]==  Var49){\nVar9[Var14]=; \nVar9=FUNC26(Var9,Var8+1); \nVar2=FUNC26(strdup(Var2),Var9); \nVar15=FUNC11(Var1,Var2); \nfree(Var2); \nfree(Var9); \nreturn  Var15; \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var53=false ; \nif (Var53){\nif (*Var2 != .){\nVar11=FUNC27(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nVar22=Var1->memberVar9=Var7 true false ; \nint  Var54=0; \nif (Var7){\nchar *Var55,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var56=Var1->memberVar10; \nbool  Var57=false ; \nchar *Var58=NULL ; \nconst char *Var59=NULL ; \nbool  Var60=false ; \nbool  Var61=false ; \nchar *Var62=NULL ; \nchar *Var63=NULL ; \nbool  Var64=false ; \nint  Var65,Var66; \nSTRUCT5 *Var39; \n*Var7  Var26=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var26){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var67; \nVar7=FUNC28(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var68=strdup(Var7+2); \nchar *Var69=strchr(Var68,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+4); \nelse \nVar56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar64=FUNC30(Var1->memberVar11,Var7+2); \nint  Var70=(int ) FUNC31(Var1->memberVar6,Var7+2); \nSTRUCT6 *Var71=FUNC32(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var72=FUNC33(Var71,Var70); \nVar55=FUNC34(Var7+2,&Var65); \nif (Var55){\nSTRUCT8 *Var73=FUNC35((const STRUCT5 *) Var55,Var65); \nSTRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); \nelse \nFUNC5(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var76; \nchar *Var77=strdup(Var7+2); \nchar *Var78=FUNC37(Var77); \nif (Var78){\nchar  Var35=*Var78; \nelse \nVar76=FUNC38(Var1->memberVar13,Var7+2); \nVar60=FUNC39(Var1,FUNC31(Var1->memberVar6,Var7+2),&Var58); \nSTRUCT3  Var56=FUNC31(Var1->memberVar6,Var7+2); \nif (Var56){\nFUNC14(Var1,STRING,Var7+2); \nchar *Var2=FUNC40(Var1,Var7+2); \nif (!Var62){\nVar62=Var2; \nelse \nVar62=FUNC41(Var62,Var2); \nfree(Var2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar66=FUNC42(Var7+2,Var39); \nSTRUCT8 *Var73=FUNC35(Var39,Var66); \nSTRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); \nchar *Var79=FUNC43(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC44(Var1->memberVar1,FUNC45(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var80=FUNC31(Var1->memberVar6,Var29); \nVar61=FUNC46(Var1,Var7+2,&Var63); \nVar66=strlen(Var7+2); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC47(Var7+2); \nSTRUCT8 *Var73=FUNC35(Var39,Var66); \nSTRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); \n*Var7=; \nchar *Var81=Var7-2; \nwhile (Var81>Var2){\nif (!FUNC48(*Var81)){\nVar7=FUNC49(Var7+1)-1; \nVar2=FUNC12(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar59=FUNC49(Var7+1); \nif (FUNC50((STRUCT5) Var7[1])&&!Var56){\nif (!FUNC51(Var1->memberVar11,Var7+1)){\nFUNC5(STRING,Var7+1); \nelse \nchar  Var35=*Var59; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var82=Var7+3; \nVar15=FUNC52(Var1,Var2,Var82); \nelse \nVar15=FUNC53(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var83[]={STRING,STRING,STRING,\nconst char *Var84[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var25=strchr(Var85,); \nif (!Var25){\nSTRUCT3  Var86=FUNC31(Var1->memberVar6,Var85); \nSTRUCT3  Var87=FUNC31(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC49(Var2)); \nelse \nif (Var57){\nVar15=FUNC3(Var1->memberVar5,FUNC49(Var2)); \n*Var7=; \nVar54=Var2 FUNC3(Var1->memberVar5,FUNC49(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 219,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2995,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 220,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2995,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 221,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 3002,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 222,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3002,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 223,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3006,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \n*Var8=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar9=FUNC13(Var9,Var8+1); \nVar2=FUNC13(strdup(Var2),Var9); \nVar12=FUNC14(Var1,Var2); \nfree(Var2); \nfree(Var9); \nreturn  Var12; \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC15(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC16(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC17(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC16(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC19(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC16(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC21(Var7+2); \nSTRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC16(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC16(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 224,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3033,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nbool  Var31=false ; \nint  Var32=1; \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var32&&Var9){\nfor (Var11=0; Var9[Var11]; Var11  Var23){\nif (Var9[Var11]==  Var33){\nVar9[Var11]=; \nVar9=FUNC13(Var9,Var8+1); \nVar2=FUNC13(strdup(Var2),Var9); \nfree(Var9); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar9; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var47=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 225,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3044,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nint  Var50=1; \nVar8=strchr(Var7+1,); \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC24(Var1,Var7+1); \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nVar9=FUNC19(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var50&&Var9){\nfor (Var14=0; Var9[Var14]; Var14  Var26){\nif (Var9[Var14]==  Var47){\nVar9[Var14]=; \nVar9=FUNC25(Var9,Var8+1); \nVar2=FUNC25(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nfree(Var9); \nreturn  Var15; \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC26(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var63=strdup(Var7+2); \nchar *Var64=strchr(Var63,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var65=(int ) FUNC28(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var66=FUNC29(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); \nchar *Var70=strdup(Var7+2); \nchar  Var34=*Var71; \nSTRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nSTRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); \nchar *Var72=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var73=FUNC28(Var1->memberVar6,Var29); \nconst STRUCT6 *Var74=(const STRUCT6 *) FUNC33(Var7+2); \nSTRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); \nchar *Var75=Var7-2; \nwhile (Var75>Var2){\nif (!FUNC34(*Var75)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC35((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC36(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var57; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nVar15=FUNC37(Var1,Var2,Var76); \nelse \nVar15=FUNC38(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC28(Var1->memberVar6,Var79); \nSTRUCT3  Var81=FUNC28(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 226,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3047,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nVar8=strchr(Var7+1,); \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC24(Var1,Var7+1); \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nVar9=FUNC19(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar9=FUNC25(Var9,Var8+1); \nVar2=FUNC25(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC26(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC28(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC29(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC28(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC28(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC33(Var7+2); \nSTRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC34(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC35((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC36(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC37(Var1,Var2,Var75); \nelse \nVar15=FUNC38(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC28(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC28(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 227,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3051,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nbool  Var31=false ; \nint  Var32=1; \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var32&&Var9){\nfor (Var11=0; Var9[Var11]; Var11  Var23){\nif (Var9[Var11]==  Var33){\nVar9[Var11]=; \nVar9=FUNC13(Var9,Var8+1); \nVar2=FUNC13(strdup(Var2),Var9); \nfree(Var9); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar9; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var47=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 228,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 3059,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var2 ==  Var27){\nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 229,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 3069,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nbool  Var31=false ; \nif (Var31){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var32=strstr(Var2,STRING); \nif (Var32){\nif (Var2 ==  Var32){\nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC12(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC13(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC14(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC16(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC17(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC13(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC18(Var7+2); \nSTRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC13(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC13(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 230,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3087,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nint  Var28=-1; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var29,*Var30; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var31; \nVar30=*Var2 FUNC5(Var2) NULL ; \nif (!Var30||!*Var30){\nFUNC6(STRINGFUNC7(%Var32).,Var2); \nelse \nchar *Var33=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var33){\nchar *Var34=strchr(Var30+1,); \nconst bool  Var35=Var30[2]== >; \nVar29=strdup(Var2); \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var30){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38\nif (Var9&&(Var9[1]== ||Var9[1]==  Var39)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var41=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var42=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var43=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var43,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var31){\nchar  Var44[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var31){\nif (!*Var11){\nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var45=1; \nint  Var46=FUNC20(Var1->memberVar8,STRING); \nint  Var47=false ; \nint  Var48=FUNC20(Var1->memberVar8,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC21(Var9[-2])){\nchar *Var49=Var9-1; \nconst bool  Var50=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var51=FUNC22(Var1,Var2); \nchar *Var52=FUNC23(Var1->memberVar5,Var11,1); \nchar *Var53=FUNC24(STRING,Var52,Var51); \nelse \nchar *Var54=FUNC24(STRING,Var51); \nelse \nchar *Var54=FUNC24(STRING,Var51); \nelse \n}else if (Var45>0){\nif (Var18 != -1){\nVar17=FUNC12(Var1,Var2); \nconst char *Var55=FUNC25(Var1->memberVar8,STRING); \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nbool  Var56=false ; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var56){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \nif (Var9[1]== !){\nVar11=FUNC26(Var1,Var9+1); \nelse \nint  Var48=FUNC20(Var1->memberVar8,STRING); \nVar11=FUNC22(Var1,Var9+1); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nVar2=FUNC27(strdup(Var2),Var11); \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var32=strstr(Var2,STRING); \nif (Var32){\nbool  Var57=false ; \nif (Var57){\nif (*Var2 != .){\nVar13=FUNC28(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar9=Var9 true false ; \nint  Var58=0; \nif (Var9){\nchar *Var59,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var60=Var1->memberVar10; \nbool  Var61=false ; \nchar *Var62=NULL ; \nconst char *Var63=NULL ; \nbool  Var64=false ; \nbool  Var65=false ; \nchar *Var66=NULL ; \nchar *Var67=NULL ; \nbool  Var68=false ; \nint  Var69=-1; \nint  Var70,Var71; \nSTRUCT6 *Var44; \n*Var9  Var31=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var31){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var72; \nVar9=FUNC29(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var73=strdup(Var9+2); \nchar *Var74=strchr(Var73,=); \nif (Var74){\n*Var74  Var31=0; \nFUNC30(Var73,Var74); \nFUNC31(Var5,Var73); \nelse \nfree(Var73); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); \nFUNC33(Var1,FUNC34((Var75) Var60-(Var75) Var1->memberVar10)); \nelse \nVar60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); \nFUNC35(Var1,Var60,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar68=FUNC36(Var1->memberVar11,Var9+2); \nint  Var76=(int ) FUNC37(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var77=FUNC38(Var1->memberVar12,Var1->memberVar10); \nif (Var77){\nif (Var76<0){\nVar76=Var77->memberVar1+Var76; \nif (Var76 >= 0&&Var76<Var77->memberVar1){\nSTRUCT8  Var78=FUNC39(Var77,Var76); \nFUNC35(Var1,Var77->memberVar2+Var78,1); \nelse \nFUNC6(STRING,Var77->memberVar1); \nVar59=FUNC40(Var9+2,&Var70); \nif (Var59){\nSTRUCT9 *Var79=FUNC41((const STRUCT6 *) Var59,Var70); \nSTRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); \nif (Var80){\nif (Var14){\nFUNC43(Var14); \nVar14=Var80; \nif (Var15){\nFUNC44(Var1->memberVar8,STRING,1); \nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); \nif (Var44){\nfree(Var1->memberVar13); \nmemcpy(Var1->memberVar13,Var59,Var70); \nfree(Var59); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var82; \nchar *Var83=strdup(Var9+2); \nchar *Var84=FUNC47(Var83); \nif (Var84){\nchar  Var40=*Var84; \n*Var84=0; \nVar82=FUNC48(Var1->memberVar14,Var83); \n*Var84=Var40; \nVar82=FUNC37(Var1->memberVar6,Var85); \nelse \nVar82=FUNC48(Var1->memberVar14,Var9+2); \nFUNC35(Var1,Var82,1); \nfree(Var83); \nVar64=FUNC49(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var62); \nVar28=FUNC20(Var1->memberVar8,STRING); \nFUNC44(Var1->memberVar8,STRING,1); \nSTRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC50(Var1,Var9+2); \nif (!Var66){\nVar66=Var2; \nelse \nVar66=FUNC51(Var66,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar44=malloc(strlen(Var9+2)+1); \nif (Var44){\nVar71=FUNC52(Var9+2,Var44); \nFUNC33(Var1,FUNC34(Var71)); \nif (Var71>0){\nSTRUCT9 *Var79=FUNC41(Var44,Var71); \nSTRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); \nif (Var80){\nif (Var14){\nFUNC43(Var14); \nVar14=Var80; \nif (Var15){\nFUNC44(Var1->memberVar8,STRING,1); \nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); \nFUNC33(Var1,Var71); \nfree(Var44); \nchar *Var86=FUNC53(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var86){\nFUNC35(Var1,FUNC37(Var1->memberVar6,Var86),1); \nfree(Var86); \nif (Var9[1]== ){\nVar69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC54(Var1->memberVar1,FUNC55(Var9+2)); \nif (Var9[1]== ){\nchar *Var34=strchr(Var9+2,); \nif (Var34){\n*Var34  Var31=0; \nint  Var87=FUNC37(Var1->memberVar6,Var34); \nVar64=FUNC49(Var1,Var87,&Var62); \nVar65=FUNC56(Var1,Var9+2,&Var67); \nVar71=strlen(Var9+2); \nFUNC33(Var1,Var71); \nconst STRUCT6 *Var44=(const STRUCT6 *) FUNC57(Var9+2); \nif (Var71>0){\nSTRUCT9 *Var79=FUNC41(Var44,Var71); \nSTRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC44(Var1->memberVar8,STRING,1); \nif (Var80){\nif (Var14){\nFUNC43(Var14); \nVar14=Var80; \nif (Var15){\nFUNC44(Var1->memberVar8,STRING,1); \nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); \nFUNC33(Var1,Var71); \n*Var9=; \nchar *Var88=Var9-2; \nwhile (Var88>Var2){\nif (!FUNC58(*Var88)){\n*Var88=0; \nVar88  Var72; \nVar9=FUNC59(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nelse \n*Var10=0; \nif (!Var10[1]){\nFUNC33(\nVar1,FUNC37(Var1->memberVar6,Var10+1)); \nVar63=FUNC59(Var9+1); \nmemberVar2=FUNC37(Var1->memberVar6,Var63); \nif (FUNC60((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC61(Var1->memberVar11,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var40=*Var63; \nif (Var40 == -||Var40 == +){\nmemberVar2=Var1->memberVar10+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var80=Var14; \nif (Var80){\nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,memberVar2,FUNC62(Var80)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar16=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var89=Var9+3; \nwhile (*Var89&&*Var89 == ){\nVar89  Var31; \nVar17=FUNC63(Var1,Var2,Var89); \nelse \nVar17=FUNC64(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var90[]={STRING,STRING,STRING,\nconst char *Var91[]={STRING,STRING,STRING,\nSTRUCT4  Var92[FUNC65(Var90)-1],Var93[FUNC65(Var91)-1]; \nif (Var9[1]== (){\nchar *Var94=Var9+3; \nchar *Var30=strchr(Var94,); \nif (!Var30){\nfree(Var66); \n*Var30=Var95; \nSTRUCT4  Var96=FUNC37(Var1->memberVar6,Var94); \nSTRUCT4  Var97=FUNC37(Var1->memberVar6,Var30+1); \nfor (Var16=0; Var90[Var16]; Var16  Var31){\nVar92[Var16]=FUNC20(Var1->memberVar8,Var90[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var31){\nVar93[Var16]=FUNC20(Var1->memberVar8,Var91[Var16]); \nfor (Var16=0; Var90[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var90[Var16],Var96); \nfor (Var16=0; Var91[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var91[Var16],Var97); \nif (Var19){\nif (Var61){\nVar1->memberVar10=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC59(Var2)); \nelse \nif (Var61){\nif (Var9[1]){\nFUNC35(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC59(Var2)); \nif (memberVar9){\nfor (Var16=0; Var90[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var90[Var16],Var92[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var91[Var16],Var93[Var16]); \nif (Var10){\n*Var10=!; \nif (Var69 != -1){\nFUNC54(Var1->memberVar1,Var69); \nif (Var14){\nif (Var15){\nFUNC44(Var1->memberVar8,STRING,0); \nFUNC43(Var14); \nif (Var64){\nFUNC66(Var1->memberVar8,STRING,Var62); \nif (Var66){\nFUNC8(Var1,Var66); \nFUNC67(Var66); \nif (Var68){\nFUNC68(Var1->memberVar11); \n*Var9=; \nVar58=Var17; \nVar58=Var2 FUNC4(Var1->memberVar5,FUNC59(Var2)) false ; \nif (Var20 != -1){\nFUNC44(Var1->memberVar8,STRING,Var20); \nif (Var21 != -1){\nFUNC44(Var1->memberVar8,STRING,Var21); \nif (Var14){\nFUNC43(Var14); \nif (memberVar9){\n*memberVar9=Var26; \nif (Var28 != -1){\nFUNC44(Var1->memberVar8,STRING,Var28); \nreturn  Var58; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 231,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3098,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nchar  Var33[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var34=FUNC8(Var1->memberVar7,STRING); \nint  Var35=false ; \nint  Var36=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var37=Var7-1; \nconst bool  Var38=(Var7[1]== >); \nchar *Var39=FUNC9(Var1,Var2); \nchar *Var40=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var41=FUNC11(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nbool  Var42=false ; \nif (Var42){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var36=FUNC8(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var43=strstr(Var2,STRING); \nif (Var43){\nbool  Var44=false ; \nif (Var44){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var45,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var46=Var1->memberVar10; \nbool  Var47=false ; \nchar *Var48=NULL ; \nconst char *Var49=NULL ; \nbool  Var50=false ; \nbool  Var51=false ; \nchar *Var52=NULL ; \nchar *Var53=NULL ; \nbool  Var54=false ; \nint  Var55,Var56; \nSTRUCT5 *Var33; \n*Var7  Var32=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var32){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var57; \nVar7=FUNC12(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var58=strdup(Var7+2); \nchar *Var59=strchr(Var58,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar54=FUNC14(Var1->memberVar11,Var7+2); \nint  Var60=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var61=FUNC16(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var62=FUNC17(Var61,Var60); \nVar45=FUNC18(Var7+2,&Var55); \nif (Var45){\nSTRUCT8 *Var63=FUNC19((const STRUCT5 *) Var45,Var55); \nSTRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); \nelse \nFUNC21(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var66; \nchar *Var67=strdup(Var7+2); \nchar *Var68=FUNC22(Var67); \nif (Var68){\nchar  Var29=*Var68; \nelse \nVar66=FUNC23(Var1->memberVar13,Var7+2); \nVar50=FUNC24(Var1,FUNC15(Var1->memberVar5,Var7+2),&Var48); \nSTRUCT3  Var46=FUNC15(Var1->memberVar5,Var7+2); \nif (Var46){\nFUNC25(Var1,STRING,Var7+2); \nchar *Var2=FUNC26(Var1,Var7+2); \nif (Var7[1]== ){\nVar33=malloc(strlen(Var7+2)+1); \nif (Var33){\nVar56=FUNC27(Var7+2,Var33); \nSTRUCT8 *Var63=FUNC19(Var33,Var56); \nSTRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); \nchar *Var69=FUNC28(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC29(Var1->memberVar1,FUNC30(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var70=FUNC15(Var1->memberVar5,Var27); \nVar51=FUNC31(Var1,Var7+2,&Var53); \nVar56=strlen(Var7+2); \nconst STRUCT5 *Var33=(const STRUCT5 *) FUNC32(Var7+2); \nSTRUCT8 *Var63=FUNC19(Var33,Var56); \nSTRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); \n*Var7=; \nchar *Var71=Var7-2; \nVar7=FUNC33(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC34(\nVar1,FUNC15(Var1->memberVar5,Var8+1)); \nVar49=FUNC33(Var7+1); \nif (FUNC35((STRUCT5) Var7[1])&&!Var46){\nif (!FUNC36(Var1->memberVar11,Var7+1)){\nFUNC21(STRING,Var7+1); \nelse \nchar  Var29=*Var49; \nSTRUCT2 *Var64=Var12; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var72=Var7+3; \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var73[]={STRING,STRING,STRING,\nconst char *Var74[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var75=Var7+3; \nchar *Var25=strchr(Var75,); \nif (!Var25){\nSTRUCT3  Var76=FUNC15(Var1->memberVar5,Var75); \nSTRUCT3  Var77=FUNC15(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var47){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 232,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3114,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_break_push (NULL, NULL);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\t\tarroba = NULL;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\ttmpdesc = NULL;\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\t\ttmpdesc = NULL;\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nfor (; *Var2; ){\nchar *Var28,*Var29; \nif (Var23){\nVar29=*Var2 FUNC4(Var2) NULL ; \nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar23=Var31 != NULL ; \nconst bool  Var32=Var29[2]== >; \nif (!Var29){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC5(Var2,,STRING); //Var33  Var34  Var7  Var35\nif (Var9&&(Var9[1]== ||Var9[1]==  Var36)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC6(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var37=Var9-1; \nif (*Var37 == ){\nmemmove(Var37,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC7(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC8(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var38=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var39=FUNC10(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC6(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var40){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nif (Var2<Var9&&Var9[-1]== ){\nFUNC11(NULL ,NULL ); \nFUNC12(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC13()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var40){\nchar  Var41[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var40){\nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC5(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var37=Var9-1; \nif (*Var37 == ){\nmemmove(Var37,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var42=FUNC14(Var1->memberVar7,STRING); \nint  Var43=false ; \nint  Var44=FUNC14(Var1->memberVar7,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC15(Var9[-2])){\nchar *Var45=Var9-1; \nconst bool  Var46=(Var9[1]== >); \nchar *Var47=FUNC16(Var1,Var2); \nchar *Var48=FUNC17(Var1->memberVar8,Var11,1); \nconst char *Var49=FUNC18(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var37=Var9-1; \nif (*Var37 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var44=FUNC14(Var1->memberVar7,STRING); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nif (*Var2 != &&*Var2){\nconst char *Var51=strstr(Var2,STRING); \nif (Var51){\nbool  Var52=false ; \nif (Var52){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nVar26=Var1->memberVar9=Var9 true false ; \nint  Var53=0; \nif (Var9){\nchar *Var54,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var55=Var1->memberVar10; \nbool  Var56=false ; \nchar *Var57=NULL ; \nconst char *Var58=NULL ; \nbool  Var59=false ; \nbool  Var60=false ; \nchar *Var61=NULL ; \nchar *Var62=NULL ; \nbool  Var63=false ; \nint  Var64=-1; \nint  Var65,Var66; \nSTRUCT6 *Var41; \n*Var9  Var40=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var40){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var67; \nVar9=FUNC19(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var68=strdup(Var9+2); \nchar *Var69=strchr(Var68,=); \nif (Var69){\n*Var69  Var40=0; \nFUNC20(Var68,Var69); \nFUNC21(Var5,Var68); \nelse \nfree(Var68); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+4); \nFUNC23(Var1,FUNC24((Var70) Var55-(Var70) Var1->memberVar10)); \nelse \nVar55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+3); \nFUNC25(Var1,Var55,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar63=FUNC26(Var1->memberVar11,Var9+2); \nint  Var71=(int ) FUNC27(Var1->memberVar5,Var9+2); \nSTRUCT7 *Var72=FUNC28(Var1->memberVar12,Var1->memberVar10); \nif (Var72){\nif (Var71<0){\nVar71=Var72->memberVar1+Var71; \nif (Var71 >= 0&&Var71<Var72->memberVar1){\nSTRUCT8  Var73=FUNC29(Var72,Var71); \nFUNC25(Var1,Var72->memberVar2+Var73,1); \nVar54=FUNC30(Var9+2,&Var65); \nif (Var54){\nSTRUCT9 *Var74=FUNC31((const STRUCT6 *) Var54,Var65); \nSTRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); \nif (Var75){\nif (Var14){\nFUNC33(Var14); \nVar14=Var75; \nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); \nif (Var41){\nmemcpy(Var1->memberVar13,Var54,Var65); \nfree(Var54); \nelse \nFUNC36(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var77; \nchar *Var78=strdup(Var9+2); \nchar *Var79=FUNC37(Var78); \nif (Var79){\nchar  Var37=*Var79; \n*Var79=0; \nVar77=FUNC38(Var1->memberVar14,Var78); \n*Var79=Var37; \nelse \nVar77=FUNC38(Var1->memberVar14,Var9+2); \nFUNC25(Var1,Var77,1); \nfree(Var78); \nVar59=FUNC39(Var1,FUNC27(Var1->memberVar5,Var9+2),&Var57); \nSTRUCT4  memberVar2=FUNC27(Var1->memberVar5,Var9+2); \nif (memberVar2){\nFUNC40(Var1,STRING,Var9+2); \nchar *Var2=FUNC41(Var1,Var9+2); \nif (!Var61){\nVar61=Var2; \nelse \nVar61=FUNC42(Var61,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar41=malloc(strlen(Var9+2)+1); \nif (Var41){\nVar66=FUNC43(Var9+2,Var41); \nFUNC23(Var1,FUNC24(Var66)); \nif (Var66>0){\nSTRUCT9 *Var74=FUNC31(Var41,Var66); \nSTRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); \nif (Var75){\nif (Var14){\nFUNC33(Var14); \nVar14=Var75; \nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); \nFUNC23(Var1,Var66); \nfree(Var41); \nchar *Var80=FUNC44(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var80){\nFUNC25(Var1,FUNC27(Var1->memberVar5,Var80),1); \nfree(Var80); \nif (Var9[1]== ){\nFUNC45(Var1->memberVar1,FUNC46(Var9+2)); \nif (Var9[1]== ){\nchar *Var31=strchr(Var9+2,); \nif (Var31){\n*Var31  Var40=0; \nint  Var81=FUNC27(Var1->memberVar5,Var31); \nVar59=FUNC39(Var1,Var81,&Var57); \nVar60=FUNC47(Var1,Var9+2,&Var62); \nVar66=strlen(Var9+2); \nFUNC23(Var1,Var66); \nconst STRUCT6 *Var41=(const STRUCT6 *) FUNC48(Var9+2); \nif (Var66>0){\nSTRUCT9 *Var74=FUNC31(Var41,Var66); \nSTRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); \nif (Var75){\nif (Var14){\nFUNC33(Var14); \nVar14=Var75; \nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); \nFUNC23(Var1,Var66); \n*Var9=; \nchar *Var82=Var9-2; \nwhile (Var82>Var2){\nif (!FUNC49(*Var82)){\n*Var82=0; \nVar82  Var67; \nVar9=FUNC50(Var9+1)-1; \nVar2=FUNC7(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar58=FUNC50(Var9+1); \nmemberVar2=FUNC27(Var1->memberVar5,Var58); \nif (FUNC51((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC52(Var1->memberVar11,Var9+1)){\nFUNC36(STRING,Var9+1); \nelse \nchar  Var37=*Var58; \nif (Var37 == -||Var37 == +){\nmemberVar2=Var1->memberVar10+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var75=Var14; \nif (Var75){\nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,memberVar2,FUNC53(Var75)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar12=NULL ; \nVar1->memberVar16=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var83=Var9+3; \nwhile (*Var83&&*Var83 == ){\nVar83  Var40; \nVar17=FUNC54(Var1,Var2,Var83); \nelse \nVar17=FUNC55(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var84[]={STRING,STRING,STRING,\nconst char *Var85[]={STRING,STRING,STRING,\nSTRUCT4  Var86[FUNC56(Var84)-1],Var87[FUNC56(Var85)-1]; \nif (Var9[1]== (){\nchar *Var88=Var9+3; \nchar *Var29=strchr(Var88,); \nif (!Var29){\nfree(Var61); \n*Var29=Var89; \nSTRUCT4  Var90=FUNC27(Var1->memberVar5,Var88); \nSTRUCT4  Var91=FUNC27(Var1->memberVar5,Var29+1); \nfor (Var16=0; Var84[Var16]; Var16  Var40){\nVar86[Var16]=FUNC14(Var1->memberVar7,Var84[Var16]); \nfor (Var16=0; Var85[Var16]; Var16  Var40){\nVar87[Var16]=FUNC14(Var1->memberVar7,Var85[Var16]); \nfor (Var16=0; Var84[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var84[Var16],Var90); \nfor (Var16=0; Var85[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var85[Var16],Var91); \nif (Var19){\nif (Var56){\nVar1->memberVar10=memberVar2; \nVar17=FUNC58(Var1->memberVar8,FUNC50(Var2)); \nelse \nif (Var56){\nif (Var9[1]){\nFUNC25(Var1,memberVar2,1); \nVar17=FUNC58(Var1->memberVar8,FUNC50(Var2)); \nif (memberVar9){\nfor (Var16=0; Var84[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var84[Var16],Var86[Var16]); \nfor (Var16=0; Var85[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var85[Var16],Var87[Var16]); \nif (Var64 != -1){\nFUNC45(Var1->memberVar1,Var64); \nif (Var14){\nif (Var15){\nFUNC57(Var1->memberVar7,STRING,0); \nFUNC33(Var14); \nVar14=NULL ; \nif (Var59){\nFUNC59(Var1->memberVar7,STRING,Var57); \nif (Var61){\nFUNC60(Var1,Var61); \nFUNC61(Var61); \nif (Var63){\nFUNC62(Var1->memberVar11); \n*Var9=; \nVar53=Var17; \nVar53=Var2 FUNC58(Var1->memberVar8,FUNC50(Var2)) false ; \nif (Var20 != -1){\nFUNC57(Var1->memberVar7,STRING,Var20); \nif (Var21 != -1){\nFUNC57(Var1->memberVar7,STRING,Var21); \nif (Var14){\nFUNC33(Var14); \nVar14=NULL ; \nreturn  Var53; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 233,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3134,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT4  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC4(Var2,,STRING); //Var31  Var32  Var7  Var33\nif (Var9&&(Var9[1]== ||Var9[1]==  Var34)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC5(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var35=Var9-1; \nif (*Var35 == ){\nmemmove(Var35,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC6(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC7(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var9+1); \nelse \nchar *Var37=FUNC9(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC5(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var38){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nif (Var2<Var9&&Var9[-1]== ){\nFUNC10(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC11()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var38){\nchar  Var39[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var38){\nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC4(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var35=Var9-1; \nif (*Var35 == ){\nmemmove(Var35,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var40=FUNC12(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC12(Var1->memberVar7,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC13(Var9[-2])){\nchar *Var43=Var9-1; \nconst bool  Var44=(Var9[1]== >); \nchar *Var45=FUNC14(Var1,Var2); \nchar *Var46=FUNC15(Var1->memberVar8,Var11,1); \nconst char *Var47=FUNC16(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var35=Var9-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC12(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nVar24=Var1->memberVar9=Var9 true false ; \nif (Var9){\nchar *Var51,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var52=Var1->memberVar10; \nbool  Var53=false ; \nchar *Var54=NULL ; \nconst char *Var55=NULL ; \nbool  Var56=false ; \nbool  Var57=false ; \nchar *Var58=NULL ; \nchar *Var59=NULL ; \nbool  Var60=false ; \nint  Var61,Var62; \nSTRUCT6 *Var39; \n*Var9  Var38=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nfor (; *Var9 == ; Var9  Var38){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var63; \nVar9=FUNC17(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var64=strdup(Var9+2); \nchar *Var65=strchr(Var64,=); \nif (Var65){\n*Var65  Var38=0; \nFUNC18(Var64,Var65); \nFUNC19(Var5,Var64); \nelse \nfree(Var64); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+4); \nelse \nVar52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+3); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar60=FUNC21(Var1->memberVar11,Var9+2); \nint  Var66=(int ) FUNC22(Var1->memberVar5,Var9+2); \nSTRUCT7 *Var67=FUNC23(Var1->memberVar12,Var1->memberVar10); \nSTRUCT8  Var68=FUNC24(Var67,Var66); \nVar51=FUNC25(Var9+2,&Var61); \nif (Var51){\nSTRUCT9 *Var69=FUNC26((const STRUCT6 *) Var51,Var61); \nSTRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); \nelse \nFUNC28(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var72; \nchar *Var73=strdup(Var9+2); \nchar *Var74=FUNC29(Var73); \nif (Var74){\nchar  Var35=*Var74; \nelse \nVar72=FUNC30(Var1->memberVar13,Var9+2); \nVar56=FUNC31(Var1,FUNC22(Var1->memberVar5,Var9+2),&Var54); \nSTRUCT4  Var52=FUNC22(Var1->memberVar5,Var9+2); \nif (Var52){\nFUNC32(Var1,STRING,Var9+2); \nchar *Var2=FUNC33(Var1,Var9+2); \nif (Var9[1]== ){\nVar39=malloc(strlen(Var9+2)+1); \nif (Var39){\nVar62=FUNC34(Var9+2,Var39); \nSTRUCT9 *Var69=FUNC26(Var39,Var62); \nSTRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); \nchar *Var75=FUNC35(Var1->memberVar14,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var9[1]== ){\nFUNC36(Var1->memberVar1,FUNC37(Var9+2)); \nif (Var9[1]== ){\nchar *Var29=strchr(Var9+2,); \nint  Var76=FUNC22(Var1->memberVar5,Var29); \nVar57=FUNC38(Var1,Var9+2,&Var59); \nVar62=strlen(Var9+2); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC39(Var9+2); \nSTRUCT9 *Var69=FUNC26(Var39,Var62); \nSTRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); \n*Var9=; \nchar *Var77=Var9-2; \nVar9=FUNC40(Var9+1)-1; \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar55=FUNC40(Var9+1); \nif (FUNC41((STRUCT6) Var9[1])&&!Var52){\nif (!FUNC42(Var1->memberVar11,Var9+1)){\nFUNC28(STRING,Var9+1); \nelse \nchar  Var35=*Var55; \nSTRUCT3 *Var70=Var14; \nif (Var12){\nVar9=Var12+1; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var78=Var9+3; \nelse \nVar17=FUNC43(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var79[]={STRING,STRING,STRING,\nconst char *Var80[]={STRING,STRING,STRING,\nif (Var9[1]== (){\nchar *Var81=Var9+3; \nchar *Var27=strchr(Var81,); \nif (!Var27){\nSTRUCT4  Var82=FUNC22(Var1->memberVar5,Var81); \nSTRUCT4  Var83=FUNC22(Var1->memberVar5,Var27+1); \nif (Var19){\nelse \nif (Var53){\n*Var9=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 234,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3135,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=Var1->memberVar2; \nbool  Var20=Var1->memberVar3; \nSTRUCT4  Var21=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var24+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27\nif (Var9&&(Var9[1]== ||Var9[1]==  Var28)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC5(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC6(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC7(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC8(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC5(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC9()->memberVar1){\nif (Var9[1]== <){\nint  Var17; \nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC4(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nif (Var9[0]&&Var9[1]== ){\nint  Var33=FUNC10(Var1->memberVar7,STRING); \nint  Var34=FUNC10(Var1->memberVar7,STRING); \n*Var9=0; \nif (!*Var11){\nchar *Var35=Var9-1; \nconst bool  Var36=(Var9[1]== >); \nchar *Var37=FUNC11(Var1,Var2); \nchar *Var38=FUNC12(Var1->memberVar8,Var11,1); \nconst char *Var39=FUNC13(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC10(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nif (Var9){\nchar *Var43,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var9  Var32=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nfor (; *Var9 == ; Var9  Var32){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var49; \nVar9=FUNC14(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var50=strdup(Var9+2); \nchar *Var51=strchr(Var50,=); \nif (Var51){\n*Var51  Var32=0; \nFUNC15(Var50,Var51); \nFUNC16(Var5,Var50); \nelse \nfree(Var50); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nSTRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nint  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); \nSTRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var9+2); \nchar  Var29=*Var58; \nSTRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); \nchar *Var2=FUNC21(Var1,Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); \nchar *Var23=strchr(Var9+2,); \nint  Var60=FUNC18(Var1->memberVar5,Var23); \nconst STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \n*Var9=; \nchar *Var62=Var9-2; \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nif (FUNC24((STRUCT7) Var9[1])&&!Var44){\nif (!FUNC25(Var1->memberVar12,Var9+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT3 *Var54=Var14; \nif (Var12){\nVar9=Var12+1; \nchar *Var63=Var9+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var9+3; \nchar *Var24=strchr(Var66,); \nSTRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); \nSTRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 235,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3141,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=Var1->memberVar2; \nbool  Var20=Var1->memberVar3; \nSTRUCT4  Var21=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var24+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27\nif (Var9&&(Var9[1]== ||Var9[1]==  Var28)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC5(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC6(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC7(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC8(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC5(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC9()->memberVar1){\nif (Var9[1]== <){\nint  Var17; \nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC4(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nif (Var9[0]&&Var9[1]== ){\nint  Var33=FUNC10(Var1->memberVar7,STRING); \nint  Var34=FUNC10(Var1->memberVar7,STRING); \n*Var9=0; \nif (!*Var11){\nchar *Var35=Var9-1; \nconst bool  Var36=(Var9[1]== >); \nchar *Var37=FUNC11(Var1,Var2); \nchar *Var38=FUNC12(Var1->memberVar8,Var11,1); \nconst char *Var39=FUNC13(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC10(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nif (Var9){\nchar *Var43,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var9  Var32=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nfor (; *Var9 == ; Var9  Var32){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var49; \nVar9=FUNC14(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var50=strdup(Var9+2); \nchar *Var51=strchr(Var50,=); \nif (Var51){\nFUNC15(Var50,Var51); \nFUNC16(Var5,Var50); \nelse \nfree(Var50); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nSTRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nint  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); \nSTRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var9+2); \nchar  Var29=*Var58; \nSTRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); \nchar *Var2=FUNC21(Var1,Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); \nchar *Var23=strchr(Var9+2,); \nint  Var60=FUNC18(Var1->memberVar5,Var23); \nconst STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \n*Var9=; \nchar *Var62=Var9-2; \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nif (FUNC24((STRUCT7) Var9[1])&&!Var44){\nif (!FUNC25(Var1->memberVar12,Var9+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT3 *Var54=Var14; \nif (Var12){\nVar9=Var12+1; \nchar *Var63=Var9+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var9+3; \nchar *Var24=strchr(Var66,); \nSTRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); \nSTRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 236,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3205,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nint  Var6=!Var7->memberVar1->memberVar1; \nint  Var8,Var9=0,Var10; \nbool  Var11=Var7->memberVar2; \nbool  Var12=Var7->memberVar3; \nSTRUCT1  Var13=Var7->memberVar4; \nif (!Var14){\nswitch (*Var14){\nif (Var14[1]== ){/*STRUCT2 */\nelse \nchar *Var15=strchr(Var14,; ); \nif (Var14[1]!= *&&!strstr(Var14,STRING)){\nif (Var14[1]== >){\nif (*Var14 != ){\nif (Var16&&Var2){\nint  Var9; \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nchar *Var3=strchr(Var14,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var18=Var7->memberVar5->memberVar1; \nelse \nchar *Var19=FUNC2(Var7->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var9 == -1){\nif (Var2&&(Var2 ==  Var14||Var2[-1]!= )){\nif (*Var14 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var20[1024]; \nint  Var9; \nif (!*Var4){\nif (!Var7->memberVar6){\nelse \n}else if (Var2 ==  Var14){\nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var21=FUNC4(Var7->memberVar7,STRING); \nint  Var22=FUNC4(Var7->memberVar7,STRING); \nif (!*Var4){\nchar *Var23=Var2-1; \nconst bool  Var24=(Var2[1]== >); \nchar *Var25=FUNC5(Var7,Var14); \nchar *Var26=FUNC6(Var7->memberVar8,Var4,1); \nconst char *Var27=FUNC7(Var7->memberVar7,STRING); \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nbool  Var28=false ; \nif (Var28){\nelse \nint  memberVar1=Var7->memberVar5->memberVar1; \nelse \nint  Var22=FUNC4(Var7->memberVar7,STRING); \nif (*Var14 != &&*Var14){\nconst char *Var29=strstr(Var14,STRING); \nif (Var29){\nbool  Var30=false ; \nif (Var30){\nif (Var2){\nchar *Var31,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var32=Var7->memberVar9; \nint  Var33,Var34; \nSTRUCT3 *Var20; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var35=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT1  Var32=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var36=(int ) FUNC9(Var7->memberVar5,Var2+2); \nSTRUCT4 *Var37=FUNC10(Var7->memberVar10,Var7->memberVar9); \nif (Var31){\nSTRUCT5 *Var38=FUNC11((const STRUCT3 *) Var31,Var33); \nSTRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); \nVar20=malloc(Var33); \nif (Var20){\nfree(Var7->memberVar11); \nVar7->memberVar11=Var20; \nVar7->memberVar4=Var33; \nmemcpy(Var7->memberVar11,Var31,Var33); \nelse \nFUNC13(STRING,Var33); \nchar *Var41=strdup(Var2+2); \nchar  Var17=*Var42; \nSTRUCT1  Var32=FUNC9(Var7->memberVar5,Var2+2); \nchar *Var14=FUNC14(Var7,Var2+2); \nSTRUCT5 *Var38=FUNC11(Var20,Var34); \nSTRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); \nchar *Var43=FUNC15(Var7->memberVar12,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var44=strchr(Var2+2,); \nint  Var45=FUNC9(Var7->memberVar5,Var44); \nconst STRUCT3 *Var20=(const STRUCT3 *) FUNC16(Var2+2); \nSTRUCT5 *Var38=FUNC11(Var20,Var34); \nSTRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); \nchar *Var46=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC17((STRUCT3) Var2[1])&&!Var32){\nif (!FUNC18(Var7->memberVar13,Var2+1)){\nelse \nchar  Var17=*Var47; \nif (Var5){\nchar *Var48=Var2+3; \nchar *Var49=Var2+3; \nSTRUCT1  Var50=FUNC9(Var7->memberVar5,Var49); \nSTRUCT1  Var51=FUNC9(Var7->memberVar5,Var52+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 237,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3207,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nint  Var26=-1; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nSTRUCT3  Var27=Var28; \nchar *Var29,*Var30; \nif (Var21){\nif (!Var30||!*Var30){\nelse \nchar *Var31=strchr(Var2,; ); \nFUNC4(Var1,Var2); \nif (!Var31){\nif (*Var30){\nif (Var30[1]== ||(Var30[1]&&Var30[2]== )){\nchar *Var32=strchr(Var30+1,); \nVar27=Var1->memberVar6; \nFUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); \nconst bool  Var33=Var30[2]== >; \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC7(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var29); \nif (Var27 !=  Var28){\nFUNC5(Var1,Var27,1); \nif (!Var30){\nif (Var20){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC8(Var1,Var34); \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (FUNC9(Var1,Var2) == -1){\nVar15=FUNC9(Var1,Var2); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC10(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nFUNC8(Var1,Var36); \nelse \n}else if (!FUNC11(Var7+1,STRING,1)){//STRING\nVar18=FUNC12(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar19=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,Var37); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC14(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var38=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var39=FUNC15(Var1->memberVar1,Var7+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar18=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,0); \nVar19=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,Var37); \nVar7=(char *) FUNC16(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var40){\nVar7=strchr(Var2,&); \nFUNC17(Var1->memberVar9); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var41=0; \nFUNC18(Var1,Var41,Var2); \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nif (Var7){\nif (FUNC19()->memberVar1){\nif (Var7[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var42[1024]; \nint  Var15; \nif (FUNC20(stdin)){\nVar1->memberVar10  STRUCT5  Var15; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var42,Var9)){\nstrcat((char *) Var1->memberVar9,Var42); \nif (!*Var9){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC21(Var9,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var7 ==  Var2){\nreturn FUNC22(Var1,(const char *) Var1->memberVar9); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nFUNC8(Var1,Var34); \nint  Var43=1; \nint  Var44=FUNC12(Var1->memberVar8,STRING); \nint  Var45=false ; \nint  Var46=FUNC12(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC23(Var7[-2])){\nchar *Var47=Var7-1; \nif (*Var47 ==  Var48){//STRING\nVar18=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var9,STRING)){\nFUNC13(Var1->memberVar8,STRING,Var37); \nconst bool  Var49=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var50=FUNC24(Var1,Var2); \nif (Var49){\nchar *Var51=FUNC25(Var1->memberVar5,Var9,1); \nif (Var51){\nchar *Var52=FUNC26(STRING,Var51,Var50); \nif (Var52){\nFUNC27(Var1->memberVar5,Var9,Var52,1); \nelse \nchar *Var53=FUNC26(STRING,Var50); \nFUNC27(Var1->memberVar5,Var9,Var53,1); \nelse \nchar *Var53=FUNC26(STRING,Var50); \nFUNC27(Var1->memberVar5,Var9,Var53,1); \nelse \n}else if (Var43>0){\nif (Var16 != -1){\nif (!Var44){\nFUNC13(Var1->memberVar8,STRING,Var37); \nVar15=FUNC9(Var1,Var2); \nif (!Var44){\nFUNC13(Var1->memberVar8,STRING,Var46); \nif (Var45){\nconst char *Var54=FUNC28(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,Var46); \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nVar1->memberVar11->memberVar1=false ; \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var55=false ; \nif (Var55){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC29(Var1,Var7+1); \nelse \nint  Var46=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar9=FUNC24(Var1,Var7+1); \nVar1->memberVar12=false ; \nFUNC13(Var1->memberVar8,STRING,Var46); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar15=FUNC9(Var1,Var2); \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (*Var2 != &&*Var2){\nconst char *Var56=strstr(Var2,STRING); \nif (Var56){\nbool  Var57=false ; \nif (Var57){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar13=Var7 true false ; \nint  Var58=0; \nif (Var7){\nchar *Var59,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var60=Var1->memberVar6; \nbool  Var61=false ; \nchar *Var62=NULL ; \nconst char *Var63=NULL ; \nbool  Var64=false ; \nbool  Var65=false ; \nchar *Var66=NULL ; \nchar *Var67=NULL ; \nbool  Var68=false ; \nint  Var69=-1; \nint  Var70,Var71; \nSTRUCT6 *Var42; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var72=strdup(Var7+2); \nchar *Var73=strchr(Var72,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+4); \nFUNC31(Var1,FUNC32((Var74) Var60-(Var74) Var1->memberVar6)); \nelse \nVar60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+3); \nFUNC5(Var1,Var60,1); \nVar24=Var1->memberVar13=true ; \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar68=FUNC33(Var1->memberVar14,Var7+2); \nint  Var75=(int ) FUNC6(Var1->memberVar7,Var7+2); \nSTRUCT7 *Var76=FUNC34(Var1->memberVar15,Var1->memberVar6); \nif (Var76){\nif (Var75 >= 0&&Var75<Var76->memberVar1){\nSTRUCT8  Var77=FUNC35(Var76,Var75); \nFUNC5(Var1,Var76->memberVar2+Var77,1); \nVar24=Var1->memberVar13=true ; \nif (Var59){\nSTRUCT9 *Var78=FUNC36((const STRUCT6 *) Var59,Var70); \nSTRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,1); \nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); \nVar42=malloc(Var70); \nif (Var42){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var42; \nVar1->memberVar4=Var70; \nmemcpy(Var1->memberVar16,Var59,Var70); \nif (Var7[1]== ){\nSTRUCT3  Var81; \nchar *Var82=strdup(Var7+2); \nchar *Var83=FUNC40(Var82); \nif (Var83){\nchar  Var35=*Var83; \nVar81=FUNC41(Var1->memberVar17,Var82); \nVar81=FUNC6(Var1->memberVar7,Var84); \nelse \nVar81=FUNC41(Var1->memberVar17,Var7+2); \nFUNC5(Var1,Var81,1); \nVar24=Var1->memberVar13=true ; \nVar64=FUNC42(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var62); \nVar26=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); \nif (memberVar2){\nFUNC14(Var1,STRING,Var7+2); \nVar24=Var1->memberVar13=true ; \nchar *Var2=FUNC43(Var1,Var7+2); \nif (Var7[1]== ){\nif (Var42){\nFUNC31(Var1,FUNC32(Var71)); \nif (Var71>0){\nSTRUCT9 *Var78=FUNC36(Var42,Var71); \nSTRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,1); \nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); \nFUNC31(Var1,Var71); \nFUNC44(Var1); \nchar *Var85=FUNC45(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var85){\nFUNC5(Var1,FUNC6(Var1->memberVar7,Var85),1); \nif (Var7[1]== ){\nVar69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC46(Var1->memberVar1,FUNC47(Var7+2)); \nif (Var7[1]== ){\nchar *Var32=strchr(Var7+2,); \nif (Var32){\nint  Var86=FUNC6(Var1->memberVar7,Var32); \nVar64=FUNC42(Var1,Var86,&Var62); \nVar65=FUNC48(Var1,Var7+2,&Var67); \nFUNC31(Var1,Var71); \nconst STRUCT6 *Var42=(const STRUCT6 *) FUNC49(Var7+2); \nif (Var71>0){\nSTRUCT9 *Var78=FUNC36(Var42,Var71); \nSTRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC13(Var1->memberVar8,STRING,1); \nif (Var79){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,1); \nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); \nFUNC31(Var1,Var71); \nchar *Var87=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nFUNC31(\nVar1,FUNC6(Var1->memberVar7,Var8+1)); \nmemberVar2=FUNC6(Var1->memberVar7,Var63); \nif (FUNC50((STRUCT6) Var7[1])&&!memberVar2){\nif (!FUNC51(Var1->memberVar14,Var7+1)){\nelse \nchar  Var35=*Var63; \nif (Var35 == -||Var35 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var79=Var12; \nif (Var79){\nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC52(Var79)); \nif (Var10){\nVar1->memberVar19=!!Var12; \nif (Var1->memberVar19){\nFUNC44(Var1); \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var88=Var7+3; \nVar15=FUNC53(Var1,Var2,Var88); \nelse \nVar15=FUNC54(Var1,Var2,Var7+2); \nelse \nbool  memberVar13=false ; \nconst char *Var89[]={STRING,STRING,STRING,\nconst char *Var90[]={STRING,STRING,STRING,\nSTRUCT3  Var91[FUNC55(Var89)-1],Var92[FUNC55(Var90)-1]; \nif (Var7[1]== (){\nchar *Var93=Var7+3; \nchar *Var30=strchr(Var93,); \nif (!Var30){\nSTRUCT3  Var94=FUNC6(Var1->memberVar7,Var93); \nSTRUCT3  Var95=FUNC6(Var1->memberVar7,Var30+1); \nfor (Var14=0; Var89[Var14]; Var14  Var40){\nVar91[Var14]=FUNC12(Var1->memberVar8,Var89[Var14]); \nfor (Var14=0; Var90[Var14]; Var14  Var40){\nVar92[Var14]=FUNC12(Var1->memberVar8,Var90[Var14]); \nfor (Var14=0; Var89[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var89[Var14],Var94); \nfor (Var14=0; Var90[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var90[Var14],Var95); \nif (Var17){\nif (Var61){\nVar1->memberVar6=memberVar2; \nVar15=FUNC3(Var1->memberVar5,FUNC56(Var2)); \nelse \nif (Var61){\nif (Var7[1]){\nFUNC5(Var1,memberVar2,1); \nFUNC44(Var1); \nVar15=FUNC3(Var1->memberVar5,FUNC56(Var2)); \nif (memberVar13){\nfor (Var14=0; Var89[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var89[Var14],Var91[Var14]); \nfor (Var14=0; Var90[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var90[Var14],Var92[Var14]); \nif (Var8){\nFUNC31(Var1,Var25); \nif (Var65){\nVar1->memberVar2=Var22; \nFUNC57(Var1->memberVar8,STRING,Var67); \nif (Var69 != -1){\nFUNC46(Var1->memberVar1,Var69); \nif (Var12){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,0); \nif (Var64){\nFUNC57(Var1->memberVar8,STRING,Var62); \nVar1->memberVar3=Var23; \nif (Var25 !=  Var1->memberVar4){\nFUNC31(Var1,Var25); \nif (Var66){\nFUNC4(Var1,Var66); \nif (Var68){\nFUNC58(Var1->memberVar14); \nVar58=Var2 FUNC3(Var1->memberVar5,FUNC56(Var2)) false ; \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nVar1->memberVar2=Var22; \nVar1->memberVar3=Var23; \nif (Var26 != -1){\nFUNC13(Var1->memberVar8,STRING,Var26); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 238,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 3210,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nint  Var26=-1; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nSTRUCT3  Var27=Var28; \nchar *Var29,*Var30; \nif (Var21){\nif (!Var30||!*Var30){\nelse \nchar *Var31=strchr(Var2,; ); \nFUNC4(Var1,Var2); \nif (!Var31){\nif (*Var30){\nif (Var30[1]== ||(Var30[1]&&Var30[2]== )){\nchar *Var32=strchr(Var30+1,); \nVar27=Var1->memberVar6; \nFUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); \nconst bool  Var33=Var30[2]== >; \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC7(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var29); \nif (Var27 !=  Var28){\nFUNC5(Var1,Var27,1); \nif (!Var30){\nif (Var20){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC8(Var1,Var34); \nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37\nif (Var7&&(Var7[1]== ||Var7[1]==  Var38)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (FUNC10(Var1,Var2) == -1){\nVar15=FUNC10(Var1,Var2); \nVar7=(char *) FUNC11(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC12(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nFUNC8(Var1,Var40); \nelse \n}else if (!FUNC13(Var7+1,STRING,1)){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC16(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var42=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var43=FUNC17(Var1->memberVar1,Var7+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nVar7=(char *) FUNC11(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){\nVar7=strchr(Var2,&); \nFUNC18(Var1->memberVar9); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var45=0; \nFUNC19(Var1,Var45,Var2); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC20()->memberVar1){\nif (Var7[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var46[1024]; \nint  Var15; \nif (FUNC21(stdin)){\nVar1->memberVar10  STRUCT5  Var15; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var46,Var9)){\nstrcat((char *) Var1->memberVar9,Var46); \nif (!*Var9){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC22(Var9,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var7 ==  Var2){\nreturn FUNC23(Var1,(const char *) Var1->memberVar9); \nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nif (Var7[0]&&Var7[1]== ){\nFUNC8(Var1,Var34); \nint  Var47=1; \nint  Var48=FUNC14(Var1->memberVar8,STRING); \nint  Var49=false ; \nint  Var50=FUNC14(Var1->memberVar8,STRING); \n*Var7=0; \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC24(Var7[-2])){\nchar *Var51=Var7-1; \nif (*Var51 ==  Var52){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var9,STRING)){\nFUNC15(Var1->memberVar8,STRING,Var41); \nconst bool  Var53=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var54=FUNC25(Var1,Var2); \nif (Var53){\nchar *Var55=FUNC26(Var1->memberVar5,Var9,1); \nif (Var55){\nchar *Var56=FUNC27(STRING,Var55,Var54); \nif (Var56){\nFUNC28(Var1->memberVar5,Var9,Var56,1); \nelse \nchar *Var57=FUNC27(STRING,Var54); \nFUNC28(Var1->memberVar5,Var9,Var57,1); \nelse \nchar *Var57=FUNC27(STRING,Var54); \nFUNC28(Var1->memberVar5,Var9,Var57,1); \nelse \n}else if (Var47>0){\nif (Var16 != -1){\nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var41); \nVar15=FUNC10(Var1,Var2); \nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var49){\nconst char *Var58=FUNC29(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar11->memberVar1=false ; \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nbool  Var59=false ; \nif (Var59){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC30(Var1,Var7+1); \nelse \nint  Var50=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar9=FUNC25(Var1,Var7+1); \nVar1->memberVar12=false ; \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar15=FUNC10(Var1,Var2); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (*Var2 != &&*Var2){\nconst char *Var60=strstr(Var2,STRING); \nif (Var60){\nbool  Var61=false ; \nif (Var61){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar13=Var7 true false ; \nint  Var62=0; \nif (Var7){\nchar *Var63,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var64=Var1->memberVar6; \nbool  Var65=false ; \nchar *Var66=NULL ; \nconst char *Var67=NULL ; \nbool  Var68=false ; \nbool  Var69=false ; \nchar *Var70=NULL ; \nchar *Var71=NULL ; \nbool  Var72=false ; \nint  Var73=-1; \nint  Var74,Var75; \nSTRUCT6 *Var46; \n*Var7  Var44=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var44){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var76; \nVar7=FUNC31(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var77=strdup(Var7+2); \nchar *Var78=strchr(Var77,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+4); \nFUNC33(Var1,FUNC34((Var79) Var64-(Var79) Var1->memberVar6)); \nelse \nVar64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+3); \nFUNC5(Var1,Var64,1); \nVar24=Var1->memberVar13=true ; \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar72=FUNC35(Var1->memberVar14,Var7+2); \nint  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); \nSTRUCT7 *Var81=FUNC36(Var1->memberVar15,Var1->memberVar6); \nif (Var81){\nif (Var80 >= 0&&Var80<Var81->memberVar1){\nSTRUCT8  Var82=FUNC37(Var81,Var80); \nFUNC5(Var1,Var81->memberVar2+Var82,1); \nVar24=Var1->memberVar13=true ; \nVar63=FUNC22(Var7+2,&Var74); \nif (Var63){\nSTRUCT9 *Var83=FUNC38((const STRUCT6 *) Var63,Var74); \nSTRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); \nVar46=malloc(Var74); \nif (Var46){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var46; \nVar1->memberVar4=Var74; \nmemcpy(Var1->memberVar16,Var63,Var74); \nelse \nFUNC42(STRING,Var74); \nfree(Var63); \nif (Var7[1]== ){\nSTRUCT3  Var86; \nchar *Var87=strdup(Var7+2); \nchar *Var88=FUNC43(Var87); \nif (Var88){\nchar  Var39=*Var88; \nVar86=FUNC44(Var1->memberVar17,Var87); \nVar86=FUNC6(Var1->memberVar7,Var89); \nelse \nVar86=FUNC44(Var1->memberVar17,Var7+2); \nFUNC5(Var1,Var86,1); \nVar24=Var1->memberVar13=true ; \nVar68=FUNC45(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); \nVar26=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); \nif (memberVar2){\nFUNC16(Var1,STRING,Var7+2); \nVar24=Var1->memberVar13=true ; \nchar *Var2=FUNC46(Var1,Var7+2); \nif (Var7[1]== ){\nif (Var46){\nFUNC33(Var1,FUNC34(Var75)); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC38(Var46,Var75); \nSTRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); \nFUNC33(Var1,Var75); \nFUNC47(Var1); \nchar *Var90=FUNC48(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var90){\nFUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); \nif (Var7[1]== ){\nVar73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC49(Var1->memberVar1,FUNC50(Var7+2)); \nif (Var7[1]== ){\nchar *Var32=strchr(Var7+2,); \nif (Var32){\nint  Var91=FUNC6(Var1->memberVar7,Var32); \nVar68=FUNC45(Var1,Var91,&Var66); \nVar69=FUNC51(Var1,Var7+2,&Var71); \nFUNC33(Var1,Var75); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC52(Var7+2); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC38(Var46,Var75); \nSTRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC15(Var1->memberVar8,STRING,1); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); \nFUNC33(Var1,Var75); \n*Var7=; \nchar *Var92=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nFUNC33(\nVar1,FUNC6(Var1->memberVar7,Var8+1)); \nmemberVar2=FUNC6(Var1->memberVar7,Var67); \nif (FUNC53((STRUCT6) Var7[1])&&!memberVar2){\nif (!FUNC54(Var1->memberVar14,Var7+1)){\nelse \nchar  Var39=*Var67; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var84=Var12; \nif (Var84){\nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC55(Var84)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar19=!!Var12; \nif (Var1->memberVar19){\nFUNC47(Var1); \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var93=Var7+3; \nVar15=FUNC56(Var1,Var2,Var93); \nelse \nVar15=FUNC57(Var1,Var2,Var7+2); \nelse \nbool  memberVar13=false ; \nconst char *Var94[]={STRING,STRING,STRING,\nconst char *Var95[]={STRING,STRING,STRING,\nSTRUCT3  Var96[FUNC58(Var94)-1],Var97[FUNC58(Var95)-1]; \nif (Var7[1]== (){\nchar *Var98=Var7+3; \nchar *Var30=strchr(Var98,); \nif (!Var30){\nSTRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); \nSTRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nVar96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nVar97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var99); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var100); \nif (Var17){\nif (Var65){\nVar1->memberVar6=memberVar2; \nVar15=FUNC3(Var1->memberVar5,FUNC59(Var2)); \nelse \nif (Var65){\nif (Var7[1]){\nFUNC5(Var1,memberVar2,1); \nFUNC47(Var1); \nVar15=FUNC3(Var1->memberVar5,FUNC59(Var2)); \nif (memberVar13){\nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); \nif (Var8){\nFUNC33(Var1,Var25); \nif (Var69){\nVar1->memberVar2=Var22; \nFUNC60(Var1->memberVar8,STRING,Var71); \nif (Var73 != -1){\nFUNC49(Var1->memberVar1,Var73); \nif (Var12){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,0); \nif (Var68){\nFUNC60(Var1->memberVar8,STRING,Var66); \nVar1->memberVar3=Var23; \nif (Var25 !=  Var1->memberVar4){\nFUNC33(Var1,Var25); \nif (Var70){\nFUNC4(Var1,Var70); \nif (Var72){\nFUNC61(Var1->memberVar14); \nVar62=Var2 FUNC3(Var1->memberVar5,FUNC59(Var2)) false ; \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar2=Var22; \nVar1->memberVar3=Var23; \nif (Var26 != -1){\nFUNC15(Var1->memberVar8,STRING,Var26); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 239,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3215,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var20=strchr(Var2,; ); \nchar *Var21=strchr(Var22+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25\nif (Var7&&(Var7[1]== ||Var7[1]==  Var26)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var28=Var1->memberVar5->memberVar1; \nelse \nchar *Var29=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nchar  Var31[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var32=FUNC9(Var1->memberVar7,STRING); \nint  Var33=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var34=Var7-1; \nconst bool  Var35=(Var7[1]== >); \nchar *Var36=FUNC10(Var1,Var2); \nchar *Var37=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var38=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nbool  Var39=false ; \nif (Var39){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var33=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var40=strstr(Var2,STRING); \nif (Var40){\nbool  Var41=false ; \nif (Var41){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var42,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var43=Var1->memberVar9; \nchar *Var44=NULL ; \nconst char *Var45=NULL ; \nchar *Var46=NULL ; \nchar *Var47=NULL ; \nint  Var48,Var49; \nSTRUCT5 *Var31; \n*Var7  Var30=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var30){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var50; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var51=strdup(Var7+2); \nchar *Var52=strchr(Var51,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); \nVar42=FUNC17(Var7+2,&Var48); \nif (Var42){\nSTRUCT7 *Var55=FUNC18((const STRUCT5 *) Var42,Var48); \nSTRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); \nif (Var31){\nmemcpy(Var1->memberVar11,Var42,Var48); \nfree(Var42); \nchar *Var58=strdup(Var7+2); \nchar  Var27=*Var59; \nSTRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC20(Var1,Var7+2); \nSTRUCT7 *Var55=FUNC18(Var31,Var49); \nSTRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); \nchar *Var60=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var21=strchr(Var7+2,); \nint  Var61=FUNC15(Var1->memberVar5,Var21); \nconst STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); \nSTRUCT7 *Var55=FUNC18(Var31,Var49); \nSTRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); \n*Var7=; \nchar *Var62=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC23((STRUCT5) Var7[1])&&!Var43){\nif (!FUNC24(Var1->memberVar13,Var7+1)){\nelse \nchar  Var27=*Var45; \nSTRUCT2 *Var56=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var7+3; \nchar *Var22=strchr(Var66,); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); \nSTRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 240,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3224,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \n*Var72=0; \nVar70=FUNC27(Var1->memberVar13,Var71); \n*Var72=Var33; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nfree(Var71); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar53=FUNC37(Var7+1); \nif (FUNC38((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC39(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC40(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 241,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3233,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tfree (numexpr);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nint  Var6=!Var7->memberVar1->memberVar1; \nint  Var8,Var9=0,Var10; \nbool  Var11=Var7->memberVar2; \nbool  Var12=Var7->memberVar3; \nSTRUCT1  Var13=Var7->memberVar4; \nif (!Var14){\nswitch (*Var14){\nif (Var14[1]== ){/*STRUCT2 */\nelse \nchar *Var15=strchr(Var14,; ); \nif (Var14[1]!= *&&!strstr(Var14,STRING)){\nif (Var14[1]== >){\nif (*Var14 != ){\nif (Var16&&Var2){\nint  Var9; \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nchar *Var3=strchr(Var14,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var18=Var7->memberVar5->memberVar1; \nelse \nchar *Var19=FUNC2(Var7->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var9 == -1){\nif (Var2&&(Var2 ==  Var14||Var2[-1]!= )){\nif (*Var14 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nint  Var9; \nif (!*Var4){\nif (!Var7->memberVar6){\nelse \n}else if (Var2 ==  Var14){\nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var20=FUNC4(Var7->memberVar7,STRING); \nint  Var21=FUNC4(Var7->memberVar7,STRING); \nif (!*Var4){\nchar *Var22=Var2-1; \nconst bool  Var23=(Var2[1]== >); \nchar *Var24=FUNC5(Var7,Var14); \nchar *Var25=FUNC6(Var7->memberVar8,Var4,1); \nconst char *Var26=FUNC7(Var7->memberVar7,STRING); \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nbool  Var27=false ; \nif (Var27){\nelse \nint  memberVar1=Var7->memberVar5->memberVar1; \nelse \nint  Var21=FUNC4(Var7->memberVar7,STRING); \nif (*Var14 != &&*Var14){\nconst char *Var28=strstr(Var14,STRING); \nif (Var28){\nbool  Var29=false ; \nif (Var29){\nif (Var2){\nchar *Var30,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var31=Var7->memberVar9; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var32=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT1  Var31=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var33=(int ) FUNC9(Var7->memberVar5,Var2+2); \nSTRUCT3 *Var34=FUNC10(Var7->memberVar10,Var7->memberVar9); \nSTRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); \nif (Var2[1]== ){\nchar *Var38=strdup(Var2+2); \nchar *Var39=FUNC12(Var38); \nif (Var39){\nchar  Var17=*Var39; \nfree(Var40); \nSTRUCT1  Var31=FUNC9(Var7->memberVar5,Var2+2); \nchar *Var14=FUNC13(Var7,Var2+2); \nSTRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); \nchar *Var41=FUNC14(Var7->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var42=strchr(Var2+2,); \nint  Var43=FUNC9(Var7->memberVar5,Var42); \nconst STRUCT5 *Var44=(const STRUCT5 *) FUNC15(Var2+2); \nSTRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); \nchar *Var45=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC16((STRUCT5) Var2[1])&&!Var31){\nif (!FUNC17(Var7->memberVar12,Var2+1)){\nelse \nchar  Var17=*Var46; \nif (Var5){\nchar *Var47=Var2+3; \nchar *Var48=Var2+3; \nSTRUCT1  Var49=FUNC9(Var7->memberVar5,Var48); \nSTRUCT1  Var50=FUNC9(Var7->memberVar5,Var51+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 242,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3239,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var20=strchr(Var2,; ); \nchar *Var21=strchr(Var22+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25\nif (Var7&&(Var7[1]== ||Var7[1]==  Var26)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var28=Var1->memberVar5->memberVar1; \nelse \nchar *Var29=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var31=FUNC9(Var1->memberVar7,STRING); \nint  Var32=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var33=Var7-1; \nconst bool  Var34=(Var7[1]== >); \nchar *Var35=FUNC10(Var1,Var2); \nchar *Var36=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var37=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nbool  Var38=false ; \nif (Var38){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var32=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var39=strstr(Var2,STRING); \nif (Var39){\nbool  Var40=false ; \nif (Var40){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var41,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var42=Var1->memberVar9; \nchar *Var43=NULL ; \nconst char *Var44=NULL ; \nchar *Var45=NULL ; \nchar *Var46=NULL ; \n*Var7  Var30=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var30){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var47; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var48=strdup(Var7+2); \nchar *Var49=strchr(Var48,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var42=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var50=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT5 *Var51=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); \nif (Var7[1]== ){\nSTRUCT3  Var55; \nchar *Var56=strdup(Var7+2); \nchar *Var57=FUNC18(Var56); \nif (Var57){\nchar  Var27=*Var57; \nVar55=FUNC19(Var1->memberVar11,Var56); \nfree(Var56); \nSTRUCT3  Var42=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC20(Var1,Var7+2); \nSTRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); \nchar *Var58=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var21=strchr(Var7+2,); \nint  Var59=FUNC15(Var1->memberVar5,Var21); \nconst STRUCT6 *Var60=(const STRUCT6 *) FUNC22(Var7+2); \nSTRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); \n*Var7=; \nchar *Var61=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC23((STRUCT6) Var7[1])&&!Var42){\nif (!FUNC24(Var1->memberVar13,Var7+1)){\nelse \nchar  Var27=*Var44; \nSTRUCT2 *Var52=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var62=Var7+3; \nconst char *Var63[]={STRING,STRING,STRING,\nconst char *Var64[]={STRING,STRING,STRING,\nchar *Var65=Var7+3; \nchar *Var22=strchr(Var65,); \nSTRUCT3  Var66=FUNC15(Var1->memberVar5,Var65); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 243,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3264,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var38,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var39=1; \nint  Var40=FUNC17(Var1->memberVar8,STRING); \nint  Var41=false ; \nint  Var42=FUNC17(Var1->memberVar8,STRING); \n*Var7=0; \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var45=FUNC19(Var1,Var2); \nchar *Var46=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var47=FUNC21(STRING,Var46,Var45); \nelse \nchar *Var48=FUNC21(STRING,Var45); \nelse \nchar *Var48=FUNC21(STRING,Var45); \nelse \n}else if (Var39>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var49=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var42=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \n*Var7  Var26=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var26){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var63; \nVar7=FUNC26(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var64=strdup(Var7+2); \nchar *Var65=strchr(Var64,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var66=(int ) FUNC28(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var67=FUNC29(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); \nchar *Var71=strdup(Var7+2); \nchar  Var35=*Var72; \nSTRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (!Var60){\nVar60=Var2; \nelse \nVar60=FUNC32(Var60,Var2); \nfree(Var2); \nSTRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); \nchar *Var73=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var74=FUNC28(Var1->memberVar6,Var29); \nconst STRUCT6 *Var75=(const STRUCT6 *) FUNC34(Var7+2); \nSTRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); \n*Var7=; \nchar *Var76=Var7-2; \nwhile (Var76>Var2){\nif (!FUNC35(*Var76)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC36((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC37(Var1->memberVar12,Var7+1)){\nelse \nchar  Var35=*Var57; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var77=Var7+3; \nVar15=FUNC38(Var1,Var2,Var77); \nelse \nVar15=FUNC39(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var78[]={STRING,STRING,STRING,\nconst char *Var79[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var80=Var7+3; \nchar *Var25=strchr(Var80,); \nif (!Var25){\nSTRUCT3  Var81=FUNC28(Var1->memberVar6,Var80); \nSTRUCT3  Var82=FUNC28(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC40(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC40(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC40(Var2)) false ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 244,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3270,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var38){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var38){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=FUNC11(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nchar *Var45=FUNC13(Var1,Var2); \nchar *Var46=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var47=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC11(Var1->memberVar7,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar9=Var7 true false ; \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar10; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nint  Var62=-1; \nint  Var63,Var64; \nSTRUCT5 *Var39; \n*Var7  Var38=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var38){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var65; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var66=strdup(Var7+2); \nchar *Var67=strchr(Var66,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar61=FUNC18(Var1->memberVar11,Var7+2); \nint  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var70=FUNC21(Var69,Var68); \nVar52=FUNC22(Var7+2,&Var63); \nif (Var52){\nSTRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nelse \nFUNC26(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var74; \nchar *Var75=strdup(Var7+2); \nchar *Var76=FUNC27(Var75); \nif (Var76){\nchar  Var35=*Var76; \nelse \nVar74=FUNC28(Var1->memberVar13,Var7+2); \nVar57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); \nSTRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); \nif (Var53){\nFUNC30(Var1,STRING,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar64=FUNC32(Var7+2,Var39); \nFUNC33(Var1,FUNC34(Var64)); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nVar12=Var72; \nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); \nFUNC33(Var1,Var64); \nfree(Var39); \nchar *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC38(Var1->memberVar1,FUNC39(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var78=FUNC19(Var1->memberVar5,Var29); \nVar58=FUNC40(Var1,Var7+2,&Var60); \nVar64=strlen(Var7+2); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \n*Var7=; \nchar *Var79=Var7-2; \nVar7=FUNC42(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar56=FUNC42(Var7+1); \nif (FUNC43((STRUCT5) Var7[1])&&!Var53){\nif (!FUNC44(Var1->memberVar11,Var7+1)){\nFUNC26(STRING,Var7+1); \nelse \nchar  Var35=*Var56; \nif (Var53){\nSTRUCT2 *Var72=Var12; \nif (Var72){\nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar15=!!Var12; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var80=Var7+3; \nelse \nVar15=FUNC46(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var81[]={STRING,STRING,STRING,\nconst char *Var82[]={STRING,STRING,STRING,\nSTRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; \nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var27=strchr(Var85,); \nif (!Var27){\nSTRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); \nSTRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nVar83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nVar84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var86); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var87); \nif (Var17){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nelse \nif (Var54){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nif (memberVar9){\nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); \nif (Var62 != -1){\nFUNC38(Var1->memberVar1,Var62); \nif (Var12){\nif (Var13){\nFUNC48(Var1->memberVar7,STRING,0); \nFUNC25(Var12); \nif (Var57){\nFUNC50(Var1->memberVar7,STRING,Var55); \nif (Var61){\nFUNC51(Var1->memberVar11); \n*Var7=; \nVar51=Var15; \nif (Var18 != -1){\nFUNC48(Var1->memberVar7,STRING,Var18); \nif (Var19 != -1){\nFUNC48(Var1->memberVar7,STRING,Var19); \nif (Var12){\nFUNC25(Var12); \nreturn  Var51; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 245,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3270,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var38){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var38){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=FUNC11(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nchar *Var45=FUNC13(Var1,Var2); \nchar *Var46=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var47=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC11(Var1->memberVar7,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar9=Var7 true false ; \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar10; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nint  Var62=-1; \nint  Var63,Var64; \nSTRUCT5 *Var39; \n*Var7  Var38=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var38){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var65; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var66=strdup(Var7+2); \nchar *Var67=strchr(Var66,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar61=FUNC18(Var1->memberVar11,Var7+2); \nint  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var70=FUNC21(Var69,Var68); \nVar52=FUNC22(Var7+2,&Var63); \nif (Var52){\nSTRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nelse \nFUNC26(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var74; \nchar *Var75=strdup(Var7+2); \nchar *Var76=FUNC27(Var75); \nif (Var76){\nchar  Var35=*Var76; \nelse \nVar74=FUNC28(Var1->memberVar13,Var7+2); \nVar57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); \nSTRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); \nif (Var53){\nFUNC30(Var1,STRING,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar64=FUNC32(Var7+2,Var39); \nFUNC33(Var1,FUNC34(Var64)); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nVar12=Var72; \nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); \nFUNC33(Var1,Var64); \nfree(Var39); \nchar *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC38(Var1->memberVar1,FUNC39(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var78=FUNC19(Var1->memberVar5,Var29); \nVar58=FUNC40(Var1,Var7+2,&Var60); \nVar64=strlen(Var7+2); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \n*Var7=; \nchar *Var79=Var7-2; \nVar7=FUNC42(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar56=FUNC42(Var7+1); \nif (FUNC43((STRUCT5) Var7[1])&&!Var53){\nif (!FUNC44(Var1->memberVar11,Var7+1)){\nFUNC26(STRING,Var7+1); \nelse \nchar  Var35=*Var56; \nif (Var53){\nSTRUCT2 *Var72=Var12; \nif (Var72){\nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar15=!!Var12; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var80=Var7+3; \nelse \nVar15=FUNC46(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var81[]={STRING,STRING,STRING,\nconst char *Var82[]={STRING,STRING,STRING,\nSTRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; \nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var27=strchr(Var85,); \nif (!Var27){\nSTRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); \nSTRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nVar83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nVar84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var86); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var87); \nif (Var17){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nelse \nif (Var54){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nif (memberVar9){\nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); \nif (Var62 != -1){\nFUNC38(Var1->memberVar1,Var62); \nif (Var12){\nif (Var13){\nFUNC48(Var1->memberVar7,STRING,0); \nFUNC25(Var12); \nif (Var57){\nFUNC50(Var1->memberVar7,STRING,Var55); \nif (Var61){\nFUNC51(Var1->memberVar11); \n*Var7=; \nVar51=Var15; \nif (Var18 != -1){\nFUNC48(Var1->memberVar7,STRING,Var18); \nif (Var19 != -1){\nFUNC48(Var1->memberVar7,STRING,Var19); \nif (Var12){\nFUNC25(Var12); \nreturn  Var51; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 246,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3292,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var20=strchr(Var2,; ); \nchar *Var21=strchr(Var22+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25\nif (Var7&&(Var7[1]== ||Var7[1]==  Var26)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var28=Var1->memberVar5->memberVar1; \nelse \nchar *Var29=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nchar  Var31[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var32=FUNC9(Var1->memberVar7,STRING); \nint  Var33=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var34=Var7-1; \nconst bool  Var35=(Var7[1]== >); \nchar *Var36=FUNC10(Var1,Var2); \nchar *Var37=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var38=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nbool  Var39=false ; \nif (Var39){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var33=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var40=strstr(Var2,STRING); \nif (Var40){\nbool  Var41=false ; \nif (Var41){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var42,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var43=Var1->memberVar9; \nchar *Var44=NULL ; \nconst char *Var45=NULL ; \nchar *Var46=NULL ; \nchar *Var47=NULL ; \nint  Var48,Var49; \nSTRUCT5 *Var31; \n*Var7  Var30=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var30){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var50; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var51=strdup(Var7+2); \nchar *Var52=strchr(Var51,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT7 *Var55=FUNC17((const STRUCT5 *) Var42,Var48); \nSTRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); \nchar *Var58=strdup(Var7+2); \nchar  Var27=*Var59; \nSTRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC19(Var1,Var7+2); \nif (Var7[1]== ){\nVar31=malloc(strlen(Var7+2)+1); \nif (Var31){\nVar49=FUNC20(Var7+2,Var31); \nif (Var49>0){\nSTRUCT7 *Var55=FUNC17(Var31,Var49); \nSTRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); \nfree(Var31); \nchar *Var60=FUNC21(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var21=strchr(Var7+2,); \nint  Var61=FUNC15(Var1->memberVar5,Var21); \nconst STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); \nSTRUCT7 *Var55=FUNC17(Var31,Var49); \nSTRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); \n*Var7=; \nchar *Var62=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC23((STRUCT5) Var7[1])&&!Var43){\nif (!FUNC24(Var1->memberVar12,Var7+1)){\nelse \nchar  Var27=*Var45; \nSTRUCT2 *Var56=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var7+3; \nchar *Var22=strchr(Var66,); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); \nSTRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 247,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3305,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var24=strchr(Var2,; ); \nchar *Var25=strchr(Var26+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var27  Var28  Var5  Var29\nif (Var7&&(Var7[1]== ||Var7[1]==  Var30)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var31=Var7-1; \nif (*Var31 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var32=Var1->memberVar5->memberVar1; \nelse \nchar *Var33=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var34){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nchar  Var35[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var31=Var7-1; \nif (*Var31 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var36=FUNC9(Var1->memberVar7,STRING); \nint  Var37=false ; \nint  Var38=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var39=Var7-1; \nconst bool  Var40=(Var7[1]== >); \nchar *Var41=FUNC10(Var1,Var2); \nchar *Var42=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var43=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var31=Var7-1; \nif (*Var31 == ){\nbool  Var44=false ; \nif (Var44){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var38=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var45=strstr(Var2,STRING); \nif (Var45){\nbool  Var46=false ; \nif (Var46){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var47,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var48=Var1->memberVar10; \nbool  Var49=false ; \nchar *Var50=NULL ; \nconst char *Var51=NULL ; \nbool  Var52=false ; \nbool  Var53=false ; \nchar *Var54=NULL ; \nchar *Var55=NULL ; \nbool  Var56=false ; \nint  Var57,Var58; \nSTRUCT5 *Var35; \n*Var7  Var34=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var34){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var59; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var60=strdup(Var7+2); \nchar *Var61=strchr(Var60,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var48=FUNC14(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var62=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var63=FUNC16(Var1->memberVar11,Var1->memberVar10); \nif (Var63){\nif (Var62 >= 0&&Var62<Var63->memberVar1){\nSTRUCT7  Var64=FUNC17(Var63,Var62); \nVar22=Var1->memberVar9=true ; \nif (Var47){\nSTRUCT8 *Var65=FUNC18((const STRUCT5 *) Var47,Var57); \nSTRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); \nif (Var35){\nVar1->memberVar4=Var57; \nif (Var7[1]== ){\nchar *Var68=strdup(Var7+2); \nchar  Var31=*Var69; \nVar22=Var1->memberVar9=true ; \nSTRUCT3  Var48=FUNC15(Var1->memberVar5,Var7+2); \nif (Var48){\nVar22=Var1->memberVar9=true ; \nchar *Var2=FUNC20(Var1,Var7+2); \nSTRUCT8 *Var65=FUNC18(Var35,Var58); \nSTRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); \nchar *Var70=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var70){\nFUNC22(Var1,FUNC15(Var1->memberVar5,Var70),1); \nfree(Var70); \nchar *Var25=strchr(Var7+2,); \nint  Var71=FUNC15(Var1->memberVar5,Var25); \nconst STRUCT5 *Var35=(const STRUCT5 *) FUNC23(Var7+2); \nSTRUCT8 *Var65=FUNC18(Var35,Var58); \nSTRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); \n*Var7=; \nchar *Var72=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC24((STRUCT5) Var7[1])&&!Var48){\nif (!FUNC25(Var1->memberVar13,Var7+1)){\nelse \nchar  Var31=*Var51; \nSTRUCT2 *Var66=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var73=Var7+3; \nelse \nbool  memberVar9=false ; \nconst char *Var74[]={STRING,STRING,STRING,\nconst char *Var75[]={STRING,STRING,STRING,\nchar *Var76=Var7+3; \nchar *Var26=strchr(Var76,); \nSTRUCT3  Var77=FUNC15(Var1->memberVar5,Var76); \nSTRUCT3  Var78=FUNC15(Var1->memberVar5,Var26+1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 248,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 3313,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nint  Var26=-1; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nSTRUCT3  Var27=Var28; \nchar *Var29,*Var30; \nif (Var21){\nif (!Var30||!*Var30){\nelse \nchar *Var31=strchr(Var2,; ); \nFUNC4(Var1,Var2); \nif (!Var31){\nif (*Var30){\nif (Var30[1]== ||(Var30[1]&&Var30[2]== )){\nchar *Var32=strchr(Var30+1,); \nVar27=Var1->memberVar6; \nFUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); \nconst bool  Var33=Var30[2]== >; \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC7(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var29); \nif (Var27 !=  Var28){\nFUNC5(Var1,Var27,1); \nif (!Var30){\nif (Var20){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC8(Var1,Var34); \nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37\nif (Var7&&(Var7[1]== ||Var7[1]==  Var38)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (FUNC10(Var1,Var2) == -1){\nVar15=FUNC10(Var1,Var2); \nVar7=(char *) FUNC11(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nmemmove(Var39,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC12(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nFUNC8(Var1,Var40); \nelse \n}else if (!FUNC13(Var7+1,STRING,1)){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC16(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var42=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var43=FUNC17(Var1->memberVar1,Var7+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nVar7=(char *) FUNC11(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){\nVar7=strchr(Var2,&); \nFUNC18(Var1->memberVar9); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var45=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC19(Var1,Var45,Var2); \nFUNC20(Var7+2,STRING); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC21()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var44){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var46[1024]; \nint  Var15; \nif (FUNC22(stdin)){\nVar1->memberVar10  STRUCT5  Var15; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var46,Var9)){\nstrcat((char *) Var1->memberVar9,Var46); \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var44){\nif (!*Var9){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC23(Var9,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var7 ==  Var2){\nreturn FUNC24(Var1,(const char *) Var1->memberVar9); \nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nmemmove(Var39,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nFUNC8(Var1,Var34); \nint  Var47=1; \nint  Var48=FUNC14(Var1->memberVar8,STRING); \nint  Var49=false ; \nint  Var50=FUNC14(Var1->memberVar8,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC25(Var7[-2])){\nchar *Var51=Var7-1; \nif (*Var51 ==  Var52){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var9,STRING)){\nFUNC15(Var1->memberVar8,STRING,Var41); \nconst bool  Var53=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var54=FUNC26(Var1,Var2); \nif (Var53){\nchar *Var55=FUNC27(Var1->memberVar5,Var9,1); \nif (Var55){\nchar *Var56=FUNC28(STRING,Var55,Var54); \nif (Var56){\nFUNC29(Var1->memberVar5,Var9,Var56,1); \nelse \nchar *Var57=FUNC28(STRING,Var54); \nFUNC29(Var1->memberVar5,Var9,Var57,1); \nelse \nchar *Var57=FUNC28(STRING,Var54); \nFUNC29(Var1->memberVar5,Var9,Var57,1); \nelse \n}else if (Var47>0){\nif (Var16 != -1){\nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var41); \nVar15=FUNC10(Var1,Var2); \nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var49){\nconst char *Var58=FUNC30(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar11->memberVar1=false ; \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nbool  Var59=false ; \nif (Var59){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC31(Var1,Var7+1); \nelse \nint  Var50=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar9=FUNC26(Var1,Var7+1); \nVar1->memberVar12=false ; \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar15=FUNC10(Var1,Var2); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (*Var2 != &&*Var2){\nconst char *Var60=strstr(Var2,STRING); \nif (Var60){\nbool  Var61=false ; \nif (Var61){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar13=Var7 true false ; \nint  Var62=0; \nif (Var7){\nchar *Var63,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var64=Var1->memberVar6; \nbool  Var65=false ; \nchar *Var66=NULL ; \nconst char *Var67=NULL ; \nbool  Var68=false ; \nbool  Var69=false ; \nchar *Var70=NULL ; \nchar *Var71=NULL ; \nbool  Var72=false ; \nint  Var73=-1; \nint  Var74,Var75; \nSTRUCT6 *Var46; \n*Var7  Var44=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var44){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var76; \nVar7=FUNC32(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var77=strdup(Var7+2); \nchar *Var78=strchr(Var77,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+4); \nFUNC34(Var1,FUNC35((Var79) Var64-(Var79) Var1->memberVar6)); \nelse \nVar64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+3); \nFUNC5(Var1,Var64,1); \nVar24=Var1->memberVar13=true ; \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar72=FUNC36(Var1->memberVar14,Var7+2); \nint  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); \nSTRUCT7 *Var81=FUNC37(Var1->memberVar15,Var1->memberVar6); \nif (Var81){\nif (Var80 >= 0&&Var80<Var81->memberVar1){\nSTRUCT8  Var82=FUNC38(Var81,Var80); \nFUNC5(Var1,Var81->memberVar2+Var82,1); \nVar24=Var1->memberVar13=true ; \nVar63=FUNC23(Var7+2,&Var74); \nif (Var63){\nSTRUCT9 *Var83=FUNC39((const STRUCT6 *) Var63,Var74); \nSTRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); \nif (Var46){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var46; \nVar1->memberVar4=Var74; \nmemcpy(Var1->memberVar16,Var63,Var74); \nelse \nFUNC43(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var86; \nchar *Var87=strdup(Var7+2); \nchar *Var88=FUNC44(Var87); \nif (Var88){\nchar  Var39=*Var88; \nVar86=FUNC45(Var1->memberVar17,Var87); \nVar86=FUNC6(Var1->memberVar7,Var89); \nelse \nVar86=FUNC45(Var1->memberVar17,Var7+2); \nFUNC5(Var1,Var86,1); \nVar24=Var1->memberVar13=true ; \nVar68=FUNC46(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); \nVar26=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); \nif (memberVar2){\nFUNC16(Var1,STRING,Var7+2); \nVar24=Var1->memberVar13=true ; \nchar *Var2=FUNC47(Var1,Var7+2); \nif (Var7[1]== ){\nVar46=malloc(strlen(Var7+2)+1); \nif (Var46){\nVar75=FUNC48(Var7+2,Var46); \nFUNC34(Var1,FUNC35(Var75)); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC39(Var46,Var75); \nSTRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); \nFUNC34(Var1,Var75); \nFUNC49(Var1); \nchar *Var90=FUNC50(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var90){\nFUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); \nif (Var7[1]== ){\nVar73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC51(Var1->memberVar1,FUNC52(Var7+2)); \nif (Var7[1]== ){\nchar *Var32=strchr(Var7+2,); \nif (Var32){\nint  Var91=FUNC6(Var1->memberVar7,Var32); \nVar68=FUNC46(Var1,Var91,&Var66); \nVar69=FUNC53(Var1,Var7+2,&Var71); \nVar75=strlen(Var7+2); \nFUNC34(Var1,Var75); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC54(Var7+2); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC39(Var46,Var75); \nSTRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC15(Var1->memberVar8,STRING,1); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); \nFUNC34(Var1,Var75); \n*Var7=; \nchar *Var92=Var7-2; \nVar7=FUNC55(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nFUNC34(\nVar1,FUNC6(Var1->memberVar7,Var8+1)); \nVar67=FUNC55(Var7+1); \nmemberVar2=FUNC6(Var1->memberVar7,Var67); \nif (FUNC56((STRUCT6) Var7[1])&&!memberVar2){\nif (!FUNC57(Var1->memberVar14,Var7+1)){\nFUNC43(STRING,Var7+1); \nelse \nchar  Var39=*Var67; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var84=Var12; \nif (Var84){\nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC58(Var84)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar19=!!Var12; \nif (Var1->memberVar19){\nFUNC49(Var1); \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var93=Var7+3; \nVar15=FUNC59(Var1,Var2,Var93); \nelse \nVar15=FUNC60(Var1,Var2,Var7+2); \nelse \nbool  memberVar13=false ; \nconst char *Var94[]={STRING,STRING,STRING,\nconst char *Var95[]={STRING,STRING,STRING,\nSTRUCT3  Var96[FUNC61(Var94)-1],Var97[FUNC61(Var95)-1]; \nif (Var7[1]== (){\nchar *Var98=Var7+3; \nchar *Var30=strchr(Var98,); \nif (!Var30){\nSTRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); \nSTRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nVar96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nVar97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var99); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var100); \nif (Var17){\nif (Var65){\nVar1->memberVar6=memberVar2; \nVar15=FUNC3(Var1->memberVar5,FUNC55(Var2)); \nelse \nif (Var65){\nif (Var7[1]){\nFUNC5(Var1,memberVar2,1); \nFUNC49(Var1); \nVar15=FUNC3(Var1->memberVar5,FUNC55(Var2)); \nif (memberVar13){\nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); \nif (Var8){\nFUNC34(Var1,Var25); \nif (Var69){\nVar1->memberVar2=Var22; \nFUNC62(Var1->memberVar8,STRING,Var71); \nif (Var73 != -1){\nFUNC51(Var1->memberVar1,Var73); \nif (Var12){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,0); \nif (Var68){\nFUNC62(Var1->memberVar8,STRING,Var66); \nVar1->memberVar3=Var23; \nif (Var25 !=  Var1->memberVar4){\nFUNC34(Var1,Var25); \nif (Var70){\nFUNC4(Var1,Var70); \nif (Var72){\nFUNC63(Var1->memberVar14); \n*Var7=; \nVar62=Var2 FUNC3(Var1->memberVar5,FUNC55(Var2)) false ; \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar2=Var22; \nVar1->memberVar3=Var23; \nif (Var26 != -1){\nFUNC15(Var1->memberVar8,STRING,Var26); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 249,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3318,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nif (Var27){\n*Var27  Var36=0; \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar54=FUNC28(Var1,Var74,&Var52); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar53=FUNC37(Var7+1); \nif (FUNC38((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC39(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC40(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 250,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3331,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var38){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var38){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=FUNC11(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nchar *Var45=FUNC13(Var1,Var2); \nchar *Var46=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var47=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC11(Var1->memberVar7,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar9=Var7 true false ; \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar10; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nint  Var62=-1; \nint  Var63,Var64; \nSTRUCT5 *Var39; \n*Var7  Var38=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var38){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var65; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var66=strdup(Var7+2); \nchar *Var67=strchr(Var66,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar61=FUNC18(Var1->memberVar11,Var7+2); \nint  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var70=FUNC21(Var69,Var68); \nVar52=FUNC22(Var7+2,&Var63); \nif (Var52){\nSTRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nelse \nFUNC26(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var74; \nchar *Var75=strdup(Var7+2); \nchar *Var76=FUNC27(Var75); \nif (Var76){\nchar  Var35=*Var76; \nelse \nVar74=FUNC28(Var1->memberVar13,Var7+2); \nVar57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); \nSTRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); \nif (Var53){\nFUNC30(Var1,STRING,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar64=FUNC32(Var7+2,Var39); \nFUNC33(Var1,FUNC34(Var64)); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nFUNC33(Var1,Var64); \nchar *Var77=FUNC35(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC36(Var1->memberVar1,FUNC37(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var78=FUNC19(Var1->memberVar5,Var29); \nVar58=FUNC38(Var1,Var7+2,&Var60); \nVar64=strlen(Var7+2); \nFUNC33(Var1,Var64); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC39(Var7+2); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nVar12=Var72; \nFUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC41(Var71)); \nFUNC33(Var1,Var64); \n*Var7=; \nchar *Var79=Var7-2; \nVar7=FUNC42(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar56=FUNC42(Var7+1); \nif (FUNC43((STRUCT5) Var7[1])&&!Var53){\nif (!FUNC44(Var1->memberVar11,Var7+1)){\nFUNC26(STRING,Var7+1); \nelse \nchar  Var35=*Var56; \nif (Var53){\nSTRUCT2 *Var72=Var12; \nif (Var72){\nFUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar15=!!Var12; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var80=Var7+3; \nelse \nVar15=FUNC46(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var81[]={STRING,STRING,STRING,\nconst char *Var82[]={STRING,STRING,STRING,\nSTRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; \nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var27=strchr(Var85,); \nif (!Var27){\nSTRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); \nSTRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nVar83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nVar84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var86); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var87); \nif (Var17){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nelse \nif (Var54){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nif (memberVar9){\nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); \nif (Var62 != -1){\nFUNC36(Var1->memberVar1,Var62); \nif (Var12){\nif (Var13){\nFUNC48(Var1->memberVar7,STRING,0); \nFUNC25(Var12); \nif (Var57){\nFUNC50(Var1->memberVar7,STRING,Var55); \nif (Var61){\nFUNC51(Var1->memberVar11); \n*Var7=; \nVar51=Var15; \nif (Var18 != -1){\nFUNC48(Var1->memberVar7,STRING,Var18); \nif (Var19 != -1){\nFUNC48(Var1->memberVar7,STRING,Var19); \nif (Var12){\nFUNC25(Var12); \nreturn  Var51; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 251,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 252,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 253,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 254,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 255,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3380,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 256,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3380,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 257,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3447,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var20,*Var21; \nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var21+1,); \nconst bool  Var24=Var21[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27\nif (Var7&&(Var7[1]== ||Var7[1]==  Var28)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var33=FUNC9(Var1->memberVar7,STRING); \nint  Var34=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var35=Var7-1; \nconst bool  Var36=(Var7[1]== >); \nchar *Var37=FUNC10(Var1,Var2); \nchar *Var38=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var39=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var43,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var7  Var32=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var32){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var49; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var50=strdup(Var7+2); \nchar *Var51=strchr(Var50,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var7+2); \nchar  Var29=*Var58; \nSTRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var23=strchr(Var7+2,); \nint  Var60=FUNC15(Var1->memberVar5,Var23); \nconst STRUCT6 *Var61=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \n*Var7=; \nchar *Var62=Var7-2; \nVar7=FUNC21(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC22((STRUCT6) Var7[1])&&!Var44){\nif (!FUNC23(Var1->memberVar12,Var7+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT2 *Var54=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nSTRUCT3  Var66[FUNC24(Var64)-1],Var67[FUNC24(Var65)-1]; \nif (Var7[1]== (){\nchar *Var68=Var7+3; \nchar *Var21=strchr(Var68,); \nif (!Var21){\n*Var21=Var69; \nSTRUCT3  Var70=FUNC15(Var1->memberVar5,Var68); \nSTRUCT3  Var71=FUNC15(Var1->memberVar5,Var21+1); \nfor (Var14=0; Var65[Var14]; Var14  Var32){\nFUNC25(Var1->memberVar7,Var65[Var14],Var71); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 258,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3450,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var20,*Var21; \nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var21+1,); \nconst bool  Var24=Var21[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27\nif (Var7&&(Var7[1]== ||Var7[1]==  Var28)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var33=FUNC9(Var1->memberVar7,STRING); \nint  Var34=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var35=Var7-1; \nconst bool  Var36=(Var7[1]== >); \nchar *Var37=FUNC10(Var1,Var2); \nchar *Var38=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var39=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var43,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var7  Var32=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var32){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var49; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var50=strdup(Var7+2); \nchar *Var51=strchr(Var50,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var7+2); \nchar  Var29=*Var58; \nSTRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nif (!Var47){\nVar47=Var2; \nelse \nVar47=FUNC19(Var47,Var2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var23=strchr(Var7+2,); \nint  Var60=FUNC15(Var1->memberVar5,Var23); \nconst STRUCT6 *Var61=(const STRUCT6 *) FUNC21(Var7+2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \n*Var7=; \nchar *Var62=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC22((STRUCT6) Var7[1])&&!Var44){\nif (!FUNC23(Var1->memberVar12,Var7+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT2 *Var54=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var66=Var7+3; \nchar *Var21=strchr(Var66,); \nif (!Var21){\nfree(Var47); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); \nSTRUCT3  Var68=FUNC15(Var1->memberVar5,Var21+1); \nif (Var47){\nFUNC24(Var1,Var47); \nFUNC25(Var47); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 259,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3451,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpasm);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\t\tR_FREE (tmpasm);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nSTRUCT1 *Var7=NULL ; \nint  Var8=!Var9->memberVar1->memberVar1; \nint  Var10,Var11=0,Var12; \nbool  Var13=Var9->memberVar2; \nbool  Var14=Var9->memberVar3; \nSTRUCT2  Var15=Var9->memberVar4; \nif (!Var16){\nswitch (*Var16){\nif (Var16[1]== ){/*STRUCT3 */\nchar *Var17,*Var18; \nelse \nchar *Var19=strchr(Var16,; ); \nchar *Var20=strchr(Var18+1,); \nconst bool  Var21=Var18[2]== >; \nif (Var16[1]!= *&&!strstr(Var16,STRING)){\nif (Var16[1]== >){\nif (*Var16 != ){\nif (Var22&&Var2){\nint  Var11; \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nchar *Var3=strchr(Var16,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var24=Var9->memberVar5->memberVar1; \nelse \nchar *Var25=FUNC2(Var9->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var11 == -1){\nif (Var2&&(Var2 ==  Var16||Var2[-1]!= )){\nif (*Var16 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nint  Var11; \nif (!*Var4){\nif (!Var9->memberVar6){\nelse \n}else if (Var2 ==  Var16){\nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var26=FUNC4(Var9->memberVar7,STRING); \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (!*Var4){\nchar *Var28=Var2-1; \nconst bool  Var29=(Var2[1]== >); \nchar *Var30=FUNC5(Var9,Var16); \nchar *Var31=FUNC6(Var9->memberVar8,Var4,1); \nconst char *Var32=FUNC7(Var9->memberVar7,STRING); \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nbool  Var33=false ; \nif (Var33){\nelse \nint  memberVar1=Var9->memberVar5->memberVar1; \nelse \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (*Var16 != &&*Var16){\nconst char *Var34=strstr(Var16,STRING); \nif (Var34){\nbool  Var35=false ; \nif (Var35){\nif (Var2){\nchar *Var36,*Var3=strchr(Var2+1,!); \nSTRUCT2  Var37=Var9->memberVar9; \nchar *Var38=NULL ; \nconst char *Var39=NULL ; \nbool  Var40=false ; \nchar *Var41=NULL ; \nchar *Var42=NULL ; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var43=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); \nSTRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var49=strdup(Var2+2); \nchar  Var23=*Var50; \nSTRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); \nchar *Var16=FUNC12(Var9,Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var20=strchr(Var2+2,); \nint  Var52=FUNC9(Var9->memberVar5,Var20); \nconst STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var54=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC15((STRUCT5) Var2[1])&&!Var37){\nif (!FUNC16(Var9->memberVar12,Var2+1)){\nelse \nchar  Var23=*Var39; \nSTRUCT1 *Var46=Var7; \nif (Var5){\nif (Var2[1]== ){\nchar *Var55=Var2+3; \nconst char *Var56[]={STRING,STRING,STRING,\nconst char *Var57[]={STRING,STRING,STRING,\nif (Var2[1]== (){\nchar *Var58=Var2+3; \nchar *Var18=strchr(Var58,); \nif (!Var18){\nfree(Var42); \nSTRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); \nSTRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); \nif (Var40){\nFUNC17(Var9->memberVar7,STRING,Var42); \nFUNC18(Var42); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 260,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3452,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpbits);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nSTRUCT1 *Var7=NULL ; \nint  Var8=!Var9->memberVar1->memberVar1; \nint  Var10,Var11=0,Var12; \nbool  Var13=Var9->memberVar2; \nbool  Var14=Var9->memberVar3; \nSTRUCT2  Var15=Var9->memberVar4; \nif (!Var16){\nswitch (*Var16){\nif (Var16[1]== ){/*STRUCT3 */\nchar *Var17,*Var18; \nelse \nchar *Var19=strchr(Var16,; ); \nchar *Var20=strchr(Var18+1,); \nconst bool  Var21=Var18[2]== >; \nif (Var16[1]!= *&&!strstr(Var16,STRING)){\nif (Var16[1]== >){\nif (*Var16 != ){\nif (Var22&&Var2){\nint  Var11; \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nchar *Var3=strchr(Var16,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var24=Var9->memberVar5->memberVar1; \nelse \nchar *Var25=FUNC2(Var9->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var11 == -1){\nif (Var2&&(Var2 ==  Var16||Var2[-1]!= )){\nif (*Var16 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nint  Var11; \nif (!*Var4){\nif (!Var9->memberVar6){\nelse \n}else if (Var2 ==  Var16){\nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var26=FUNC4(Var9->memberVar7,STRING); \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (!*Var4){\nchar *Var28=Var2-1; \nconst bool  Var29=(Var2[1]== >); \nchar *Var30=FUNC5(Var9,Var16); \nchar *Var31=FUNC6(Var9->memberVar8,Var4,1); \nconst char *Var32=FUNC7(Var9->memberVar7,STRING); \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nbool  Var33=false ; \nif (Var33){\nelse \nint  memberVar1=Var9->memberVar5->memberVar1; \nelse \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (*Var16 != &&*Var16){\nconst char *Var34=strstr(Var16,STRING); \nif (Var34){\nbool  Var35=false ; \nif (Var35){\nif (Var2){\nchar *Var36,*Var3=strchr(Var2+1,!); \nSTRUCT2  Var37=Var9->memberVar9; \nchar *Var38=NULL ; \nconst char *Var39=NULL ; \nbool  Var40=false ; \nchar *Var41=NULL ; \nchar *Var42=NULL ; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var43=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); \nSTRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var49=strdup(Var2+2); \nchar  Var23=*Var50; \nSTRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); \nchar *Var16=FUNC12(Var9,Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var20=strchr(Var2+2,); \nint  Var52=FUNC9(Var9->memberVar5,Var20); \nconst STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var54=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC15((STRUCT5) Var2[1])&&!Var37){\nif (!FUNC16(Var9->memberVar12,Var2+1)){\nelse \nchar  Var23=*Var39; \nSTRUCT1 *Var46=Var7; \nif (Var5){\nif (Var2[1]== ){\nchar *Var55=Var2+3; \nconst char *Var56[]={STRING,STRING,STRING,\nconst char *Var57[]={STRING,STRING,STRING,\nif (Var2[1]== (){\nchar *Var58=Var2+3; \nchar *Var18=strchr(Var58,); \nif (!Var18){\nfree(Var38); \nSTRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); \nSTRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); \nif (Var40){\nFUNC17(Var9->memberVar7,STRING,Var38); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreach_comment",
    "Source": false,
    "Sink": false,
    "idx": 261,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3576,
    "label": -3,
    "slices": [
      "static int foreach_comment(void *user, const char *k, const char *v) {\n",
      "\tif (!strncmp (k, \"meta.C.\", 7)) {\n",
      "\t\tchar *cmt = (char *)sdb_decode (v, 0);\n",
      "\t\tif (cmt) {\n",
      "\t\t\tfree (cmt);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2,const char *Var3){\nif (!FUNC2(Var2,STRING,7)){\nchar *Var4=(char *) FUNC3(Var3,0); \nif (Var4){\nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreach_pairs",
    "Source": false,
    "Sink": false,
    "idx": 262,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3599,
    "label": -3,
    "slices": [
      "static void foreach_pairs(RCore *core, const char *cmd, const char *each) {\n",
      "\tconst char *arg;\n",
      "\tint pair = 0;\n",
      "\tfor (arg = each ; ; ) {\n",
      "\t\tchar *next = strchr (arg, ' ');\n",
      "\t\tif (next) {\n",
      "\t\t\t*next = 0;\n",
      "\t\tif (arg && *arg) {\n",
      "\t\t\tut64 n = r_num_get (NULL, arg);\n",
      "\t\t\tif (pair%2) {\n",
      "\t\t\t\tr_core_block_size (core, n);\n",
      "else\n",
      "\t\t\t\tr_core_seek (core, n, 1);\n",
      "\t\tif (!next) {\n",
      "\t\targ = next + 1;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nconst char *Var4; \nint  Var5=0; \nfor (Var4=Var3; ; ){\nchar *Var6=strchr(Var4,); \nif (Var6){\n*Var6=0; \nif (Var4&&*Var4){\nSTRUCT2  Var7=FUNC2(NULL ,Var4); \nif (Var5%2){\nFUNC3(Var1,Var7); \nelse \nFUNC4(Var1,Var7,1); \nif (!Var6){\nVar4=Var6+1; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 263,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3642,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\tif (filter) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tforeach_pairs (core, cmd, arg);\n",
      "\t\t\tfree (arg);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING\nSTRUCT2 *Var5=Var2->memberVar1; \nconst char *Var6=NULL ; \nif (Var4[1]== ){\nVar6=Var4+2; \nswitch (Var4[0]){\nif (Var6){\nchar *Var7=FUNC2(Var2,Var6); \nFUNC3(Var2,Var3,Var7); \nfree(Var7); \nint  Var8=FUNC4(Var2->memberVar2); \nSTRUCT3 *Var9=FUNC5(Var2->memberVar2,Var8); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var11=FUNC6(Var2->memberVar4,Var12); \nSTRUCT5 *Var13=FUNC7(Var2->memberVar5); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var14=Var2->memberVar6; \nSTRUCT5 *Var13=FUNC7(Var2->memberVar5); \nint  Var15=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nchar *Var17=Var6 FUNC8(Var6) NULL ; \nSTRUCT4  Var18=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT6 *Var19=FUNC9(Var2->memberVar7,Var2->memberVar3,0); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 264,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3728,
    "label": -3,
    "slices": [
      "\tRDebug *dbg = core->dbg;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRBinImport *imp;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tchar *impflag = r_str_newf (\"sym.imp.%s\", imp->name);\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\t\tfree (impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 addr = sec->vaddr;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ],
    "tokenized": "STRUCT1 *Var1=Var2->memberVar1; \nswitch (Var3[0]){\nchar *Var4=FUNC1(Var2,Var5); \nint  Var6=FUNC2(Var2->memberVar2); \nSTRUCT2 *Var7=FUNC3(Var2->memberVar2,Var6); \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT4 *Var9; \nSTRUCT3  Var8=Var2->memberVar3; \nchar *Var10=FUNC4(STRING,Var9->memberVar1); \nSTRUCT3  Var11=FUNC5(Var2->memberVar4,Var10); \nfree(Var10); \nSTRUCT5 *Var12=FUNC6(Var2->memberVar5); \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var13=Var2->memberVar6; \nSTRUCT5 *Var12=FUNC6(Var2->memberVar5); \nint  Var14=Var2->memberVar6; \nSTRUCT3  Var11=Var15->memberVar1; \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var17=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT6 *Var18=FUNC7(Var2->memberVar7,Var2->memberVar3,0); \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 265,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3819,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tr_flag_foreach_glob (core->flags, glob, exec_command_on_flag, &u);\n",
      "\t\t\tfree (glob);\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING\nSTRUCT2 *Var5=Var2->memberVar1; \nconst char *Var6=NULL ; \nif (Var4[1]== ){\nVar6=Var4+2; \nswitch (Var4[0]){\nchar *Var7=FUNC2(Var2,Var6); \nint  Var8=FUNC3(Var2->memberVar2); \nSTRUCT3 *Var9=FUNC4(Var2->memberVar2,Var8); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var11=FUNC5(Var2->memberVar4,Var12); \nSTRUCT5 *Var13=FUNC6(Var2->memberVar5); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var14=Var2->memberVar6; \nSTRUCT5 *Var13=FUNC6(Var2->memberVar5); \nint  Var15=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nchar *Var17=Var6 FUNC7(Var6) NULL ; \nSTRUCT4  Var18=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nFUNC8(Var2->memberVar7,Var17,Var19,&Var20); \nfree(Var17); \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT6 *Var21=FUNC9(Var2->memberVar8,Var2->memberVar3,0); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 266,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3867,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=strdup(Var2); \nwhile (Var3){\nif (!*Var3){\nchar *Var5=strchr(Var3,Var6); \nwhile (Var3&&*Var3){\nchar *Var7=strchr(Var3,); \nif (Var7){\nelse \nif (!*Var3){\nFUNC2(Var1,Var4,0); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 267,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3881,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=NULL ; \nSTRUCT2  Var5; \nwhile (Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nif (!*Var3){\nchar *Var7=strchr(Var3,Var8); \nif (Var7){\n*Var7=0; \nVar4=Var7+1; \nelse \nVar4=NULL ; \nVar7=strchr(Var3,); \nif (Var7){\n*Var7=0; \nwhile (Var3&&*Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nchar *Var9=strchr(Var3,); \nif (Var9){\n*Var9=0; \nVar5=FUNC2(Var1->memberVar1,Var3); \n*Var9=; \nVar3=Var9+1; \nelse \nif (!*Var3){\nVar5=FUNC2(Var1->memberVar1,Var3); \nFUNC3(Var1,Var5,1); \nVar3=Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 268,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3889,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\teach = nextLine;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=NULL ; \nSTRUCT2  Var5; \nwhile (Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nif (!*Var3){\nchar *Var7=strchr(Var3,Var8); \nif (Var7){\n*Var7=0; \nVar4=Var7+1; \nelse \nVar4=NULL ; \nVar7=strchr(Var3,); \nif (Var7){\n*Var7=0; \nwhile (Var3&&*Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nchar *Var9=strchr(Var3,); \nif (Var9){\nVar5=FUNC2(Var1->memberVar1,Var3); \nelse \nif (!*Var3){\nVar5=FUNC2(Var1->memberVar1,Var3); \nVar3=Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 269,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3899,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = NULL;\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=NULL ; \nSTRUCT2  Var5; \nwhile (Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nif (!*Var3){\nchar *Var7=strchr(Var3,Var8); \nif (Var7){\nVar4=Var7+1; \nelse \nVar4=NULL ; \nVar7=strchr(Var3,); \nwhile (Var3&&*Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nchar *Var9=strchr(Var3,); \nif (Var9){\n*Var9=0; \nVar5=FUNC2(Var1->memberVar1,Var3); \n*Var9=; \nVar3=Var9+1; \nelse \nif (!*Var3){\nVar5=FUNC2(Var1->memberVar1,Var3); \nVar3=NULL ; \nFUNC3(Var1,Var5,1); \nVar3=Var4; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 270,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3918,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=strdup(Var2); \nwhile (Var3){\nif (!*Var3){\nchar *Var5=strchr(Var3,Var6); \nwhile (Var3&&*Var3){\nchar *Var7=strchr(Var3,); \nif (Var7){\nelse \nif (!*Var3){\nFUNC2(Var1,Var4,0); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 271,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3953,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\t\tfree (out);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar  Var7; \nchar *Var8=NULL ; \nchar *Var9,*Var10=NULL ; \nSTRUCT2  Var11,Var12; \nVar10=Var9=strdup(Var4); \nswitch (Var4[0]){\nchar *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2,Var4); \nfree(Var10); \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var15=Var2->memberVar4; \nif (Var14){\nif (FUNC5()){\nchar *Var9=Var4+1; \nif (*Var9 == ||*Var9 == ){\nVar9  Var16; \nint  Var17=FUNC6(Var9,); \nif (Var17 == 3){\nSTRUCT2  Var18=FUNC7(Var2->memberVar5,FUNC8(Var9,0)); \nSTRUCT2  Var19=FUNC7(Var2->memberVar5,FUNC8(Var9,1)); \nSTRUCT2  Var20=FUNC7(Var2->memberVar5,FUNC8(Var9,2)); \nint  Var5; \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT3 *Var14; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var14->memberVar1,Var4+2)){\nif (FUNC5()){\nelse \nSTRUCT3 *Var14; \nif (Var2->memberVar2){\nSTRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC5()){\nint  Var23=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var25=FUNC11(Var2,Var4+2); \nFUNC12(Var2,Var3,Var9+1); \nif (Var4[1]==  Var26&&Var4[2]==  Var27){\nSTRUCT2  Var11=Var2->memberVar3; \nchar *Var28=FUNC13(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var28){\nVar4=Var28; \nwhile (*Var4 == ){\nVar4  Var16; \nif (!*Var4){\nVar9=strchr(Var4,); \nif (Var9){\n*Var9=0; \nmemberVar1=FUNC7(Var2->memberVar5,Var4); \n*Var9=; \nelse \nmemberVar1=FUNC7(Var2->memberVar5,Var4); \nVar4=Var9+1; \nFUNC14(Var2,memberVar1,1); \n}while (Var9 != NULL ); \nfree(Var28); \nif (Var4[1]== (){\nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){\nif (FUNC5()){\nFUNC15(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nSTRUCT6 *Var29=FUNC16(Var4+1,STRING); \nif (Var29){\nelse \nFUNC17(STRING,Var4+1); \nfor (; *Var4 == ; Var4  Var16){\nwhile (Var9[Var5]){\nVar7=Var9[Var5]; \nVar9[Var5]=0; \nVar8=strdup(Var9+Var6); \nif (!Var8){\nVar9[Var5]=Var7; \nconst STRUCT7 *Var30=FUNC18(Var2->memberVar10); \nSTRUCT5 *Var31=FUNC19((Var32) Var33); \nif (!Var31){\nif (FUNC5()){\nchar *Var34=NULL ; \nconst char *Var35=NULL ; \nFUNC20(Var8); \nfree(Var8); \nfree(Var10); \nfree(Var10); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 272,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3958,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tRFlagItem *flag;\n",
      "\tut64 oseek, addr;\n",
      "\toseek = core->offset;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmd);\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\tr_core_cmd_help (core, help_msg_at_at);\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tr_core_block_size (core, bb->size);\n",
      "\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tr_core_block_size (core, bs);\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 cur;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\t\tfor (cur = from; cur < to; cur += step) {\n",
      "\t\t\t\t\t(void)r_core_seek (core, cur, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tcore->cons->context->grep = grep;\n",
      "\t\t\tRDebugPid *p;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_debug_select (core->dbg, pid, pid);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\t\tRDebugFrame *frame;\n",
      "\t\t\tRList *list;\n",
      "\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n",
      "\t\t\t\tswitch (each[3]) {\n",
      "\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_core_seek (core, oseek, 0);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\t\taddr = core->rcmd->macro._brk_value;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n",
      "\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "\t\t\t\t\tcore->rcmd->macro.counter++;\n",
      "\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\tr_flag_foreach_space (core->flags, flagspace, duplicate_flag, &u);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\tcore->rcmd->macro.counter++ ;\n",
      "\tcore->offset = oseek;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar *Var7=NULL ; \nchar *Var8,*Var9=NULL ; \nSTRUCT2 *Var10; \nSTRUCT3  Var11,Var12; \nVar11=Var2->memberVar1; \nswitch (Var4[0]){\nchar *Var13=strdup(FUNC2(Var2->memberVar2,STRING)); \nFUNC3(Var2->memberVar2,STRING,Var3); \nFUNC4(Var2,Var4); \nFUNC3(Var2->memberVar2,STRING,Var13); \nfree(Var13); \nFUNC5(Var2,Var14); \nSTRUCT4 *Var15; \nSTRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); \nint  Var17=Var2->memberVar4; \nif (Var16){\nFUNC7(Var2,Var15->size ); \nFUNC8(Var2,Var15->memberVar1,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nFUNC7(Var2,Var17); \nchar *Var8=Var4+1; \nint  Var18=FUNC11(Var8,); \nif (Var18 == 3){\nSTRUCT3  Var19; \nSTRUCT3  Var20=FUNC12(Var2->memberVar5,FUNC13(Var8,0)); \nSTRUCT3  Var21=FUNC12(Var2->memberVar5,FUNC13(Var8,1)); \nSTRUCT3  Var22=FUNC12(Var2->memberVar5,FUNC13(Var8,2)); \nfor (Var19=Var20; Var19<Var21; Var19  STRUCT6  Var22){\n(void ) FUNC8(Var2,Var19,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nSTRUCT4 *Var15; \nint  Var5; \nSTRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); \nif (Var16){\nfor (Var5=0; Var5<Var15->memberVar2; Var5  Var23){\nSTRUCT3  memberVar1=Var15->memberVar1+Var15->memberVar3[Var5]; \nFUNC8(Var2,memberVar1,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nif (Var4[1]== ){\nSTRUCT5 *Var16; \nif (Var2->memberVar3){\nif (Var4[2]&&strstr(Var16->memberVar1,Var4+2)){\nFUNC8(Var2,Var16->memberVar2,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nelse \nSTRUCT5 *Var16; \nif (Var2->memberVar3){\nSTRUCT7  Var24=Var2->memberVar6->memberVar1->memberVar1; \nchar *Var25; \nFUNC8(Var2,Var16->memberVar2,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nVar2->memberVar6->memberVar1->memberVar1=memberVar1; \nSTRUCT8 *Var26; \nint  Var27=Var2->memberVar7->memberVar1; \nif (Var2->memberVar7->memberVar2&&Var2->memberVar7->memberVar2->memberVar1){\nSTRUCT9 *Var28=Var2->memberVar7->memberVar2->memberVar1(Var2->memberVar7,FUNC14(0,memberVar1)); \nFUNC15(Var2->memberVar7,Var26->memberVar1,Var26->memberVar1); \nFUNC9(Var2,Var3,0); \nFUNC15(Var2->memberVar7,memberVar1,memberVar1); \nif (Var4[1]== ){\nchar *Var29=FUNC16(Var2,Var4+2); \nif (Var29){\nFUNC17(Var2,Var3,Var29); \nFUNC17(Var2,Var3,Var8+1); \nif (Var4[1]==  Var30&&Var4[2]==  Var31){\nSTRUCT3  Var11=Var2->memberVar1; \nSTRUCT10 *Var32; \nSTRUCT9 *Var28; \nVar28=FUNC18(Var2->memberVar7,Var33); \nswitch (Var4[3]){\nFUNC8(Var2,Var32->memberVar1,1); \nFUNC8(Var2,Var32->memberVar2,1); \nFUNC8(Var2,Var32->memberVar3,1); \nFUNC9(Var2,Var3,0); \nFUNC8(Var2,Var11,0); \nchar *Var34=FUNC19(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nif (Var34){\nif (!*Var4){\nif (Var8){\nmemberVar3=FUNC12(Var2->memberVar5,Var4); \nelse \nmemberVar3=FUNC12(Var2->memberVar5,Var4); \nFUNC8(Var2,memberVar3,1); \nFUNC9(Var2,Var3,0); \n}while (Var8 != NULL ); \nif (Var4[1]== (){\nchar  Var35[1024]; \nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var23){\nif (FUNC10()){\nFUNC20(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nmemberVar3=Var2->memberVar9->memberVar1.memberVar3; \nFUNC8(Var2,memberVar3,1); \nFUNC9(Var2,Var35,0); \nelse \nchar  Var25[1024]; \nchar  Var35[1024]; \nSTRUCT11 *Var36=FUNC21(Var4+1,STRING); \nif (Var36){\nVar2->memberVar9->memberVar1.memberVar1=0; \nwhile (!FUNC22(Var36)){\nif (!fgets(Var25,sizeof (Var25),Var36)){\nmemberVar3=FUNC12(Var2->memberVar5,Var25); \nFUNC8(Var2,memberVar3,1); //Var37\nFUNC9(Var2,Var35,0); \nVar2->memberVar9->memberVar1.memberVar1  Var23; \nVar2->memberVar9->memberVar1.memberVar1=0; \nwhile (Var8[Var5]){\nif (!Var7){\nconst STRUCT12 *Var38=FUNC23(Var2->memberVar10); \nSTRUCT9 *Var39=FUNC24((Var40) Var41); \nif (!Var39){\nFUNC25(Var2->memberVar10,Var38,Var42,&Var43); \nif (FUNC10()){\nchar *Var25=NULL ; \nconst char *Var44=NULL ; \nFUNC8(Var2,Var10->memberVar1,1); \nFUNC9(Var2,Var3,0); \nVar2->memberVar9->memberVar1.memberVar1  Var23; \nVar2->memberVar1=Var11; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 273,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3962,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nswitch (Var4[0]){\nchar *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2->memberVar1,STRING,Var5); \nfree(Var5); \nSTRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var7=Var2->memberVar4; \nchar *Var8=Var4+1; \nSTRUCT3  Var9=FUNC5(Var2->memberVar5,FUNC6(Var8,0)); \nSTRUCT3  Var10=FUNC5(Var2->memberVar5,FUNC6(Var8,1)); \nSTRUCT3  Var11=FUNC5(Var2->memberVar5,FUNC6(Var8,2)); \nSTRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; \nint  Var13=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); \nchar *Var15=FUNC9(Var2,Var4+2); \nSTRUCT3  Var16=Var2->memberVar3; \nchar *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nSTRUCT6 *Var18=FUNC11(Var4+1,STRING); \nconst STRUCT7 *Var19=FUNC12(Var2->memberVar9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 274,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3964,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nVar6=Var5=strdup(Var4); \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nfree(Var6); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nif (Var8){\nif (FUNC4()){\nchar *Var5=Var4+1; \nint  Var10=FUNC5(Var5,); \nSTRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); \nSTRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nif (Var4[1]== ){\nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nSTRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var15=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var17=FUNC10(Var2,Var4+2); \nSTRUCT3  Var18=Var2->memberVar3; \nchar *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); \nSTRUCT6 *Var20=FUNC12(Var4+1,STRING); \nconst STRUCT7 *Var21=FUNC13(Var2->memberVar9); \nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 275,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 4043,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar *Var7,*Var8=NULL ; \nVar8=Var7=strdup(Var4); \nswitch (Var4[0]){\nchar *Var9=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2,Var4); \nSTRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var11=Var2->memberVar4; \nchar *Var7=Var4+1; \nint  Var12=FUNC5(Var7,); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var7,0)); \nSTRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var7,1)); \nSTRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var7,2)); \nint  Var5; \nSTRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT2 *Var10; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var10->memberVar1,Var4+2)){\nFUNC8(Var2,Var10->memberVar2,1); \nelse \nSTRUCT2 *Var10; \nSTRUCT4  Var18=Var2->memberVar6->memberVar1->memberVar1; \nint  Var19=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var20=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var21=FUNC11(Var2,Var4+2); \nif (Var4[1]==  Var22&&Var4[2]==  Var23){\nSTRUCT3  Var24=Var2->memberVar3; \nchar *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var4[1]== (){\nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var26){\nif (FUNC13()){\nFUNC14(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nSTRUCT6 *Var27=FUNC15(Var4+1,STRING); \nif (Var27){\nelse \nFUNC16(STRING,Var4+1); \nfor (; *Var4 == ; Var4  Var26){\nconst STRUCT7 *Var28=FUNC17(Var2->memberVar10); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 276,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4065,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "switch (Var1[0]){\nchar *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nint  Var5=Var3->memberVar4; \nchar *Var6=Var1+1; \nSTRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); \nSTRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); \nSTRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nif (Var1[1]== ){\nif (Var3->memberVar2){\nSTRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; \nchar *Var11; \nVar11=(char *) FUNC5(); \nif (Var11){\nVar11=strdup(Var11); \nFUNC6(Var11); \nfree(Var11); \nint  Var12=Var3->memberVar7->memberVar1; \nSTRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); \nchar *Var14=FUNC9(Var3,Var1+2); \nSTRUCT2  Var15=Var3->memberVar3; \nchar *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); \nelse \nchar  Var11[1024]; \nSTRUCT5 *Var17=FUNC11(Var1+1,STRING); \nconst STRUCT6 *Var18=FUNC12(Var3->memberVar9); \nchar *Var11=NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 277,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4069,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "switch (Var1[0]){\nchar *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nint  Var5=Var3->memberVar4; \nchar *Var6=Var1+1; \nSTRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); \nSTRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); \nSTRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nif (Var1[1]== ){\nif (Var3->memberVar2){\nSTRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; \nchar *Var11; \nVar11=(char *) FUNC5(); \nif (Var11){\nVar11=strdup(Var11); \nFUNC6(Var11); \nfree(Var11); \nint  Var12=Var3->memberVar7->memberVar1; \nSTRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); \nchar *Var14=FUNC9(Var3,Var1+2); \nSTRUCT2  Var15=Var3->memberVar3; \nchar *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); \nelse \nchar  Var11[1024]; \nSTRUCT5 *Var17=FUNC11(Var1+1,STRING); \nconst STRUCT6 *Var18=FUNC12(Var3->memberVar9); \nchar *Var11=NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 278,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4102,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\t\t\tfree (arg);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nswitch (Var4[0]){\nchar *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var7=Var2->memberVar4; \nchar *Var8=Var4+1; \nSTRUCT3  Var9=FUNC4(Var2->memberVar5,FUNC5(Var8,0)); \nSTRUCT3  Var10=FUNC4(Var2->memberVar5,FUNC5(Var8,1)); \nSTRUCT3  Var11=FUNC4(Var2->memberVar5,FUNC5(Var8,2)); \nSTRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; \nint  Var13=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var15=FUNC8(Var2,Var4+2); \nif (Var15){\nFUNC9(Var2,Var3,Var15); \nfree(Var15); \nSTRUCT3  Var16=Var2->memberVar3; \nchar *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nSTRUCT6 *Var18=FUNC11(Var4+1,STRING); \nconst STRUCT7 *Var19=FUNC12(Var2->memberVar9); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 279,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4153,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar  Var7; \nchar *Var8=NULL ; \nchar *Var9,*Var10=NULL ; \nSTRUCT2  Var11,Var12; \nVar10=Var9=strdup(Var4); \nswitch (Var4[0]){\nchar *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2,Var4); \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var15=Var2->memberVar4; \nchar *Var9=Var4+1; \nif (*Var9 == ||*Var9 == ){\nVar9  Var16; \nint  Var17=FUNC5(Var9,); \nif (Var17 == 3){\nSTRUCT2  Var18=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); \nSTRUCT2  Var19=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); \nSTRUCT2  Var20=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); \nint  Var5; \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT3 *Var14; \nif (Var2->memberVar2){\nelse \nSTRUCT3 *Var14; \nSTRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; \nint  Var23=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var25=FUNC10(Var2,Var4+2); \nFUNC11(Var2,Var3,Var9+1); \nif (Var4[1]==  Var26&&Var4[2]==  Var27){\nSTRUCT2  Var11=Var2->memberVar3; \nchar *Var28=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var28){\nVar4=Var28; \nwhile (*Var4 == ){\nVar4  Var16; \nif (!*Var4){\nVar9=strchr(Var4,); \nif (Var9){\n*Var9=0; \nmemberVar1=FUNC6(Var2->memberVar5,Var4); \n*Var9=; \nelse \nmemberVar1=FUNC6(Var2->memberVar5,Var4); \nVar4=Var9+1; \nFUNC13(Var2,memberVar1,1); \n}while (Var9 != NULL ); \nif (Var4[1]== (){\nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){\nif (FUNC14()){\nFUNC15(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nSTRUCT6 *Var29=FUNC16(Var4+1,STRING); \nif (Var29){\nelse \nFUNC17(STRING,Var4+1); \nfor (; *Var4 == ; Var4  Var16){\nwhile (Var9[Var5]){\nVar7=Var9[Var5]; \nVar9[Var5]=0; \nVar8=strdup(Var9+Var6); \nif (!Var8){\nVar9[Var5]=Var7; \nconst STRUCT7 *Var30=FUNC18(Var2->memberVar10); \nSTRUCT5 *Var31=FUNC19((Var32) Var33); \nif (!Var31){\nif (FUNC14()){\nchar *Var34=NULL ; \nconst char *Var35=NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 280,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4167,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\tfree (out);\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5=NULL ; \nchar *Var6,*Var7=NULL ; \nVar7=Var6=strdup(Var4); \nswitch (Var4[0]){\nchar *Var8=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var10=Var2->memberVar4; \nchar *Var6=Var4+1; \nint  Var11=FUNC4(Var6,); \nSTRUCT3  Var12=FUNC5(Var2->memberVar5,FUNC6(Var6,0)); \nSTRUCT3  Var13=FUNC5(Var2->memberVar5,FUNC6(Var6,1)); \nSTRUCT3  Var14=FUNC5(Var2->memberVar5,FUNC6(Var6,2)); \nSTRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT4  Var15=Var2->memberVar6->memberVar1->memberVar1; \nint  Var16=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var17=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); \nchar *Var18=FUNC9(Var2,Var4+2); \nSTRUCT3  Var19=Var2->memberVar3; \nchar *Var20=FUNC10(Var2->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var20){\nVar4=Var20; \nfree(Var20); \nSTRUCT6 *Var21=FUNC11(Var4+1,STRING); \nconst STRUCT7 *Var22=FUNC12(Var2->memberVar9); \nchar *Var23=NULL ; \nconst char *Var24=NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 281,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 4199,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tut64 oseek, addr;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tbuf[0] = '\\0';\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nSTRUCT2  Var5,Var6; \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nchar *Var10=Var4+1; \nSTRUCT2  Var11=FUNC4(Var2->memberVar5,FUNC5(Var10,0)); \nSTRUCT2  Var12=FUNC4(Var2->memberVar5,FUNC5(Var10,1)); \nSTRUCT2  Var13=FUNC4(Var2->memberVar5,FUNC5(Var10,2)); \nSTRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT2  Var6=Var14->memberVar1+Var14->memberVar2[Var15]; \nSTRUCT4  Var16=Var2->memberVar6->memberVar1->memberVar1; \nchar *Var17; \nint  Var18=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var19=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); \nchar *Var20=FUNC8(Var2,Var4+2); \nSTRUCT2  Var5=Var2->memberVar3; \nchar *Var21=FUNC9(Var2->memberVar8,NULL ,0,Var10+((Var10[1]) 21)); \nif (Var4[1]== (){\nelse \nchar  Var17[1024]; \nSTRUCT6 *Var22=FUNC10(Var4+1,STRING); \nif (Var22){\nwhile (!FUNC11(Var22)){\nVar17[0]=0; \nif (!fgets(Var17,sizeof (Var17),Var22)){\nmemberVar1=FUNC4(Var2->memberVar5,Var17); \nfclose(Var22); \nconst STRUCT7 *Var23=FUNC12(Var2->memberVar9); \nchar *Var17=NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 282,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 4209,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nswitch (Var4[0]){\nchar *Var5=Var4+1; \nchar *Var6; \nchar *Var7=FUNC2(Var2,Var4+2); \nif (Var4[1]== (){\nelse \nchar  Var6[1024]; \nSTRUCT2 *Var8=FUNC3(Var4+1,STRING); \nif (Var8){\nwhile (!FUNC4(Var8)){\nif (!fgets(Var6,sizeof (Var6),Var8)){\nfclose(Var8); \nchar *Var6=NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 283,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4231,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar  Var7; \nchar *Var8=NULL ; \nchar *Var9,*Var10=NULL ; \nVar10=Var9=strdup(Var4); \nswitch (Var4[0]){\nchar *Var11=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var13=Var2->memberVar4; \nif (Var12){\nif (FUNC4()){\nchar *Var9=Var4+1; \nint  Var14=FUNC5(Var9,); \nSTRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); \nSTRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); \nSTRUCT3  Var17=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); \nint  Var5; \nSTRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT3  Var18=Var19->memberVar1+Var19->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT2 *Var12; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var12->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var12; \nif (Var2->memberVar2){\nSTRUCT4  Var20=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var21=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var22=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var23=FUNC10(Var2,Var4+2); \nFUNC11(Var2,Var3,Var9+1); \nSTRUCT3  Var24=Var2->memberVar3; \nchar *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); \nSTRUCT6 *Var26=FUNC13(Var4+1,STRING); \nVar5=0; \nwhile (Var9[Var5]){\nVar6=Var5; \nfor (; Var9[Var6]&&Var9[Var6]== ; Var6  Var27){\nfor (Var5=Var6; Var9[Var5]&&Var9[Var5]!= ; Var5  Var27){\nVar7=Var9[Var5]; \nVar9[Var5]=0; \nVar8=strdup(Var9+Var6); \nif (!Var8){\nVar9[Var5]=Var7; \nconst STRUCT7 *Var28=FUNC14(Var2->memberVar9); \nSTRUCT5 *Var29=FUNC15((Var30) Var31); \nif (!Var29){\nif (FUNC4()){\nchar *Var32=NULL ; \nconst char *Var33=NULL ; \nFUNC16(Var8); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 284,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4265,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tr_cons_break_push (NULL, NULL); //pop on return\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t} while (str != NULL);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4,*Var5=NULL ; \nFUNC1(NULL ,NULL ); //Var6  STRUCT1 return \nswitch (Var7[0]){\nchar *Var8=strdup(FUNC2(Var9->memberVar1,STRING)); \nSTRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); \nint  Var11=Var9->memberVar4; \nchar *Var4=Var7+1; \nint  Var12=FUNC4(Var4,); \nSTRUCT3  Var13=FUNC5(Var9->memberVar5,FUNC6(Var4,0)); \nSTRUCT3  Var14=FUNC5(Var9->memberVar5,FUNC6(Var4,1)); \nSTRUCT3  Var15=FUNC5(Var9->memberVar5,FUNC6(Var4,2)); \nint  Var1; \nSTRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); \nSTRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var1]; \nSTRUCT4  Var18=Var9->memberVar6->memberVar1->memberVar1; \nchar *Var19; \nint  Var20=Var9->memberVar7->memberVar1; \nSTRUCT5 *Var21=Var9->memberVar7->memberVar2->FUNC7(Var9->memberVar7,FUNC8(0,memberVar1)); \nchar *Var22=FUNC9(Var9,Var7+2); \nSTRUCT3  Var23=Var9->memberVar3; \nchar *Var24=FUNC10(Var9->memberVar8,NULL ,0,Var4+((Var4[1]) 21)); \nif (Var24){\nif (!*Var7){\n}while (Var4 != NULL ); \nelse \nchar  Var19[1024]; \nSTRUCT6 *Var25=FUNC11(Var7+1,STRING); \nwhile (Var4[Var1]){\nif (!Var3){\nconst STRUCT7 *Var26=FUNC12(Var9->memberVar9); \nSTRUCT5 *Var27=FUNC13((Var28) Var29); \nif (!Var27){\nif (FUNC14()){\nchar *Var19=NULL ; \nconst char *Var30=NULL ; \nVar30=FUNC15(); \nVar19=Var30 strdup(Var30) NULL ; \nFUNC16(Var19); \nfree(Var19); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 285,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4268,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4,*Var5=NULL ; \nswitch (Var6[0]){\nchar *Var7=strdup(FUNC1(Var8->memberVar1,STRING)); \nchar *Var4=Var6+1; \nint  Var9=FUNC2(Var4,); \nSTRUCT1  Var10=FUNC3(Var8->memberVar2,FUNC4(Var4,0)); \nSTRUCT1  Var11=FUNC3(Var8->memberVar2,FUNC4(Var4,1)); \nSTRUCT1  Var12=FUNC3(Var8->memberVar2,FUNC4(Var4,2)); \nint  Var1; \nSTRUCT1  Var13=Var14->memberVar1+Var14->memberVar2[Var1]; \nchar *Var15; \nchar *Var16=FUNC5(Var8,Var6+2); \nchar *Var17=FUNC6(Var8->memberVar3,NULL ,0,Var4+((Var4[1]) 21)); \nelse \nchar  Var15[1024]; \nSTRUCT2 *Var18=FUNC7(Var6+1,STRING); \nwhile (Var4[Var1]){\nif (!Var3){\nSTRUCT3 *Var19=FUNC8((Var20) Var21); \nif (!Var19){\nif (FUNC9()){\nchar *Var15=NULL ; \nconst char *Var22=NULL ; \nVar22=FUNC10(); \nVar15=Var22 strdup(Var22) NULL ; \nFUNC11(Var15); \nfree(Var15); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 286,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4281,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar *Var7=NULL ; \nchar *Var8,*Var9=NULL ; \nVar9=Var8=strdup(Var4); \nswitch (Var4[0]){\nchar *Var10=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var12=Var2->memberVar4; \nif (Var11){\nif (FUNC4()){\nchar *Var8=Var4+1; \nint  Var13=FUNC5(Var8,); \nSTRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var8,0)); \nSTRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var8,1)); \nSTRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var8,2)); \nint  Var5; \nSTRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT3  Var17=Var18->memberVar1+Var18->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT2 *Var11; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var11->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var11; \nif (Var2->memberVar2){\nSTRUCT4  Var19=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var20=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var21=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var22=FUNC10(Var2,Var4+2); \nSTRUCT3  Var23=Var2->memberVar3; \nchar *Var24=FUNC11(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nSTRUCT6 *Var25=FUNC12(Var4+1,STRING); \nVar5=0; \nwhile (Var8[Var5]){\nVar6=Var5; \nfor (; Var8[Var6]&&Var8[Var6]== ; Var6  Var26){\nfor (Var5=Var6; Var8[Var5]&&Var8[Var5]!= ; Var5  Var26){\nVar7=strdup(Var8+Var6); \nif (!Var7){\nconst STRUCT7 *Var27=FUNC13(Var2->memberVar9); \nSTRUCT5 *Var28=FUNC14((Var29) Var30); \nif (!Var28){\nif (FUNC4()){\nchar *Var31=NULL ; \nconst char *Var32=NULL ; \nFUNC15(Var7); \nfree(Var7); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 287,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4282,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nVar6=Var5=strdup(Var4); \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nfree(Var6); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nif (Var8){\nif (FUNC4()){\nchar *Var5=Var4+1; \nint  Var10=FUNC5(Var5,); \nSTRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); \nSTRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nif (Var4[1]== ){\nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nSTRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var15=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var17=FUNC10(Var2,Var4+2); \nSTRUCT3  Var18=Var2->memberVar3; \nchar *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); \nSTRUCT6 *Var20=FUNC12(Var4+1,STRING); \nconst STRUCT7 *Var21=FUNC13(Var2->memberVar9); \nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 288,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4285,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nVar6=Var5=strdup(Var4); \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nfree(Var6); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nif (Var8){\nif (FUNC4()){\nchar *Var5=Var4+1; \nint  Var10=FUNC5(Var5,); \nSTRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); \nSTRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nif (Var4[1]== ){\nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nSTRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var15=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var17=FUNC10(Var2,Var4+2); \nSTRUCT3  Var18=Var2->memberVar3; \nchar *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); \nSTRUCT6 *Var20=FUNC12(Var4+1,STRING); \nconst STRUCT7 *Var21=FUNC13(Var2->memberVar9); \nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "run_pending_anal",
    "Source": false,
    "Sink": false,
    "idx": 289,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4297,
    "label": -3,
    "slices": [
      "R_API void run_pending_anal(RCore *core) {\n",
      "\tcore->ev->incall = false;\n",
      "\tif (core && core->anal && core->anal->cmdtail) {\n",
      "\t\tchar *res = core->anal->cmdtail;\n",
      "\t\tr_core_cmd_lines (core, res);\n",
      "\t\tfree (res);\n"
    ],
    "tokenized": "Var1 void FUNC1(STRUCT1 *Var2){\nVar2->memberVar1->memberVar1=false ; \nif (Var2&&Var2->memberVar2&&Var2->memberVar2->memberVar1){\nchar *Var3=Var2->memberVar2->memberVar1; \nFUNC2(Var2,Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 290,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4308,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 291,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4313,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nVar2->memberVar4=false ; \nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nfree(Var2->memberVar5); \nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nVar2->memberVar6->memberVar1->memberVar1  Var15; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nif (!Var7){\nFUNC9(Var2); \nVar2->memberVar6->memberVar1->memberVar1  Var12; \nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nif (FUNC10(Var2->memberVar9)){\nFUNC11(Var2->memberVar10); \nFUNC9(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 292,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4323,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nint  Var5=false ,Var6; \nif (Var2->memberVar1){\nconst char *Var7=STRING; \nfor (Var6=0; Var7[Var6]; Var6  Var8){\nif (strchr(Var3,Var7[Var6])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var9&&FUNC2(Var3,STRING,2)){\nchar *Var10=FUNC3(Var2->memberVar3,Var3); \nif (Var10){\nFUNC4(STRING,Var10); \nfree(Var10); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 293,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4347,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nVar2->memberVar4=false ; \nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nfree(Var2->memberVar5); \nVar2->memberVar5=strdup(Var3); \nif (!Var6){\nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC5(Var2->memberVar7); \nVar2->memberVar8=0; \nVar2->memberVar6->memberVar1->memberVar1  Var15; \nVar9=FUNC6(Var2,Var8); \nif (Var9 == -1){\nif (!Var7){\nFUNC7(Var2); \nVar2->memberVar6->memberVar1->memberVar1  Var12; \nFUNC5(Var2->memberVar7); \nVar2->memberVar8=0; \nif (FUNC8(Var2->memberVar9)){\nFUNC9(Var2->memberVar10); \nFUNC7(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 294,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4348,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nVar2->memberVar4=false ; \nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nfree(Var2->memberVar5); \nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nVar2->memberVar6->memberVar1->memberVar1  Var15; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nif (!Var7){\nFUNC9(Var2); \nVar2->memberVar6->memberVar1->memberVar1  Var12; \nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nif (FUNC10(Var2->memberVar9)){\nFUNC11(Var2->memberVar10); \nFUNC9(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 295,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 4351,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(STRING,Var5); \nfree(Var6); \nfor (Var8=Var5; ; ){\nVar7=strchr(Var8,Var15); \nif (Var7){\n*Var7=0; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nFUNC7(STRING,Var8,*Var8); \nif (!Var7){\nVar8=Var7+1; \nfree(Var6); \nreturn  Var9; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 296,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4351,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(STRING,Var5); \nfree(Var6); \nfor (Var8=Var5; ; ){\nVar7=strchr(Var8,Var15); \nif (Var7){\n*Var7=0; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nFUNC7(STRING,Var8,*Var8); \nif (!Var7){\nVar8=Var7+1; \nfree(Var6); \nreturn  Var9; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 297,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4362,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nif (Var2->memberVar5->memberVar1->memberVar1<1){\nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 298,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4369,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\treturn ret;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nif (Var2->memberVar5->memberVar1->memberVar1<1){\nfor (Var8=Var5; ; ){\nVar7=strchr(Var8,Var15); \nif (Var7){\n*Var7=0; \nVar9=FUNC5(Var2,Var8); \nif (Var9 == -1){\nFUNC6(STRING,Var8,*Var8); \nif (!Var7){\nVar8=Var7+1; \nreturn  Var9; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 299,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4386,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nif (Var2->memberVar5->memberVar1->memberVar1<1){\nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 300,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4412,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \n*Var6=0; \nVar4=FUNC3(Var2,Var7,0); \nif (Var4<0){/Var10=-1){\nVar7=Var6+1; \nif (Var7[0]==  Var11){\nVar7=Var6+1; \nVar7=Var6+1; \n}while ((Var6=strchr(Var7,Var9))); \nif (Var5 >= 0&&Var7&&*Var7){\nFUNC3(Var2,Var7,0); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 301,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4416,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \n*Var6=0; \nVar4=FUNC3(Var2,Var7,0); \nif (Var4<0){/Var10=-1){\nVar7=Var6+1; \nif (Var7[0]==  Var11){\nVar7=Var6+1; \nVar7=Var6+1; \n}while ((Var6=strchr(Var7,Var9))); \nif (Var5 >= 0&&Var7&&*Var7){\nFUNC3(Var2,Var7,0); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 302,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4421,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \nif (Var4<0){/Var10=-1){\nif (Var7[0]==  Var11){\n}while ((Var6=strchr(Var7,Var9))); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 303,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4443,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\n*Var6=0; \nVar4=FUNC3(Var2,Var7,0); \nif (Var4<0){/Var10=-1){\nVar7=Var6+1; \nif (Var7[0]==  Var11){\nVar7=Var6+1; \nVar7=Var6+1; \n}while ((Var6=strchr(Var7,Var9))); \nif (Var5 >= 0&&Var7&&*Var7){\nFUNC3(Var2,Var7,0); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 304,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4449,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \nif (Var4<0){/Var10=-1){\nif (Var7[0]==  Var11){\n}while ((Var6=strchr(Var7,Var9))); \nfree(Var8); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 305,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4459,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tfree (data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4=FUNC2(Var3); \nif (!Var4){\nchar *Var5=FUNC3(Var4,NULL ); \nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 306,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4465,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4=FUNC2(Var3); \nif (!Var4){\nchar *Var5=FUNC3(Var4,NULL ); \nif (!Var5){\nif (!FUNC4(Var2,Var5)){\nfree(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 307,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4468,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4=FUNC2(Var3); \nif (!Var4){\nchar *Var5=FUNC3(Var4,NULL ); \nif (!Var5){\nif (!FUNC4(Var2,Var5)){\nfree(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 308,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4478,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\t\tfree (cmd);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6; \nchar *Var7=FUNC2(Var2,Var3); \nVar5=Var6=Var4=FUNC3(Var7,0,&Var8); \nif (!Var4){\nfree(Var7); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 309,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4483,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6; \nchar *Var7=FUNC2(Var2,Var3); \nVar5=Var6=Var4=FUNC3(Var7,0,&Var8); \nif (!Var4){\nfree(Var4); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_disassemble_instr",
    "Source": false,
    "Sink": false,
    "idx": 310,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4493,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (Var1){\nVar2=FUNC1(Var3,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_disassemble_bytes",
    "Source": false,
    "Sink": false,
    "idx": 311,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4503,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (Var1){\nVar2=FUNC1(Var3,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 312,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4509,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\n*Var4=0; \nFUNC2(Var2,Var5,0); \nVar5=Var4+1; \nVar4=strchr(Var6,Var7); \nFUNC2(Var2,Var5,0); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 313,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4514,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\n*Var4=0; \nFUNC2(Var2,Var5,0); \nVar5=Var4+1; \nVar4=strchr(Var6,Var7); \nFUNC2(Var2,Var5,0); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 314,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4519,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\n*Var4=0; \nFUNC2(Var2,Var5,0); \nVar5=Var4+1; \nVar4=strchr(Var6,Var7); \nFUNC2(Var2,Var5,0); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 315,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4522,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\nVar4=strchr(Var6,Var7); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmdf",
    "Source": false,
    "Sink": false,
    "idx": 316,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4531,
    "label": -3,
    "slices": [
      "R_API int r_core_cmdf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tint ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd (core, string, 0);\n",
      "\tva_end (ap);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,...){\nchar  Var4[4096]; \nint  Var5; \nSTRUCT2  Var6; \nFUNC2(Var6,Var3); \nvsnprintf(Var4,sizeof (Var4),Var3,Var6); \nVar5=FUNC3(Var2,Var4,0); \nFUNC4(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 317,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4550,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\treturn NULL;\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nreturn FUNC3(Var1,Var2); \nif (FUNC6(STRING,&Var4) != -1){\nint  Var11=FUNC7(Var4,1,0); \nif (Var11 == -1){\nreturn FUNC3(Var1,Var2); \nchar *Var12=strdup(Var2); \nVar3=FUNC8(Var4,NULL ); \nif (Var3){\nreturn FUNC3(Var1,Var2); \nreturn NULL ; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 318,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4555,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\t\treturn hres;\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\treturn ret;\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nfree(Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nfree(Var7); \nreturn  Var8; \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nfree(Var6); \nreturn  Var10; \nreturn FUNC3(Var1,Var2); \nif (FUNC6(STRING,&Var4) != -1){\nint  Var11=FUNC7(Var4,1,0); \nif (Var11 == -1){\nreturn FUNC3(Var1,Var2); \nchar *Var12=strdup(Var2); \nif (Var3){\nreturn FUNC3(Var1,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 319,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4557,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nchar *Var9=FUNC3(Var1,Var6); \nint  Var10=FUNC5(Var4,1,0); \nchar *Var11=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 320,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4559,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nif (FUNC2(0)){\nchar *Var3=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var3){\nchar *Var4=strdup(Var2); \nVar4[Var3-Var2]=0; \nif (!strcmp(Var3+1,STRING)){\nchar *Var5=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var6=FUNC4(Var5,NULL ); \nelse \nint  Var7=FUNC5(Var1->memberVar1,STRING); \nchar *Var8=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var9=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 321,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4561,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nfree(Var7); \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nchar *Var11=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 322,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4568,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nif (FUNC2(0)){\nchar *Var3=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var3){\nchar *Var4=strdup(Var2); \nVar4[Var3-Var2]=0; \nif (!strcmp(Var3+1,STRING)){\nchar *Var5=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var6=FUNC4(Var5,NULL ); \nelse \nint  Var7=FUNC5(Var1->memberVar1,STRING); \nchar *Var8=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var9=strdup(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 323,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4581,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (FUNC1(0)){\nchar *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; \nchar *Var4=FUNC2(Var5,NULL ); \nif (FUNC3(STRING,&Var2) != -1){\nint  Var6=FUNC4(Var2,1,0); \nif (Var6 == -1){\nFUNC5(Var2); \nfree(Var2); \nVar1=FUNC6(Var2,NULL ); \nif (Var1){\nFUNC5(Var2); \nfree(Var2); \nFUNC7(STRING,Var2); \nFUNC5(Var2); \nfree(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 324,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4584,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nreturn FUNC3(Var1,Var2); \nif (FUNC6(STRING,&Var4) != -1){\nint  Var11=FUNC7(Var4,1,0); \nif (Var11 == -1){\nreturn FUNC3(Var1,Var2); \nchar *Var12=strdup(Var2); \nFUNC8(Var1,Var12); \nif (Var3){\nfree(Var12); \nfree(Var12); \nreturn FUNC3(Var1,Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 325,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4592,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (FUNC1(0)){\nchar *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; \nchar *Var4=FUNC2(Var5,NULL ); \nif (FUNC3(STRING,&Var2) != -1){\nint  Var6=FUNC4(Var2,1,0); \nif (Var6 == -1){\nFUNC5(Var2); \nfree(Var2); \nVar1=FUNC6(Var2,NULL ); \nif (Var1){\nFUNC5(Var2); \nfree(Var2); \nFUNC7(STRING,Var2); \nFUNC5(Var2); \nfree(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 326,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4593,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nchar *Var6=strdup(Var2); \nchar *Var7=FUNC3(Var1,Var6); \nelse \nint  Var8=FUNC4(Var1->memberVar1,STRING); \nchar *Var9=FUNC3(Var1,Var6); \nif (FUNC5(STRING,&Var4) != -1){\nint  Var10=FUNC6(Var4,1,0); \nif (Var10 == -1){\nchar *Var11=strdup(Var2); \nFUNC7(Var1,Var11); \nif (Var3){\nfree(Var11); \nfree(Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 327,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4598,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (FUNC1(0)){\nchar *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; \nchar *Var4=FUNC2(Var5,NULL ); \nif (FUNC3(STRING,&Var2) != -1){\nint  Var6=FUNC4(Var2,1,0); \nif (Var6 == -1){\nFUNC5(Var2); \nfree(Var2); \nVar1=FUNC6(Var2,NULL ); \nif (Var1){\nFUNC5(Var2); \nfree(Var2); \nFUNC7(STRING,Var2); \nFUNC5(Var2); \nfree(Var2); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 328,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4599,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nchar *Var6=strdup(Var2); \nchar *Var7=FUNC3(Var1,Var6); \nelse \nint  Var8=FUNC4(Var1->memberVar1,STRING); \nchar *Var9=FUNC3(Var1,Var6); \nif (FUNC5(STRING,&Var4) != -1){\nint  Var10=FUNC6(Var4,1,0); \nif (Var10 == -1){\nchar *Var11=strdup(Var2); \nFUNC7(Var1,Var11); \nif (Var3){\nfree(Var11); \nfree(Var11); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_strf",
    "Source": false,
    "Sink": false,
    "idx": 329,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4612,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tchar *ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd_str (core, string);\n",
      "\tva_end (ap);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2,...){\nchar  Var3[4096]; \nchar *Var4; \nSTRUCT3  Var5; \nFUNC2(Var5,Var2); \nvsnprintf(Var3,sizeof (Var3),Var2,Var5); \nVar4=FUNC3(Var1,Var3); \nFUNC4(Var5); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str",
    "Source": false,
    "Sink": false,
    "idx": 330,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4629,
    "label": -3,
    "slices": [
      "\tconst char *static_str;\n",
      "\tchar *retstr = NULL;\n",
      "\tif (r_core_cmd (core, cmd, 0) == -1) {\n",
      "\tstatic_str = r_cons_get_buffer ();\n",
      "\tretstr = strdup (static_str? static_str: \"\");\n",
      "\treturn retstr;\n"
    ],
    "tokenized": "const char *Var1; \nchar *Var2=NULL ; \nif (FUNC1(Var3,Var4,0) == -1){\nVar1=FUNC2(); \nVar2=strdup(Var1  Var1 STRING); \nreturn  Var2; \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 331,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4682,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){\nSTRUCT2 *Var5=Var2->memberVar1; \nchar *Var6=strdup(Var3); \nif (!Var6){\nVar5->memberVar1=Var6; \nint  Var7=FUNC2(Var2,Var5); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 332,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4690,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){\nSTRUCT2 *Var5=Var2->memberVar1; \nchar *Var6=strdup(Var3); \nif (!Var6){\nVar5->memberVar1=Var6; \nint  Var7=FUNC2(Var2,Var5); \nfree(Var6); \n"
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "compare_cmd_descriptor_name",
    "Source": false,
    "Sink": false,
    "idx": 333,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4699,
    "label": -3,
    "slices": [
      "static int compare_cmd_descriptor_name(const void *a, const void *b) {\n",
      "\treturn strcmp (((RCmdDescriptor *)a)->cmd, ((RCmdDescriptor *)b)->cmd);\n"
    ],
    "tokenized": "static int FUNC1(const void *Var1,const void *Var2){\nreturn strcmp(((STRUCT1 *) Var1)->memberVar1,((STRUCT1 *) Var2)->memberVar1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 334,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 361,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (FUNC3(Var3->memberVar1,Var4)){\nFUNC4(Var3,STRING,Var4); \nelse \nchar *Var5=FUNC5(Var4); \nif (Var5){\nFUNC6(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 335,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 379,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (!Var4){\nVar4=STRING; \nif (FUNC3(Var3->memberVar1,Var4)){\nelse \nchar *Var5=FUNC4(Var4); \nif (Var5){\nFUNC5(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 336,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 390,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\n*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var12=FUNC6(Var6,Var4); \nif (Var12){\nFUNC7(Var12); \nfree(Var12); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 337,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 391,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\n*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var12=FUNC6(Var6,Var4); \nif (Var12){\nFUNC7(Var12); \nfree(Var12); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 338,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 395,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\n*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var12=FUNC6(Var6,Var4); \nif (Var12){\nFUNC7(Var12); \nfree(Var12); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 339,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 399,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\tlines = atoi (arg);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\nVar4=FUNC3(Var6); \nswitch (*Var5){\nif (FUNC4(Var3->memberVar1,Var6)){\nFUNC5(Var3,STRING,Var6); \nelse \nchar *Var9=FUNC6(Var6,Var4); \nif (Var9){\nFUNC7(Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 340,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 417,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=5; \nchar *Var5=strdup(Var2); \nchar *Var6=strchr(Var5,); \nchar *Var7,*Var8; \nif (Var6){\nVar6=(char *) FUNC2(Var6+1); //STRUCT2 STRING\nVar8=strchr(Var6,); \nif (Var8){\nVar7=(char *) FUNC2(Var8+1); \nVar4=FUNC3(Var6); \nVar6=Var7; \nswitch (*Var5){\nif (!Var6){\nVar6=STRING; \nif (FUNC4(Var3->memberVar1,Var6)){\nelse \nchar *Var9=FUNC5(Var6,Var4); \nif (Var9){\nFUNC6(Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 341,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 422,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nchar *Var3=strdup(Var2); \nchar *Var4=strchr(Var3,); \nelse \nchar *Var5=FUNC2(Var4,Var6); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 342,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 435,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n",
      "\t\tr_core_cmdf (data, \"s-%s\", input + 1);\n",
      "\t\tr_core_cmdf (data, \"wc%s\", input + 1);\n",
      "\t\tif (input[1] == 'i' && input[2] == 'q') {\n",
      "\t\t\tcmd_uniq (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nchar *Var4=strdup(Var2+2); \nchar *Var5=strchr(Var4,,); \nif (Var5){\n*Var5  Var6=0; \nSTRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); \nFUNC3(Var3,Var7); \nfree(Var4); \nFUNC4(Var1,STRING,Var2+1); \nFUNC4(Var1,STRING,Var2+1); \nif (Var2[1]==  Var8&&Var2[2]==  Var9){\nFUNC5(Var3,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 343,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 436,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nchar *Var4=strdup(Var2+2); \nchar *Var5=strchr(Var4,,); \nif (Var5){\n*Var5  Var6=0; \nSTRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); \nFUNC3(Var3,Var7); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 344,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 444,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nchar *Var4=strdup(Var2+2); \nchar *Var5=strchr(Var4,,); \nif (Var5){\nSTRUCT2 *Var6=FUNC2(Var3->memberVar1,Var4,Var5); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 345,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 504,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\n*Var11  Var13=0; \nsize_t  Var14=strlen(Var11); \nif (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){\nVar11[Var14-1]=0; \nVar11  Var13; \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var16=FUNC3(NULL ,Var15); \nif (Var16){\nFUNC4(Var3->memberVar1,Var5,Var16,0); \nfree(Var16); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\n*Var12=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nFUNC6(Var15); \nfree(Var5); \nelse \nFUNC7(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nfor (Var4=0; Var4<Var17; Var4  Var13){\nchar *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); \nchar *Var10=FUNC9(Var15,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nelse \nif (Var10){\n*Var10=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nif (*Var15 == ){\nFUNC10(Var15+1); \nelse \n}else if (Var10){\nchar *Var19=FUNC11(STRING,Var15,Var10+1); \nFUNC12(Var3,Var19); \nfree(Var19); \nelse \nFUNC12(Var3,Var15); \nelse \nFUNC7(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 346,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 505,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\n*Var11  Var13=0; \nsize_t  Var14=strlen(Var11); \nif (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){\nVar11[Var14-1]=0; \nVar11  Var13; \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var16=FUNC3(NULL ,Var15); \nif (Var16){\nFUNC4(Var3->memberVar1,Var5,Var16,0); \nfree(Var16); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\n*Var12=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nFUNC6(Var15); \nfree(Var5); \nelse \nFUNC7(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nfor (Var4=0; Var4<Var17; Var4  Var13){\nchar *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); \nchar *Var10=FUNC9(Var15,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var17=0; \nchar **Var18=FUNC8(Var3->memberVar1,&Var17); \nelse \nif (Var10){\n*Var10=0; \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nif (*Var15 == ){\nFUNC10(Var15+1); \nelse \n}else if (Var10){\nchar *Var19=FUNC11(STRING,Var15,Var10+1); \nFUNC12(Var3,Var19); \nfree(Var19); \nelse \nFUNC12(Var3,Var15); \nelse \nFUNC7(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 347,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 510,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 348,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 511,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nelse \nif (Var10){\n*Var10=0; \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nif (*Var14 == ){\nelse \n}else if (Var10){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nFUNC10(Var3,Var19); \nfree(Var19); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 349,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 512,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\n*Var11  Var13=0; \nsize_t  Var14=strlen(Var11); \nif (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){\nVar11[Var14-1]=0; \nVar11  Var13; \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var16=FUNC3(NULL ,Var15); \nif (Var16){\nFUNC4(Var3->memberVar1,Var5,Var16,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var17=0; \nchar **Var18=FUNC7(Var3->memberVar1,&Var17); \nfor (Var4=0; Var4<Var17; Var4  Var13){\nchar *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); \nchar *Var10=FUNC8(Var15,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var17=0; \nchar **Var18=FUNC7(Var3->memberVar1,&Var17); \nchar *Var15=FUNC2(Var3->memberVar1,Var5,0); \nif (Var15){\nchar *Var19=FUNC9(STRING,Var15,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 350,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 513,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\n*Var12=0; \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 351,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 518,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\n*Var7  Var9=0; \nsize_t  Var10=strlen(Var7); \nif (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){\nVar7[Var10-1]=0; \nVar7  Var9; \nif (!Var6||(Var6&&Var6>Var7)){\nif (*Var7){\nif (!strcmp(Var7,STRING)){\nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nelse \nFUNC3(Var3->memberVar1,Var5,Var7,0); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var11,-1); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var14=FUNC6(STRING,Var11,Var6+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 352,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 526,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\n*Var7  Var9=0; \nsize_t  Var10=strlen(Var7); \nif (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){\nVar7[Var10-1]=0; \nVar7  Var9; \nif (!Var6||(Var6&&Var6>Var7)){\nif (*Var7){\nif (!strcmp(Var7,STRING)){\nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nelse \nFUNC3(Var3->memberVar1,Var5,Var7,0); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var11,-1); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var11=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var14=FUNC6(STRING,Var11,Var6+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 353,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 531,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\nsize_t  Var9=strlen(Var7); \nif (!Var6||(Var6&&Var6>Var7)){\nif (*Var7){\nif (!strcmp(Var7,STRING)){\nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var11=FUNC3(NULL ,Var10); \nif (Var11){\nFUNC4(Var3->memberVar1,Var5,Var11,0); \nfree(Var11); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nint  Var4,Var12=0; \nchar **Var13=FUNC5(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC6(Var10,-1); \nint  Var4,Var12=0; \nchar **Var13=FUNC5(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var14=FUNC7(STRING,Var10,Var6+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 354,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 546,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 355,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 563,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\t\tif (buf[2] == '*') {\n",
      "else\n",
      "\t\t\t\tr_cons_printf (\"%s=base64:%s\\n\", keys[i], q);\n",
      "\t\t\tfree (q);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\nsize_t  Var9=strlen(Var7); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var11=FUNC3(NULL ,Var10); \nelse \n}else if (Var8&&!Var6){\nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nfor (Var4=0; Var4<Var12; Var4  Var14){\nchar *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var10,-1); \nif (Var5[2]== *){\nelse \nFUNC6(STRING,Var13[Var4],Var6); \nfree(Var6); \nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC7(STRING,Var10,Var6+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 356,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 584,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\nchar *Var6=strchr(Var5,); \nchar *Var7=strchr(Var5,=); \nchar *Var8=strchr(Var5,); \nif ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){\nsize_t  Var9=strlen(Var7); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var11=FUNC3(NULL ,Var10); \nelse \n}else if (Var8&&!Var6){\nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); \nchar *Var6=FUNC5(Var10,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var12=0; \nchar **Var13=FUNC4(Var3->memberVar1,&Var12); \nchar *Var10=FUNC2(Var3->memberVar1,Var5,0); \nif (Var10){\nif (*Var10 == ){\nelse \n}else if (Var6){\nchar *Var14=FUNC6(STRING,Var10,Var6+1); \nFUNC7(Var3,Var14); \nfree(Var14); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 357,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 592,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nif (*Var2 == ){\nint  Var4=strlen(Var2); \nchar *Var5=malloc(Var4+2); \nif (!Var5){\n*Var5=; //Var6  Var7  Var8  STRUCT2  Var9\nmemcpy(Var5+1,Var2,Var4+1); \nchar *Var10=strchr(Var5,); \nchar *Var11=strchr(Var5,=); \nchar *Var12=strchr(Var5,); \nif ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){\nsize_t  Var13=strlen(Var11); \nif (!Var10||(Var10&&Var10>Var11)){\nif (*Var11){\nif (!strcmp(Var11,STRING)){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nchar *Var15=FUNC3(NULL ,Var14); \nif (Var15){\nFUNC4(Var3->memberVar1,Var5,Var15,0); \nelse \nFUNC4(Var3->memberVar1,Var5,Var11,0); \nelse \nFUNC5(Var3->memberVar1,Var5); \nelse \n}else if (Var12&&!Var10){\nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nfree(Var5); \nelse \nFUNC6(STRING,Var5); \nelse \n}else if (Var5[1]== *){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nfor (Var4=0; Var4<Var16; Var4  Var18){\nchar *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); \nchar *Var10=FUNC8(Var14,-1); \nelse \n}else if (!Var5[1]){\nint  Var4,Var16=0; \nchar **Var17=FUNC7(Var3->memberVar1,&Var16); \nchar *Var14=FUNC2(Var3->memberVar1,Var5,0); \nif (Var14){\nchar *Var19=FUNC9(STRING,Var14,Var10+1); \nelse \nFUNC6(STRING,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_rap",
    "Source": false,
    "Sink": false,
    "idx": 358,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 648,
    "label": -3,
    "slices": [
      "static int cmd_rap(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '=') {\n",
      "else\n",
      "\t\t\tchar *res = r_io_system (core->io, input + 1);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\tconst char *arg = r_str_trim_ro (input + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nif (Var2[1]== =){\nelse \nchar *Var4=FUNC2(Var3->memberVar1,Var2+1); \nif (Var4){\nFUNC3(STRING,Var4); \nfree(Var4); \nelse \nconst char *Var5=FUNC4(Var2+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 359,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 705,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n",
      "\t\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nchar *Var4=FUNC2(Var3->memberVar1,Var2); \nif (Var4){\nint  Var5=FUNC3(Var4); \nfree(Var4); \nreturn  Var5; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 360,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 706,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nchar *Var4=FUNC2(Var3->memberVar1,Var2); \nif (Var4){\nint  Var5=FUNC3(Var4); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 361,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 738,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tcore->num->value = r_buf_size (core->yank_buf);\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_paste (core, n, 0);\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n",
      "\t\tr_core_cmd_help (core, help_msg_y);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1  Var3; \nSTRUCT2 *Var4=(STRUCT2 *) Var1; \nswitch (Var2[0]){\nFUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nVar4->memberVar2->memberVar1=FUNC4(Var4->memberVar3); \nwhile (Var2[1]== ){\nVar2  Var5; \nVar3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; \nFUNC5(Var4,Var3,0); \nFUNC6(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC7(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nswitch (Var2[1]){\nFUNC8(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); \nif (Var2[2]== ){\nchar *Var6=strdup(Var2+3); \nint  Var7=FUNC9(Var2+3,(STRUCT3 *) Var6); \nif (Var7>0){\nFUNC8(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); \nFUNC10(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC11(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nif (Var2[1]==  Var8){//STRING\nconst char *Var9=FUNC12(Var2+2); \nconst STRUCT3 *Var10=FUNC13(Var4->memberVar3,&Var11); \nelse \n}else if (Var2[1]== ){\nFUNC14(Var4,Var2+1); \nswitch (Var2[1]){\nFUNC15(Var4,Var2+1); \nFUNC16(Var4,Var2+2); \nFUNC17(Var4,Var2+2); \nchar *Var12=FUNC18(Var4,STRING); \nchar *Var1=FUNC19(Var4,NULL ,Var12); \nFUNC20(Var4,STRING,Var1); \nFUNC21(Var4,0,Var2[0]); \nFUNC22(Var4,Var13); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 362,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 742,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1  Var3; \nSTRUCT2 *Var4=(STRUCT2 *) Var1; \nswitch (Var2[0]){\nFUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nwhile (Var2[1]== ){\nVar2  Var5; \nVar3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; \nFUNC4(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC5(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); \nswitch (Var2[1]){\nFUNC6(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); \nif (Var2[2]== ){\nchar *Var6=strdup(Var2+3); \nint  Var7=FUNC7(Var2+3,(STRUCT3 *) Var6); \nif (Var7>0){\nFUNC6(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); \nfree(Var6); \nFUNC8(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nFUNC9(Var4,FUNC3(Var4->memberVar2,Var2+1)); \nif (Var2[1]==  Var8){//STRING\nconst char *Var9=FUNC10(Var2+2); \nconst STRUCT3 *Var10=FUNC11(Var4->memberVar3,&Var11); \nelse \n}else if (Var2[1]== ){\nFUNC12(Var4,Var2+1); \nswitch (Var2[1]){\nFUNC13(Var4,Var2+1); \nFUNC14(Var4,Var2+2); \nFUNC15(Var4,Var2+2); \nchar *Var12=FUNC16(Var4,STRING); \nchar *Var1=FUNC17(Var4,NULL ,Var12); \nFUNC18(Var4,0,Var2[0]); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 363,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 749,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nswitch (Var2[1]){\nif (Var2[2]== ){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nif (Var5>0){\nFUNC3(Var3,Var3->memberVar1,(const STRUCT2 *) Var4,Var5); \nfree(Var4); \nconst char *Var6=FUNC4(Var2+2); \nconst STRUCT2 *Var7=FUNC5(Var3->memberVar2,&Var8); \nchar *Var9=FUNC6(Var3,STRING); \nchar *Var1=FUNC7(Var3,NULL ,Var9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 364,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 803,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nfree(Var9); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 365,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 804,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (sig);\n",
      "\t\t\tfree (data);\n"
    ],
    "tokenized": "STRUCT1 *Var1=(STRUCT1 *) Var2; \nswitch (Var3[0]){\nchar *Var4=strdup(Var3+3); \nint  Var5=FUNC1(Var3+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC2(Var3+2); \nconst STRUCT2 *Var7=FUNC3(Var1->memberVar1,&Var8); \nchar *Var9=FUNC4(Var1,STRING); \nif (!Var9||!*Var9){\nVar9=strdup(STRING); \nchar *Var2=FUNC5(Var1,NULL ,Var9); \n(void ) strtok(Var2,STRING); \nFUNC6(Var1,STRING,Var2); \nfree(Var9); \nfree(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 366,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strtok",
    "line": 807,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nVar9=strdup(STRING); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \n(void ) strtok(Var1,STRING); \nFUNC7(Var3,STRING,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 367,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 809,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nfree(Var9); \nVar9=strdup(STRING); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \nfree(Var9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 368,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 810,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (Var2[0]){\nchar *Var4=strdup(Var2+3); \nint  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); \nconst char *Var6=FUNC3(Var2+2); \nconst STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); \nchar *Var9=FUNC5(Var3,STRING); \nif (!Var9||!*Var9){\nVar9=strdup(STRING); \nchar *Var1=FUNC6(Var3,NULL ,Var9); \n(void ) strtok(Var1,STRING); \nFUNC7(Var3,STRING,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 369,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 839,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ],
    "tokenized": "int  Var1=FUNC1(Var2,Var3,0); \nif (Var1 != -1){\nchar  Var4[128]={0}; \nint  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); \nVar4[Var5]=0; \nif (!FUNC3(Var4,STRING,3)){\nchar *Var6=strchr(Var4,Var7); \nif (Var6){\n*Var6=0; \nVar6=strchr(Var4,); \nif (Var6){\n*Var6=0; \nreturn strdup(Var4+2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 370,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 843,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ],
    "tokenized": "int  Var1=FUNC1(Var2,Var3,0); \nif (Var1 != -1){\nchar  Var4[128]={0}; \nint  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); \nVar4[Var5]=0; \nif (!FUNC3(Var4,STRING,3)){\nchar *Var6=strchr(Var4,Var7); \nif (Var6){\n*Var6=0; \nVar6=strchr(Var4,); \nif (Var6){\n*Var6=0; \nreturn strdup(Var4+2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 371,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 847,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ],
    "tokenized": "int  Var1=FUNC1(Var2,Var3,0); \nif (Var1 != -1){\nchar  Var4[128]={0}; \nint  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); \nVar4[Var5]=0; \nif (!FUNC3(Var4,STRING,3)){\nchar *Var6=strchr(Var4,Var7); \nVar6=strchr(Var4,); \nreturn strdup(Var4+2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 372,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 861,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(STRING,Var3); \nFUNC3(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC4(Var2,NULL ,NULL ); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nchar *Var10=FUNC8(Var3); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC9(Var2,STRING,Var3); \nelse \n}else if (FUNC10(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); \nelse \nVar5=FUNC12(Var2->memberVar4,Var3); \nif (Var5){\nVar4=FUNC13(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC14(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC16(STRING,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC13(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC17(STRING); \nif (Var14){\nchar *Var13=FUNC16(STRING,Var14,Var3); \nchar *Var13=FUNC15(STRING); \nchar *Var13=FUNC15(STRING); \nelse \nchar *Var15=FUNC18(Var3); \nchar *memberVar4=FUNC19(Var2,Var3); \nif (memberVar4){\nchar *Var13=FUNC16(STRING,memberVar4,Var3); \nif (!Var4){\nVar4=FUNC20(Var2,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 373,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 866,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(STRING,Var3); \nFUNC3(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC4(Var2,NULL ,NULL ); \nif (Var7){\nVar4=FUNC5(Var2,Var7); \nelse \n}else if (FUNC6(Var3,STRING)){\nconst bool  Var8=FUNC7(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC8(Var2->memberVar2,STRING)); \nFUNC9(Var2->memberVar2,STRING,0); \nchar *Var10=FUNC10(Var3); \nFUNC11(Var2->memberVar2,STRING,Var10); \nFUNC12(Var2,STRING); \nFUNC9(Var2->memberVar2,STRING,Var8); \nFUNC11(Var2->memberVar2,STRING,Var9); \nelse \n}else if (FUNC6(Var3,STRING)){\nFUNC13(Var2,STRING,Var3); \nelse \n}else if (FUNC14(Var3)){\nconst char *Var11=FUNC8(Var2->memberVar2,STRING); \nchar *Var7=FUNC15(Var2->memberVar3,Var3,Var11,NULL ); \nif (Var7){\nFUNC16(Var2->memberVar3->memberVar1,Var7); \nelse \nVar5=FUNC17(Var2->memberVar4,Var3); \nif (Var5){\nFUNC18(Var2->memberVar4,Var5->memberVar1); \nVar4=FUNC19(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC20(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC22(STRING,Var3); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC23(STRING); \nif (Var14){\nFUNC18(Var2->memberVar4,STRING); \nchar *Var13=FUNC22(STRING,Var14,Var3); \nif (Var13){\nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING); \nFUNC18(Var2->memberVar4,STRING); \nFUNC19(Var2,Var2->memberVar4,Var13); \nelse \nchar *Var15=FUNC24(Var3); \nchar *memberVar4=FUNC25(Var2,Var3); \nif (memberVar4){\nFUNC18(Var2->memberVar4,STRING); \nchar *Var13=FUNC22(STRING,memberVar4,Var3); \nFUNC19(Var2,Var2->memberVar4,Var13); \nif (!Var4){\nVar4=FUNC26(Var2,Var3); \nfree(FUNC27(Var2->memberVar1)); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 374,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 868,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(STRING,Var3); \nFUNC3(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC4(Var2,NULL ,NULL ); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nchar *Var10=FUNC8(Var3); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC9(Var2,STRING,Var3); \nelse \n}else if (FUNC10(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); \nelse \nVar5=FUNC12(Var2->memberVar4,Var3); \nif (Var5){\nVar4=FUNC13(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC14(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC16(STRING,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC15(STRING); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC13(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC17(STRING); \nif (Var14){\nchar *Var13=FUNC16(STRING,Var14,Var3); \nchar *Var13=FUNC15(STRING); \nchar *Var13=FUNC15(STRING); \nelse \nchar *Var15=FUNC18(Var3); \nchar *memberVar4=FUNC19(Var2,Var3); \nif (memberVar4){\nchar *Var13=FUNC16(STRING,memberVar4,Var3); \nif (!Var4){\nVar4=FUNC20(Var2,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 375,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 872,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nif (Var6){\nVar4=FUNC3(Var2,Var6); \nfree(Var6); \nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC7(Var2->memberVar2,Var3,Var10,NULL ); \nconst char *Var11=FUNC8(Var3,.); \nchar *Var12=FUNC9(STRING,Var3); \nchar *Var12=FUNC9(STRING,Var13,Var3); \nelse \nchar *Var14=FUNC10(Var3); \nchar *Var15=FUNC11(Var2,Var3); \nchar *Var12=FUNC9(STRING,Var15,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 376,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 876,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC3(Var2,NULL ,NULL ); \nif (Var7){\nVar4=FUNC4(Var2,Var7); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nFUNC8(Var2->memberVar2,STRING,0); \nchar *Var10=FUNC9(Var3); \nFUNC10(Var2->memberVar2,STRING,Var10); \nFUNC11(Var2,STRING); \nFUNC8(Var2->memberVar2,STRING,Var8); \nFUNC10(Var2->memberVar2,STRING,Var9); \nfree(Var9); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC12(Var2,STRING,Var3); \nelse \n}else if (FUNC13(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); \nif (Var7){\nFUNC15(Var2->memberVar3->memberVar1,Var7); \nelse \nVar5=FUNC16(Var2->memberVar4,Var3); \nif (Var5){\nFUNC17(Var2->memberVar4,Var5->memberVar1); \nVar4=FUNC18(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC19(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING,Var3); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC22(STRING); \nif (Var14){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,Var14,Var3); \nif (Var13){\nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \nchar *Var15=FUNC23(Var3); \nchar *memberVar4=FUNC24(Var2,Var3); \nif (memberVar4){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,memberVar4,Var3); \nFUNC18(Var2,Var2->memberVar4,Var13); \nif (!Var4){\nVar4=FUNC25(Var2,Var3); \nfree(FUNC26(Var2->memberVar1)); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 377,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 880,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tfree (absfile);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4; \nif (!strcmp(Var3,Var4)){\nif (!strcmp(Var3,STRING)){\nchar *Var5=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var6=FUNC4(Var2->memberVar1,STRING); \nchar *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var8=FUNC6(Var3); \nFUNC7(Var2->memberVar1,STRING,Var8); \nfree(Var8); \nconst char *Var9=FUNC5(Var2->memberVar1,STRING); \nchar *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); \nconst char *Var10=FUNC9(Var3,.); \nchar *Var11=FUNC10(STRING,Var3); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \nchar *Var13=FUNC11(Var3); \nchar *Var14=FUNC12(Var2,Var3); \nchar *Var11=FUNC10(STRING,Var14,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 378,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 884,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4; \nif (!strcmp(Var3,Var4)){\nif (!strcmp(Var3,STRING)){\nchar *Var5=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var6=FUNC4(Var2->memberVar1,STRING); \nchar *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var8=FUNC6(Var3); \nFUNC7(Var2->memberVar1,STRING,Var7); \nfree(Var7); \nconst char *Var9=FUNC5(Var2->memberVar1,STRING); \nchar *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); \nconst char *Var10=FUNC9(Var3,.); \nchar *Var11=FUNC10(STRING,Var3); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \nchar *Var13=FUNC11(Var3); \nchar *Var14=FUNC12(Var2,Var3); \nchar *Var11=FUNC10(STRING,Var14,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 379,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 895,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_strcat (out);\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tret = out? true: false;\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var6){\nFUNC9(Var6); \nFUNC10(Var2->memberVar2->memberVar1,Var6); \nfree(Var6); \nVar4=Var6 true false ; \nconst char *Var11=FUNC11(Var3,.); \nchar *Var12=FUNC12(STRING,Var3); \nchar *Var12=FUNC12(STRING,Var13,Var3); \nelse \nchar *Var14=FUNC13(Var3); \nchar *Var15=FUNC14(Var2,Var3); \nchar *Var12=FUNC12(STRING,Var15,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 380,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 914,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 381,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 918,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC10(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC11(STRING,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC11(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC11(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 382,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 920,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 383,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 928,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nif (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC11(STRING,Var3); \nFUNC12(Var2,Var2->memberVar3,Var12); \nfree(Var12); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var13,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC13(Var3); \nchar *memberVar3=FUNC14(Var2,Var3); \nchar *Var12=FUNC11(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 384,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 930,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 385,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 934,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 386,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 936,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 387,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 940,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 388,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 942,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 389,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 946,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 390,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 948,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 391,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 952,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 392,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 954,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 393,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 958,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 394,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 960,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 395,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 964,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC10(STRING,Var12,Var3); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 396,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 966,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 397,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 970,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 398,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 973,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var12=FUNC11(STRING); \nif (!Var12){\nVar12=strdup(STRING); \nif (Var12){\nchar *Var11=FUNC10(STRING,Var12,Var3); \nif (Var11){\nFUNC12(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nfree(Var12); \nchar *Var11=FUNC9(STRING); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC13(Var3); \nchar *memberVar3=FUNC14(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 399,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 980,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nif (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC11(STRING,Var3); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var12=FUNC10(STRING); \nelse \n}else if (!strcmp(Var11,STRING)){\nelse \n}else if (!strcmp(Var11,STRING)){\nchar *Var13=FUNC12(STRING); \nif (!Var13){\nVar13=strdup(STRING); \nif (Var13){\nchar *Var12=FUNC11(STRING,Var13,Var3); \nif (Var12){\nFUNC13(Var2,Var2->memberVar3,Var12); \nfree(Var12); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC14(Var3); \nchar *memberVar3=FUNC15(Var2,Var3); \nchar *Var12=FUNC11(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 400,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 982,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC1(Var3,STRING)){\nchar *Var4=strdup(FUNC2(Var5->memberVar1,STRING)); \nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC1(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var5->memberVar2,Var3,Var8,NULL ); \nif (Var1){\nconst char *Var1=FUNC6(Var3,.); \nif (Var1){\nconst char *Var9=Var1+1; \nif (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC8(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var11=FUNC9(STRING); \nif (!Var11){\nVar11=strdup(STRING); \nif (Var11){\nchar *Var10=FUNC8(STRING,Var11,Var3); \nfree(Var11); \nchar *Var10=FUNC7(STRING); \nchar *Var10=FUNC7(STRING); \nelse \nchar *Var12=FUNC10(Var3); \nchar *Var13=FUNC11(Var5,Var3); \nchar *Var10=FUNC8(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 401,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 985,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 402,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 989,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nchar *Var11=FUNC9(STRING); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 403,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 991,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nif (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nelse \n}else if (!strcmp(Var9,STRING)){\nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \n}else if (!strcmp(Var9,STRING)){\nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 404,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 995,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ],
    "tokenized": "STRUCT1 *Var1; \nchar *Var2; \nif (!strcmp(Var3,Var2)){\nif (!strcmp(Var3,STRING)){\nchar *Var4=FUNC1(Var5,NULL ,NULL ); \nelse \n}else if (FUNC2(Var3,STRING)){\nconst bool  Var6=FUNC3(Var5->memberVar1,STRING); \nchar *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); \nchar *Var8=FUNC5(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC6(Var3)){\nconst char *Var9=FUNC4(Var5->memberVar1,STRING); \nchar *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); \nif (Var1){\nconst char *Var1=FUNC8(Var3,.); \nif (Var1){\nconst char *Var10=Var1+1; \nif (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC10(STRING,Var12,Var3); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nelse \n}else if (!strcmp(Var10,STRING)){\nchar *Var11=FUNC9(STRING); \nFUNC11(Var5,Var5->memberVar3,Var11); \nfree(Var11); \nelse \nchar *Var13=FUNC12(Var3); \nchar *memberVar3=FUNC13(Var5,Var3); \nchar *Var11=FUNC10(STRING,memberVar3,Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 405,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1005,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tfree (lang);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var13,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC12(Var3); \nchar *Var15=FUNC13(Var2,Var3); \nif (Var15){\nchar *Var12=FUNC11(STRING,Var15,Var3); \nfree(Var15); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 406,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1006,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nchar *Var6=FUNC2(Var2,NULL ,NULL ); \nelse \n}else if (FUNC3(Var3,STRING)){\nconst bool  Var7=FUNC4(Var2->memberVar1,STRING); \nchar *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); \nchar *Var9=FUNC6(Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC7(Var3)){\nconst char *Var10=FUNC5(Var2->memberVar1,STRING); \nchar *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); \nif (Var4){\nconst char *Var4=FUNC9(Var3,.); \nif (Var4){\nconst char *Var11=Var4+1; \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC11(STRING,Var13,Var3); \nchar *Var12=FUNC10(STRING); \nchar *Var12=FUNC10(STRING); \nelse \nchar *Var14=FUNC12(Var3); \nchar *Var15=FUNC13(Var2,Var3); \nif (Var15){\nchar *Var12=FUNC11(STRING,Var15,Var3); \nFUNC14(Var2,Var2->memberVar3,Var12); \nfree(Var12); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 407,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1009,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\tfree (abspath);\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nSTRUCT2 *Var4; \nchar *Var5; \nif (!strcmp(Var3,Var5)){\nif (!strcmp(Var3,STRING)){\nelse \n}else if (FUNC2(Var3,STRING)){\nchar *Var6=FUNC3(Var3); \nelse \n}else if (FUNC2(Var3,STRING)){\nelse \n}else if (FUNC4(Var3)){\nchar *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); \nif (Var4){\nconst char *Var4=FUNC6(Var3,.); \nif (Var4){\nconst char *Var9=Var4+1; \nchar *Var10=FUNC7(STRING,Var3); \nchar *Var10=FUNC7(STRING,Var11,Var3); \nelse \nchar *Var12=FUNC8(Var3); \nchar *Var13=FUNC9(Var2,Var3); \nchar *Var10=FUNC7(STRING,Var13,Var3); \nfree(Var12); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 408,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1016,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ],
    "tokenized": "Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){\nbool  Var4=false ; \nSTRUCT2 *Var5; \nchar *Var6; \nif (!strcmp(Var3,Var6)){\nFUNC2(Var2->memberVar1,strdup(Var3)); \nif (!strcmp(Var3,STRING)){\nchar *Var7=FUNC3(Var2,NULL ,NULL ); \nif (Var7){\nVar4=FUNC4(Var2,Var7); \nelse \n}else if (FUNC5(Var3,STRING)){\nconst bool  Var8=FUNC6(Var2->memberVar2,STRING); \nchar *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); \nFUNC8(Var2->memberVar2,STRING,0); \nchar *Var10=FUNC9(Var3); \nFUNC10(Var2->memberVar2,STRING,Var10); \nFUNC11(Var2,STRING); \nFUNC8(Var2->memberVar2,STRING,Var8); \nFUNC10(Var2->memberVar2,STRING,Var9); \nelse \n}else if (FUNC5(Var3,STRING)){\nFUNC12(Var2,STRING,Var3); \nelse \n}else if (FUNC13(Var3)){\nconst char *Var11=FUNC7(Var2->memberVar2,STRING); \nchar *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); \nif (Var7){\nFUNC15(Var2->memberVar3->memberVar1,Var7); \nelse \nVar5=FUNC16(Var2->memberVar4,Var3); \nif (Var5){\nFUNC17(Var2->memberVar4,Var5->memberVar1); \nVar4=FUNC18(Var2,Var2->memberVar4,Var3); \nconst char *Var5=FUNC19(Var3,.); \nif (Var5){\nconst char *Var12=Var5+1; \nif (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC21(STRING,Var3); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var3); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var14=FUNC22(STRING); \nif (Var14){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,Var14,Var3); \nif (Var13){\nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \n}else if (!strcmp(Var12,STRING)){\nchar *Var13=FUNC20(STRING); \nFUNC17(Var2->memberVar4,STRING); \nFUNC18(Var2,Var2->memberVar4,Var13); \nelse \nchar *Var15=FUNC23(Var3); \nchar *memberVar4=FUNC24(Var2,Var3); \nif (memberVar4){\nFUNC17(Var2->memberVar4,STRING); \nchar *Var13=FUNC21(STRING,memberVar4,Var3); \nFUNC18(Var2,Var2->memberVar4,Var13); \nif (!Var4){\nVar4=FUNC25(Var2,Var3); \nfree(FUNC26(Var2->memberVar1)); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 409,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1022,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (arg) {\n",
      "\t\t\tr_core_cmdf (core, \"cat %s~..\", arg);\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (Var4){\nFUNC3(Var3,STRING,Var4); \nif (FUNC4(Var3->memberVar1,Var4)){\nFUNC3(Var3,STRING,Var4); \nelse \nchar *Var5=FUNC5(Var4); \nif (Var5){\nFUNC6(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 410,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1047,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strchr(Var2,); \nif (Var4){\nVar4=FUNC2(Var4+1); \nswitch (*Var2){\nif (!Var4){\nVar4=STRING; \nif (FUNC3(Var3->memberVar1,Var4)){\nelse \nchar *Var5=FUNC4(Var4); \nif (Var5){\nFUNC5(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 411,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1057,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\n*Var6=0; \nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \nFUNC6(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 412,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1058,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\n*Var6=0; \nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \nFUNC6(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 413,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1063,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\n*Var6=0; \nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 414,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1087,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg1) {\n",
      "\t\t\targ1 = \"\";\n",
      "\t\tif (!arg2) {\n",
      "\t\t\targ2 = \"\";\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){//STRING\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4=strdup(Var2); \nconst char *Var5=strchr(Var4,); \nif (!Var5){\nVar5=FUNC2(Var5); \nchar *Var6=strchr(Var5,); \nif (!Var6){\nconst char *Var7=Var6+1; \nif (!Var7){\nVar7=FUNC2(Var7); \nswitch (*Var2){\nif (!Var5){\nVar5=STRING; \nif (!Var7){\nVar7=STRING; \nif (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){\nchar *Var8=FUNC4(Var5,Var7); \nif (Var8){\nFUNC5(Var8); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 415,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1118,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\t*ptr = 0;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar11=Var4+1; \n*Var4=0; \nVar5=strchr(Var2+1,); \nif (Var5){\nVar9=Var2+1; \nVar10=Var2+((Var2[1]== ) 21); \nVar6=FUNC2(Var12,Var9,Var10,Var11); \nif (Var6){\nFUNC3(Var6); \nfree(Var6); \nelse \nFUNC4(Var12,Var2+1); \nif (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC5(Var12,FUNC6(Var2)); \nconst char *Var17=FUNC6(Var2+1); \nchar *Var18=strdup(Var17); \nchar *Var19=strchr(Var18,); \nconst char *Var20=FUNC6(Var2+1); \nFUNC7(Var12,Var2+1); \nFUNC8(&Var12->memberVar1->memberVar1,Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nchar *Var21=FUNC9(strdup(Var4),Var7); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 416,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1123,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\t*eol = 0;\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar5=strchr(Var2+1,); \nif (Var5){\n*Var5=0; \nVar9=Var2+1; \nVar10=Var5+1; \nVar10=Var2+((Var2[1]== ) 21); \nVar6=FUNC2(Var12,Var9,Var10,Var11); \nif (Var6){\nFUNC3(Var6); \nfree(Var6); \nelse \nFUNC4(Var12,Var2+1); \nif (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC5(Var12,FUNC6(Var2)); \nconst char *Var17=FUNC6(Var2+1); \nchar *Var18=strdup(Var17); \nchar *Var19=strchr(Var18,); \nconst char *Var20=FUNC6(Var2+1); \nFUNC7(Var12,Var2+1); \nFUNC8(&Var12->memberVar1->memberVar1,Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nchar *Var21=FUNC9(strdup(Var4),Var7); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 417,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1135,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "else\n",
      "\t\t\t\thost = \"localhost\";\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar11=Var4+1; \nVar5=strchr(Var2+1,); \nif (Var5){\nVar9=Var2+1; \nVar10=Var5+1; \nelse \nVar9=STRING; \nVar10=Var2+((Var2[1]== ) 21); \nVar6=FUNC2(Var12,Var9,Var10,Var11); \nif (Var6){\nFUNC3(Var6); \nfree(Var6); \nchar *Var3=FUNC4(Var12,FUNC5(Var2)); \nconst char *Var13=FUNC5(Var2+1); \nchar *Var14=strchr(Var15,); \nconst char *Var16=FUNC5(Var2+1); \nchar *Var17=FUNC6(strdup(Var4),Var7); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 418,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1149,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\tr_core_cmd (core, str, 0);\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nif (Var2[1]== .){//STRING Var10  Var11  Var12  STRUCT2  Var13\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nif (Var3){\nFUNC4(Var9,Var3,0); \nfree(Var3); \nconst char *Var14=FUNC3(Var2+1); \nconst char *Var15=FUNC3(Var2+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 419,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1158,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var4=FUNC2(Var3,FUNC3(Var2)); \nconst char *Var5=FUNC3(Var2+1); \nchar *Var6=strdup(Var5); \nchar *Var7=strchr(Var6,); \nif (Var7){\n*Var7=0; \nif (FUNC4(Var6)){\nFUNC5(Var3,Var6); \nfree(Var6); \nconst char *Var8=FUNC3(Var2+1); \nchar *Var9=FUNC6(strdup(Var10),Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 420,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1159,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var4=FUNC2(Var3,FUNC3(Var2)); \nconst char *Var5=FUNC3(Var2+1); \nchar *Var6=strdup(Var5); \nchar *Var7=strchr(Var6,); \nif (Var7){\n*Var7=0; \nif (FUNC4(Var6)){\nFUNC5(Var3,Var6); \nfree(Var6); \nconst char *Var8=FUNC3(Var2+1); \nchar *Var9=FUNC6(strdup(Var10),Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 421,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1166,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var4=FUNC2(Var3,FUNC3(Var2)); \nconst char *Var5=FUNC3(Var2+1); \nchar *Var6=strdup(Var5); \nchar *Var7=strchr(Var6,); \nif (FUNC4(Var6)){\nFUNC5(Var3,Var6); \nfree(Var6); \nconst char *Var8=FUNC3(Var2+1); \nchar *Var9=FUNC6(strdup(Var10),Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 422,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1206,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n",
      "\t\tfree (str);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nconst char *Var9,*Var10,*Var11; \nSTRUCT1 *Var12=(STRUCT1 *) Var1; \nswitch (*Var2){\nif ((Var4=strchr(Var2+1,))){\nVar5=strchr(Var2+1,); \nif (Var5){\nVar9=Var2+1; \nVar10=Var2+((Var2[1]== ) 21); \nelse \nFUNC2(Var12,Var2+1); \nif (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16\nelse \n}else if (Var2[1]){\nchar *Var3=FUNC3(Var12,FUNC4(Var2)); \nconst char *Var17=FUNC4(Var2+1); \nchar *Var18=strdup(Var17); \nchar *Var19=strchr(Var18,); \nconst char *Var20=FUNC4(Var2+1); \nFUNC5(Var12,Var2+1); \nFUNC6(&Var12->memberVar1->memberVar1,Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nif (Var7){\n*Var7=0; \nVar4=Var3=FUNC7(Var12,Var8); \nif (Var7){\n*Var7=; \nif (Var4){\nif (FUNC8()){\nVar5=strchr(Var4,Var21); \nif (Var5){\n*Var5=0; \nif (*Var4){\nchar *Var22=FUNC9(strdup(Var4),Var7); \nFUNC10(Var12,Var22); \nfree(Var22); \nif (!Var5){\nVar4=Var5+1; \nfree(Var3); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 423,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1207,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nif (Var7){\n*Var7=0; \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var7){\n*Var7=; \nif (Var4){\nif (FUNC5()){\nif (*Var4){\nchar *Var14=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var14); \nfree(Var14); \nif (!Var5){\nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 424,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1225,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var4){\nif (FUNC5()){\nVar5=strchr(Var4,Var14); \nif (Var5){\n*Var5=0; \nif (*Var4){\nchar *Var15=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var15); \nfree(Var15); \nif (!Var5){\nVar4=Var5+1; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 425,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1230,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nif (Var7){\n*Var7=0; \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var7){\n*Var7=; \nif (Var4){\nif (FUNC5()){\nVar5=strchr(Var4,Var14); \nif (*Var4){\nchar *Var15=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var15); \nfree(Var15); \nif (!Var5){\nVar4=Var5+1; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 426,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1232,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nVar4=Var3=FUNC4(Var9,Var8); \nif (Var4){\nif (FUNC5()){\nVar5=strchr(Var4,Var14); \nif (*Var4){\nchar *Var15=FUNC6(strdup(Var4),Var7); \nFUNC7(Var9,Var15); \nfree(Var15); \nif (!Var5){\nVar4=Var5+1; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 427,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1241,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (str);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nconst char *Var12=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar4=Var3=FUNC4(Var9,Var8); \nchar *Var13=FUNC5(strdup(Var4),Var7); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 428,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1242,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; \nSTRUCT1 *Var9=(STRUCT1 *) Var1; \nswitch (*Var2){\nchar *Var3=FUNC2(Var9,FUNC3(Var2)); \nconst char *Var10=FUNC3(Var2+1); \nchar *Var11=strdup(Var10); \nchar *Var12=strchr(Var11,); \nconst char *Var13=FUNC3(Var2+1); \nif (*Var2 >= 0&&*Var2 <= 9){\nVar8=strdup(Var2); \nVar7=strchr(Var8,); \nVar4=Var3=FUNC4(Var9,Var8); \nchar *Var14=FUNC5(strdup(Var4),Var7); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 429,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1258,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 430,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1259,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 431,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1268,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 432,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1269,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2){\nif (!Var2->memberVar1||!Var2->memberVar1->memberVar1){\nVar2->memberVar1=Var2->memberVar1->memberVar1; \nstrncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); \nVar2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 433,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1295,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tr_cons_printf (\"\\n\\n\\\"%s\\\" : [\", cur_cmd);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nFUNC4(STRING%Var6 STRING,Var8); \nVar9=FUNC5(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nwhile (*Var12){\nVar10=strchr(Var12,Var13); \nif (!Var10){\nVar11=FUNC3(Var12,Var10-Var12); \nFUNC4(STRING%Var6 STRING,Var11); \nVar12  STRUCT3  Var10-Var12+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var9); \nfree(Var12); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC6(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 434,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1314,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nVar9=FUNC4(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nwhile (*Var12){\nVar10=strchr(Var12,Var13); \nif (!Var10){\nVar11=FUNC3(Var12,Var10-Var12); \nFUNC5(STRING%Var6 STRING,Var11); \nVar12  STRUCT3  Var10-Var12+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var12); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC6(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 435,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1329,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nVar9=FUNC4(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var9); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC5(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 436,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1330,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,STRING); \nif (!Var4){\nwhile (*Var4){\nVar7=strchr(Var4,Var13); \nif (!Var7){\nVar8=FUNC3(Var4,Var7-Var4); \nVar9=FUNC4(STRING,Var8); \nVar12=FUNC2(Var6,NULL ,0,Var9); \nif (!Var12){\nVar4  STRUCT3  Var7-Var4+1; \nwhile (*Var12){\nVar10=strchr(Var12,Var13); \nif (!Var10){\nVar11=FUNC3(Var12,Var10-Var12); \nVar12  STRUCT3  Var10-Var12+1; \nVar4  STRUCT3  Var7-Var4+1; \nfree(Var12); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT4 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var19=FUNC5(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nchar *Var18=strchr(Var17,); \nSTRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 437,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1338,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\tfree (out);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nSTRUCT2 *Var6=Var5->memberVar1; \nchar *Var7,*Var8,*Var9=NULL ; \nchar *Var10,*Var11,*Var12=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var6,NULL ,0,Var2+1); \nif (Var4){\nFUNC3(Var4); \nfree(Var4); \nchar *Var13,*Var14,*Var15=strdup(Var2+2); \nSTRUCT3 *Var16=Var5->memberVar2->memberVar1; \nchar *Var17=strdup(Var2+2); \nSTRUCT2 *Var18=FUNC4(NULL ,Var17,0); \nchar *Var17=strdup(Var2+2); \nSTRUCT2 *Var19=FUNC5(Var5->memberVar1,Var20,0); \nchar *Var21=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 438,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1354,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nconst int  Var8=sizeof (Var3)-1; \nSTRUCT2 *Var9=Var5->memberVar1; \nchar *Var10,*Var11,*Var12=NULL ; \nchar *Var13,*Var14,*Var15=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var9,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var16,*Var17,*Var7=strdup(Var2+2); \nfor (Var16=Var17=Var7; Var16; Var17=Var16){\nVar16=strchr(Var17,/); //STRUCT3  Var18\nif (Var16){\n*Var16  Var19=0; \nVar9=FUNC4(Var9,Var17,1); \nfree(Var7); \nSTRUCT4 *Var20=Var5->memberVar3->memberVar1; \nFUNC5(Var7); \nif (FUNC6(Var3,Var8,0,NULL )<1){\nif (!*Var3){\nVar4=FUNC2(Var9,NULL ,0,Var3); \nif (Var4){\nFUNC7(Var4); \nif (FUNC8(0)){\nif (Var2[1]== ){\nchar *Var21=strdup(Var2+2); \nif (!Var21){\nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var23=FUNC9(NULL ,Var21,0); \nif (FUNC8(0)){\nif (Var2[1]== ){\nchar *Var21=strdup(Var2+2); \nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var24=FUNC10(Var5->memberVar1,Var22,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var25=strdup(Var2); \nVar25[(size_t )(Var6-Var2)]=0; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 439,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1357,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nconst int  Var8=sizeof (Var3)-1; \nSTRUCT2 *Var9=Var5->memberVar1; \nchar *Var10,*Var11,*Var12=NULL ; \nchar *Var13,*Var14,*Var15=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nif (Var2[1]== ){\nchar *Var16,*Var17,*Var7=strdup(Var2+2); \nfor (Var16=Var17=Var7; Var16; Var17=Var16){\nVar16=strchr(Var17,/); //STRUCT3  Var18\nif (Var16){\n*Var16  Var19=0; \nVar9=FUNC3(Var9,Var17,1); \nSTRUCT4 *Var20=Var5->memberVar3->memberVar1; \nif (FUNC4(Var3,Var8,0,NULL )<1){\nif (!*Var3){\nVar4=FUNC5(Var9,NULL ,0,Var3); \nif (Var4){\nFUNC6(Var4); \nchar *Var21=strdup(Var2+2); \nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var23=FUNC7(NULL ,Var21,0); \nchar *Var21=strdup(Var2+2); \nchar *Var22=strchr(Var21,); \nSTRUCT2 *Var24=FUNC8(Var5->memberVar1,Var22,0); \nchar *Var25=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 440,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1363,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nconst int  Var8=sizeof (Var3)-1; \nSTRUCT2 *Var9=Var5->memberVar1; \nchar *Var10,*Var11,*Var12=NULL ; \nchar *Var13,*Var14,*Var15=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nif (Var2[1]== ){\nchar *Var16,*Var17,*Var7=strdup(Var2+2); \nfor (Var16=Var17=Var7; Var16; Var17=Var16){\nfree(Var7); \nSTRUCT3 *Var18=Var5->memberVar3->memberVar1; \nFUNC3(Var7); \nif (FUNC4(Var3,Var8,0,NULL )<1){\nif (!*Var3){\nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var20=FUNC5(NULL ,Var19,0); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var21=FUNC6(Var5->memberVar1,Var22,0); \nchar *Var23=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 441,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1384,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst int  Var6=sizeof (Var3)-1; \nSTRUCT2 *Var7=Var5->memberVar1; \nchar *Var8,*Var9,*Var10=NULL ; \nchar *Var11,*Var12,*Var13=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nchar *Var14,*Var15,*Var16=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (!memberVar1->memberVar1){\nmemberVar1->memberVar1=FUNC3(free); \nSTRUCT4 *Var18=memberVar1->memberVar1; \nif (FUNC4(Var3,Var6,0,NULL )<1){\nif (!*Var3){\nif (Var18){\nif ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){\nFUNC7(Var18,1,strdup(Var3)); \nmemberVar1->memberVar2=Var18->memberVar1; \nVar4=FUNC8(Var7,NULL ,0,Var3); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var20=FUNC9(NULL ,Var19,0); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); \nchar *Var23=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 442,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1385,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst int  Var6=sizeof (Var3)-1; \nSTRUCT2 *Var7=Var5->memberVar1; \nchar *Var8,*Var9,*Var10=NULL ; \nchar *Var11,*Var12,*Var13=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nchar *Var14,*Var15,*Var16=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (!memberVar1->memberVar1){\nmemberVar1->memberVar1=FUNC3(free); \nSTRUCT4 *Var18=memberVar1->memberVar1; \nif (FUNC4(Var3,Var6,0,NULL )<1){\nif (!*Var3){\nif (Var18){\nif ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){\nFUNC7(Var18,1,strdup(Var3)); \nmemberVar1->memberVar2=Var18->memberVar1; \nVar4=FUNC8(Var7,NULL ,0,Var3); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var20=FUNC9(NULL ,Var19,0); \nchar *Var19=strdup(Var2+2); \nSTRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); \nchar *Var23=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 443,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1403,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nif (Var19){\nSTRUCT2 *Var20; \n*Var19  Var21=0; \nif (FUNC5(Var18)){\nVar20=FUNC6(Var5->memberVar1,Var19,1); \nif (Var20){\nSTRUCT2 *Var22=FUNC7(NULL ,Var18,0); \nif (Var22){\nFUNC8(Var20,Var22); \nelse \nFUNC9(STRING,Var18); \nelse \nFUNC9(STRING,Var19); \nfree(Var18); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nif (Var19){\nSTRUCT2 *Var20=FUNC6(Var5->memberVar1,Var19,0); \nif (Var20){\nFUNC10(Var20,Var18); \nfree(Var18); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var23=strdup(Var2); \nVar23[(size_t )(Var6-Var2)]=0; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 444,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1408,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2 *Var4=Var3->memberVar1; \nchar *Var5,*Var6,*Var7=NULL ; \nchar *Var8,*Var9,*Var10=NULL ; \nswitch (Var2[0]){\nchar *Var11,*Var12,*Var13=strdup(Var2+2); \nSTRUCT3 *Var14=Var3->memberVar2->memberVar1; \nif (FUNC2(0)){\nif (Var2[1]== ){\nchar *Var15=strdup(Var2+2); \nif (!Var15){\nchar *Var16=strchr(Var15,); \nif (Var16){\nSTRUCT2 *Var17; \n*Var16  Var18=0; \nif (FUNC3(Var15)){\nVar17=FUNC4(Var3->memberVar1,Var16,1); \nif (Var17){\nSTRUCT2 *Var19=FUNC5(NULL ,Var15,0); \nif (Var19){\nFUNC6(Var17,Var19); \nelse \nFUNC7(STRING,Var15); \nelse \nFUNC7(STRING,Var16); \nfree(Var15); \nchar *Var15=strdup(Var2+2); \nchar *Var16=strchr(Var15,); \nSTRUCT2 *Var17=FUNC4(Var3->memberVar1,Var16,0); \nchar *Var20=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 445,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1430,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3,*Var4,*Var5=NULL ; \nchar *Var6,*Var7,*Var8=NULL ; \nswitch (Var2[0]){\nchar *Var9,*Var10,*Var11=strdup(Var2+2); \nif (FUNC2(0)){\nif (Var2[1]== ){\nchar *Var12=strdup(Var2+2); \nif (!Var12){\nchar *Var13=strchr(Var12,); \nif (Var13){\nSTRUCT1 *Var14; \nif (FUNC3(Var12)){\nif (Var14){\nSTRUCT1 *Var15=FUNC4(NULL ,Var12,0); \nif (Var15){\nelse \nFUNC5(STRING,Var12); \nfree(Var12); \nchar *Var12=strdup(Var2+2); \nchar *Var13=strchr(Var12,); \nSTRUCT1 *Var14=FUNC6(Var16->memberVar1,Var13,0); \nchar *Var17=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 446,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1441,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nif (Var19){\nSTRUCT2 *Var20; \nif (FUNC5(Var18)){\nif (Var20){\nSTRUCT2 *Var21=FUNC6(NULL ,Var18,0); \nif (Var21){\nelse \nFUNC7(STRING,Var18); \nfree(Var18); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nif (Var19){\n*Var19  Var22=0; \nSTRUCT2 *Var20=FUNC8(Var5->memberVar1,Var19,0); \nif (Var20){\nFUNC9(Var20,Var18); \nFUNC10(Var20); \nelse \nFUNC7(STRING,Var19); \nfree(Var18); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var23=strdup(Var2); \nVar23[(size_t )(Var6-Var2)]=0; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 447,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1442,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2 *Var4=Var3->memberVar1; \nswitch (Var2[0]){\nchar *Var5,*Var6,*Var7=strdup(Var2+2); \nSTRUCT3 *Var8=Var3->memberVar2->memberVar1; \nchar *Var9=strdup(Var2+2); \nchar *Var10=strchr(Var9,); \nSTRUCT2 *Var11; \nSTRUCT2 *Var12=FUNC2(NULL ,Var9,0); \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var9=strdup(Var2+2); \nchar *Var10=strchr(Var9,); \nif (Var10){\n*Var10  Var13=0; \nSTRUCT2 *Var11=FUNC4(Var3->memberVar1,Var10,0); \nif (Var11){\nFUNC5(Var11,Var9); \nFUNC6(Var11); \nelse \nFUNC7(STRING,Var10); \nfree(Var9); \nchar *Var14=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 448,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1455,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nswitch (Var2[0]){\nchar *Var3,*Var4,*Var5=strdup(Var2+2); \nchar *Var6=strdup(Var2+2); \nchar *Var7=strchr(Var6,); \nSTRUCT1 *Var8; \nSTRUCT1 *Var9=FUNC2(NULL ,Var6,0); \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var6=strdup(Var2+2); \nchar *Var7=strchr(Var6,); \nif (Var7){\nSTRUCT1 *Var8=FUNC4(Var10->memberVar1,Var7,0); \nif (Var8){\nFUNC5(Var8,Var6); \nfree(Var6); \nchar *Var11=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 449,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1470,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var20=FUNC5(NULL ,Var18,0); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var22=strdup(Var2); \nVar22[(size_t )(Var6-Var2)]=0; \nVar4=FUNC2(Var8,NULL ,0,Var6+1); \nif (Var4){\nFUNC7(Var4); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 450,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1472,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nVar4=FUNC2(Var8,NULL ,0,Var2+1); \nif (Var5->memberVar2){\nif (!FUNC3()){\nif (Var2[1]== ){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var20=FUNC5(NULL ,Var18,0); \nif (FUNC4(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var22=strdup(Var2); \nVar22[(size_t )(Var6-Var2)]=0; \nVar8=FUNC7(Var5->memberVar1,Var22+1,1); \nVar4=FUNC2(Var8,NULL ,0,Var6+1); \nif (Var4){\nFUNC8(Var4); \nfree(Var4); \nfree(Var22); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 451,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1478,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar  Var3[1024],*Var4; \nSTRUCT1 *Var5=(STRUCT1 *) Var1; \nconst char *Var6,*Var7=STRING; \nSTRUCT2 *Var8=Var5->memberVar1; \nchar *Var9,*Var10,*Var11=NULL ; \nchar *Var12,*Var13,*Var14=NULL ; \nswitch (Var2[0]){\nif (Var5->memberVar2){\nif (!FUNC2()){\nchar *Var15,*Var16,*Var7=strdup(Var2+2); \nSTRUCT3 *Var17=Var5->memberVar3->memberVar1; \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var18=strdup(Var2+2); \nif (!Var18){\nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var20=FUNC4(NULL ,Var18,0); \nif (FUNC3(0)){\nchar *Var18=strdup(Var2+2); \nchar *Var19=strchr(Var18,); \nSTRUCT2 *Var21=FUNC5(Var5->memberVar1,Var19,0); \nif (Var2[0]== 0){\nVar6=strchr(Var2+1,); \nif (Var6){\nchar *Var22=strdup(Var2); \nVar8=FUNC6(Var5->memberVar1,Var22+1,1); \nVar4=FUNC7(Var8,NULL ,0,Var6+1); \nif (Var4){\nFUNC8(Var4); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 452,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1480,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tfree (inp);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nconst char *Var4,*Var5=STRING; \nSTRUCT2 *Var6=Var3->memberVar1; \nswitch (Var2[0]){\nif (Var3->memberVar2){\nif (!FUNC2()){\nchar *Var7,*Var8,*Var5=strdup(Var2+2); \nSTRUCT3 *Var9=Var3->memberVar3->memberVar1; \nif (FUNC3(0)){\nif (Var2[1]== ){\nchar *Var10=strdup(Var2+2); \nif (!Var10){\nchar *Var11=strchr(Var10,); \nSTRUCT2 *Var12=FUNC4(NULL ,Var10,0); \nif (FUNC3(0)){\nchar *Var10=strdup(Var2+2); \nchar *Var11=strchr(Var10,); \nSTRUCT2 *Var13=FUNC5(Var3->memberVar1,Var11,0); \nif (Var2[0]== 0){\nif (Var4){\nchar *Var14=strdup(Var2); \nVar14[(size_t )(Var4-Var2)]=0; \nVar6=FUNC6(Var3->memberVar1,Var14+1,1); \nfree(Var14); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 453,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1544,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tint argc = 0;\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (args);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1  Var1,const char *Var2){\nchar *Var3=FUNC2(Var2); \nint  Var4=0; \nchar **Var5=FUNC3(Var3,&Var4); \nint  Var6=Var1(Var4,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 454,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1545,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (a);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1  Var1,const char *Var2){\nchar *Var3=FUNC2(Var2); \nchar **Var4=FUNC3(Var3,&Var5); \nint  Var6=Var1(Var5,Var4); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 455,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1578,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=FUNC2(STRING,Var2); \nint  Var4=0; \nif (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nVar4=FUNC5(Var1->memberVar1,Var3); \nelse \nconst char *Var5[]={\nint  Var6; \nfor (Var6=0; Var5[Var6]; Var6  Var7){\nif (FUNC3(Var3,Var5[Var6])){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 456,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1584,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=FUNC2(STRING,Var2); \nint  Var4=0; \nif (FUNC3(Var3,STRING)){\nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nFUNC4(STRING,Var3); \nelse \n}else if (FUNC3(Var3,STRING)){\nVar4=FUNC5(Var1->memberVar1,Var3); \nelse \nconst char *Var5[]={\nint  Var6; \nfor (Var6=0; Var5[Var6]; Var6  Var7){\nif (FUNC3(Var3,Var5[Var6])){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 457,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ],
    "tokenized": "STRUCT1 *Var1=(STRUCT1 *) Var2; \nif (FUNC1(Var1,Var3)){\nSTRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; \nswitch (*Var3){\nconst char *memberVar1=FUNC3(Var3+2); \nwrite(1,Var5,strlen(Var5)); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 458,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ],
    "tokenized": "STRUCT1 *Var1=(STRUCT1 *) Var2; \nif (FUNC1(Var1,Var3)){\nSTRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; \nswitch (*Var3){\nconst char *memberVar1=FUNC3(Var3+2); \nwrite(1,Var5,strlen(Var5)); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 459,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1727,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4=FUNC2(Var3); \nFUNC3(Var3,Var4); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 460,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1730,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4=FUNC2(Var3); \nFUNC3(Var3,Var4); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 461,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1823,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "else\n",
      "\t\tret = r_core_cmdf (core, \"?v [%s]\", input);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=true ; \nchar *Var5,*Var6; \nVar2=FUNC2(Var2); \nwhile (*Var2 == ){\nVar2  Var7; \nif (!*Var2||*Var2 == ){\nVar5=strdup(Var2); \nVar6=strchr(Var5,=); \nif (Var6){\n*Var6  Var7=0; \nif (!FUNC3(Var6,STRING,2)){\nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var2); \nfree(Var5); \nreturn  Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 462,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1824,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=true ; \nchar *Var5,*Var6; \nVar2=FUNC2(Var2); \nwhile (*Var2 == ){\nVar2  Var7; \nif (!*Var2||*Var2 == ){\nVar5=strdup(Var2); \nVar6=strchr(Var5,=); \nif (Var6){\n*Var6  Var7=0; \nif (!FUNC3(Var6,STRING,2)){\nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var6,Var5); \nfree(Var5); \nreturn  Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 463,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1835,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=true ; \nchar *Var5,*Var6; \nVar2=FUNC2(Var2); \nwhile (*Var2 == ){\nVar2  Var7; \nif (!*Var2||*Var2 == ){\nVar5=strdup(Var2); \nVar6=strchr(Var5,=); \nif (Var6){\nif (!FUNC3(Var6,STRING,2)){\nVar4=FUNC4(Var3,STRING,Var6,Var5); \nelse \nVar4=FUNC4(Var3,STRING,Var6,Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_autocomplete",
    "Source": false,
    "Sink": false,
    "idx": 464,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 1950,
    "label": -3,
    "slices": [
      "static void cmd_autocomplete(RCore *core, const char *input) {\n",
      "\tRCoreAutocomplete* b = core->autocomplete;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\tchar arg[256];\n",
      "\tif (!*input) {\n",
      "\tif (*input == '?') {\n",
      "\tif (*input == '-') {\n",
      "\t\tconst char *arg = input + 1;\n",
      "\t\tif (!*input) {\n",
      "\t\tr_core_autocomplete_remove (b, arg);\n",
      "\twhile (b) {\n",
      "\t\tconst char* end = r_str_trim_wp (input);\n",
      "\t\tif (!end) {\n",
      "\t\tif ((end - input) >= sizeof (arg)) {\n",
      "\t\tif (end == input) {\n",
      "\t\tmemcpy (arg, input, end - input);\n",
      "\t\targ[end - input] = 0;\n",
      "\t\tRCoreAutocomplete* a = r_core_autocomplete_find (b, arg, true);\n",
      "\t\tinput = r_str_trim_ro (end);\n",
      "\t\tif (input && *input && !a) {\n",
      "\t\t\tif (b->type == R_CORE_AUTOCMPLT_DFLT && !(b = r_core_autocomplete_add (b, arg, R_CORE_AUTOCMPLT_DFLT, false))) {\n",
      "else\n",
      "\t\t\t} else if (b->type != R_CORE_AUTOCMPLT_DFLT) {\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && !a) {\n",
      "\t\t\tif (arg[0] == '$') {\n",
      "\t\t\t\tint type = autocomplete_type (arg);\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && a) {\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2){\nSTRUCT2 *Var3=Var1->memberVar1; \nVar2=FUNC2(Var2); \nchar  Var4[256]; \nif (!*Var2){\nif (*Var2 == ){\nif (*Var2 == -){\nconst char *Var4=Var2+1; \nif (!*Var2){\nFUNC3(Var3,Var4); \nwhile (Var3){\nconst char *Var5=FUNC4(Var2); \nif (!Var5){\nif ((Var5-Var2) >= sizeof (Var4)){\nif (Var5 ==  Var2){\nmemcpy(Var4,Var2,Var5-Var2); \nVar4[Var5-Var2]=0; \nSTRUCT2 *Var6=FUNC5(Var3,Var4,true ); \nVar2=FUNC2(Var5); \nif (Var2&&*Var2&&!Var6){\nif (Var3->memberVar1 ==  Var7&&!(Var3=FUNC6(Var3,Var4,Var7,false ))){\nelse \n}else if (Var3->memberVar1 !=  Var7){\nelse \n}else if ((!Var2||!*Var2)&&!Var6){\nif (Var4[0]== ){\nint  memberVar1=FUNC7(Var4); \nelse \n}else if ((!Var2||!*Var2)&&Var6){\n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 465,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2032,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t(void)r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nswitch (*Var2){\nif (Var2[1]== !){//!!!&!!!-\nelse \n}else if (Var2[1]== ){\nelse \n}else if (Var2[1]== *){\nchar *Var4=FUNC2(Var2+1); \n(void ) FUNC3(Var3,STRING!Var5%STRUCT2 STRING,Var4); \nfree(Var4); \nchar *Var4=FUNC4(Var3,Var2); \nchar *Var4=FUNC2(Var2+1); \nconst char *Var4=FUNC5(Var6); \nelse \nchar *Var4=FUNC4(Var3,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 466,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2048,
    "label": -3,
    "slices": [
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tint olen;\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_cons_memcat (out, olen);\n",
      "\t\t\t\t\tfree (out);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "switch (*Var1){\nif (Var1[1]== !){//!!!&!!!-\nelse \n}else if (Var1[1]== ){\nelse \n}else if (Var1[1]== *){\nchar *Var2=FUNC1(Var1+1); \nelse \nif (FUNC2(0)){\nif (Var1[1]){\nint  Var3; \nchar *Var4=NULL ; \nchar *Var2=FUNC3(Var5,Var1); \nif (Var2){\nFUNC4(Var4,Var3); \nfree(Var4); \nchar *Var2=FUNC1(Var1+1); \nconst char *Var2=FUNC5(Var6); \nelse \nchar *Var2=FUNC3(Var5,Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 467,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2049,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=0; \nswitch (*Var2){\nif (Var2[1]== !){//!!!&!!!-\nelse \n}else if (Var2[1]== ){\nelse \n}else if (Var2[1]== *){\nchar *Var5=FUNC2(Var2+1); \nelse \nif (FUNC3(0)){\nif (Var2[1]){\nchar *Var6=NULL ; \nchar *Var5=FUNC4(Var3,Var2); \nif (Var5){\nVar4=FUNC5(Var5+1,NULL ,&Var6,&Var7,NULL ); \nfree(Var5); \nchar *Var5=FUNC2(Var2+1); \nconst char *Var5=FUNC6(Var8); \nelse \nchar *Var5=FUNC4(Var3,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 468,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2071,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tcmd = r_str_replace (cmd, \" \", \"\\\\ \", true);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\\ \", \" \", false);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\"\", \"'\", false);\n",
      "\t\tret = r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\tfree (cmd);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nint  Var4=0; \nswitch (*Var2){\nchar *Var5=FUNC2(Var2+1); \nchar *Var5=FUNC3(Var3,Var2); \nchar *Var5=FUNC2(Var2+1); \nVar5=FUNC4(Var5,STRING,STRING,true ); \nVar5=FUNC4(Var5,STRING,STRING,false ); \nVar5=FUNC4(Var5,STRINGSTRING,false ); \nVar4=FUNC5(Var3,STRING!Var6%STRUCT2 STRING,Var5); \nfree(Var5); \nconst char *Var5=FUNC6(Var7); \nelse \nchar *Var5=FUNC3(Var3,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 469,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 2075,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '?') {\n",
      "else\n",
      "\t\t\tif (!r_sandbox_enable (0)) {\n",
      "\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_core_sysenv_end (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tn = atoi (input);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_sysenv_end (core, input);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2  Var4; \nswitch (*Var2){\nif (Var2[1]== ){\nelse \nif (!FUNC2(0)){\nVar3->memberVar1=Var2[1]10; \nif (Var2[1]== !){//!!!&!!!-\nelse \n}else if (Var2[1]== ){\nelse \n}else if (Var2[1]== *){\nchar *Var5=FUNC3(Var2+1); \nelse \nif (FUNC2(0)){\nif (Var2[1]){\nchar *Var5=FUNC4(Var3,Var2); \nif (Var5){\nFUNC5(Var3,Var2); \nchar *Var5=FUNC3(Var2+1); \nVar4=FUNC6(Var2); \nif (*Var2 == 0||Var4>0){\nconst char *Var5=FUNC7(Var4); \nif (Var5){\nFUNC8(Var3,Var5); \nelse \nchar *Var5=FUNC4(Var3,Var2); \nif (Var5){\nFUNC5(Var3,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 470,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2089,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tret = r_sys_cmd (cmd);\n",
      "\t\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2){\nSTRUCT1 *Var3=(STRUCT1 *) Var1; \nSTRUCT2  Var4; \nint  Var5=0; \nswitch (*Var2){\nchar *Var6=FUNC2(Var2+1); \nchar *Var6=FUNC3(Var3,Var2); \nchar *Var6=FUNC2(Var2+1); \nif (*Var2 == 0||Var4>0){\nconst char *Var6=FUNC4(Var4); \nelse \nchar *Var6=FUNC3(Var3,Var2); \nif (Var6){\nVar5=FUNC5(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 471,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2138,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\tfree (tmp);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){\nSTRUCT2  Var4[2]={NULL ,NULL }; \nchar *Var5=NULL ; \nif (!FUNC2(&Var4[0],&Var4[1],&Var6,0)){\nif (!FUNC3(Var4[1],Var7,0)){\nchar *Var8=FUNC4(STRING%STRUCT3 STRING,Var3); \nif (!Var8){\nVar5=Var8; \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 472,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "calloc",
    "line": 2142,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nchar *Var2=NULL ; \nSTRUCT2  Var3=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){\nif (!FUNC2(Var1[1],Var5,0)){\nchar *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); \nif (!Var6){\nif (!Var3){\nSTRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); \nif (!Var8){\nint  Var10=FUNC4(Var8,Var9); \nif (!Var10){\nFUNC5(Var8,Var9,FUNC6(STRING)); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 473,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2167,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tclose (1);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nif (Var2 == -1){\nclose(1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 474,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2168,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nVar2=FUNC6((Var16) Var1[1],Var17|Var18); \nif (Var2 == -1){\nFUNC7(Var2,1); \nclose(Var2); \nif (Var2 != -1){\nclose(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 475,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2185,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tfd_out = -1;\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nVar2=FUNC6((Var16) Var1[1],Var17|Var18); \nif (Var2 == -1){\nFUNC7(Var2,1); \nclose(Var2); \nVar2=-1; \nif (Var2 != -1){\nclose(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 476,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2189,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tcons_out = dup (1);\n",
      "\tif (cons_out != -1) {\n",
      "\t\tdup2 (cons_out, 1);\n",
      "\t\tclose (cons_out);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nint  Var2=-1,Var3=-1; \nchar *Var4=NULL ; \nSTRUCT2  Var5=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){\nif (!FUNC2(Var1[1],Var7,0)){\nchar *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); \nif (!Var8){\nif (!Var5){\nSTRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); \nif (!Var10){\nint  Var12=FUNC4(Var10,Var11); \nif (!Var12){\nif (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){\nif (Var2 == -1){\nVar3=FUNC6(1); \nif (Var3 != -1){\nFUNC7(Var3,1); \nclose(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 477,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2191,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ],
    "tokenized": "STRUCT1  Var1[2]={NULL ,NULL }; \nchar *Var2=NULL ; \nSTRUCT2  Var3=NULL ; \nif (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){\nif (!FUNC2(Var1[1],Var5,0)){\nchar *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); \nif (!Var6){\nif (!Var3){\nSTRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); \nif (!Var8){\nint  Var10=FUNC4(Var8,Var9); \nif (!Var10){\nFUNC5(Var8,Var9,FUNC6(STRING)); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 478,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2192,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\t_shell_cmd_ = r_sys_conv_utf8_to_win (_shell_cmd);\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tfree (_shell_cmd_);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){\nSTRUCT2  Var4[2]={NULL ,NULL }; \nchar *Var5=NULL ; \nSTRUCT3  Var6=NULL ; \nif (!FUNC2(&Var4[0],&Var4[1],&Var7,0)){\nif (!FUNC3(Var4[1],Var8,0)){\nchar *Var9=FUNC4(STRING%STRUCT4 STRING,Var3); \nif (!Var9){\nVar5=Var9; \nVar6=FUNC5(Var5); \nif (!Var6){\nSTRUCT5 *Var10=calloc(Var11,sizeof (STRUCT5)); \nif (!Var10){\nint  Var12=FUNC6(Var10,Var11); \nif (!Var12){\nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 479,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2222,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tstr = r_core_cmd_str (core, radare_cmd);\n",
      "\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n",
      "\t\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nif (FUNC2(0)){\nif (*Var4 == !){\nVar5=FUNC3(Var2,Var3); \nFUNC4(Var4+1,Var5,&Var6,&Var7,NULL ); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 480,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2224,
    "label": -3,
    "slices": [
      "\tint si, olen, ret = -1, pipecolor = -1;\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tout = NULL;\n",
      "\t\tr_cons_memcat (out, olen);\n",
      "\t\tfree (out);\n"
    ],
    "tokenized": "int  Var1,Var2,Var3=-1,Var4=-1; \nchar *Var5,*Var6=NULL ; \nif (FUNC1(0)){\nif (*STRUCT1 == !){\nVar6=NULL ; \nFUNC2(Var6,Var2); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 481,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 2231,
    "label": -3,
    "slices": [
      "\tif (r_sandbox_enable (0)) {\n",
      "\tsignal (SIGPIPE, SIG_IGN);\n"
    ],
    "tokenized": "if (FUNC1(0)){\nsignal(Var1,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 482,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2238,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nVar1=FUNC2(1); \nif (Var1 != -1){\nif (FUNC3(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC4(Var1,1); \nclose(Var1); \nclose(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 483,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2241,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC3(Var2[1],1); \nclose(Var2[1]); \nclose(Var2[0]); \nelse \nclose(Var2[1]); \nFUNC3(Var2[0],0); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 484,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2242,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC3(Var2[1],1); \nclose(Var2[1]); \nclose(Var2[0]); \nelse \nclose(Var2[1]); \nFUNC3(Var2[0],0); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 485,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2245,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tclose (1);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nclose(1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 486,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2248,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nVar1=FUNC2(1); \nif (Var1 != -1){\nif (FUNC3(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC4(Var1,1); \nclose(Var1); \nclose(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 487,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2250,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nif (Var1 != -1){\nif (FUNC2(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC3(Var2[1],1); \nclose(Var2[1]); \nclose(Var2[0]); \nelse \nclose(Var2[1]); \nFUNC3(Var2[0],0); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 488,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2254,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ],
    "tokenized": "int  Var1,Var2[2]; \nint  Var3; \nif (FUNC1(0)){\nVar1=FUNC2(1); \nif (Var1 != -1){\nif (FUNC3(Var2) == 0){\nif (Var3 == -1){\nelse \n}else if (Var3){\nFUNC4(Var1,1); \nclose(Var1); \nclose(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 489,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2278,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n",
      "\tfree (s);\n",
      "\treturn res;\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nVar8=strchr(Var9,=); \nif (Var8){\n*Var8=0; \nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var6); \nVar6=FUNC6(Var6,Var11); \nfree(Var11); \nFUNC7(Var1->memberVar1,Var9,Var8+1); \n*Var8==; \nelse \nFUNC8(STRING,Var9); \nfree(Var3); \nreturn  Var6; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 490,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2280,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ],
    "tokenized": "char *Var1=strdup(Var2); \nint  Var3,Var4=FUNC1(Var1,,); \nchar *Var5=strdup(STRING); \nif (!Var1||!Var5){\nfree(Var5); \nfor (Var3=0; Var3<Var4; Var3  Var6){\nchar *Var7,*Var8=(char *) FUNC2(Var1,Var3); \nif (!Var8){\nif (Var7){\nconst char *Var9=FUNC3(Var10->memberVar1,Var8); \nif (!Var9){\nchar *Var11=FUNC4(STRING,Var8,Var9); \nif (!Var11){\nfree(Var5); \nVar5=FUNC5(Var5,Var11); \nreturn  Var5; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 491,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2282,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 492,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2283,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ],
    "tokenized": "char *Var1=strdup(Var2); \nint  Var3,Var4=FUNC1(Var1,,); \nchar *Var5=strdup(STRING); \nif (!Var1||!Var5){\nfree(Var5); \nfor (Var3=0; Var3<Var4; Var3  Var6){\nchar *Var7,*Var8=(char *) FUNC2(Var1,Var3); \nif (!Var8){\nif (Var7){\nconst char *Var9=FUNC3(Var10->memberVar1,Var8); \nif (!Var9){\nchar *Var11=FUNC4(STRING,Var8,Var9); \nif (!Var11){\nfree(Var5); \nVar5=FUNC5(Var5,Var11); \nreturn  Var5; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 493,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2291,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nVar8=strchr(Var9,=); \nif (Var8){\n*Var8=0; \nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nFUNC6(Var1->memberVar1,Var9,Var8+1); \n*Var8==; \nelse \nFUNC7(STRING,Var9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 494,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2300,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 495,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2301,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var6); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var6); \nVar6=FUNC6(Var6,Var11); \nreturn  Var6; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 496,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2305,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nVar6=FUNC6(Var6,Var11); \nfree(Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 497,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2312,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "static char *FUNC1(STRUCT1 *Var1,const char *Var2){\nchar *Var3=strdup(Var2); \nint  Var4,Var5=FUNC2(Var3,,); \nchar *Var6=strdup(STRING); \nif (!Var3||!Var6){\nfree(Var3); \nfor (Var4=0; Var4<Var5; Var4  Var7){\nchar *Var8,*Var9=(char *) FUNC3(Var3,Var4); \nif (!Var9){\nif (Var8){\nconst char *Var10=FUNC4(Var1->memberVar1,Var9); \nif (!Var10){\nchar *Var11=FUNC5(STRING,Var9,Var10); \nif (!Var11){\nfree(Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 498,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nchar *Var4,*Var5=NULL ,*Var6=NULL ; \nbool  Var7=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var8=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var9=Var1->memberVar2; \nVar6=strdup(Var2); \nconst char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nchar *Var12=strdup(Var10); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 499,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nchar *Var4,*Var5=NULL ,*Var6=NULL ; \nbool  Var7=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var8=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var9=Var1->memberVar2; \nVar6=strdup(Var2); \nconst char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nchar *Var12=strdup(Var10); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 500,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2325,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\tif (http) {\n",
      "\t\t\t*http = 0;\n",
      "\t\t\thttp--;\n",
      "\t\t\tif (*http == ' ') {\n",
      "\t\t\t\t*http = 0;\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nchar *Var4,*Var5=NULL ,*Var6=NULL ; \nbool  Var7=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var8=strstr(Var2,STRING); \nif (Var8){\n*Var8=0; \nVar8  Var9; \nif (*Var8 == ){\n*Var8=0; \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var10=Var1->memberVar2; \nVar6=strdup(Var2); \nconst char *Var11=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var12=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nchar *Var13=strdup(Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 501,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2342,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n",
      "\t\t*cmt = 0;\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\tfree (icmd);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var10=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC5(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nVar6=*Var8(char *) FUNC6(Var8,,STRING) NULL ; \nif (Var6&&(Var6[1]== ||Var6[1]==  Var12)){\n*Var6=0; \nif (*Var2 != ){\nif (!strchr(Var2,)){//Var13|Var14{Var15; Var16}//Var17; if  Var18  Var19  Var20  STRUCT3  Var21\nif ((Var7=strchr(Var2,; ))){\n*Var7=0; \nif (Var3>0){\nwhile (FUNC7(*Var2)){\nVar2  Var22; \nif (!*Var2){\nif (Var3>1&&FUNC8(0)){\nFUNC9(STRING,Var2); \nelse \nif (Var3>Var23){\nif (FUNC10()){\nconst char *Var24=Var1->STRUCT4  Var1->STRUCT4 STRING; \nint  Var25=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var26&&*Var2){\nif (FUNC11()){\nchar *Var27=strdup(Var24); \nVar4=FUNC12(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); \nif (Var4&&*Var2 ==  Var28){\nif (Var1->memberVar4){\nif (Var7&&Var7[1]){\nfor (Var22  Var7; *Var7 == ; ; Var7  Var22){\nFUNC1(Var1,Var7); \nfree(Var8); \nreturn  Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 502,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2364,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var10=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC5(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (*Var2 != ){\nif (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20\nif (Var3>0){\nwhile (FUNC6(*Var2)){\nVar2  Var21; \nif (!*Var2){\nif (Var3>1&&FUNC7(0)){\nFUNC8(STRING,Var2); \nelse \nif (Var3>Var22){\nif (FUNC9()){\nconst char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; \nint  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var25&&*Var2){\nif (FUNC10()){\nchar *Var26=strdup(Var23); \nVar4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); \nif (Var4&&*Var2 ==  Var27){\nif (Var1->memberVar4){\n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 503,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2365,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nmemmove(Var2,Var2+9,strlen(Var2+9)+1); \nchar *Var10=strstr(Var2,STRING); \nreturn FUNC4(Var1,Var2); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC5(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (*Var2 != ){\nif (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20\nif ((Var7=strchr(Var2,; ))){\n*Var7=0; \nif (Var3>0){\nwhile (FUNC6(*Var2)){\nVar2  Var21; \nif (!*Var2){\nif (Var3>1&&FUNC7(0)){\nFUNC8(STRING,Var2); \nelse \nif (Var3>Var22){\nif (FUNC9()){\nconst char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; \nint  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var25&&*Var2){\nif (FUNC10()){\nchar *Var26=strdup(Var23); \nVar4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); \nif (Var4&&*Var2 ==  Var27){\nif (Var1->memberVar4){\nif (Var7&&Var7[1]){\nfor (Var21  Var7; *Var7 == ; ; Var7  Var21){\nFUNC1(Var1,Var7); \nreturn  Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 504,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2416,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 505,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2420,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 506,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2424,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 507,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2434,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nif (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){\nVar1->memberVar5=Var1->memberVar2; \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC4(0)){\nelse \nif (Var3>Var12){\nif (FUNC5()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC6()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nfree(Var16); \nif (Var1->memberVar7){\nfree(Var16); \nif (Var16&&*Var16&&Var5>1){\n(void ) FUNC7(Var1,Var16); \nfree(Var16); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 508,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2457,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\tfree (icmd);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2){\nSTRUCT2  Var3=FUNC2(Var2,NULL ,10); \nint  Var4=0,Var5; \nchar *Var6,*Var7=NULL ,*Var8=NULL ; \nbool  Var9=Var1->memberVar1; \nif (FUNC3(Var2,STRING)){\nchar *Var10=strstr(Var2,STRING); \nSTRUCT2  Var11=Var1->memberVar2; \nVar8=strdup(Var2); \nVar2=FUNC4(Var8); \nif (!*Var2){\nif (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){\nVar6=*Var8(char *) FUNC5(Var8,,STRING) NULL ; \nif (Var3>0){\nif (!*Var2){\nif (Var3>1&&FUNC6(0)){\nelse \nif (Var3>Var12){\nif (FUNC7()){\nconst char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; \nint  Var14=Var1->memberVar3&&Var1->memberVar3->memberVar1; \nwhile (Var3  Var15&&*Var2){\nif (FUNC8()){\nchar *Var16=strdup(Var13); \nif (Var4&&*Var2 ==  Var17){\nif (Var1->memberVar4){\nif (Var7&&Var7[1]){\nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 509,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2474,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\t\treturn q;\n",
      "\treturn strchr (p, '-');\n"
    ],
    "tokenized": "static char *FUNC1(char *Var1){\nchar *Var2=strchr(Var1,+); \nif (Var2){\nreturn  Var2; \nreturn strchr(Var1,-); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 510,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2478,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\treturn strchr (p, '-');\n"
    ],
    "tokenized": "static char *FUNC1(char *Var1){\nchar *Var2=strchr(Var1,+); \nif (Var2){\nreturn strchr(Var1,-); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "tmpenvs_free",
    "Source": false,
    "Sink": false,
    "idx": 511,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2483,
    "label": -3,
    "slices": [
      "static void tmpenvs_free(void *item) {\n",
      "\tr_sys_setenv (item, NULL);\n",
      "\tfree (item);\n"
    ],
    "tokenized": "static void FUNC1(void *Var1){\nFUNC2(Var1,NULL ); \nfree(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "set_tmp_arch",
    "Source": false,
    "Sink": false,
    "idx": 512,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2490,
    "label": -3,
    "slices": [
      "static bool set_tmp_arch(RCore *core, char *arch, char **tmparch) {\n",
      "\t*tmparch = strdup (r_config_get (core->config, \"asm.arch\"));\n",
      "\tr_config_set (core->config, \"asm.arch\", arch);\n",
      "\tcore->fixedarch = true;\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,char *Var2,char **Var3){\n*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); \nFUNC3(Var1->memberVar1,STRING,Var2); \nVar1->memberVar2=true ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "set_tmp_bits",
    "Source": false,
    "Sink": false,
    "idx": 513,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2500,
    "label": -3,
    "slices": [
      "static bool set_tmp_bits(RCore *core, int bits, char **tmpbits) {\n",
      "\t*tmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n",
      "\tr_config_set_i (core->config, \"asm.bits\", bits);\n",
      "\tcore->fixedbits = true;\n"
    ],
    "tokenized": "static bool FUNC1(STRUCT1 *Var1,int  Var2,char **Var3){\n*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); \nFUNC3(Var1->memberVar1,STRING,Var2); \nVar1->memberVar2=true ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 514,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2533,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 515,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2535,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tchar *$1 = strchr ($0 + 2, ')');\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n"
    ],
    "tokenized": "if (!Var1){\nif (0){\nchar *1=strchr(0+2,)); \nelse \nchar *Var2=strchr(Var1,; ); \nchar *Var3=strchr(Var4+1,); \nchar *Var5=strchr(Var1,); \nchar *Var6=FUNC1(Var7,Var1); \nconst char *Var8=strstr(Var1,STRING); \nchar *Var9,*Var5=strchr(Var10+1,!); \nchar *Var11=strchr(Var12,=); \nchar *Var1=FUNC2(Var7,Var10+2); \nchar *Var3=strchr(Var10+2,); \nchar *Var4=strchr(Var13,); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 516,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ],
    "tokenized": "if (!Var1){\nif (0){\nif (1){\nmemmove(0+1,0+2,strlen(0+2)+1); \nelse \nchar *Var2=strchr(Var1,; ); \nchar *Var3=strchr(Var1,); \nchar *Var4=FUNC1(Var5,Var1); \nconst char *Var6=strstr(Var1,STRING); \nchar *Var1=FUNC2(Var5,Var7+2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 517,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ],
    "tokenized": "if (!Var1){\nif (0){\nif (1){\nmemmove(0+1,0+2,strlen(0+2)+1); \nelse \nchar *Var2=strchr(Var1,; ); \nchar *Var3=strchr(Var1,); \nchar *Var4=FUNC1(Var5,Var1); \nconst char *Var6=strstr(Var1,STRING); \nchar *Var1=FUNC2(Var5,Var7+2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 518,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2572,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tchar op0 = 0;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\top0 = *q;\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\t\t\t*p = op0;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \n*Var25  Var26=0; \nelse \nchar *Var28=strchr(Var2,; ); \nif (Var28){\n*Var28=0; \nFUNC7(Var1,Var2); \nif (!Var28){\nVar2=Var28+1; \nchar  Var29=0; \nif (*Var25){\nif (Var25[0]== ){\nVar25  Var30; \nwhile (Var25[1]== ; ||FUNC8(Var25[1])){\nVar25  Var26; \nif (Var25[1]== ||(Var25[1]&&Var25[2]== )){\nchar *Var31=strchr(Var25+1,); \nif (Var31){\nVar29=*Var31; \n*Var31=0; \nVar19=Var31 != NULL ; \nFUNC9(Var1,FUNC10(Var1->memberVar6,Var25+2),1); \nif (Var31){\n*Var25=; \nVar25=Var31; \nelse \nVar25=strchr(Var25+1,; ); \nif (Var25&&*Var25&&Var25[1]== >){\nVar9=Var25+2; \nwhile (*Var9 == >){\nVar9  Var26; \nVar9=(char *) FUNC11(Var9); \nconst bool  Var32=Var25[2]== >; \nVar16=FUNC12(Var9,1,Var32); \nVar24=strdup(Var2); \nVar24=FUNC13(Var24,STRINGSTRINGSTRING,true ); \nif (Var25&&*Var25&&Var25[1]== |){\nVar9=Var25+2; \nwhile (FUNC8(*Var9)){\nVar9  Var26; \nFUNC14(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var24); \nfree(Var24); \nif (Var16 != -1){\nFUNC15(Var16); \nif (!Var25){\nif (Var18){\nif (Var19){\nif (*Var25 == ; ){\nVar2=Var25+1; \nelse \nif (*Var25 == ){\nVar2=Var25; \nelse \n*Var25=Var29; \nVar2=Var25; \nelse \nVar2=Var25+1; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC16(Var2,,STRING); //Var33  Var34  Var5  Var35\nif (*Var2 != ){\nVar7=(char *) FUNC17(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC17(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var36=Var7-1; \nif (*Var36 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC18(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC19(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC20(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var37=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC14(Var1,Var2,Var7+1); \nelse \nchar *Var38=FUNC21(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC17(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC22(Var1,Var39,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC23()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC16(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var36=Var7-1; \nif (*Var36 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var40=1; \nint  Var41=FUNC24(Var1->memberVar8,STRING); \nint  Var42=false ; \nint  Var43=FUNC24(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC25(Var7[-2])){\nchar *Var44=Var7-1; \nconst bool  Var45=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var46=FUNC26(Var1,Var2); \nchar *Var47=FUNC27(Var1->memberVar5,Var9,1); \nchar *Var48=FUNC28(STRING,Var47,Var46); \nelse \nchar *Var49=FUNC28(STRING,Var46); \nelse \nchar *Var49=FUNC28(STRING,Var46); \nelse \n}else if (Var40>0){\nif (Var16 != -1){\nVar15=FUNC29(Var1,Var2); \nconst char *Var50=FUNC30(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var36=Var7-1; \nif (*Var36 == ){\nbool  Var51=false ; \nif (Var51){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var43=FUNC24(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC31(strdup(Var2),Var9); \nVar15=FUNC29(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var52=false ; \nif (Var52){\nif (*Var2 != .){\nVar11=FUNC32(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var53=0; \nif (Var7){\nchar *Var54,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var55=Var1->memberVar9; \nbool  Var56=false ; \nchar *Var57=NULL ; \nconst char *Var58=NULL ; \nbool  Var59=false ; \nbool  Var60=false ; \nchar *Var61=NULL ; \nchar *Var62=NULL ; \nbool  Var63=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var64=strdup(Var7+2); \nchar *Var65=strchr(Var64,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var55=FUNC33(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var66=(int ) FUNC10(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var67=FUNC34(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var68=FUNC35(Var1->memberVar1,Var69,Var70,0); \nchar *Var71=strdup(Var7+2); \nchar  Var36=*Var72; \nSTRUCT3  Var55=FUNC10(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC36(Var1,Var7+2); \nSTRUCT2 *Var68=FUNC35(Var1->memberVar1,Var69,Var70,0); \nchar *Var73=FUNC37(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var31=strchr(Var7+2,); \nint  Var74=FUNC10(Var1->memberVar6,Var31); \nconst STRUCT6 *Var75=(const STRUCT6 *) FUNC11(Var7+2); \nSTRUCT2 *Var68=FUNC35(Var1->memberVar1,Var69,Var70,0); \nchar *Var76=Var7-2; \nwhile (Var76>Var2){\nif (!FUNC8(*Var76)){\nVar2=FUNC18(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC38((STRUCT6) Var7[1])&&!Var55){\nif (!FUNC39(Var1->memberVar12,Var7+1)){\nelse \nchar  Var36=*Var58; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var77=Var7+3; \nVar15=FUNC40(Var1,Var2,Var77); \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var78[]={STRING,STRING,STRING,\nconst char *Var79[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var80=Var7+3; \nchar *Var25=strchr(Var80,); \nif (!Var25){\nSTRUCT3  Var81=FUNC10(Var1->memberVar6,Var80); \nSTRUCT3  Var82=FUNC10(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC42(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC42(Var2)); \nVar53=Var2 FUNC3(Var1->memberVar5,FUNC42(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 519,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2593,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tchar op0 = 0;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\top0 = *q;\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\t\t\t*p = op0;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nbool  Var17=false ; \nbool  Var18=Var1->memberVar2; \nbool  Var19=Var1->memberVar3; \nSTRUCT3  Var20=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nfor (; *Var2; ){\nint  Var15=-1; \nchar *Var21,*Var22; \nVar17=*Var2 == ; \nif (Var17){\nVar2  Var23; \nVar22=*Var2 FUNC3(Var2) NULL ; \nif (!Var22||!*Var22){\nFUNC4(STRINGFUNC5(%Var24).,Var2); \n*Var22  Var23=0; \nelse \nchar *Var25=strchr(Var2,; ); \nif (Var25){\n*Var25=0; \nFUNC6(Var1,Var2); \nif (!Var25){\nVar2=Var25+1; \nchar  Var26=0; \nif (*Var22){\nif (Var22[0]== ){\nVar22  Var27; \nwhile (Var22[1]== ; ||FUNC7(Var22[1])){\nVar22  Var23; \nif (Var22[1]== ||(Var22[1]&&Var22[2]== )){\nchar *Var28=strchr(Var22+1,); \nif (Var28){\nVar26=*Var28; \n*Var28=0; \nVar17=Var28 != NULL ; \nFUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); \nif (Var28){\n*Var22=; \nVar22=Var28; \nelse \nVar22=strchr(Var22+1,; ); \nif (Var22&&*Var22&&Var22[1]== >){\nVar8=Var22+2; \nwhile (*Var8 == >){\nVar8  Var23; \nVar8=(char *) FUNC10(Var8); \nconst bool  Var29=Var22[2]== >; \nVar15=FUNC11(Var8,1,Var29); \nVar21=strdup(Var2); \nVar21=FUNC12(Var21,STRINGSTRINGSTRING,true ); \nif (Var22&&*Var22&&Var22[1]== |){\nVar8=Var22+2; \nwhile (FUNC7(*Var8)){\nVar8  Var23; \nFUNC13(Var1,Var2,Var8); \nelse \nFUNC14(Var1->memberVar6,Var21); \nfree(Var21); \nif (Var15 != -1){\nFUNC15(Var15); \nif (!Var22){\nif (Var16){\nif (Var17){\nif (*Var22 == ; ){\nVar2=Var22+1; \nelse \nif (*Var22 == ){\nVar2=Var22; \nelse \n*Var22=Var26; \nVar2=Var22; \nelse \nVar2=Var22+1; \nchar *Var7=strchr(Var2,); \nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC16(Var1->memberVar1,Var6+1); \nint  Var32=FUNC17(Var1->memberVar7,STRING); \nint  Var33=FUNC17(Var1->memberVar7,STRING); \nchar *Var34=FUNC18(Var1,Var2); \nchar *Var35=FUNC19(Var1->memberVar6,Var8,1); \nconst char *Var36=FUNC20(Var1->memberVar7,STRING); \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var33=FUNC17(Var1->memberVar7,STRING); \nconst char *Var24=strstr(Var2,STRING); \nchar *Var37,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var38=Var1->memberVar8; \nchar *Var39=NULL ; \nconst char *Var40=NULL ; \nchar *Var41=NULL ; \nchar *Var42=NULL ; \nchar *Var43=strdup(Var6+2); \nchar *Var44=strchr(Var43,=); \nSTRUCT3  Var38=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); \nint  Var45=(int ) FUNC9(Var1->memberVar5,Var6+2); \nSTRUCT4 *Var46=FUNC22(Var1->memberVar9,Var1->memberVar8); \nSTRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); \nchar *Var50=strdup(Var6+2); \nSTRUCT3  Var38=FUNC9(Var1->memberVar5,Var6+2); \nchar *Var2=FUNC24(Var1,Var6+2); \nSTRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); \nchar *Var51=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); \nchar *Var28=strchr(Var6+2,); \nint  Var52=FUNC9(Var1->memberVar5,Var28); \nconst STRUCT5 *Var53=(const STRUCT5 *) FUNC10(Var6+2); \nSTRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); \nSTRUCT2 *Var47=Var11; \nconst char *Var54[]={STRING,STRING,STRING,\nconst char *Var55[]={STRING,STRING,STRING,\nchar *Var22=strchr(Var56,); \nSTRUCT3  Var57=FUNC9(Var1->memberVar5,Var56); \nSTRUCT3  Var58=FUNC9(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 520,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2605,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tchar op0 = 0;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\top0 = *q;\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\t\t\t*p = op0;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nbool  Var17=false ; \nbool  Var18=Var1->memberVar2; \nbool  Var19=Var1->memberVar3; \nSTRUCT3  Var20=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nfor (; *Var2; ){\nint  Var15=-1; \nchar *Var21,*Var22; \nVar17=*Var2 == ; \nif (Var17){\nVar2  Var23; \nVar22=*Var2 FUNC3(Var2) NULL ; \nif (!Var22||!*Var22){\nFUNC4(STRINGFUNC5(%Var24).,Var2); \n*Var22  Var23=0; \nelse \nchar *Var25=strchr(Var2,; ); \nif (Var25){\n*Var25=0; \nFUNC6(Var1,Var2); \nif (!Var25){\nVar2=Var25+1; \nchar  Var26=0; \nif (*Var22){\nif (Var22[0]== ){\nVar22  Var27; \nwhile (Var22[1]== ; ||FUNC7(Var22[1])){\nVar22  Var23; \nif (Var22[1]== ||(Var22[1]&&Var22[2]== )){\nchar *Var28=strchr(Var22+1,); \nif (Var28){\nVar26=*Var28; \n*Var28=0; \nVar17=Var28 != NULL ; \nFUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); \nif (Var28){\n*Var22=; \nVar22=Var28; \nelse \nVar22=strchr(Var22+1,; ); \nif (Var22&&*Var22&&Var22[1]== >){\nVar8=Var22+2; \nwhile (*Var8 == >){\nVar8  Var23; \nVar8=(char *) FUNC10(Var8); \nconst bool  Var29=Var22[2]== >; \nVar15=FUNC11(Var8,1,Var29); \nVar21=strdup(Var2); \nVar21=FUNC12(Var21,STRINGSTRINGSTRING,true ); \nif (Var22&&*Var22&&Var22[1]== |){\nVar8=Var22+2; \nwhile (FUNC7(*Var8)){\nVar8  Var23; \nFUNC13(Var1,Var2,Var8); \nelse \nFUNC14(Var1->memberVar6,Var21); \nfree(Var21); \nif (Var15 != -1){\nFUNC15(Var15); \nif (!Var22){\nif (Var16){\nif (Var17){\nif (*Var22 == ; ){\nVar2=Var22+1; \nelse \nif (*Var22 == ){\nVar2=Var22; \nelse \n*Var22=Var26; \nVar2=Var22; \nelse \nVar2=Var22+1; \nchar *Var7=strchr(Var2,); \nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC16(Var1->memberVar1,Var6+1); \nint  Var32=FUNC17(Var1->memberVar7,STRING); \nint  Var33=FUNC17(Var1->memberVar7,STRING); \nchar *Var34=FUNC18(Var1,Var2); \nchar *Var35=FUNC19(Var1->memberVar6,Var8,1); \nconst char *Var36=FUNC20(Var1->memberVar7,STRING); \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var33=FUNC17(Var1->memberVar7,STRING); \nconst char *Var24=strstr(Var2,STRING); \nchar *Var37,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var38=Var1->memberVar8; \nchar *Var39=NULL ; \nconst char *Var40=NULL ; \nchar *Var41=NULL ; \nchar *Var42=NULL ; \nchar *Var43=strdup(Var6+2); \nchar *Var44=strchr(Var43,=); \nSTRUCT3  Var38=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); \nint  Var45=(int ) FUNC9(Var1->memberVar5,Var6+2); \nSTRUCT4 *Var46=FUNC22(Var1->memberVar9,Var1->memberVar8); \nSTRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); \nchar *Var50=strdup(Var6+2); \nSTRUCT3  Var38=FUNC9(Var1->memberVar5,Var6+2); \nchar *Var2=FUNC24(Var1,Var6+2); \nSTRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); \nchar *Var51=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); \nchar *Var28=strchr(Var6+2,); \nint  Var52=FUNC9(Var1->memberVar5,Var28); \nconst STRUCT5 *Var53=(const STRUCT5 *) FUNC10(Var6+2); \nSTRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); \nSTRUCT2 *Var47=Var11; \nconst char *Var54[]={STRING,STRING,STRING,\nconst char *Var55[]={STRING,STRING,STRING,\nchar *Var22=strchr(Var56,); \nSTRUCT3  Var57=FUNC9(Var1->memberVar5,Var56); \nSTRUCT3  Var58=FUNC9(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 521,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2619,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \n*Var25  Var26=0; \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nVar2=Var28+1; \nif (*Var25){\nif (Var25[0]== ){\nVar25  Var29; \nwhile (Var25[1]== ; ||FUNC8(Var25[1])){\nVar25  Var26; \nif (Var25[1]== ||(Var25[1]&&Var25[2]== )){\nchar *Var30=strchr(Var25+1,); \nif (Var30){\nVar25=Var30; \nelse \nVar25=strchr(Var25+1,; ); \nconst bool  Var31=Var25[2]== >; \nVar24=strdup(Var2); \nVar24=FUNC9(Var24,STRINGSTRINGSTRING,true ); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC10(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var24); \nfree(Var24); \nif (!Var25){\nif (Var18){\nif (Var19){\nif (*Var25 == ; ){\nVar2=Var25+1; \nelse \nif (*Var25 == ){\nVar2=Var25; \nVar2=Var25; \nelse \nVar2=Var25+1; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC11(Var2,,STRING); //Var32  Var33  Var5  Var34\nif (*Var2 != ){\nVar7=(char *) FUNC12(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC12(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC13(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC10(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC16(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC12(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC17(Var1,Var38,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC18()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC11(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var39=1; \nint  Var40=FUNC19(Var1->memberVar8,STRING); \nint  Var41=false ; \nint  Var42=FUNC19(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC20(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var45=FUNC21(Var1,Var2); \nchar *Var46=FUNC22(Var1->memberVar5,Var9,1); \nchar *Var47=FUNC23(STRING,Var46,Var45); \nelse \nchar *Var48=FUNC23(STRING,Var45); \nelse \nchar *Var48=FUNC23(STRING,Var45); \nelse \n}else if (Var39>0){\nif (Var16 != -1){\nVar15=FUNC24(Var1,Var2); \nconst char *Var49=FUNC25(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var42=FUNC19(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC26(strdup(Var2),Var9); \nVar15=FUNC24(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC27(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var63=strdup(Var7+2); \nchar *Var64=strchr(Var63,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC28(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var65=(int ) FUNC29(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var66=FUNC30(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); \nchar *Var70=strdup(Var7+2); \nchar  Var35=*Var71; \nSTRUCT3  Var54=FUNC29(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC32(Var1,Var7+2); \nSTRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); \nchar *Var72=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var30=strchr(Var7+2,); \nint  Var73=FUNC29(Var1->memberVar6,Var30); \nconst STRUCT6 *Var74=(const STRUCT6 *) FUNC34(Var7+2); \nSTRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); \nchar *Var75=Var7-2; \nwhile (Var75>Var2){\nif (!FUNC8(*Var75)){\nVar2=FUNC13(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC35((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC36(Var1->memberVar12,Var7+1)){\nelse \nchar  Var35=*Var57; \nSTRUCT2 *Var67=Var12; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nVar15=FUNC37(Var1,Var2,Var76); \nelse \nVar15=FUNC38(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC29(Var1->memberVar6,Var79); \nSTRUCT3  Var81=FUNC29(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 522,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2630,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nSTRUCT2 *Var8=NULL ; \nint  Var9=!Var1->memberVar1->memberVar1; \nbool  Var10=false ; \nbool  Var11=false ; \nbool  Var12=Var1->memberVar2; \nbool  Var13=Var1->memberVar3; \nSTRUCT3  Var14=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nfor (; *Var2; ){\nchar *Var15,*Var16; \nif (Var11){\nVar2  Var17; \nVar16=*Var2 FUNC3(Var2) NULL ; \nif (!Var16||!*Var16){\n*Var16  Var17=0; \nelse \nchar *Var18=strchr(Var2,; ); \nif (!Var18){\nVar2=Var18+1; \nif (*Var16){\nif (Var16[0]== ){\nVar16  Var19; \nwhile (Var16[1]== ; ||FUNC4(Var16[1])){\nVar16  Var17; \nif (Var16[1]== ||(Var16[1]&&Var16[2]== )){\nchar *Var20=strchr(Var16+1,); \nif (Var20){\nVar16=Var20; \nelse \nVar16=strchr(Var16+1,; ); \nconst bool  Var21=Var16[2]== >; \nVar15=strdup(Var2); \nVar15=FUNC5(Var15,STRINGSTRINGSTRING,true ); \nif (Var16&&*Var16&&Var16[1]== |){\nelse \nFUNC6(Var1->memberVar5,Var15); \nfree(Var15); \nif (!Var16){\nif (Var10){\nif (Var11){\nif (*Var16 == ; ){\nVar2=Var16+1; \nelse \nif (*Var16 == ){\nVar2=Var16; \nVar2=Var16; \nelse \nVar2=Var16+1; \nchar *Var22=strchr(Var2,); \nint  Var23=Var1->memberVar6->memberVar1; \nelse \nchar *Var24=FUNC7(Var1->memberVar1,Var25+1); \nint  Var26=FUNC8(Var1->memberVar7,STRING); \nint  Var27=FUNC8(Var1->memberVar7,STRING); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar5,Var30,1); \nconst char *Var31=FUNC11(Var1->memberVar7,STRING); \nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var27=FUNC8(Var1->memberVar7,STRING); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var22=strchr(Var25+1,!); \nSTRUCT3  Var34=Var1->memberVar8; \nchar *Var35=NULL ; \nconst char *Var36=NULL ; \nchar *Var37=NULL ; \nchar *Var38=NULL ; \nchar *Var39=strdup(Var25+2); \nchar *Var40=strchr(Var39,=); \nSTRUCT3  Var34=FUNC12(Var1->memberVar6,Var1->memberVar8,Var25+4); \nint  Var41=(int ) FUNC13(Var1->memberVar6,Var25+2); \nSTRUCT4 *Var42=FUNC14(Var1->memberVar9,Var1->memberVar8); \nSTRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); \nchar *Var46=strdup(Var25+2); \nSTRUCT3  Var34=FUNC13(Var1->memberVar6,Var25+2); \nchar *Var2=FUNC16(Var1,Var25+2); \nSTRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); \nchar *Var47=FUNC17(Var1->memberVar10,NULL ,0,Var25+((Var25[1]) 21)); \nchar *Var20=strchr(Var25+2,); \nint  Var48=FUNC13(Var1->memberVar6,Var20); \nSTRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); \nSTRUCT2 *Var43=Var8; \nconst char *Var49[]={STRING,STRING,STRING,\nconst char *Var50[]={STRING,STRING,STRING,\nchar *Var16=strchr(Var51,); \nSTRUCT3  Var52=FUNC13(Var1->memberVar6,Var51); \nSTRUCT3  Var53=FUNC13(Var1->memberVar6,Var16+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 523,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2662,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 524,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2713,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 525,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2713,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 526,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2717,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 527,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2722,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 528,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2729,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 529,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2733,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nmemmove(Var15,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC5(Var1,Var2,Var7+1); \nelse \nchar *Var17=FUNC6(Var1->memberVar1,Var7+1); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 530,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2745,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\t\tif (res) {\n",
      "\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\t\t\t\tfree (res);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nbool  Var11=Var1->memberVar2; \nbool  Var12=Var1->memberVar3; \nSTRUCT2  Var13=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var14=strchr(Var2,; ); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nVar7=(char *) FUNC3(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var15=Var7-1; \nif (*Var15 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var16=Var1->memberVar5->memberVar1; \nif (*Var2){\nelse \nchar *Var17=FUNC5(Var1->memberVar1,Var7+1); \nif (Var17){\nFUNC6(STRING,Var17); \nfree(Var17); \nchar *Var15=Var7-1; \nint  Var18=FUNC7(Var1->memberVar6,STRING); \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nchar *Var20=Var7-1; \nconst bool  Var21=(Var7[1]== >); \nchar *Var22=FUNC8(Var1,Var2); \nchar *Var23=FUNC9(Var1->memberVar7,Var9,1); \nconst char *Var24=FUNC10(Var1->memberVar6,STRING); \nchar *Var15=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var19=FUNC7(Var1->memberVar6,STRING); \nconst char *Var25=strstr(Var2,STRING); \nchar *Var26,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var27=Var1->memberVar8; \nchar *Var28=strdup(Var7+2); \nSTRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); \nint  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var34=strdup(Var7+2); \nchar  Var15=*Var35; \nSTRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC15(Var1,Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var37=strchr(Var7+2,); \nint  Var38=FUNC12(Var1->memberVar5,Var37); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); \nSTRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); \nchar *Var40=Var7-2; \nelse \nchar  Var15=*Var41; \nchar *Var42=Var7+3; \nchar *Var43=Var7+3; \nSTRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); \nSTRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 531,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2783,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\t\treturn ret;\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\t\t\t*fdnum = 0;\n",
      "else\n",
      "\t\t\t\tif (IS_DIGIT (*fdnum)) {\n",
      "\t\t\t\t\tfdn = *fdnum - '0';\n",
      "\t\t\t\t*fdnum = 0;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tfree (str);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tr_cons_grep_process (grep);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nint  Var28=-1; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var29,*Var30; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var31; \nVar30=*Var2 FUNC5(Var2) NULL ; \nif (!Var30||!*Var30){\nFUNC6(STRINGFUNC7(%Var32).,Var2); \nelse \nchar *Var33=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var33){\nchar *Var34=strchr(Var30+1,); \nconst bool  Var35=Var30[2]== >; \nVar29=strdup(Var2); \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var30){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38\nif (Var9&&(Var9[1]== ||Var9[1]==  Var39)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var41=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var42=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nreturn  Var17; \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var43=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var43,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var31){\nFUNC6(STRING,Var11); \nchar  Var44[1024]; \nint  Var17; \nif (FUNC20(stdin)){\nif (Var1->memberVar7){\nif (!strcmp(Var44,Var11)){\nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var31){\nif (!*Var11){\nFUNC6(STRING,Var11); \nVar1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); \nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nreturn FUNC22(Var1,(const char *) Var1->memberVar7); \nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var45=1; \nint  Var46=FUNC23(Var1->memberVar9,STRING); \nint  Var47=false ; \nint  Var48=FUNC23(Var1->memberVar9,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC24(Var9[-2])){\nchar *Var49=Var9-1; \nif (*Var49 ==  Var50){//STRING\nVar20=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,true ); \n*Var49=0; \nelse \nif (FUNC26(*Var49)){\nVar45=*Var49-0; \n*Var49=0; \nif (!strcmp(Var11,STRING)){\nFUNC25(Var1->memberVar9,STRING,Var51); \nconst bool  Var52=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var53=FUNC27(Var1,Var2); \nif (Var52){\nchar *Var54=FUNC28(Var1->memberVar5,Var11,1); \nif (Var54){\nchar *Var55=FUNC29(STRING,Var54,Var53); \nif (Var55){\nFUNC30(Var1->memberVar5,Var11,Var55,1); \nfree(Var55); \nelse \nchar *Var56=FUNC29(STRING,Var53); \nFUNC30(Var1->memberVar5,Var11,Var56,1); \nfree(Var56); \nelse \nchar *Var56=FUNC29(STRING,Var53); \nFUNC30(Var1->memberVar5,Var11,Var56,1); \nfree(Var56); \nelse \n}else if (Var45>0){\nVar18=FUNC31(Var11,Var45,Var52); \nif (Var18 != -1){\nif (!Var46){\nFUNC25(Var1->memberVar9,STRING,Var51); \nVar17=FUNC12(Var1,Var2); \nFUNC32(Var18); \nif (!Var46){\nFUNC25(Var1->memberVar9,STRING,Var48); \nif (Var47){\nconst char *Var57=FUNC33(Var1->memberVar9,STRING); \nif (Var57&&*Var57){\nFUNC34(STRING,Var57,Var11); \nFUNC35(Var11); \nFUNC25(Var1->memberVar9,STRING,Var48); \nfree(Var11); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nVar1->memberVar10->memberVar1=false ; \nreturn  Var17; \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nbool  Var58=false ; \nint  Var59=1; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var58){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \n*Var10=0; \nif (Var9[1]== !){\nVar11=FUNC36(Var1,Var9+1); \nelse \nint  Var48=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,0); \nVar11=FUNC27(Var1,Var9+1); \nFUNC25(Var1->memberVar9,STRING,Var48); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nfree(Var11); \nif (Var59&&Var11){\nfor (Var16=0; Var11[Var16]; Var16  Var31){\nif (Var11[Var16]==  Var56){\nVar11[Var16]=; \nVar11=FUNC37(Var11,Var10+1); \nVar2=FUNC37(strdup(Var2),Var11); \nVar1->memberVar6->memberVar1=memberVar1; \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nfree(Var11); \nreturn  Var17; \nif (*Var2 != &&*Var2){\nconst char *Var32=strstr(Var2,STRING); \nif (Var32){\nbool  Var60=false ; \nif (Var2 ==  Var32){\nif (Var60){\nif (*Var2 != .){\nVar13=FUNC38(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar11=Var9 true false ; \nint  Var61=0; \nif (Var9){\nchar *Var62,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var63=Var1->memberVar12; \nbool  Var64=false ; \nchar *Var65=NULL ; \nconst char *Var66=NULL ; \nbool  Var67=false ; \nbool  Var68=false ; \nchar *Var69=NULL ; \nchar *Var70=NULL ; \nbool  Var71=false ; \nint  Var72=-1; \nint  Var73,Var74; \nSTRUCT6 *Var44; \n*Var9  Var31=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var31){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var75; \nVar9=FUNC39(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var76=strdup(Var9+2); \nchar *Var77=strchr(Var76,=); \nif (Var77){\n*Var77  Var31=0; \nFUNC40(Var76,Var77); \nFUNC41(Var5,Var76); \nelse \nfree(Var76); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+4); \nFUNC43(Var1,FUNC44((Var78) Var63-(Var78) Var1->memberVar12)); \nelse \nVar63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+3); \nFUNC45(Var1,Var63,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar71=FUNC46(Var1->memberVar13,Var9+2); \nint  Var79=(int ) FUNC47(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var80=FUNC48(Var1->memberVar14,Var1->memberVar12); \nif (Var80){\nif (Var79<0){\nVar79=Var80->memberVar1+Var79; \nif (Var79 >= 0&&Var79<Var80->memberVar1){\nSTRUCT8  Var81=FUNC49(Var80,Var79); \nFUNC45(Var1,Var80->memberVar2+Var81,1); \nelse \nFUNC6(STRING,Var80->memberVar1); \nVar62=FUNC21(Var9+2,&Var73); \nif (Var62){\nSTRUCT9 *Var82=FUNC50((const STRUCT6 *) Var62,Var73); \nSTRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); \nif (Var83){\nif (Var14){\nFUNC52(Var14); \nVar14=Var83; \nif (Var15){\nFUNC25(Var1->memberVar9,STRING,1); \nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); \nif (Var44){\nfree(Var1->memberVar15); \nmemcpy(Var1->memberVar15,Var62,Var73); \nfree(Var62); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var85; \nchar *Var86=strdup(Var9+2); \nchar *Var87=FUNC55(Var86); \nif (Var87){\nchar  Var40=*Var87; \n*Var87=0; \nVar85=FUNC56(Var1->memberVar16,Var86); \n*Var87=Var40; \nVar85=FUNC47(Var1->memberVar6,Var88); \nelse \nVar85=FUNC56(Var1->memberVar16,Var9+2); \nFUNC45(Var1,Var85,1); \nfree(Var86); \nVar67=FUNC57(Var1,FUNC47(Var1->memberVar6,Var9+2),&Var65); \nVar28=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,1); \nSTRUCT4  memberVar2=FUNC47(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC58(Var1,Var9+2); \nif (!Var69){\nVar69=Var2; \nelse \nVar69=FUNC59(Var69,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar44=malloc(strlen(Var9+2)+1); \nif (Var44){\nVar74=FUNC60(Var9+2,Var44); \nFUNC43(Var1,FUNC44(Var74)); \nif (Var74>0){\nSTRUCT9 *Var82=FUNC50(Var44,Var74); \nSTRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); \nif (Var83){\nif (Var14){\nFUNC52(Var14); \nVar14=Var83; \nif (Var15){\nFUNC25(Var1->memberVar9,STRING,1); \nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); \nFUNC43(Var1,Var74); \nfree(Var44); \nchar *Var89=FUNC61(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var89){\nFUNC45(Var1,FUNC47(Var1->memberVar6,Var89),1); \nfree(Var89); \nif (Var9[1]== ){\nVar72=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC62(Var1->memberVar1,FUNC63(Var9+2)); \nif (Var9[1]== ){\nchar *Var34=strchr(Var9+2,); \nif (Var34){\n*Var34  Var31=0; \nint  Var90=FUNC47(Var1->memberVar6,Var34); \nVar67=FUNC57(Var1,Var90,&Var65); \nVar68=FUNC64(Var1,Var9+2,&Var70); \nVar74=strlen(Var9+2); \nFUNC43(Var1,Var74); \nconst STRUCT6 *Var44=(const STRUCT6 *) FUNC65(Var9+2); \nif (Var74>0){\nSTRUCT9 *Var82=FUNC50(Var44,Var74); \nSTRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC25(Var1->memberVar9,STRING,1); \nif (Var83){\nif (Var14){\nFUNC52(Var14); \nVar14=Var83; \nif (Var15){\nFUNC25(Var1->memberVar9,STRING,1); \nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); \nFUNC43(Var1,Var74); \n*Var9=; \nchar *Var91=Var9-2; \nwhile (Var91>Var2){\nif (!FUNC66(*Var91)){\n*Var91=0; \nVar91  Var75; \nVar9=FUNC67(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nelse \n*Var10=0; \nif (!Var10[1]){\nFUNC43(\nVar1,FUNC47(Var1->memberVar6,Var10+1)); \nVar66=FUNC67(Var9+1); \nmemberVar2=FUNC47(Var1->memberVar6,Var66); \nif (FUNC68((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC69(Var1->memberVar13,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var40=*Var66; \nif (Var40 == -||Var40 == +){\nmemberVar2=Var1->memberVar12+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var83=Var14; \nif (Var83){\nFUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,memberVar2,FUNC70(Var83)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar18=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var92=Var9+3; \nwhile (*Var92&&*Var92 == ){\nVar92  Var31; \nVar17=FUNC71(Var1,Var2,Var92); \nelse \nVar17=FUNC72(Var1,Var2,Var9+2); \nelse \nbool  memberVar11=false ; \nconst char *Var93[]={STRING,STRING,STRING,\nconst char *Var94[]={STRING,STRING,STRING,\nSTRUCT4  Var95[FUNC73(Var93)-1],Var96[FUNC73(Var94)-1]; \nif (Var9[1]== (){\nchar *Var97=Var9+3; \nchar *Var30=strchr(Var97,); \nif (!Var30){\nfree(Var69); \n*Var30=Var98; \nSTRUCT4  Var99=FUNC47(Var1->memberVar6,Var97); \nSTRUCT4  Var100=FUNC47(Var1->memberVar6,Var30+1); \nfor (Var16=0; Var93[Var16]; Var16  Var31){\nVar95[Var16]=FUNC23(Var1->memberVar9,Var93[Var16]); \nfor (Var16=0; Var94[Var16]; Var16  Var31){\nVar96[Var16]=FUNC23(Var1->memberVar9,Var94[Var16]); \nfor (Var16=0; Var93[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var93[Var16],Var99); \nfor (Var16=0; Var94[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var94[Var16],Var100); \nif (Var19){\nif (Var64){\nVar1->memberVar12=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC67(Var2)); \nelse \nif (Var64){\nif (Var9[1]){\nFUNC45(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC67(Var2)); \nif (memberVar11){\nfor (Var16=0; Var93[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var93[Var16],Var95[Var16]); \nfor (Var16=0; Var94[Var16]; Var16  Var31){\nFUNC25(Var1->memberVar9,Var94[Var16],Var96[Var16]); \nif (Var10){\n*Var10=!; \nif (Var72 != -1){\nFUNC62(Var1->memberVar1,Var72); \nif (Var14){\nif (Var15){\nFUNC25(Var1->memberVar9,STRING,0); \nFUNC52(Var14); \nif (Var67){\nFUNC74(Var1->memberVar9,STRING,Var65); \nif (Var69){\nFUNC8(Var1,Var69); \nFUNC75(Var69); \nif (Var71){\nFUNC76(Var1->memberVar13); \n*Var9=; \nVar61=Var17; \nVar61=Var2 FUNC4(Var1->memberVar5,FUNC67(Var2)) false ; \nFUNC77(Var13); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nif (Var14){\nFUNC52(Var14); \nif (memberVar11){\n*memberVar11=Var26; \nif (Var28 != -1){\nFUNC25(Var1->memberVar9,STRING,Var28); \nreturn  Var61; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 532,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2789,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var28,*Var29; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var30; \nVar29=*Var2 FUNC5(Var2) NULL ; \nif (!Var29||!*Var29){\nFUNC6(STRINGFUNC7(%Var31).,Var2); \nelse \nchar *Var32=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var32){\nchar *Var33=strchr(Var29+1,); \nconst bool  Var34=Var29[2]== >; \nVar28=strdup(Var2); \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var29){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37\nif (Var9&&(Var9[1]== ||Var9[1]==  Var38)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var40=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var41=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var42=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var42,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var30){\nchar  Var43[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var30){\nif (!*Var11){\nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var44=1; \nint  Var45=FUNC20(Var1->memberVar8,STRING); \nint  Var46=false ; \nint  Var47=FUNC20(Var1->memberVar8,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC21(Var9[-2])){\nchar *Var48=Var9-1; \nconst bool  Var49=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var50=FUNC22(Var1,Var2); \nchar *Var51=FUNC23(Var1->memberVar5,Var11,1); \nchar *Var52=FUNC24(STRING,Var51,Var50); \nelse \nchar *Var53=FUNC24(STRING,Var50); \nelse \nchar *Var53=FUNC24(STRING,Var50); \nelse \n}else if (Var44>0){\nif (Var18 != -1){\nVar17=FUNC12(Var1,Var2); \nconst char *Var54=FUNC25(Var1->memberVar8,STRING); \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nbool  Var55=false ; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var55){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \nif (Var9[1]== !){\nVar11=FUNC26(Var1,Var9+1); \nelse \nint  Var47=FUNC20(Var1->memberVar8,STRING); \nVar11=FUNC22(Var1,Var9+1); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nVar2=FUNC27(strdup(Var2),Var11); \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var31=strstr(Var2,STRING); \nif (Var31){\nbool  Var56=false ; \nif (Var56){\nif (*Var2 != .){\nVar13=FUNC28(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar9=Var9 true false ; \nint  Var57=0; \nif (Var9){\nchar *Var58,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var59=Var1->memberVar10; \nbool  Var60=false ; \nchar *Var61=NULL ; \nconst char *Var62=NULL ; \nbool  Var63=false ; \nbool  Var64=false ; \nchar *Var65=NULL ; \nchar *Var66=NULL ; \nbool  Var67=false ; \nint  Var68=-1; \nint  Var69,Var70; \nSTRUCT6 *Var43; \n*Var9  Var30=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var30){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var71; \nVar9=FUNC29(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var72=strdup(Var9+2); \nchar *Var73=strchr(Var72,=); \nif (Var73){\n*Var73  Var30=0; \nFUNC30(Var72,Var73); \nFUNC31(Var5,Var72); \nelse \nfree(Var72); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); \nFUNC33(Var1,FUNC34((Var74) Var59-(Var74) Var1->memberVar10)); \nelse \nVar59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); \nFUNC35(Var1,Var59,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar67=FUNC36(Var1->memberVar11,Var9+2); \nint  Var75=(int ) FUNC37(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var76=FUNC38(Var1->memberVar12,Var1->memberVar10); \nif (Var76){\nif (Var75<0){\nVar75=Var76->memberVar1+Var75; \nif (Var75 >= 0&&Var75<Var76->memberVar1){\nSTRUCT8  Var77=FUNC39(Var76,Var75); \nFUNC35(Var1,Var76->memberVar2+Var77,1); \nVar58=FUNC40(Var9+2,&Var69); \nif (Var58){\nSTRUCT9 *Var78=FUNC41((const STRUCT6 *) Var58,Var69); \nSTRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var14){\nFUNC43(Var14); \nVar14=Var79; \nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); \nif (Var43){\nmemcpy(Var1->memberVar13,Var58,Var69); \nfree(Var58); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var81; \nchar *Var82=strdup(Var9+2); \nchar *Var83=FUNC46(Var82); \nif (Var83){\nchar  Var39=*Var83; \n*Var83=0; \nVar81=FUNC47(Var1->memberVar14,Var82); \n*Var83=Var39; \nelse \nVar81=FUNC47(Var1->memberVar14,Var9+2); \nFUNC35(Var1,Var81,1); \nfree(Var82); \nVar63=FUNC48(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var61); \nSTRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC49(Var1,Var9+2); \nif (!Var65){\nVar65=Var2; \nelse \nVar65=FUNC50(Var65,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar43=malloc(strlen(Var9+2)+1); \nif (Var43){\nVar70=FUNC51(Var9+2,Var43); \nFUNC33(Var1,FUNC34(Var70)); \nif (Var70>0){\nSTRUCT9 *Var78=FUNC41(Var43,Var70); \nSTRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var14){\nFUNC43(Var14); \nVar14=Var79; \nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); \nFUNC33(Var1,Var70); \nfree(Var43); \nchar *Var84=FUNC52(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var84){\nFUNC35(Var1,FUNC37(Var1->memberVar6,Var84),1); \nfree(Var84); \nif (Var9[1]== ){\nFUNC53(Var1->memberVar1,FUNC54(Var9+2)); \nif (Var9[1]== ){\nchar *Var33=strchr(Var9+2,); \nif (Var33){\n*Var33  Var30=0; \nint  Var85=FUNC37(Var1->memberVar6,Var33); \nVar63=FUNC48(Var1,Var85,&Var61); \nVar64=FUNC55(Var1,Var9+2,&Var66); \nVar70=strlen(Var9+2); \nFUNC33(Var1,Var70); \nconst STRUCT6 *Var43=(const STRUCT6 *) FUNC56(Var9+2); \nif (Var70>0){\nSTRUCT9 *Var78=FUNC41(Var43,Var70); \nSTRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var14){\nFUNC43(Var14); \nVar14=Var79; \nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); \nFUNC33(Var1,Var70); \n*Var9=; \nchar *Var86=Var9-2; \nwhile (Var86>Var2){\nif (!FUNC57(*Var86)){\n*Var86=0; \nVar86  Var71; \nVar9=FUNC58(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar62=FUNC58(Var9+1); \nmemberVar2=FUNC37(Var1->memberVar6,Var62); \nif (FUNC59((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC60(Var1->memberVar11,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var39=*Var62; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar10+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var79=Var14; \nif (Var79){\nFUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC61(Var79)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar16=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var87=Var9+3; \nwhile (*Var87&&*Var87 == ){\nVar87  Var30; \nVar17=FUNC62(Var1,Var2,Var87); \nelse \nVar17=FUNC63(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var88[]={STRING,STRING,STRING,\nconst char *Var89[]={STRING,STRING,STRING,\nSTRUCT4  Var90[FUNC64(Var88)-1],Var91[FUNC64(Var89)-1]; \nif (Var9[1]== (){\nchar *Var92=Var9+3; \nchar *Var29=strchr(Var92,); \nif (!Var29){\nfree(Var65); \n*Var29=Var93; \nSTRUCT4  Var94=FUNC37(Var1->memberVar6,Var92); \nSTRUCT4  Var95=FUNC37(Var1->memberVar6,Var29+1); \nfor (Var16=0; Var88[Var16]; Var16  Var30){\nVar90[Var16]=FUNC20(Var1->memberVar8,Var88[Var16]); \nfor (Var16=0; Var89[Var16]; Var16  Var30){\nVar91[Var16]=FUNC20(Var1->memberVar8,Var89[Var16]); \nfor (Var16=0; Var88[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var88[Var16],Var94); \nfor (Var16=0; Var89[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var89[Var16],Var95); \nif (Var19){\nif (Var60){\nVar1->memberVar10=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC58(Var2)); \nelse \nif (Var60){\nif (Var9[1]){\nFUNC35(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC58(Var2)); \nif (memberVar9){\nfor (Var16=0; Var88[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var88[Var16],Var90[Var16]); \nfor (Var16=0; Var89[Var16]; Var16  Var30){\nFUNC65(Var1->memberVar8,Var89[Var16],Var91[Var16]); \nif (Var68 != -1){\nFUNC53(Var1->memberVar1,Var68); \nif (Var14){\nif (Var15){\nFUNC65(Var1->memberVar8,STRING,0); \nFUNC43(Var14); \nif (Var63){\nFUNC66(Var1->memberVar8,STRING,Var61); \nif (Var65){\nFUNC8(Var1,Var65); \nFUNC67(Var65); \nif (Var67){\nFUNC68(Var1->memberVar11); \n*Var9=; \nVar57=Var17; \nVar57=Var2 FUNC4(Var1->memberVar5,FUNC58(Var2)) false ; \nif (Var20 != -1){\nFUNC65(Var1->memberVar8,STRING,Var20); \nif (Var21 != -1){\nFUNC65(Var1->memberVar8,STRING,Var21); \nif (Var14){\nFUNC43(Var14); \nreturn  Var57; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 533,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2816,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var28,*Var29; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var30; \nVar29=*Var2 FUNC5(Var2) NULL ; \nif (!Var29||!*Var29){\nFUNC6(STRINGFUNC7(%Var31).,Var2); \nelse \nchar *Var32=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var32){\nchar *Var33=strchr(Var29+1,); \nconst bool  Var34=Var29[2]== >; \nVar28=strdup(Var2); \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var29){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37\nif (Var9&&(Var9[1]== ||Var9[1]==  Var38)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var40=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var41=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var42=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var42,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var30){\nFUNC6(STRING,Var11); \nchar  Var43[1024]; \nint  Var17; \nif (FUNC20(stdin)){\nif (Var1->memberVar7){\nif (!strcmp(Var43,Var11)){\nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var30){\nif (!*Var11){\nFUNC6(STRING,Var11); \nVar1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); \nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nreturn FUNC22(Var1,(const char *) Var1->memberVar7); \nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var44=1; \nint  Var45=FUNC23(Var1->memberVar9,STRING); \nint  Var46=false ; \nint  Var47=FUNC23(Var1->memberVar9,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC24(Var9[-2])){\nchar *Var48=Var9-1; \nif (*Var48 ==  Var49){//STRING\nVar20=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,true ); \nif (!strcmp(Var11,STRING)){\nFUNC25(Var1->memberVar9,STRING,Var50); \nconst bool  Var51=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var52=FUNC26(Var1,Var2); \nif (Var51){\nchar *Var53=FUNC27(Var1->memberVar5,Var11,1); \nif (Var53){\nchar *Var54=FUNC28(STRING,Var53,Var52); \nif (Var54){\nFUNC29(Var1->memberVar5,Var11,Var54,1); \nfree(Var54); \nelse \nchar *Var55=FUNC28(STRING,Var52); \nFUNC29(Var1->memberVar5,Var11,Var55,1); \nelse \nchar *Var55=FUNC28(STRING,Var52); \nFUNC29(Var1->memberVar5,Var11,Var55,1); \nelse \n}else if (Var44>0){\nif (Var18 != -1){\nif (!Var45){\nFUNC25(Var1->memberVar9,STRING,Var50); \nVar17=FUNC12(Var1,Var2); \nif (!Var45){\nFUNC25(Var1->memberVar9,STRING,Var47); \nif (Var46){\nconst char *Var56=FUNC30(Var1->memberVar9,STRING); \nif (Var56&&*Var56){\nFUNC31(STRING,Var56,Var11); \nFUNC25(Var1->memberVar9,STRING,Var47); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nVar1->memberVar10->memberVar1=false ; \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var39=Var9-1; \nif (*Var39 == ){\nmemmove(Var39,Var9,strlen(Var9)+1); \nbool  Var57=false ; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var57){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \nif (Var9[1]== !){\nVar11=FUNC32(Var1,Var9+1); \nelse \nint  Var47=FUNC23(Var1->memberVar9,STRING); \nFUNC25(Var1->memberVar9,STRING,0); \nVar11=FUNC26(Var1,Var9+1); \nFUNC25(Var1->memberVar9,STRING,Var47); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nVar2=FUNC33(strdup(Var2),Var11); \nVar1->memberVar6->memberVar1=memberVar1; \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (*Var2 != &&*Var2){\nconst char *Var31=strstr(Var2,STRING); \nif (Var31){\nbool  Var58=false ; \nif (Var58){\nif (*Var2 != .){\nVar13=FUNC34(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar11=Var9 true false ; \nint  Var59=0; \nif (Var9){\nchar *Var60,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var61=Var1->memberVar12; \nbool  Var62=false ; \nchar *Var63=NULL ; \nconst char *Var64=NULL ; \nbool  Var65=false ; \nbool  Var66=false ; \nchar *Var67=NULL ; \nchar *Var68=NULL ; \nbool  Var69=false ; \nint  Var70=-1; \nint  Var71,Var72; \nSTRUCT6 *Var43; \n*Var9  Var30=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var30){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var73; \nVar9=FUNC35(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var74=strdup(Var9+2); \nchar *Var75=strchr(Var74,=); \nif (Var75){\n*Var75  Var30=0; \nFUNC36(Var74,Var75); \nFUNC37(Var5,Var74); \nelse \nfree(Var74); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+4); \nFUNC39(Var1,FUNC40((Var76) Var61-(Var76) Var1->memberVar12)); \nelse \nVar61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+3); \nFUNC41(Var1,Var61,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar69=FUNC42(Var1->memberVar13,Var9+2); \nint  Var77=(int ) FUNC43(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var78=FUNC44(Var1->memberVar14,Var1->memberVar12); \nif (Var78){\nif (Var77<0){\nVar77=Var78->memberVar1+Var77; \nif (Var77 >= 0&&Var77<Var78->memberVar1){\nSTRUCT8  Var79=FUNC45(Var78,Var77); \nFUNC41(Var1,Var78->memberVar2+Var79,1); \nVar60=FUNC21(Var9+2,&Var71); \nif (Var60){\nSTRUCT9 *Var80=FUNC46((const STRUCT6 *) Var60,Var71); \nSTRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); \nif (Var81){\nif (Var14){\nFUNC48(Var14); \nVar14=Var81; \nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); \nif (Var43){\nmemcpy(Var1->memberVar15,Var60,Var71); \nfree(Var60); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var83; \nchar *Var84=strdup(Var9+2); \nchar *Var85=FUNC51(Var84); \nif (Var85){\nchar  Var39=*Var85; \n*Var85=0; \nVar83=FUNC52(Var1->memberVar16,Var84); \n*Var85=Var39; \nelse \nVar83=FUNC52(Var1->memberVar16,Var9+2); \nFUNC41(Var1,Var83,1); \nfree(Var84); \nVar65=FUNC53(Var1,FUNC43(Var1->memberVar6,Var9+2),&Var63); \nSTRUCT4  memberVar2=FUNC43(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC54(Var1,Var9+2); \nif (!Var67){\nVar67=Var2; \nelse \nVar67=FUNC55(Var67,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar43=malloc(strlen(Var9+2)+1); \nif (Var43){\nVar72=FUNC56(Var9+2,Var43); \nFUNC39(Var1,FUNC40(Var72)); \nif (Var72>0){\nSTRUCT9 *Var80=FUNC46(Var43,Var72); \nSTRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); \nif (Var81){\nif (Var14){\nFUNC48(Var14); \nVar14=Var81; \nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); \nFUNC39(Var1,Var72); \nfree(Var43); \nchar *Var86=FUNC57(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var86){\nFUNC41(Var1,FUNC43(Var1->memberVar6,Var86),1); \nfree(Var86); \nif (Var9[1]== ){\nFUNC58(Var1->memberVar1,FUNC59(Var9+2)); \nif (Var9[1]== ){\nchar *Var33=strchr(Var9+2,); \nif (Var33){\n*Var33  Var30=0; \nint  Var87=FUNC43(Var1->memberVar6,Var33); \nVar65=FUNC53(Var1,Var87,&Var63); \nVar66=FUNC60(Var1,Var9+2,&Var68); \nVar72=strlen(Var9+2); \nFUNC39(Var1,Var72); \nconst STRUCT6 *Var43=(const STRUCT6 *) FUNC61(Var9+2); \nif (Var72>0){\nSTRUCT9 *Var80=FUNC46(Var43,Var72); \nSTRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); \nif (Var81){\nif (Var14){\nFUNC48(Var14); \nVar14=Var81; \nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); \nFUNC39(Var1,Var72); \n*Var9=; \nchar *Var88=Var9-2; \nwhile (Var88>Var2){\nif (!FUNC62(*Var88)){\n*Var88=0; \nVar88  Var73; \nVar9=FUNC63(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar64=FUNC63(Var9+1); \nmemberVar2=FUNC43(Var1->memberVar6,Var64); \nif (FUNC64((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC65(Var1->memberVar13,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var39=*Var64; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar12+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var81=Var14; \nif (Var81){\nFUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,memberVar2,FUNC66(Var81)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar18=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var89=Var9+3; \nwhile (*Var89&&*Var89 == ){\nVar89  Var30; \nVar17=FUNC67(Var1,Var2,Var89); \nelse \nVar17=FUNC68(Var1,Var2,Var9+2); \nelse \nbool  memberVar11=false ; \nconst char *Var90[]={STRING,STRING,STRING,\nconst char *Var91[]={STRING,STRING,STRING,\nSTRUCT4  Var92[FUNC69(Var90)-1],Var93[FUNC69(Var91)-1]; \nif (Var9[1]== (){\nchar *Var94=Var9+3; \nchar *Var29=strchr(Var94,); \nif (!Var29){\nfree(Var67); \n*Var29=Var95; \nSTRUCT4  Var96=FUNC43(Var1->memberVar6,Var94); \nSTRUCT4  Var97=FUNC43(Var1->memberVar6,Var29+1); \nfor (Var16=0; Var90[Var16]; Var16  Var30){\nVar92[Var16]=FUNC23(Var1->memberVar9,Var90[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var30){\nVar93[Var16]=FUNC23(Var1->memberVar9,Var91[Var16]); \nfor (Var16=0; Var90[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var90[Var16],Var96); \nfor (Var16=0; Var91[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var91[Var16],Var97); \nif (Var19){\nif (Var62){\nVar1->memberVar12=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC63(Var2)); \nelse \nif (Var62){\nif (Var9[1]){\nFUNC41(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC63(Var2)); \nif (memberVar11){\nfor (Var16=0; Var90[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var90[Var16],Var92[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var30){\nFUNC25(Var1->memberVar9,Var91[Var16],Var93[Var16]); \nif (Var70 != -1){\nFUNC58(Var1->memberVar1,Var70); \nif (Var14){\nif (Var15){\nFUNC25(Var1->memberVar9,STRING,0); \nFUNC48(Var14); \nif (Var65){\nFUNC70(Var1->memberVar9,STRING,Var63); \nif (Var67){\nFUNC8(Var1,Var67); \nFUNC71(Var67); \nif (Var69){\nFUNC72(Var1->memberVar13); \n*Var9=; \nVar59=Var17; \nVar59=Var2 FUNC4(Var1->memberVar5,FUNC63(Var2)) false ; \nif (Var20 != -1){\nFUNC25(Var1->memberVar9,STRING,Var20); \nif (Var21 != -1){\nFUNC25(Var1->memberVar9,STRING,Var21); \nif (Var14){\nFUNC48(Var14); \nreturn  Var59; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 534,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2828,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC26(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC30(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC32(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC37(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC38(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC38(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC40(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC28(Var1,FUNC29(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nFUNC41(Var1); \nchar *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC43(Var1->memberVar1,FUNC44(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC39(Var1,Var83,&Var60); \nVar63=FUNC45(Var1,Var6+2,&Var65); \nFUNC28(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC28(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC47((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC48(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC41(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC50(Var1,Var2,Var85); \nelse \nVar14=FUNC51(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC41(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC28(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC54(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC43(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC54(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC28(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC55(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 535,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 2829,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nfree(Var50); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nif (Var52&&*Var52){\nFUNC26(STRING,Var52,Var8); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC27(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC31(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC33(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC38(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC39(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC39(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC41(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC29(Var1,FUNC30(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nFUNC42(Var1); \nchar *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC44(Var1->memberVar1,FUNC45(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC40(Var1,Var83,&Var60); \nVar63=FUNC46(Var1,Var6+2,&Var65); \nFUNC29(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC29(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC48((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC49(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC42(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC51(Var1,Var2,Var85); \nelse \nVar14=FUNC52(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC42(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC29(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC55(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC44(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC55(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC29(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC56(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 536,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 2837,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\twrite (1, \"> \", 2);\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=Var6->memberVar2; \nbool  Var11=Var6->memberVar3; \nSTRUCT1  Var12=Var6->memberVar4; \nif (!Var13){\nswitch (*Var13){\nif (Var13[1]== ){/*STRUCT2 */\nelse \nchar *Var14=strchr(Var13,; ); \nif (Var13[1]!= *&&!strstr(Var13,STRING)){\nif (Var13[1]== >){\nif (*Var13 != ){\nif (Var15&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var13){\nchar *Var16=Var2-1; \nif (*Var16 == ){\nchar *Var3=strchr(Var13,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var17=Var6->memberVar5->memberVar1; \nelse \nchar *Var18=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var13||Var2[-1]!= )){\nif (*Var13 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var19[1024]; \nint  Var8; \nwrite(1,STRING,2); \nif (FUNC4(stdin)){\nif (Var6->memberVar6){\nif (!strcmp(Var19,Var4)){\nchar *Var16=Var2-1; \nint  Var20=FUNC5(Var6->memberVar7,STRING); \nint  Var21=FUNC5(Var6->memberVar7,STRING); \nchar *Var22=Var2-1; \nconst bool  Var23=(Var2[1]== >); \nchar *Var24=FUNC6(Var6,Var13); \nchar *Var25=FUNC7(Var6->memberVar8,Var4,1); \nconst char *Var26=FUNC8(Var6->memberVar7,STRING); \nchar *Var16=Var2-1; \nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nelse \nint  Var21=FUNC5(Var6->memberVar7,STRING); \nconst char *Var27=strstr(Var13,STRING); \nchar *Var28,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var29=Var6->memberVar9; \nSTRUCT3 *Var19; \nchar *Var30=strdup(Var2+2); \nSTRUCT1  Var29=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); \nint  Var31=(int ) FUNC10(Var6->memberVar5,Var2+2); \nSTRUCT4 *Var32=FUNC11(Var6->memberVar10,Var6->memberVar9); \nSTRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); \nchar *Var36=strdup(Var2+2); \nchar  Var16=*Var37; \nSTRUCT1  Var29=FUNC10(Var6->memberVar5,Var2+2); \nchar *Var13=FUNC13(Var6,Var2+2); \nSTRUCT6 *Var34=FUNC14(Var19,Var38); \nSTRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); \nchar *Var39=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var40=strchr(Var2+2,); \nint  Var41=FUNC10(Var6->memberVar5,Var40); \nconst STRUCT3 *Var19=(const STRUCT3 *) FUNC16(Var2+2); \nSTRUCT6 *Var34=FUNC14(Var19,Var38); \nSTRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); \nchar *Var42=Var2-2; \nelse \nchar  Var16=*Var43; \nchar *Var44=Var2+3; \nchar *Var45=Var2+3; \nSTRUCT1  Var46=FUNC10(Var6->memberVar5,Var45); \nSTRUCT1  Var47=FUNC10(Var6->memberVar5,Var48+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 537,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 2838,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=Var6->memberVar2; \nbool  Var11=Var6->memberVar3; \nSTRUCT1  Var12=Var6->memberVar4; \nif (!Var13){\nswitch (*Var13){\nif (Var13[1]== ){/*STRUCT2 */\nelse \nchar *Var14=strchr(Var13,; ); \nif (Var13[1]!= *&&!strstr(Var13,STRING)){\nif (Var13[1]== >){\nif (*Var13 != ){\nif (Var15&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var13){\nchar *Var16=Var2-1; \nif (*Var16 == ){\nchar *Var3=strchr(Var13,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var17=Var6->memberVar5->memberVar1; \nelse \nchar *Var18=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var13||Var2[-1]!= )){\nif (*Var13 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var19[1024]; \nint  Var8; \nfgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21\nif (FUNC4(stdin)){\nif (*Var19) Var19[strlen(Var19)-1]=0; \nVar8=strlen(Var19); \nif (Var6->memberVar6){\nif (!strcmp(Var19,Var4)){\nstrcat((char *) Var6->memberVar6,Var19); \nchar *Var16=Var2-1; \nint  Var22=FUNC5(Var6->memberVar7,STRING); \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nchar *Var24=Var2-1; \nconst bool  Var25=(Var2[1]== >); \nchar *Var26=FUNC6(Var6,Var13); \nchar *Var27=FUNC7(Var6->memberVar8,Var4,1); \nconst char *Var28=FUNC8(Var6->memberVar7,STRING); \nchar *Var16=Var2-1; \nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nelse \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nconst char *Var29=strstr(Var13,STRING); \nchar *Var30,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var31=Var6->memberVar9; \nSTRUCT4 *Var19; \nchar *Var32=strdup(Var2+2); \nSTRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); \nint  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); \nSTRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var38=strdup(Var2+2); \nchar  Var16=*Var39; \nSTRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); \nchar *Var13=FUNC13(Var6,Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var42=strchr(Var2+2,); \nint  Var43=FUNC10(Var6->memberVar5,Var42); \nconst STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var44=Var2-2; \nelse \nchar  Var16=*Var45; \nchar *Var46=Var2+3; \nchar *Var47=Var2+3; \nSTRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); \nSTRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 538,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2842,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=Var6->memberVar2; \nbool  Var11=Var6->memberVar3; \nSTRUCT1  Var12=Var6->memberVar4; \nif (!Var13){\nswitch (*Var13){\nif (Var13[1]== ){/*STRUCT2 */\nelse \nchar *Var14=strchr(Var13,; ); \nif (Var13[1]!= *&&!strstr(Var13,STRING)){\nif (Var13[1]== >){\nif (*Var13 != ){\nif (Var15&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var13){\nchar *Var16=Var2-1; \nif (*Var16 == ){\nchar *Var3=strchr(Var13,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var17=Var6->memberVar5->memberVar1; \nelse \nchar *Var18=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var13||Var2[-1]!= )){\nif (*Var13 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var19[1024]; \nint  Var8; \nfgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21\nif (FUNC4(stdin)){\nif (*Var19) Var19[strlen(Var19)-1]=0; \nVar8=strlen(Var19); \nif (Var6->memberVar6){\nif (!strcmp(Var19,Var4)){\nstrcat((char *) Var6->memberVar6,Var19); \nchar *Var16=Var2-1; \nint  Var22=FUNC5(Var6->memberVar7,STRING); \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nchar *Var24=Var2-1; \nconst bool  Var25=(Var2[1]== >); \nchar *Var26=FUNC6(Var6,Var13); \nchar *Var27=FUNC7(Var6->memberVar8,Var4,1); \nconst char *Var28=FUNC8(Var6->memberVar7,STRING); \nchar *Var16=Var2-1; \nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nelse \nint  Var23=FUNC5(Var6->memberVar7,STRING); \nconst char *Var29=strstr(Var13,STRING); \nchar *Var30,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var31=Var6->memberVar9; \nSTRUCT4 *Var19; \nchar *Var32=strdup(Var2+2); \nSTRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); \nint  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); \nSTRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var38=strdup(Var2+2); \nchar  Var16=*Var39; \nSTRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); \nchar *Var13=FUNC13(Var6,Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var42=strchr(Var2+2,); \nint  Var43=FUNC10(Var6->memberVar5,Var42); \nconst STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); \nSTRUCT7 *Var36=FUNC14(Var19,Var40); \nSTRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); \nchar *Var44=Var2-2; \nelse \nchar  Var16=*Var45; \nchar *Var46=Var2+3; \nchar *Var47=Var2+3; \nSTRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); \nSTRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 539,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2843,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nint  Var5=!Var6->memberVar1->memberVar1; \nint  Var7,Var8=0,Var9; \nbool  Var10=false ; \nint  Var11=-1; \nint  Var12=-1; \nbool  Var13=false ; \nbool  Var14=false ; \nbool  Var15=Var6->memberVar2; \nbool  Var16=Var6->memberVar3; \nbool  Var17=false ; \nSTRUCT1  Var18=Var6->memberVar4; \nif (!Var19){\nswitch (*Var19){\nif (Var19[1]== ){/*STRUCT2 */\nint  Var9=-1; \nelse \nchar *Var20=strchr(Var19,; ); \nif (Var19[1]!= *&&!strstr(Var19,STRING)){\nif (Var19[1]== >){\nif (*Var19 != ){\nif (Var21&&Var2){\nint  Var8; \nif (Var2){\nif (Var2>Var19){\nchar *Var22=Var2-1; \nif (*Var22 == ){\nchar *Var3=strchr(Var19,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var23=Var6->memberVar5->memberVar1; \nelse \nchar *Var24=FUNC2(Var6->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var8 == -1){\nif (Var2&&(Var2 ==  Var19||Var2[-1]!= )){\nif (*Var19 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var25[1024]; \nint  Var8; \nfgets(Var25,sizeof (Var25)-1,stdin); //Var26  STRUCT3  Var27\nif (FUNC4(stdin)){\nif (*Var25) Var25[strlen(Var25)-1]=0; \nVar8=strlen(Var25); \nVar6->memberVar6  STRUCT4  Var8; \nVar6->memberVar7=realloc(Var6->memberVar7,Var6->memberVar6+1); \nif (Var6->memberVar7){\nif (!strcmp(Var25,Var4)){\nstrcat((char *) Var6->memberVar7,Var25); \nif (!*Var4){\nif (!Var6->memberVar7){\nelse \n}else if (Var2 ==  Var19){\nif (Var2){\nif (Var2>Var19){\nchar *Var22=Var2-1; \nif (*Var22 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var28=1; \nint  Var29=FUNC5(Var6->memberVar8,STRING); \nint  Var30=false ; \nint  Var31=FUNC5(Var6->memberVar8,STRING); \nif (!*Var4){\nif (Var2>(Var19+1)&&FUNC6(Var2[-2])){\nchar *Var32=Var2-1; \nif (*Var32 ==  Var33){//STRING\nVar11=FUNC5(Var6->memberVar8,STRING); \nFUNC7(Var6->memberVar8,STRING,true ); \nif (!strcmp(Var4,STRING)){\nFUNC7(Var6->memberVar8,STRING,Var34); \nconst bool  Var35=(Var2[1]== >); \nif (*Var4 == ){\nchar *Var36=FUNC8(Var6,Var19); \nif (Var35){\nchar *Var37=FUNC9(Var6->memberVar9,Var4,1); \nif (Var37){\nchar *Var38=FUNC10(STRING,Var37,Var36); \nif (Var38){\nFUNC11(Var6->memberVar9,Var4,Var38,1); \nfree(Var38); \nelse \nchar *Var39=FUNC10(STRING,Var36); \nFUNC11(Var6->memberVar9,Var4,Var39,1); \nelse \nchar *Var39=FUNC10(STRING,Var36); \nFUNC11(Var6->memberVar9,Var4,Var39,1); \nelse \n}else if (Var28>0){\nif (Var9 != -1){\nif (!Var29){\nFUNC7(Var6->memberVar8,STRING,Var34); \nif (!Var29){\nFUNC7(Var6->memberVar8,STRING,Var31); \nif (Var30){\nconst char *Var40=FUNC12(Var6->memberVar8,STRING); \nif (Var40&&*Var40){\nFUNC13(STRING,Var40,Var4); \nFUNC7(Var6->memberVar8,STRING,Var31); \nif (Var11 != -1){\nFUNC7(Var6->memberVar8,STRING,Var11); \nif (Var12 != -1){\nFUNC7(Var6->memberVar8,STRING,Var12); \nVar6->memberVar10->memberVar1=false ; \nreturn  Var8; \nif (Var2){\nif (Var2>Var19){\nchar *Var22=Var2-1; \nif (*Var22 == ){\nbool  Var41=false ; \nif (Var41){\nelse \n}else if (!Var3){\nelse \nint  memberVar1=Var6->memberVar5->memberVar1; \nif (Var2[1]== !){\nelse \nint  Var31=FUNC5(Var6->memberVar8,STRING); \nFUNC7(Var6->memberVar8,STRING,0); \nFUNC7(Var6->memberVar8,STRING,Var31); \nif (!Var4){\nif (*Var4 == |||*Var4 == *){\nVar6->memberVar5->memberVar1=memberVar1; \nif (Var11 != -1){\nFUNC7(Var6->memberVar8,STRING,Var11); \nif (*Var19 != &&*Var19){\nconst char *Var42=strstr(Var19,STRING); \nif (Var42){\nbool  Var43=false ; \nif (Var43){\nchar *Var44,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var45=Var6->memberVar11; \nbool  Var46=false ; \nbool  Var47=false ; \nbool  Var48=false ; \nbool  Var49=false ; \nSTRUCT5 *Var25; \nchar *Var50=strdup(Var2+2); \nSTRUCT1  Var45=FUNC14(Var6->memberVar5,Var6->memberVar11,Var2+4); \nint  Var51=(int ) FUNC15(Var6->memberVar5,Var2+2); \nSTRUCT6 *Var52=FUNC16(Var6->memberVar12,Var6->memberVar11); \nSTRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); \nchar *Var56=strdup(Var2+2); \nchar  Var22=*Var57; \nSTRUCT1  Var45=FUNC15(Var6->memberVar5,Var2+2); \nchar *Var19=FUNC18(Var6,Var2+2); \nSTRUCT8 *Var54=FUNC19(Var25,Var58); \nSTRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); \nchar *Var59=FUNC20(Var6->memberVar13,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var60=strchr(Var2+2,); \nint  Var61=FUNC15(Var6->memberVar5,Var60); \nconst STRUCT5 *Var25=(const STRUCT5 *) FUNC21(Var2+2); \nSTRUCT8 *Var54=FUNC19(Var25,Var58); \nSTRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); \nchar *Var62=Var2-2; \nelse \nchar  Var22=*Var63; \nchar *Var64=Var2+3; \nelse \nbool  Var65=false ; \nchar *Var66=Var2+3; \nSTRUCT1  Var67=FUNC15(Var6->memberVar5,Var66); \nSTRUCT1  Var68=FUNC15(Var6->memberVar5,Var69+1); \nif (Var11 != -1){\nFUNC7(Var6->memberVar8,STRING,Var11); \nif (Var12 != -1){\nFUNC7(Var6->memberVar8,STRING,Var12); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 540,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "realloc",
    "line": 2845,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar14=strlen(Var40); \nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nfree(Var50); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nif (Var52&&*Var52){\nFUNC26(STRING,Var52,Var8); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC27(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC31(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC33(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC38(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC39(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC39(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC41(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC29(Var1,FUNC30(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nFUNC42(Var1); \nchar *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC44(Var1->memberVar1,FUNC45(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC40(Var1,Var83,&Var60); \nVar63=FUNC46(Var1,Var6+2,&Var65); \nFUNC29(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC34(Var40,Var69); \nSTRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); \nFUNC29(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC29(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC48((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC49(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC42(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC51(Var1,Var2,Var85); \nelse \nVar14=FUNC52(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC42(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC54(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC29(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC55(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC44(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC55(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC29(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC56(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 541,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2847,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var23){\nFUNC8(STRING,Var9); \nchar  Var24[1024]; \nint  Var12; \nfgets(Var24,sizeof (Var24)-1,stdin); //Var25  STRUCT4  Var26\nif (FUNC9(stdin)){\nif (*Var24) Var24[strlen(Var24)-1]=0; \nVar12=strlen(Var24); \nif (Var1->memberVar6){\nif (!strcmp(Var24,Var9)){\nstrcat((char *) Var1->memberVar6,Var24); \nchar *Var20=Var7-1; \nint  Var27=FUNC10(Var1->memberVar7,STRING); \nint  Var28=FUNC10(Var1->memberVar7,STRING); \nchar *Var29=Var7-1; \nconst bool  Var30=(Var7[1]== >); \nchar *Var31=FUNC11(Var1,Var2); \nchar *Var32=FUNC12(Var1->memberVar8,Var9,1); \nconst char *Var33=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var28=FUNC10(Var1->memberVar7,STRING); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar9; \nSTRUCT5 *Var24; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT8 *Var42=FUNC19(Var24,Var46); \nSTRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var47=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT5 *Var24=(const STRUCT5 *) FUNC21(Var7+2); \nSTRUCT8 *Var42=FUNC19(Var24,Var46); \nSTRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 542,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcat",
    "line": 2850,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nfgets(Var40,sizeof (Var40)-1,stdin); //Var41  STRUCT5  Var42\nif (FUNC17(stdin)){\nif (*Var40) Var40[strlen(Var40)-1]=0; \nVar14=strlen(Var40); \nVar1->memberVar10  STRUCT6  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT7 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var43=1; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nint  Var45=false ; \nint  Var46=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var47=Var6-1; \nif (*Var47 ==  Var48){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var49=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var50=FUNC21(Var1,Var2); \nif (Var49){\nchar *Var51=FUNC22(Var1->memberVar5,Var8,1); \nif (Var51){\nchar *Var52=FUNC23(STRING,Var51,Var50); \nif (Var52){\nFUNC24(Var1->memberVar5,Var8,Var52,1); \nelse \nchar *Var53=FUNC23(STRING,Var50); \nFUNC24(Var1->memberVar5,Var8,Var53,1); \nelse \nchar *Var53=FUNC23(STRING,Var50); \nFUNC24(Var1->memberVar5,Var8,Var53,1); \nelse \n}else if (Var43>0){\nif (Var15 != -1){\nif (!Var44){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var44){\nFUNC11(Var1->memberVar8,STRING,Var46); \nif (Var45){\nconst char *Var54=FUNC25(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var46); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var55=false ; \nif (Var55){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC26(Var1,Var6+1); \nelse \nint  Var46=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var46); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var56=strstr(Var2,STRING); \nif (Var56){\nbool  Var57=false ; \nif (Var57){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var58=0; \nif (Var6){\nchar *Var59,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var60=Var1->memberVar6; \nbool  Var61=false ; \nchar *Var62=NULL ; \nconst char *Var63=NULL ; \nbool  Var64=false ; \nbool  Var65=false ; \nchar *Var66=NULL ; \nchar *Var67=NULL ; \nbool  Var68=false ; \nint  Var69=-1; \nint  Var70,Var71; \nSTRUCT7 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var72=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC28(Var1,FUNC29((Var73) Var60-(Var73) Var1->memberVar6)); \nelse \nVar60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var60,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar68=FUNC30(Var1->memberVar14,Var6+2); \nint  Var74=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT8 *Var75=FUNC31(Var1->memberVar15,Var1->memberVar6); \nif (Var75){\nif (Var74 >= 0&&Var74<Var75->memberVar1){\nSTRUCT9  Var76=FUNC32(Var75,Var74); \nFUNC4(Var1,Var75->memberVar2+Var76,1); \nVar23=Var1->memberVar13=true ; \nif (Var59){\nSTRUCT10 *Var77=FUNC33((const STRUCT7 *) Var59,Var70); \nSTRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); \nif (Var78){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var70; \nmemcpy(Var1->memberVar16,Var59,Var70); \nif (Var6[1]== ){\nSTRUCT3  Var80; \nchar *Var81=strdup(Var6+2); \nchar *Var82=FUNC37(Var81); \nif (Var82){\nchar  Var34=*Var82; \nVar80=FUNC38(Var1->memberVar17,Var81); \nVar80=FUNC5(Var1->memberVar7,Var83); \nelse \nVar80=FUNC38(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var80,1); \nVar23=Var1->memberVar13=true ; \nVar64=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var62); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC40(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC28(Var1,FUNC29(Var71)); \nif (Var71>0){\nSTRUCT10 *Var77=FUNC33(Var40,Var71); \nSTRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); \nif (Var78){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); \nFUNC28(Var1,Var71); \nFUNC41(Var1); \nchar *Var84=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var84){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var84),1); \nif (Var6[1]== ){\nVar69=Var1->memberVar1->STRUCT11  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC43(Var1->memberVar1,FUNC44(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var85=FUNC5(Var1->memberVar7,Var31); \nVar64=FUNC39(Var1,Var85,&Var62); \nVar65=FUNC45(Var1,Var6+2,&Var67); \nFUNC28(Var1,Var71); \nconst STRUCT7 *Var40=(const STRUCT7 *) FUNC46(Var6+2); \nif (Var71>0){\nSTRUCT10 *Var77=FUNC33(Var40,Var71); \nSTRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var78){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); \nFUNC28(Var1,Var71); \nchar *Var86=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC28(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var63); \nif (FUNC47((STRUCT7) Var6[1])&&!memberVar2){\nif (!FUNC48(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var63; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var78=Var11; \nif (Var78){\nFUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,memberVar2,FUNC49(Var78)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC41(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var87=Var6+3; \nVar14=FUNC50(Var1,Var2,Var87); \nelse \nVar14=FUNC51(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var88[]={STRING,STRING,STRING,\nconst char *Var89[]={STRING,STRING,STRING,\nSTRUCT3  Var90[FUNC52(Var88)-1],Var91[FUNC52(Var89)-1]; \nif (Var6[1]== (){\nchar *Var92=Var6+3; \nchar *Var29=strchr(Var92,); \nif (!Var29){\nSTRUCT3  Var93=FUNC5(Var1->memberVar7,Var92); \nSTRUCT3  Var94=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var88[Var13]; Var13  Var95){\nVar90[Var13]=FUNC10(Var1->memberVar8,Var88[Var13]); \nfor (Var13=0; Var89[Var13]; Var13  Var95){\nVar91[Var13]=FUNC10(Var1->memberVar8,Var89[Var13]); \nfor (Var13=0; Var88[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var88[Var13],Var93); \nfor (Var13=0; Var89[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var89[Var13],Var94); \nif (Var16){\nif (Var61){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nelse \nif (Var61){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC41(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nif (memberVar13){\nfor (Var13=0; Var88[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var88[Var13],Var90[Var13]); \nfor (Var13=0; Var89[Var13]; Var13  Var95){\nFUNC11(Var1->memberVar8,Var89[Var13],Var91[Var13]); \nif (Var7){\nFUNC28(Var1,Var24); \nif (Var65){\nVar1->memberVar2=Var21; \nFUNC54(Var1->memberVar8,STRING,Var67); \nif (Var69 != -1){\nFUNC43(Var1->memberVar1,Var69); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var64){\nFUNC54(Var1->memberVar8,STRING,Var62); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC28(Var1,Var24); \nif (Var66){\nFUNC3(Var1,Var66); \nif (Var68){\nFUNC55(Var1->memberVar14); \nVar58=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 543,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2862,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=NULL ; \nchar *Var6,*Var7,*Var8; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nSTRUCT2 *Var11=NULL ; \nint  Var12=!Var1->memberVar1->memberVar1; \nint  Var13,Var14=0,Var15; \nbool  Var16=false ; \nint  Var17=-1; \nint  Var18=-1; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=Var1->memberVar2; \nbool  Var22=Var1->memberVar3; \nbool  Var23=false ; \nSTRUCT3  Var24=Var1->memberVar4; \nint  Var25=-1; \nif (!Var2){\nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC2(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var15=-1; \nSTRUCT3  Var26=Var27; \nchar *Var28,*Var29; \nif (Var20){\nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nFUNC3(Var1,Var2); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar26=Var1->memberVar6; \nFUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); \nconst bool  Var32=Var29[2]== >; \nif (Var29&&*Var29&&Var29[1]== |){\nFUNC6(Var1,Var2,Var8); \nelse \nFUNC2(Var1->memberVar5,Var28); \nif (Var26 !=  Var27){\nFUNC4(Var1,Var26,1); \nif (!Var29){\nif (Var19){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC2(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC7(Var1,Var33); \nif (*Var2 != ){\nif (Var3&&Var6){\nint  Var14; \nif (FUNC8(Var1,Var2) == -1){\nVar14=FUNC8(Var1,Var2); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nchar *Var7=strchr(Var2,); \nif (!Var7||(Var7&&Var7>Var6)){\nif (!Var5||(Var5&&Var5>Var6)){\nif (!strcmp(Var6+1,STRING)){//STRING\nFUNC7(Var1,Var35); \nelse \n}else if (!FUNC9(Var6+1,STRING,1)){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nelse \n}else if (!strcmp(Var6+1,STRING)){//STRING\nVar14=*Var2 FUNC12(Var1,STRING,Var2) 0; \nelse \n}else if (Var6[1]){//STRING\nint  Var37=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC6(Var1,Var2,Var6+1); \nelse \nchar *Var38=FUNC13(Var1->memberVar1,Var6+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar18=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var36); \nwhile (Var6&&*Var6&&Var6[1]== &){\nVar14=FUNC2(Var1->memberVar5,Var2); \nif (Var14 == -1){\nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nFUNC14(Var1->memberVar9); \nif (Var6&&(Var6 ==  Var2||Var6[-1]!= )){\nif (*Var2 != ){\nint  Var39=0; \nFUNC15(Var1,Var39,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nif (Var6){\nif (FUNC16()->memberVar1){\nif (Var6[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var40[1024]; \nint  Var14; \nif (FUNC17(stdin)){\nVar1->memberVar10  STRUCT5  Var14; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var40,Var8)){\nstrcat((char *) Var1->memberVar9,Var40); \nif (!*Var8){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var6 ==  Var2){\nreturn FUNC19(Var1,(const char *) Var1->memberVar9); \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nif (Var6[0]&&Var6[1]== ){\nFUNC7(Var1,Var33); \nint  Var41=1; \nint  Var42=FUNC10(Var1->memberVar8,STRING); \nint  Var43=false ; \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nif (!*Var8){\nif (Var6>(Var2+1)&&FUNC20(Var6[-2])){\nchar *Var45=Var6-1; \nif (*Var45 ==  Var46){//STRING\nVar17=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var8,STRING)){\nFUNC11(Var1->memberVar8,STRING,Var36); \nconst bool  Var47=(Var6[1]== >); \nif (*Var8 == ){\nchar *Var48=FUNC21(Var1,Var2); \nif (Var47){\nchar *Var49=FUNC22(Var1->memberVar5,Var8,1); \nif (Var49){\nchar *Var50=FUNC23(STRING,Var49,Var48); \nif (Var50){\nFUNC24(Var1->memberVar5,Var8,Var50,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \nchar *Var51=FUNC23(STRING,Var48); \nFUNC24(Var1->memberVar5,Var8,Var51,1); \nelse \n}else if (Var41>0){\nif (Var15 != -1){\nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var36); \nVar14=FUNC8(Var1,Var2); \nif (!Var42){\nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var43){\nconst char *Var52=FUNC25(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar11->memberVar1=false ; \nif (Var6){\nif (Var6>Var2){\nchar *Var34=Var6-1; \nif (*Var34 == ){\nbool  Var53=false ; \nif (Var53){\nelse \n}else if (!Var7){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var6[1]== !){\nVar8=FUNC26(Var1,Var6+1); \nelse \nint  Var44=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar8=FUNC21(Var1,Var6+1); \nVar1->memberVar12=false ; \nFUNC11(Var1->memberVar8,STRING,Var44); \nif (!Var8){\nif (*Var8 == |||*Var8 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar14=FUNC8(Var1,Var2); \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (*Var2 != &&*Var2){\nconst char *Var54=strstr(Var2,STRING); \nif (Var54){\nbool  Var55=false ; \nif (Var55){\nVar23=Var1->memberVar13=Var6 true false ; \nint  Var56=0; \nif (Var6){\nchar *Var57,*Var7=strchr(Var6+1,!); \nSTRUCT3  Var58=Var1->memberVar6; \nbool  Var59=false ; \nchar *Var60=NULL ; \nconst char *Var61=NULL ; \nbool  Var62=false ; \nbool  Var63=false ; \nchar *Var64=NULL ; \nchar *Var65=NULL ; \nbool  Var66=false ; \nint  Var67=-1; \nint  Var68,Var69; \nSTRUCT6 *Var40; \nif (Var6[1]== ){\nelse \n}else if (Var6[1]== %){//STRING\nchar *Var70=strdup(Var6+2); \nelse \n}else if (Var6[1]== .){//STRING\nif (Var6[2]== .){//STRING\nif (Var6[3]== .){//STRING\nSTRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); \nFUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); \nelse \nVar58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); \nFUNC4(Var1,Var58,1); \nVar23=Var1->memberVar13=true ; \nelse \n}else if (Var6[0]&&Var6[1]== &&Var6[2]){\nswitch (Var6[0]){\nVar66=FUNC30(Var1->memberVar14,Var6+2); \nint  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); \nSTRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); \nif (Var73){\nif (Var72 >= 0&&Var72<Var73->memberVar1){\nSTRUCT8  Var74=FUNC32(Var73,Var72); \nFUNC4(Var1,Var73->memberVar2+Var74,1); \nVar23=Var1->memberVar13=true ; \nif (Var57){\nSTRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nif (Var40){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var40; \nVar1->memberVar4=Var68; \nmemcpy(Var1->memberVar16,Var57,Var68); \nif (Var6[1]== ){\nSTRUCT3  Var78; \nchar *Var79=strdup(Var6+2); \nchar *Var80=FUNC37(Var79); \nif (Var80){\nchar  Var34=*Var80; \nVar78=FUNC38(Var1->memberVar17,Var79); \nVar78=FUNC5(Var1->memberVar7,Var81); \nelse \nVar78=FUNC38(Var1->memberVar17,Var6+2); \nFUNC4(Var1,Var78,1); \nVar23=Var1->memberVar13=true ; \nVar62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); \nVar25=FUNC10(Var1->memberVar8,STRING); \nFUNC11(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); \nif (memberVar2){\nFUNC12(Var1,STRING,Var6+2); \nVar23=Var1->memberVar13=true ; \nchar *Var2=FUNC40(Var1,Var6+2); \nif (Var6[1]== ){\nif (Var40){\nFUNC28(Var1,FUNC29(Var69)); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nFUNC41(Var1); \nchar *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var82){\nFUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); \nif (Var6[1]== ){\nVar67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC43(Var1->memberVar1,FUNC44(Var6+2)); \nif (Var6[1]== ){\nchar *Var31=strchr(Var6+2,); \nif (Var31){\nint  Var83=FUNC5(Var1->memberVar7,Var31); \nVar62=FUNC39(Var1,Var83,&Var60); \nVar63=FUNC45(Var1,Var6+2,&Var65); \nFUNC28(Var1,Var69); \nconst STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); \nif (Var69>0){\nSTRUCT9 *Var75=FUNC33(Var40,Var69); \nSTRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC11(Var1->memberVar8,STRING,1); \nif (Var76){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,1); \nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); \nFUNC28(Var1,Var69); \nchar *Var84=Var6-2; \nif (Var7){\nif (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&\n!memcmp(Var6+1,STRING,2)&&\n!memcmp(Var7+1,STRING,2)){\nelse \n}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){\nif (!Var7[1]){\nFUNC28(\nVar1,FUNC5(Var1->memberVar7,Var7+1)); \nmemberVar2=FUNC5(Var1->memberVar7,Var61); \nif (FUNC47((STRUCT6) Var6[1])&&!memberVar2){\nif (!FUNC48(Var1->memberVar14,Var6+1)){\nelse \nchar  Var34=*Var61; \nif (Var34 == -||Var34 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var76=Var11; \nif (Var76){\nFUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); \nif (Var9){\nVar1->memberVar19=!!Var11; \nif (Var1->memberVar19){\nFUNC41(Var1); \nif (Var6[1]== ){\nif (Var6[2]== ){\nchar *Var85=Var6+3; \nVar14=FUNC50(Var1,Var2,Var85); \nelse \nVar14=FUNC51(Var1,Var2,Var6+2); \nelse \nbool  memberVar13=false ; \nconst char *Var86[]={STRING,STRING,STRING,\nconst char *Var87[]={STRING,STRING,STRING,\nSTRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; \nif (Var6[1]== (){\nchar *Var90=Var6+3; \nchar *Var29=strchr(Var90,); \nif (!Var29){\nSTRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); \nSTRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nVar88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nVar89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); \nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var91); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var92); \nif (Var16){\nif (Var59){\nVar1->memberVar6=memberVar2; \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nelse \nif (Var59){\nif (Var6[1]){\nFUNC4(Var1,memberVar2,1); \nFUNC41(Var1); \nVar14=FUNC2(Var1->memberVar5,FUNC53(Var2)); \nif (memberVar13){\nfor (Var13=0; Var86[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); \nfor (Var13=0; Var87[Var13]; Var13  Var93){\nFUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); \nif (Var7){\nFUNC28(Var1,Var24); \nif (Var63){\nVar1->memberVar2=Var21; \nFUNC54(Var1->memberVar8,STRING,Var65); \nif (Var67 != -1){\nFUNC43(Var1->memberVar1,Var67); \nif (Var11){\nif (Var12){\nFUNC11(Var1->memberVar8,STRING,0); \nif (Var62){\nFUNC54(Var1->memberVar8,STRING,Var60); \nVar1->memberVar3=Var22; \nif (Var24 !=  Var1->memberVar4){\nFUNC28(Var1,Var24); \nif (Var64){\nFUNC3(Var1,Var64); \nif (Var66){\nFUNC55(Var1->memberVar14); \nVar56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; \nif (Var17 != -1){\nFUNC11(Var1->memberVar8,STRING,Var17); \nif (Var18 != -1){\nFUNC11(Var1->memberVar8,STRING,Var18); \nVar1->memberVar2=Var21; \nVar1->memberVar3=Var22; \nif (Var25 != -1){\nFUNC11(Var1->memberVar8,STRING,Var25); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 544,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2885,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC9(Var1->memberVar7,STRING); \nint  Var25=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC10(Var7[-2])){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC11(Var1,Var2); \nchar *Var29=FUNC12(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nconst char *Var31=strstr(Var2,STRING); \nchar *Var32,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var33=Var1->memberVar9; \nchar *Var34=strdup(Var7+2); \nchar *Var35=strchr(Var34,=); \nSTRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var41=strdup(Var7+2); \nchar  Var20=*Var42; \nSTRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var44=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var46=Var7-2; \nelse \nchar  Var20=*Var47; \nchar *Var48=Var7+3; \nchar *Var49=Var7+3; \nchar *Var19=strchr(Var49,); \nSTRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); \nSTRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 545,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2885,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC9(Var1->memberVar7,STRING); \nint  Var25=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC10(Var7[-2])){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC11(Var1,Var2); \nchar *Var29=FUNC12(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nconst char *Var31=strstr(Var2,STRING); \nchar *Var32,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var33=Var1->memberVar9; \nchar *Var34=strdup(Var7+2); \nchar *Var35=strchr(Var34,=); \nSTRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var41=strdup(Var7+2); \nchar  Var20=*Var42; \nSTRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var44=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); \nchar *Var46=Var7-2; \nelse \nchar  Var20=*Var47; \nchar *Var48=Var7+3; \nchar *Var49=Var7+3; \nchar *Var19=strchr(Var49,); \nSTRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); \nSTRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 546,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2922,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nint  Var13=-1; \nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=1; \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nint  Var26=false ; \nint  Var27=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nchar *Var28=Var7-1; \nconst bool  Var29=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var30=FUNC10(Var1,Var2); \nif (Var29){\nchar *Var31=FUNC11(Var1->memberVar8,Var9,1); \nif (Var31){\nchar *Var32=FUNC12(STRING,Var31,Var30); \nif (Var32){\nFUNC13(Var1->memberVar8,Var9,Var32,1); \nelse \nchar *Var33=FUNC12(STRING,Var30); \nFUNC13(Var1->memberVar8,Var9,Var33,1); \nelse \nchar *Var33=FUNC12(STRING,Var30); \nFUNC13(Var1->memberVar8,Var9,Var33,1); \nelse \n}else if (Var24>0){\nVar13=FUNC14(Var9,Var24,Var29); \nif (Var26){\nconst char *Var34=FUNC15(Var1->memberVar7,STRING); \nif (Var34&&*Var34){\nFUNC16(STRING,Var34,Var9); \nFUNC17(Var9); \nfree(Var9); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var27=FUNC9(Var1->memberVar7,STRING); \nconst char *Var35=strstr(Var2,STRING); \nchar *Var36,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var37=Var1->memberVar9; \nchar *Var38=strdup(Var7+2); \nchar *Var39=strchr(Var38,=); \nSTRUCT2  Var37=FUNC18(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var40=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var41=FUNC20(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); \nchar *Var45=strdup(Var7+2); \nchar  Var20=*Var46; \nSTRUCT2  Var37=FUNC19(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC22(Var1,Var7+2); \nSTRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); \nchar *Var47=FUNC23(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC19(Var1->memberVar5,Var18); \nconst STRUCT6 *Var49=(const STRUCT6 *) FUNC24(Var7+2); \nSTRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); \nchar *Var50=Var7-2; \nelse \nchar  Var20=*Var51; \nchar *Var52=Var7+3; \nchar *Var53=Var7+3; \nchar *Var19=strchr(Var53,); \nSTRUCT2  Var54=FUNC19(Var1->memberVar5,Var53); \nSTRUCT2  Var55=FUNC19(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 547,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2938,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nVar1->memberVar6=malloc(1); \nVar1->memberVar7=0; \nchar  Var24[1024]; \nint  Var12; \nif (FUNC8(stdin)){\nVar12=strlen(Var24); \nVar1->memberVar7  STRUCT4  Var12; \nVar1->memberVar6=realloc(Var1->memberVar6,Var1->memberVar7+1); \nif (Var1->memberVar6){\nif (!strcmp(Var24,Var9)){\nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var23){\nif (!*Var9){\nVar1->memberVar6=(STRUCT5 *) FUNC9(Var9,&Var1->memberVar7); \nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC10(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var25=FUNC11(Var1->memberVar8,STRING); \nint  Var26=FUNC11(Var1->memberVar8,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nchar *Var27=Var7-1; \nif (!strcmp(Var9,STRING)){\nVar9=FUNC12(STRING); \nconst bool  Var28=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var29=FUNC13(Var1,Var2); \nif (Var28){\nchar *Var30=FUNC14(Var1->memberVar9,Var9,1); \nif (Var30){\nchar *Var31=FUNC15(STRING,Var30,Var29); \nif (Var31){\nFUNC16(Var1->memberVar9,Var9,Var31,1); \nfree(Var31); \nelse \nchar *Var32=FUNC15(STRING,Var29); \nelse \nchar *Var32=FUNC15(STRING,Var29); \nconst char *Var33=FUNC17(Var1->memberVar8,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var26=FUNC11(Var1->memberVar8,STRING); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar10; \nSTRUCT5 *Var24; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC18(Var1->memberVar5,Var1->memberVar10,Var7+4); \nint  Var39=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var40=FUNC20(Var1->memberVar11,Var1->memberVar10); \nSTRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC19(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC22(Var1,Var7+2); \nSTRUCT8 *Var42=FUNC23(Var24,Var46); \nSTRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); \nchar *Var47=FUNC24(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC19(Var1->memberVar5,Var18); \nconst STRUCT5 *Var24=(const STRUCT5 *) FUNC25(Var7+2); \nSTRUCT8 *Var42=FUNC23(Var24,Var46); \nSTRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC19(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC19(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 548,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2943,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var28=FUNC9(Var1,Var2); \nif (Var27){\nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nif (Var29){\nchar *Var30=FUNC11(STRING,Var29,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nFUNC12(Var1->memberVar8,Var9,Var31,1); \nfree(Var31); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nconst char *Var32=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nconst char *Var33=strstr(Var2,STRING); \nchar *Var34,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var35=Var1->memberVar9; \nchar *Var36=strdup(Var7+2); \nchar *Var37=strchr(Var36,=); \nSTRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var43=strdup(Var7+2); \nchar  Var20=*Var44; \nSTRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var46=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var48=Var7-2; \nelse \nchar  Var20=*Var49; \nchar *Var50=Var7+3; \nchar *Var51=Var7+3; \nchar *Var19=strchr(Var51,); \nSTRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 549,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2948,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var28=FUNC9(Var1,Var2); \nif (Var27){\nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nchar *Var30=FUNC11(STRING,Var29,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nFUNC12(Var1->memberVar8,Var9,Var31,1); \nfree(Var31); \nconst char *Var32=FUNC13(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nconst char *Var33=strstr(Var2,STRING); \nchar *Var34,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var35=Var1->memberVar9; \nchar *Var36=strdup(Var7+2); \nchar *Var37=strchr(Var36,=); \nSTRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var43=strdup(Var7+2); \nchar  Var20=*Var44; \nSTRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var46=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); \nchar *Var48=Var7-2; \nelse \nchar  Var20=*Var49; \nchar *Var50=Var7+3; \nchar *Var51=Var7+3; \nchar *Var19=strchr(Var51,); \nSTRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 550,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2951,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var28=FUNC9(Var1,Var2); \nif (Var27){\nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nif (Var29){\nchar *Var30=FUNC11(STRING,Var29,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nelse \nchar *Var31=FUNC11(STRING,Var28); \nelse \nconst char *Var32=FUNC12(Var1->memberVar7,STRING); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nconst char *Var33=strstr(Var2,STRING); \nchar *Var34,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var35=Var1->memberVar9; \nchar *Var36=strdup(Var7+2); \nchar *Var37=strchr(Var36,=); \nSTRUCT2  Var35=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var38=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var39=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); \nchar *Var43=strdup(Var7+2); \nchar  Var20=*Var44; \nSTRUCT2  Var35=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); \nchar *Var45=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var46=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var47=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); \nchar *Var48=Var7-2; \nelse \nchar  Var20=*Var49; \nchar *Var50=Var7+3; \nchar *Var51=Var7+3; \nchar *Var19=strchr(Var51,); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var51); \nSTRUCT2  Var53=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 551,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2977,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nint  Var13=-1; \nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC8(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=1; \nint  Var25=FUNC9(Var1->memberVar7,STRING); \nint  Var26=false ; \nint  Var27=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nchar *Var28=Var7-1; \nif (!strcmp(Var9,STRING)){\nVar9=FUNC10(STRING); \nconst bool  Var29=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var30=FUNC11(Var1,Var2); \nif (Var29){\nchar *Var31=FUNC12(Var1->memberVar8,Var9,1); \nif (Var31){\nchar *Var32=FUNC13(STRING,Var31,Var30); \nif (Var32){\nFUNC14(Var1->memberVar8,Var9,Var32,1); \nelse \nchar *Var33=FUNC13(STRING,Var30); \nFUNC14(Var1->memberVar8,Var9,Var33,1); \nelse \nchar *Var33=FUNC13(STRING,Var30); \nFUNC14(Var1->memberVar8,Var9,Var33,1); \nelse \n}else if (Var24>0){\nVar13=FUNC15(Var9,Var24,Var29); \nif (Var26){\nconst char *Var34=FUNC16(Var1->memberVar7,STRING); \nif (Var34&&*Var34){\nFUNC17(STRING,Var34,Var9); \nFUNC18(Var9); \nfree(Var9); \nchar *Var20=Var7-1; \nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var27=FUNC9(Var1->memberVar7,STRING); \nconst char *Var35=strstr(Var2,STRING); \nchar *Var36,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var37=Var1->memberVar9; \nchar *Var38=strdup(Var7+2); \nchar *Var39=strchr(Var38,=); \nSTRUCT2  Var37=FUNC19(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var40=(int ) FUNC20(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var41=FUNC21(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); \nchar *Var45=strdup(Var7+2); \nchar  Var20=*Var46; \nSTRUCT2  Var37=FUNC20(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC23(Var1,Var7+2); \nSTRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); \nchar *Var47=FUNC24(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var48=FUNC20(Var1->memberVar5,Var18); \nconst STRUCT6 *Var49=(const STRUCT6 *) FUNC25(Var7+2); \nSTRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); \nchar *Var50=Var7-2; \nelse \nchar  Var20=*Var51; \nchar *Var52=Var7+3; \nchar *Var53=Var7+3; \nchar *Var19=strchr(Var53,); \nSTRUCT2  Var54=FUNC20(Var1->memberVar5,Var53); \nSTRUCT2  Var55=FUNC20(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 552,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2992,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \n*Var7=0; \nif (FUNC11(Var1,Var2) == -1){\nVar2=Var7+1; \nVar15=FUNC11(Var1,Var2); \n*Var7=; ; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC12(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC13(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC14(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC15(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC16(Var1,Var38,Var2); \nFUNC17(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC18()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var26){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var26){\nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=1; \nint  Var41=FUNC19(Var1->memberVar8,STRING); \nint  Var42=false ; \nint  Var43=FUNC19(Var1->memberVar8,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC20(Var7[-2])){\nchar *Var44=Var7-1; \nconst bool  Var45=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var46=FUNC21(Var1,Var2); \nchar *Var47=FUNC22(Var1->memberVar5,Var9,1); \nchar *Var48=FUNC23(STRING,Var47,Var46); \nelse \nchar *Var49=FUNC23(STRING,Var46); \nelse \nchar *Var49=FUNC23(STRING,Var46); \nelse \n}else if (Var40>0){\nif (Var16 != -1){\nVar15=FUNC11(Var1,Var2); \nconst char *Var50=FUNC24(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nbool  Var51=false ; \nint  Var52=1; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var51){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var7=0; \n*Var8=0; \nif (Var7[1]== !){\nVar9=FUNC25(Var1,Var7+1); \nelse \nint  Var43=FUNC19(Var1->memberVar8,STRING); \nVar9=FUNC21(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var52&&Var9){\nfor (Var14=0; Var9[Var14]; Var14  Var26){\nif (Var9[Var14]==  Var49){\nVar9[Var14]=; \nVar9=FUNC26(Var9,Var8+1); \nVar2=FUNC26(strdup(Var2),Var9); \nVar15=FUNC11(Var1,Var2); \nfree(Var2); \nfree(Var9); \nreturn  Var15; \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var53=false ; \nif (Var53){\nif (*Var2 != .){\nVar11=FUNC27(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nVar22=Var1->memberVar9=Var7 true false ; \nint  Var54=0; \nif (Var7){\nchar *Var55,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var56=Var1->memberVar10; \nbool  Var57=false ; \nchar *Var58=NULL ; \nconst char *Var59=NULL ; \nbool  Var60=false ; \nbool  Var61=false ; \nchar *Var62=NULL ; \nchar *Var63=NULL ; \nbool  Var64=false ; \nint  Var65,Var66; \nSTRUCT5 *Var39; \n*Var7  Var26=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var26){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var67; \nVar7=FUNC28(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var68=strdup(Var7+2); \nchar *Var69=strchr(Var68,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+4); \nelse \nVar56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar64=FUNC30(Var1->memberVar11,Var7+2); \nint  Var70=(int ) FUNC31(Var1->memberVar6,Var7+2); \nSTRUCT6 *Var71=FUNC32(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var72=FUNC33(Var71,Var70); \nVar55=FUNC34(Var7+2,&Var65); \nif (Var55){\nSTRUCT8 *Var73=FUNC35((const STRUCT5 *) Var55,Var65); \nSTRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); \nelse \nFUNC5(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var76; \nchar *Var77=strdup(Var7+2); \nchar *Var78=FUNC37(Var77); \nif (Var78){\nchar  Var35=*Var78; \nelse \nVar76=FUNC38(Var1->memberVar13,Var7+2); \nVar60=FUNC39(Var1,FUNC31(Var1->memberVar6,Var7+2),&Var58); \nSTRUCT3  Var56=FUNC31(Var1->memberVar6,Var7+2); \nif (Var56){\nFUNC14(Var1,STRING,Var7+2); \nchar *Var2=FUNC40(Var1,Var7+2); \nif (!Var62){\nVar62=Var2; \nelse \nVar62=FUNC41(Var62,Var2); \nfree(Var2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar66=FUNC42(Var7+2,Var39); \nSTRUCT8 *Var73=FUNC35(Var39,Var66); \nSTRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); \nchar *Var79=FUNC43(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC44(Var1->memberVar1,FUNC45(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var80=FUNC31(Var1->memberVar6,Var29); \nVar61=FUNC46(Var1,Var7+2,&Var63); \nVar66=strlen(Var7+2); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC47(Var7+2); \nSTRUCT8 *Var73=FUNC35(Var39,Var66); \nSTRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); \n*Var7=; \nchar *Var81=Var7-2; \nwhile (Var81>Var2){\nif (!FUNC48(*Var81)){\nVar7=FUNC49(Var7+1)-1; \nVar2=FUNC12(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar59=FUNC49(Var7+1); \nif (FUNC50((STRUCT5) Var7[1])&&!Var56){\nif (!FUNC51(Var1->memberVar11,Var7+1)){\nFUNC5(STRING,Var7+1); \nelse \nchar  Var35=*Var59; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var82=Var7+3; \nVar15=FUNC52(Var1,Var2,Var82); \nelse \nVar15=FUNC53(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var83[]={STRING,STRING,STRING,\nconst char *Var84[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var25=strchr(Var85,); \nif (!Var25){\nSTRUCT3  Var86=FUNC31(Var1->memberVar6,Var85); \nSTRUCT3  Var87=FUNC31(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC49(Var2)); \nelse \nif (Var57){\nVar15=FUNC3(Var1->memberVar5,FUNC49(Var2)); \n*Var7=; \nVar54=Var2 FUNC3(Var1->memberVar5,FUNC49(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 553,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2997,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 554,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2997,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 555,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 3004,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 556,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3004,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC17(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC14(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); \nSTRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 557,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3008,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nmemmove(Var20,Var7,strlen(Var7)+1); \nbool  Var31=false ; \nif (Var7[1]== ){\nmemmove(Var7,Var7+1,strlen(Var7)); \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \n*Var7=0; \n*Var8=0; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar9=FUNC13(Var9,Var8+1); \nVar2=FUNC13(strdup(Var2),Var9); \nVar12=FUNC14(Var1,Var2); \nfree(Var2); \nfree(Var9); \nreturn  Var12; \nconst char *Var32=strstr(Var2,STRING); \nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC15(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC16(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC17(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC16(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC19(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC16(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC21(Var7+2); \nSTRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC16(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC16(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 558,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3035,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nbool  Var31=false ; \nint  Var32=1; \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var32&&Var9){\nfor (Var11=0; Var9[Var11]; Var11  Var23){\nif (Var9[Var11]==  Var33){\nVar9[Var11]=; \nVar9=FUNC13(Var9,Var8+1); \nVar2=FUNC13(strdup(Var2),Var9); \nfree(Var9); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar9; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var47=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 559,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3046,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nint  Var50=1; \nVar8=strchr(Var7+1,); \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC24(Var1,Var7+1); \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nVar9=FUNC19(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var50&&Var9){\nfor (Var14=0; Var9[Var14]; Var14  Var26){\nif (Var9[Var14]==  Var47){\nVar9[Var14]=; \nVar9=FUNC25(Var9,Var8+1); \nVar2=FUNC25(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nfree(Var9); \nreturn  Var15; \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC26(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var63=strdup(Var7+2); \nchar *Var64=strchr(Var63,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var65=(int ) FUNC28(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var66=FUNC29(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); \nchar *Var70=strdup(Var7+2); \nchar  Var34=*Var71; \nSTRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nSTRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); \nchar *Var72=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var73=FUNC28(Var1->memberVar6,Var29); \nconst STRUCT6 *Var74=(const STRUCT6 *) FUNC33(Var7+2); \nSTRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); \nchar *Var75=Var7-2; \nwhile (Var75>Var2){\nif (!FUNC34(*Var75)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC35((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC36(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var57; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nVar15=FUNC37(Var1,Var2,Var76); \nelse \nVar15=FUNC38(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC28(Var1->memberVar6,Var79); \nSTRUCT3  Var81=FUNC28(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 560,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3049,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nVar8=strchr(Var7+1,); \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC24(Var1,Var7+1); \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nVar9=FUNC19(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar9=FUNC25(Var9,Var8+1); \nVar2=FUNC25(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != .){\nVar11=FUNC26(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC28(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC29(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC28(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC28(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC33(Var7+2); \nSTRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC34(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC35((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC36(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC37(Var1,Var2,Var75); \nelse \nVar15=FUNC38(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC28(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC28(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC39(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 561,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3053,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nbool  Var31=false ; \nint  Var32=1; \nVar8=strchr(Var7+1,); \nif (Var31){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC12(Var1,Var7+1); \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nVar9=FUNC9(Var1,Var7+1); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nfree(Var9); \nif (Var32&&Var9){\nfor (Var11=0; Var9[Var11]; Var11  Var23){\nif (Var9[Var11]==  Var33){\nVar9[Var11]=; \nVar9=FUNC13(Var9,Var8+1); \nVar2=FUNC13(strdup(Var2),Var9); \nfree(Var9); \nconst char *Var34=strstr(Var2,STRING); \nchar *Var35,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var36=Var1->memberVar9; \nchar *Var37=strdup(Var7+2); \nchar *Var38=strchr(Var37,=); \nSTRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var44=strdup(Var7+2); \nchar  Var20=*Var45; \nSTRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var47=FUNC15(Var1->memberVar5,Var18); \nconst STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); \nchar *Var49=Var7-2; \nelse \nchar  Var20=*Var50; \nchar *Var51=Var7+3; \nchar *Var52=Var7+3; \nchar *Var19=strchr(Var52,); \nSTRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); \nSTRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 562,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 3061,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var35=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var36=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var37=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var37,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var38=1; \nint  Var39=FUNC17(Var1->memberVar8,STRING); \nint  Var40=false ; \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var42=Var7-1; \nconst bool  Var43=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var44=FUNC19(Var1,Var2); \nchar *Var45=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var46=FUNC21(STRING,Var45,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \nchar *Var47=FUNC21(STRING,Var44); \nelse \n}else if (Var38>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var48=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var34=Var7-1; \nif (*Var34 == ){\nbool  Var49=false ; \nif (Var49){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var41=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var50=false ; \nif (Var2 ==  Var27){\nif (Var50){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar9; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var69=strdup(Var7+2); \nchar  Var34=*Var70; \nSTRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var72=FUNC27(Var1->memberVar6,Var29); \nconst STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); \nSTRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); \nchar *Var74=Var7-2; \nwhile (Var74>Var2){\nif (!FUNC33(*Var74)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC34((STRUCT6) Var7[1])&&!Var53){\nif (!FUNC35(Var1->memberVar12,Var7+1)){\nelse \nchar  Var34=*Var56; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var75=Var7+3; \nVar15=FUNC36(Var1,Var2,Var75); \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var76[]={STRING,STRING,STRING,\nconst char *Var77[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var78=Var7+3; \nchar *Var25=strchr(Var78,); \nif (!Var25){\nSTRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); \nSTRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC38(Var2)); \nVar51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 563,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 3071,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nint  Var10=!Var1->memberVar1->memberVar1; \nint  Var11,Var12=0,Var13; \nbool  Var14=Var1->memberVar2; \nbool  Var15=Var1->memberVar3; \nSTRUCT2  Var16=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT3 */\nelse \nchar *Var17=strchr(Var2,; ); \nchar *Var18=strchr(Var19+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var12; \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var21=Var1->memberVar5->memberVar1; \nelse \nchar *Var22=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nif (Var12 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nint  Var12; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var24=FUNC8(Var1->memberVar7,STRING); \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var26=Var7-1; \nconst bool  Var27=(Var7[1]== >); \nchar *Var28=FUNC9(Var1,Var2); \nchar *Var29=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var30=FUNC11(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var20=Var7-1; \nif (*Var20 == ){\nbool  Var31=false ; \nif (Var31){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var25=FUNC8(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var32=strstr(Var2,STRING); \nif (Var32){\nif (Var2 ==  Var32){\nchar *Var33,*Var8=strchr(Var7+1,!); \nSTRUCT2  Var34=Var1->memberVar9; \nchar *Var35=strdup(Var7+2); \nchar *Var36=strchr(Var35,=); \nSTRUCT2  Var34=FUNC12(Var1->memberVar5,Var1->memberVar9,Var7+4); \nint  Var37=(int ) FUNC13(Var1->memberVar5,Var7+2); \nSTRUCT4 *Var38=FUNC14(Var1->memberVar10,Var1->memberVar9); \nSTRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); \nchar *Var42=strdup(Var7+2); \nchar  Var20=*Var43; \nSTRUCT2  Var34=FUNC13(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC16(Var1,Var7+2); \nSTRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); \nchar *Var44=FUNC17(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var18=strchr(Var7+2,); \nint  Var45=FUNC13(Var1->memberVar5,Var18); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC18(Var7+2); \nSTRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); \nchar *Var47=Var7-2; \nelse \nchar  Var20=*Var48; \nchar *Var49=Var7+3; \nchar *Var50=Var7+3; \nchar *Var19=strchr(Var50,); \nSTRUCT2  Var51=FUNC13(Var1->memberVar5,Var50); \nSTRUCT2  Var52=FUNC13(Var1->memberVar5,Var19+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 564,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3089,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nint  Var28=-1; \nif (!Var2){\nVar2=FUNC3(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nreturn FUNC4(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var18=-1; \nchar *Var29,*Var30; \nVar23=*Var2 == ; \nif (Var23){\nVar2  Var31; \nVar30=*Var2 FUNC5(Var2) NULL ; \nif (!Var30||!*Var30){\nFUNC6(STRINGFUNC7(%Var32).,Var2); \nelse \nchar *Var33=strchr(Var2,; ); \nFUNC8(Var1,Var2); \nif (!Var33){\nchar *Var34=strchr(Var30+1,); \nconst bool  Var35=Var30[2]== >; \nVar29=strdup(Var2); \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC9(Var1,Var2,Var11); \nif (!Var30){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC4(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38\nif (Var9&&(Var9[1]== ||Var9[1]==  Var39)){\n*Var9=0; \nif (*Var2 != ){\nVar9=(char *) FUNC11(Var2,; ,Var7); \nif (Var3&&Var9){\nint  Var17; \n*Var9=0; \nif (FUNC12(Var1,Var2) == -1){\nVar2=Var9+1; \nVar17=FUNC12(Var1,Var2); \n*Var9=; ; \nVar9=(char *) FUNC11(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC13(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC14(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nVar17=*Var2 FUNC15(Var1,STRING,Var2) 0; \nelse \n}else if (Var9[1]){//STRING\nint  Var41=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var42=FUNC16(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC11(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nVar17=FUNC4(Var1->memberVar5,Var2); \nif (Var17 == -1){\nFUNC6(STRING,Var2); \nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nint  Var43=0; \nif (Var2<Var9&&Var9[-1]== ){\nFUNC17(Var1,Var43,Var2); \nFUNC18(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC19()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var31){\nchar  Var44[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var31){\nif (!*Var11){\nif (!Var1->memberVar7){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC10(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var45=1; \nint  Var46=FUNC20(Var1->memberVar8,STRING); \nint  Var47=false ; \nint  Var48=FUNC20(Var1->memberVar8,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC21(Var9[-2])){\nchar *Var49=Var9-1; \nconst bool  Var50=(Var9[1]== >); \nif (*Var11 == ){\nchar *Var51=FUNC22(Var1,Var2); \nchar *Var52=FUNC23(Var1->memberVar5,Var11,1); \nchar *Var53=FUNC24(STRING,Var52,Var51); \nelse \nchar *Var54=FUNC24(STRING,Var51); \nelse \nchar *Var54=FUNC24(STRING,Var51); \nelse \n}else if (Var45>0){\nif (Var18 != -1){\nVar17=FUNC12(Var1,Var2); \nconst char *Var55=FUNC25(Var1->memberVar8,STRING); \nVar9=strchr(Var2,); \nif (Var9){\nif (Var9>Var2){\nchar *Var40=Var9-1; \nif (*Var40 == ){\nmemmove(Var40,Var9,strlen(Var9)+1); \nbool  Var56=false ; \nif (Var9[1]== ){\nmemmove(Var9,Var9+1,strlen(Var9)); \nVar10=strchr(Var9+1,); \nif (Var56){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \n*Var9=0; \nif (Var9[1]== !){\nVar11=FUNC26(Var1,Var9+1); \nelse \nint  Var48=FUNC20(Var1->memberVar8,STRING); \nVar11=FUNC22(Var1,Var9+1); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nVar2=FUNC27(strdup(Var2),Var11); \nVar17=FUNC12(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var32=strstr(Var2,STRING); \nif (Var32){\nbool  Var57=false ; \nif (Var57){\nif (*Var2 != .){\nVar13=FUNC28(Var2,Var7); \nif (*Var2 != ){\nVar9=strchr(Var2,); \nVar26=Var1->memberVar9=Var9 true false ; \nint  Var58=0; \nif (Var9){\nchar *Var59,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var60=Var1->memberVar10; \nbool  Var61=false ; \nchar *Var62=NULL ; \nconst char *Var63=NULL ; \nbool  Var64=false ; \nbool  Var65=false ; \nchar *Var66=NULL ; \nchar *Var67=NULL ; \nbool  Var68=false ; \nint  Var69=-1; \nint  Var70,Var71; \nSTRUCT6 *Var44; \n*Var9  Var31=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var31){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var72; \nVar9=FUNC29(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var73=strdup(Var9+2); \nchar *Var74=strchr(Var73,=); \nif (Var74){\n*Var74  Var31=0; \nFUNC30(Var73,Var74); \nFUNC31(Var5,Var73); \nelse \nfree(Var73); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); \nFUNC33(Var1,FUNC34((Var75) Var60-(Var75) Var1->memberVar10)); \nelse \nVar60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); \nFUNC35(Var1,Var60,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar68=FUNC36(Var1->memberVar11,Var9+2); \nint  Var76=(int ) FUNC37(Var1->memberVar6,Var9+2); \nSTRUCT7 *Var77=FUNC38(Var1->memberVar12,Var1->memberVar10); \nif (Var77){\nif (Var76<0){\nVar76=Var77->memberVar1+Var76; \nif (Var76 >= 0&&Var76<Var77->memberVar1){\nSTRUCT8  Var78=FUNC39(Var77,Var76); \nFUNC35(Var1,Var77->memberVar2+Var78,1); \nelse \nFUNC6(STRING,Var77->memberVar1); \nVar59=FUNC40(Var9+2,&Var70); \nif (Var59){\nSTRUCT9 *Var79=FUNC41((const STRUCT6 *) Var59,Var70); \nSTRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); \nif (Var80){\nif (Var14){\nFUNC43(Var14); \nVar14=Var80; \nif (Var15){\nFUNC44(Var1->memberVar8,STRING,1); \nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); \nif (Var44){\nfree(Var1->memberVar13); \nmemcpy(Var1->memberVar13,Var59,Var70); \nfree(Var59); \nelse \nFUNC6(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var82; \nchar *Var83=strdup(Var9+2); \nchar *Var84=FUNC47(Var83); \nif (Var84){\nchar  Var40=*Var84; \n*Var84=0; \nVar82=FUNC48(Var1->memberVar14,Var83); \n*Var84=Var40; \nVar82=FUNC37(Var1->memberVar6,Var85); \nelse \nVar82=FUNC48(Var1->memberVar14,Var9+2); \nFUNC35(Var1,Var82,1); \nfree(Var83); \nVar64=FUNC49(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var62); \nVar28=FUNC20(Var1->memberVar8,STRING); \nFUNC44(Var1->memberVar8,STRING,1); \nSTRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); \nif (memberVar2){\nFUNC15(Var1,STRING,Var9+2); \nchar *Var2=FUNC50(Var1,Var9+2); \nif (!Var66){\nVar66=Var2; \nelse \nVar66=FUNC51(Var66,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar44=malloc(strlen(Var9+2)+1); \nif (Var44){\nVar71=FUNC52(Var9+2,Var44); \nFUNC33(Var1,FUNC34(Var71)); \nif (Var71>0){\nSTRUCT9 *Var79=FUNC41(Var44,Var71); \nSTRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); \nif (Var80){\nif (Var14){\nFUNC43(Var14); \nVar14=Var80; \nif (Var15){\nFUNC44(Var1->memberVar8,STRING,1); \nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); \nFUNC33(Var1,Var71); \nfree(Var44); \nchar *Var86=FUNC53(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var86){\nFUNC35(Var1,FUNC37(Var1->memberVar6,Var86),1); \nfree(Var86); \nif (Var9[1]== ){\nVar69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC54(Var1->memberVar1,FUNC55(Var9+2)); \nif (Var9[1]== ){\nchar *Var34=strchr(Var9+2,); \nif (Var34){\n*Var34  Var31=0; \nint  Var87=FUNC37(Var1->memberVar6,Var34); \nVar64=FUNC49(Var1,Var87,&Var62); \nVar65=FUNC56(Var1,Var9+2,&Var67); \nVar71=strlen(Var9+2); \nFUNC33(Var1,Var71); \nconst STRUCT6 *Var44=(const STRUCT6 *) FUNC57(Var9+2); \nif (Var71>0){\nSTRUCT9 *Var79=FUNC41(Var44,Var71); \nSTRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC44(Var1->memberVar8,STRING,1); \nif (Var80){\nif (Var14){\nFUNC43(Var14); \nVar14=Var80; \nif (Var15){\nFUNC44(Var1->memberVar8,STRING,1); \nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); \nFUNC33(Var1,Var71); \n*Var9=; \nchar *Var88=Var9-2; \nwhile (Var88>Var2){\nif (!FUNC58(*Var88)){\n*Var88=0; \nVar88  Var72; \nVar9=FUNC59(Var9+1)-1; \nVar2=FUNC13(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nelse \n*Var10=0; \nif (!Var10[1]){\nFUNC33(\nVar1,FUNC37(Var1->memberVar6,Var10+1)); \nVar63=FUNC59(Var9+1); \nmemberVar2=FUNC37(Var1->memberVar6,Var63); \nif (FUNC60((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC61(Var1->memberVar11,Var9+1)){\nFUNC6(STRING,Var9+1); \nelse \nchar  Var40=*Var63; \nif (Var40 == -||Var40 == +){\nmemberVar2=Var1->memberVar10+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var80=Var14; \nif (Var80){\nFUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,memberVar2,FUNC62(Var80)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar1->memberVar16=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var89=Var9+3; \nwhile (*Var89&&*Var89 == ){\nVar89  Var31; \nVar17=FUNC63(Var1,Var2,Var89); \nelse \nVar17=FUNC64(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var90[]={STRING,STRING,STRING,\nconst char *Var91[]={STRING,STRING,STRING,\nSTRUCT4  Var92[FUNC65(Var90)-1],Var93[FUNC65(Var91)-1]; \nif (Var9[1]== (){\nchar *Var94=Var9+3; \nchar *Var30=strchr(Var94,); \nif (!Var30){\nfree(Var66); \n*Var30=Var95; \nSTRUCT4  Var96=FUNC37(Var1->memberVar6,Var94); \nSTRUCT4  Var97=FUNC37(Var1->memberVar6,Var30+1); \nfor (Var16=0; Var90[Var16]; Var16  Var31){\nVar92[Var16]=FUNC20(Var1->memberVar8,Var90[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var31){\nVar93[Var16]=FUNC20(Var1->memberVar8,Var91[Var16]); \nfor (Var16=0; Var90[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var90[Var16],Var96); \nfor (Var16=0; Var91[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var91[Var16],Var97); \nif (Var19){\nif (Var61){\nVar1->memberVar10=memberVar2; \nVar17=FUNC4(Var1->memberVar5,FUNC59(Var2)); \nelse \nif (Var61){\nif (Var9[1]){\nFUNC35(Var1,memberVar2,1); \nVar17=FUNC4(Var1->memberVar5,FUNC59(Var2)); \nif (memberVar9){\nfor (Var16=0; Var90[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var90[Var16],Var92[Var16]); \nfor (Var16=0; Var91[Var16]; Var16  Var31){\nFUNC44(Var1->memberVar8,Var91[Var16],Var93[Var16]); \nif (Var10){\n*Var10=!; \nif (Var69 != -1){\nFUNC54(Var1->memberVar1,Var69); \nif (Var14){\nif (Var15){\nFUNC44(Var1->memberVar8,STRING,0); \nFUNC43(Var14); \nif (Var64){\nFUNC66(Var1->memberVar8,STRING,Var62); \nif (Var66){\nFUNC8(Var1,Var66); \nFUNC67(Var66); \nif (Var68){\nFUNC68(Var1->memberVar11); \n*Var9=; \nVar58=Var17; \nVar58=Var2 FUNC4(Var1->memberVar5,FUNC59(Var2)) false ; \nif (Var20 != -1){\nFUNC44(Var1->memberVar8,STRING,Var20); \nif (Var21 != -1){\nFUNC44(Var1->memberVar8,STRING,Var21); \nif (Var14){\nFUNC43(Var14); \nif (memberVar9){\n*memberVar9=Var26; \nif (Var28 != -1){\nFUNC44(Var1->memberVar8,STRING,Var28); \nreturn  Var58; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 565,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3100,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC3(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC4(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC5(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC6(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){\nVar7=strchr(Var2,&); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nif (Var7){\nif (FUNC7()->memberVar1){\nif (Var7[1]== <){\nchar  Var33[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var34=FUNC8(Var1->memberVar7,STRING); \nint  Var35=false ; \nint  Var36=FUNC8(Var1->memberVar7,STRING); \nif (!*Var9){\nchar *Var37=Var7-1; \nconst bool  Var38=(Var7[1]== >); \nchar *Var39=FUNC9(Var1,Var2); \nchar *Var40=FUNC10(Var1->memberVar8,Var9,1); \nconst char *Var41=FUNC11(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nbool  Var42=false ; \nif (Var42){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var36=FUNC8(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var43=strstr(Var2,STRING); \nif (Var43){\nbool  Var44=false ; \nif (Var44){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var45,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var46=Var1->memberVar10; \nbool  Var47=false ; \nchar *Var48=NULL ; \nconst char *Var49=NULL ; \nbool  Var50=false ; \nbool  Var51=false ; \nchar *Var52=NULL ; \nchar *Var53=NULL ; \nbool  Var54=false ; \nint  Var55,Var56; \nSTRUCT5 *Var33; \n*Var7  Var32=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var32){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var57; \nVar7=FUNC12(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var58=strdup(Var7+2); \nchar *Var59=strchr(Var58,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar54=FUNC14(Var1->memberVar11,Var7+2); \nint  Var60=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var61=FUNC16(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var62=FUNC17(Var61,Var60); \nVar45=FUNC18(Var7+2,&Var55); \nif (Var45){\nSTRUCT8 *Var63=FUNC19((const STRUCT5 *) Var45,Var55); \nSTRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); \nelse \nFUNC21(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var66; \nchar *Var67=strdup(Var7+2); \nchar *Var68=FUNC22(Var67); \nif (Var68){\nchar  Var29=*Var68; \nelse \nVar66=FUNC23(Var1->memberVar13,Var7+2); \nVar50=FUNC24(Var1,FUNC15(Var1->memberVar5,Var7+2),&Var48); \nSTRUCT3  Var46=FUNC15(Var1->memberVar5,Var7+2); \nif (Var46){\nFUNC25(Var1,STRING,Var7+2); \nchar *Var2=FUNC26(Var1,Var7+2); \nif (Var7[1]== ){\nVar33=malloc(strlen(Var7+2)+1); \nif (Var33){\nVar56=FUNC27(Var7+2,Var33); \nSTRUCT8 *Var63=FUNC19(Var33,Var56); \nSTRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); \nchar *Var69=FUNC28(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC29(Var1->memberVar1,FUNC30(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var70=FUNC15(Var1->memberVar5,Var27); \nVar51=FUNC31(Var1,Var7+2,&Var53); \nVar56=strlen(Var7+2); \nconst STRUCT5 *Var33=(const STRUCT5 *) FUNC32(Var7+2); \nSTRUCT8 *Var63=FUNC19(Var33,Var56); \nSTRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); \n*Var7=; \nchar *Var71=Var7-2; \nVar7=FUNC33(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC34(\nVar1,FUNC15(Var1->memberVar5,Var8+1)); \nVar49=FUNC33(Var7+1); \nif (FUNC35((STRUCT5) Var7[1])&&!Var46){\nif (!FUNC36(Var1->memberVar11,Var7+1)){\nFUNC21(STRING,Var7+1); \nelse \nchar  Var29=*Var49; \nSTRUCT2 *Var64=Var12; \nif (Var10){\nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var72=Var7+3; \nelse \nVar15=FUNC37(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var73[]={STRING,STRING,STRING,\nconst char *Var74[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var75=Var7+3; \nchar *Var25=strchr(Var75,); \nif (!Var25){\nSTRUCT3  Var76=FUNC15(Var1->memberVar5,Var75); \nSTRUCT3  Var77=FUNC15(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var47){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 566,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3116,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_break_push (NULL, NULL);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\t\tarroba = NULL;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\ttmpdesc = NULL;\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\t\ttmpdesc = NULL;\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nint  Var20=-1; \nint  Var21=-1; \nbool  Var22=false ; \nbool  Var23=false ; \nbool  Var24=Var1->memberVar2; \nbool  Var25=Var1->memberVar3; \nbool  Var26=false ; \nSTRUCT4  Var27=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nfor (; *Var2; ){\nchar *Var28,*Var29; \nif (Var23){\nVar29=*Var2 FUNC4(Var2) NULL ; \nif (!Var29||!*Var29){\nelse \nchar *Var30=strchr(Var2,; ); \nif (!Var30){\nif (*Var29){\nif (Var29[1]== ||(Var29[1]&&Var29[2]== )){\nchar *Var31=strchr(Var29+1,); \nVar23=Var31 != NULL ; \nconst bool  Var32=Var29[2]== >; \nif (!Var29){\nif (Var22){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC5(Var2,,STRING); //Var33  Var34  Var7  Var35\nif (Var9&&(Var9[1]== ||Var9[1]==  Var36)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC6(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var37=Var9-1; \nif (*Var37 == ){\nmemmove(Var37,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC7(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC8(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var38=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC9(Var1,Var2,Var9+1); \nelse \nchar *Var39=FUNC10(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC6(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var40){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nif (Var2<Var9&&Var9[-1]== ){\nFUNC11(NULL ,NULL ); \nFUNC12(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC13()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var40){\nchar  Var41[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var40){\nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC5(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var37=Var9-1; \nif (*Var37 == ){\nmemmove(Var37,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var42=FUNC14(Var1->memberVar7,STRING); \nint  Var43=false ; \nint  Var44=FUNC14(Var1->memberVar7,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC15(Var9[-2])){\nchar *Var45=Var9-1; \nconst bool  Var46=(Var9[1]== >); \nchar *Var47=FUNC16(Var1,Var2); \nchar *Var48=FUNC17(Var1->memberVar8,Var11,1); \nconst char *Var49=FUNC18(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var37=Var9-1; \nif (*Var37 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var10){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var44=FUNC14(Var1->memberVar7,STRING); \nif (!Var11){\nif (*Var11 == |||*Var11 == *){\nif (*Var2 != &&*Var2){\nconst char *Var51=strstr(Var2,STRING); \nif (Var51){\nbool  Var52=false ; \nif (Var52){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nVar26=Var1->memberVar9=Var9 true false ; \nint  Var53=0; \nif (Var9){\nchar *Var54,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var55=Var1->memberVar10; \nbool  Var56=false ; \nchar *Var57=NULL ; \nconst char *Var58=NULL ; \nbool  Var59=false ; \nbool  Var60=false ; \nchar *Var61=NULL ; \nchar *Var62=NULL ; \nbool  Var63=false ; \nint  Var64=-1; \nint  Var65,Var66; \nSTRUCT6 *Var41; \n*Var9  Var40=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nif (Var12){\n*Var12=0; \nfor (; *Var9 == ; Var9  Var40){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var67; \nVar9=FUNC19(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var68=strdup(Var9+2); \nchar *Var69=strchr(Var68,=); \nif (Var69){\n*Var69  Var40=0; \nFUNC20(Var68,Var69); \nFUNC21(Var5,Var68); \nelse \nfree(Var68); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+4); \nFUNC23(Var1,FUNC24((Var70) Var55-(Var70) Var1->memberVar10)); \nelse \nVar55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+3); \nFUNC25(Var1,Var55,1); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar63=FUNC26(Var1->memberVar11,Var9+2); \nint  Var71=(int ) FUNC27(Var1->memberVar5,Var9+2); \nSTRUCT7 *Var72=FUNC28(Var1->memberVar12,Var1->memberVar10); \nif (Var72){\nif (Var71<0){\nVar71=Var72->memberVar1+Var71; \nif (Var71 >= 0&&Var71<Var72->memberVar1){\nSTRUCT8  Var73=FUNC29(Var72,Var71); \nFUNC25(Var1,Var72->memberVar2+Var73,1); \nVar54=FUNC30(Var9+2,&Var65); \nif (Var54){\nSTRUCT9 *Var74=FUNC31((const STRUCT6 *) Var54,Var65); \nSTRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); \nif (Var75){\nif (Var14){\nFUNC33(Var14); \nVar14=Var75; \nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); \nif (Var41){\nmemcpy(Var1->memberVar13,Var54,Var65); \nfree(Var54); \nelse \nFUNC36(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var77; \nchar *Var78=strdup(Var9+2); \nchar *Var79=FUNC37(Var78); \nif (Var79){\nchar  Var37=*Var79; \n*Var79=0; \nVar77=FUNC38(Var1->memberVar14,Var78); \n*Var79=Var37; \nelse \nVar77=FUNC38(Var1->memberVar14,Var9+2); \nFUNC25(Var1,Var77,1); \nfree(Var78); \nVar59=FUNC39(Var1,FUNC27(Var1->memberVar5,Var9+2),&Var57); \nSTRUCT4  memberVar2=FUNC27(Var1->memberVar5,Var9+2); \nif (memberVar2){\nFUNC40(Var1,STRING,Var9+2); \nchar *Var2=FUNC41(Var1,Var9+2); \nif (!Var61){\nVar61=Var2; \nelse \nVar61=FUNC42(Var61,Var2); \nfree(Var2); \nif (Var9[1]== ){\nVar41=malloc(strlen(Var9+2)+1); \nif (Var41){\nVar66=FUNC43(Var9+2,Var41); \nFUNC23(Var1,FUNC24(Var66)); \nif (Var66>0){\nSTRUCT9 *Var74=FUNC31(Var41,Var66); \nSTRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); \nif (Var75){\nif (Var14){\nFUNC33(Var14); \nVar14=Var75; \nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); \nFUNC23(Var1,Var66); \nfree(Var41); \nchar *Var80=FUNC44(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var80){\nFUNC25(Var1,FUNC27(Var1->memberVar5,Var80),1); \nfree(Var80); \nif (Var9[1]== ){\nFUNC45(Var1->memberVar1,FUNC46(Var9+2)); \nif (Var9[1]== ){\nchar *Var31=strchr(Var9+2,); \nif (Var31){\n*Var31  Var40=0; \nint  Var81=FUNC27(Var1->memberVar5,Var31); \nVar59=FUNC39(Var1,Var81,&Var57); \nVar60=FUNC47(Var1,Var9+2,&Var62); \nVar66=strlen(Var9+2); \nFUNC23(Var1,Var66); \nconst STRUCT6 *Var41=(const STRUCT6 *) FUNC48(Var9+2); \nif (Var66>0){\nSTRUCT9 *Var74=FUNC31(Var41,Var66); \nSTRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); \nif (Var75){\nif (Var14){\nFUNC33(Var14); \nVar14=Var75; \nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); \nFUNC23(Var1,Var66); \n*Var9=; \nchar *Var82=Var9-2; \nwhile (Var82>Var2){\nif (!FUNC49(*Var82)){\n*Var82=0; \nVar82  Var67; \nVar9=FUNC50(Var9+1)-1; \nVar2=FUNC7(Var2); \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar58=FUNC50(Var9+1); \nmemberVar2=FUNC27(Var1->memberVar5,Var58); \nif (FUNC51((STRUCT6) Var9[1])&&!memberVar2){\nif (!FUNC52(Var1->memberVar11,Var9+1)){\nFUNC36(STRING,Var9+1); \nelse \nchar  Var37=*Var58; \nif (Var37 == -||Var37 == +){\nmemberVar2=Var1->memberVar10+memberVar2; \nif (memberVar2){\nSTRUCT3 *Var75=Var14; \nif (Var75){\nFUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,memberVar2,FUNC53(Var75)); \nif (Var12){\nVar9=Var12+1; \n*Var12=; \nVar12=NULL ; \nVar1->memberVar16=!!Var14; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var83=Var9+3; \nwhile (*Var83&&*Var83 == ){\nVar83  Var40; \nVar17=FUNC54(Var1,Var2,Var83); \nelse \nVar17=FUNC55(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var84[]={STRING,STRING,STRING,\nconst char *Var85[]={STRING,STRING,STRING,\nSTRUCT4  Var86[FUNC56(Var84)-1],Var87[FUNC56(Var85)-1]; \nif (Var9[1]== (){\nchar *Var88=Var9+3; \nchar *Var29=strchr(Var88,); \nif (!Var29){\nfree(Var61); \n*Var29=Var89; \nSTRUCT4  Var90=FUNC27(Var1->memberVar5,Var88); \nSTRUCT4  Var91=FUNC27(Var1->memberVar5,Var29+1); \nfor (Var16=0; Var84[Var16]; Var16  Var40){\nVar86[Var16]=FUNC14(Var1->memberVar7,Var84[Var16]); \nfor (Var16=0; Var85[Var16]; Var16  Var40){\nVar87[Var16]=FUNC14(Var1->memberVar7,Var85[Var16]); \nfor (Var16=0; Var84[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var84[Var16],Var90); \nfor (Var16=0; Var85[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var85[Var16],Var91); \nif (Var19){\nif (Var56){\nVar1->memberVar10=memberVar2; \nVar17=FUNC58(Var1->memberVar8,FUNC50(Var2)); \nelse \nif (Var56){\nif (Var9[1]){\nFUNC25(Var1,memberVar2,1); \nVar17=FUNC58(Var1->memberVar8,FUNC50(Var2)); \nif (memberVar9){\nfor (Var16=0; Var84[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var84[Var16],Var86[Var16]); \nfor (Var16=0; Var85[Var16]; Var16  Var40){\nFUNC57(Var1->memberVar7,Var85[Var16],Var87[Var16]); \nif (Var64 != -1){\nFUNC45(Var1->memberVar1,Var64); \nif (Var14){\nif (Var15){\nFUNC57(Var1->memberVar7,STRING,0); \nFUNC33(Var14); \nVar14=NULL ; \nif (Var59){\nFUNC59(Var1->memberVar7,STRING,Var57); \nif (Var61){\nFUNC60(Var1,Var61); \nFUNC61(Var61); \nif (Var63){\nFUNC62(Var1->memberVar11); \n*Var9=; \nVar53=Var17; \nVar53=Var2 FUNC58(Var1->memberVar8,FUNC50(Var2)) false ; \nif (Var20 != -1){\nFUNC57(Var1->memberVar7,STRING,Var20); \nif (Var21 != -1){\nFUNC57(Var1->memberVar7,STRING,Var21); \nif (Var14){\nFUNC33(Var14); \nVar14=NULL ; \nreturn  Var53; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 567,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3136,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=false ; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT4  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC4(Var2,,STRING); //Var31  Var32  Var7  Var33\nif (Var9&&(Var9[1]== ||Var9[1]==  Var34)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC5(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var35=Var9-1; \nif (*Var35 == ){\nmemmove(Var35,Var9,strlen(Var9)+1); \nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC6(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC7(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var9+1); \nelse \nchar *Var37=FUNC9(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC5(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var38){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nif (Var2<Var9&&Var9[-1]== ){\nFUNC10(Var9+2,STRING); \nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC11()->memberVar1){\nif (Var9[1]== <){\nfor (Var11=Var9+2; Var11[0]== ; Var11  Var38){\nchar  Var39[1024]; \nint  Var17; \nelse \nfor (Var11=Var9+1; *Var11 == ; Var11  Var38){\nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC4(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var35=Var9-1; \nif (*Var35 == ){\nmemmove(Var35,Var9,strlen(Var9)+1); \nif (Var9[0]&&Var9[1]== ){\nint  Var40=FUNC12(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC12(Var1->memberVar7,STRING); \n*Var9=0; \nVar11=FUNC3(Var9+1+(Var9[1]== >)); \nif (!*Var11){\nif (Var9>(Var2+1)&&FUNC13(Var9[-2])){\nchar *Var43=Var9-1; \nconst bool  Var44=(Var9[1]== >); \nchar *Var45=FUNC14(Var1,Var2); \nchar *Var46=FUNC15(Var1->memberVar8,Var11,1); \nconst char *Var47=FUNC16(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var35=Var9-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC12(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nVar24=Var1->memberVar9=Var9 true false ; \nif (Var9){\nchar *Var51,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var52=Var1->memberVar10; \nbool  Var53=false ; \nchar *Var54=NULL ; \nconst char *Var55=NULL ; \nbool  Var56=false ; \nbool  Var57=false ; \nchar *Var58=NULL ; \nchar *Var59=NULL ; \nbool  Var60=false ; \nint  Var61,Var62; \nSTRUCT6 *Var39; \n*Var9  Var38=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nfor (; *Var9 == ; Var9  Var38){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var63; \nVar9=FUNC17(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var64=strdup(Var9+2); \nchar *Var65=strchr(Var64,=); \nif (Var65){\n*Var65  Var38=0; \nFUNC18(Var64,Var65); \nFUNC19(Var5,Var64); \nelse \nfree(Var64); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nif (Var9[3]== .){//STRING\nSTRUCT4  Var52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+4); \nelse \nVar52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+3); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nVar60=FUNC21(Var1->memberVar11,Var9+2); \nint  Var66=(int ) FUNC22(Var1->memberVar5,Var9+2); \nSTRUCT7 *Var67=FUNC23(Var1->memberVar12,Var1->memberVar10); \nSTRUCT8  Var68=FUNC24(Var67,Var66); \nVar51=FUNC25(Var9+2,&Var61); \nif (Var51){\nSTRUCT9 *Var69=FUNC26((const STRUCT6 *) Var51,Var61); \nSTRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); \nelse \nFUNC28(STRING,Var9+3); \nif (Var9[1]== ){\nSTRUCT4  Var72; \nchar *Var73=strdup(Var9+2); \nchar *Var74=FUNC29(Var73); \nif (Var74){\nchar  Var35=*Var74; \nelse \nVar72=FUNC30(Var1->memberVar13,Var9+2); \nVar56=FUNC31(Var1,FUNC22(Var1->memberVar5,Var9+2),&Var54); \nSTRUCT4  Var52=FUNC22(Var1->memberVar5,Var9+2); \nif (Var52){\nFUNC32(Var1,STRING,Var9+2); \nchar *Var2=FUNC33(Var1,Var9+2); \nif (Var9[1]== ){\nVar39=malloc(strlen(Var9+2)+1); \nif (Var39){\nVar62=FUNC34(Var9+2,Var39); \nSTRUCT9 *Var69=FUNC26(Var39,Var62); \nSTRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); \nchar *Var75=FUNC35(Var1->memberVar14,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var9[1]== ){\nFUNC36(Var1->memberVar1,FUNC37(Var9+2)); \nif (Var9[1]== ){\nchar *Var29=strchr(Var9+2,); \nint  Var76=FUNC22(Var1->memberVar5,Var29); \nVar57=FUNC38(Var1,Var9+2,&Var59); \nVar62=strlen(Var9+2); \nconst STRUCT6 *Var39=(const STRUCT6 *) FUNC39(Var9+2); \nSTRUCT9 *Var69=FUNC26(Var39,Var62); \nSTRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); \n*Var9=; \nchar *Var77=Var9-2; \nVar9=FUNC40(Var9+1)-1; \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nVar55=FUNC40(Var9+1); \nif (FUNC41((STRUCT6) Var9[1])&&!Var52){\nif (!FUNC42(Var1->memberVar11,Var9+1)){\nFUNC28(STRING,Var9+1); \nelse \nchar  Var35=*Var55; \nSTRUCT3 *Var70=Var14; \nif (Var12){\nVar9=Var12+1; \nif (Var9[1]== ){\nif (Var9[2]== ){\nchar *Var78=Var9+3; \nelse \nVar17=FUNC43(Var1,Var2,Var9+2); \nelse \nbool  memberVar9=false ; \nconst char *Var79[]={STRING,STRING,STRING,\nconst char *Var80[]={STRING,STRING,STRING,\nif (Var9[1]== (){\nchar *Var81=Var9+3; \nchar *Var27=strchr(Var81,); \nif (!Var27){\nSTRUCT4  Var82=FUNC22(Var1->memberVar5,Var81); \nSTRUCT4  Var83=FUNC22(Var1->memberVar5,Var27+1); \nif (Var19){\nelse \nif (Var53){\n*Var9=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 568,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3137,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=Var1->memberVar2; \nbool  Var20=Var1->memberVar3; \nSTRUCT4  Var21=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var24+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27\nif (Var9&&(Var9[1]== ||Var9[1]==  Var28)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC5(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC6(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC7(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC8(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC5(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC9()->memberVar1){\nif (Var9[1]== <){\nint  Var17; \nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC4(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nif (Var9[0]&&Var9[1]== ){\nint  Var33=FUNC10(Var1->memberVar7,STRING); \nint  Var34=FUNC10(Var1->memberVar7,STRING); \n*Var9=0; \nif (!*Var11){\nchar *Var35=Var9-1; \nconst bool  Var36=(Var9[1]== >); \nchar *Var37=FUNC11(Var1,Var2); \nchar *Var38=FUNC12(Var1->memberVar8,Var11,1); \nconst char *Var39=FUNC13(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC10(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nif (Var9){\nchar *Var43,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var9  Var32=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nfor (; *Var9 == ; Var9  Var32){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var49; \nVar9=FUNC14(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var50=strdup(Var9+2); \nchar *Var51=strchr(Var50,=); \nif (Var51){\n*Var51  Var32=0; \nFUNC15(Var50,Var51); \nFUNC16(Var5,Var50); \nelse \nfree(Var50); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nSTRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nint  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); \nSTRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var9+2); \nchar  Var29=*Var58; \nSTRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); \nchar *Var2=FUNC21(Var1,Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); \nchar *Var23=strchr(Var9+2,); \nint  Var60=FUNC18(Var1->memberVar5,Var23); \nconst STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \n*Var9=; \nchar *Var62=Var9-2; \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nif (FUNC24((STRUCT7) Var9[1])&&!Var44){\nif (!FUNC25(Var1->memberVar12,Var9+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT3 *Var54=Var14; \nif (Var12){\nVar9=Var12+1; \nchar *Var63=Var9+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var9+3; \nchar *Var24=strchr(Var66,); \nSTRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); \nSTRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 569,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3143,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nSTRUCT2 *Var5=FUNC2(Var6); \nconst char *Var7=STRING; \nconst char *Var8=NULL ; \nchar *Var9,*Var10,*Var11; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT3 *Var14=NULL ; \nint  Var15=!Var1->memberVar1->memberVar1; \nint  Var16,Var17=0,Var18; \nbool  Var19=Var1->memberVar2; \nbool  Var20=Var1->memberVar3; \nSTRUCT4  Var21=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC3(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT5 */\nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var24+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27\nif (Var9&&(Var9[1]== ||Var9[1]==  Var28)){\n*Var9=0; \nif (*Var2 != ){\nif (Var3&&Var9){\nint  Var17; \nVar9=(char *) FUNC5(Var2,|,Var7); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nchar *Var10=strchr(Var2,); \nif (!Var10||(Var10&&Var10>Var9)){\nif (!Var8||(Var8&&Var8>Var9)){\n*Var9=0; \nVar2=FUNC6(Var2); \nif (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!FUNC7(Var9+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var9+1,STRING)){//STRING\nelse \n}else if (Var9[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC8(Var1->memberVar1,Var9+1); \nVar9=(char *) FUNC5(Var2,&,Var7); \nwhile (Var9&&*Var9&&Var9[1]== &){\n*Var9=0; \nif (Var17 == -1){\nfor (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){\nVar9=strchr(Var2,&); \nVar9=strstr(Var2,STRING); \nif (Var9&&(Var9 ==  Var2||Var9[-1]!= )){\nVar9[0]=0; \nif (*Var2 != ){\nVar9=strchr(Var2,<); \nif (Var9){\nVar9[0]=0; \nif (FUNC9()->memberVar1){\nif (Var9[1]== <){\nint  Var17; \nif (!*Var11){\nif (!Var1->memberVar6){\nelse \n}else if (Var9 ==  Var2){\nVar9=(char *) FUNC4(Var2,>,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nif (Var9[0]&&Var9[1]== ){\nint  Var33=FUNC10(Var1->memberVar7,STRING); \nint  Var34=FUNC10(Var1->memberVar7,STRING); \n*Var9=0; \nif (!*Var11){\nchar *Var35=Var9-1; \nconst bool  Var36=(Var9[1]== >); \nchar *Var37=FUNC11(Var1,Var2); \nchar *Var38=FUNC12(Var1->memberVar8,Var11,1); \nconst char *Var39=FUNC13(Var1->memberVar7,STRING); \nif (Var9){\nif (Var9>Var2){\nchar *Var29=Var9-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC10(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar9=strchr(Var2,); \nif (Var9 ==  Var2+1&&*Var2 == ){\nVar9=NULL ; \nelse \nVar9=NULL ; \nif (Var9){\nchar *Var43,*Var10=strchr(Var9+1,!); \nSTRUCT4  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var9  Var32=0; \nVar12=(Var9[0]&&Var9[1]&&Var9[2])\nfor (; *Var9 == ; Var9  Var32){\nif (*Var9&&Var9[1]== ){\nelse \nVar9  Var49; \nVar9=FUNC14(Var9); \nif (Var9[1]== ){\nelse \n}else if (Var9[1]== %){//STRING\nchar *Var50=strdup(Var9+2); \nchar *Var51=strchr(Var50,=); \nif (Var51){\nFUNC15(Var50,Var51); \nFUNC16(Var5,Var50); \nelse \nfree(Var50); \nelse \n}else if (Var9[1]== .){//STRING\nif (Var9[2]== .){//STRING\nSTRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); \nelse \n}else if (Var9[0]&&Var9[1]== &&Var9[2]){\nswitch (Var9[0]){\nint  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); \nSTRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var9+2); \nchar  Var29=*Var58; \nSTRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); \nchar *Var2=FUNC21(Var1,Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); \nchar *Var23=strchr(Var9+2,); \nint  Var60=FUNC18(Var1->memberVar5,Var23); \nconst STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); \nSTRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); \n*Var9=; \nchar *Var62=Var9-2; \nif (Var10){\nif (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&\n!memcmp(Var9+1,STRING,2)&&\n!memcmp(Var10+1,STRING,2)){\nelse \n}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){\nif (!Var10[1]){\nif (FUNC24((STRUCT7) Var9[1])&&!Var44){\nif (!FUNC25(Var1->memberVar12,Var9+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT3 *Var54=Var14; \nif (Var12){\nVar9=Var12+1; \nchar *Var63=Var9+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var9+3; \nchar *Var24=strchr(Var66,); \nSTRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); \nSTRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 570,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3207,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nint  Var6=!Var7->memberVar1->memberVar1; \nint  Var8,Var9=0,Var10; \nbool  Var11=Var7->memberVar2; \nbool  Var12=Var7->memberVar3; \nSTRUCT1  Var13=Var7->memberVar4; \nif (!Var14){\nswitch (*Var14){\nif (Var14[1]== ){/*STRUCT2 */\nelse \nchar *Var15=strchr(Var14,; ); \nif (Var14[1]!= *&&!strstr(Var14,STRING)){\nif (Var14[1]== >){\nif (*Var14 != ){\nif (Var16&&Var2){\nint  Var9; \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nchar *Var3=strchr(Var14,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var18=Var7->memberVar5->memberVar1; \nelse \nchar *Var19=FUNC2(Var7->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var9 == -1){\nif (Var2&&(Var2 ==  Var14||Var2[-1]!= )){\nif (*Var14 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nchar  Var20[1024]; \nint  Var9; \nif (!*Var4){\nif (!Var7->memberVar6){\nelse \n}else if (Var2 ==  Var14){\nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var21=FUNC4(Var7->memberVar7,STRING); \nint  Var22=FUNC4(Var7->memberVar7,STRING); \nif (!*Var4){\nchar *Var23=Var2-1; \nconst bool  Var24=(Var2[1]== >); \nchar *Var25=FUNC5(Var7,Var14); \nchar *Var26=FUNC6(Var7->memberVar8,Var4,1); \nconst char *Var27=FUNC7(Var7->memberVar7,STRING); \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nbool  Var28=false ; \nif (Var28){\nelse \nint  memberVar1=Var7->memberVar5->memberVar1; \nelse \nint  Var22=FUNC4(Var7->memberVar7,STRING); \nif (*Var14 != &&*Var14){\nconst char *Var29=strstr(Var14,STRING); \nif (Var29){\nbool  Var30=false ; \nif (Var30){\nif (Var2){\nchar *Var31,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var32=Var7->memberVar9; \nint  Var33,Var34; \nSTRUCT3 *Var20; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var35=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT1  Var32=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var36=(int ) FUNC9(Var7->memberVar5,Var2+2); \nSTRUCT4 *Var37=FUNC10(Var7->memberVar10,Var7->memberVar9); \nif (Var31){\nSTRUCT5 *Var38=FUNC11((const STRUCT3 *) Var31,Var33); \nSTRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); \nVar20=malloc(Var33); \nif (Var20){\nfree(Var7->memberVar11); \nVar7->memberVar11=Var20; \nVar7->memberVar4=Var33; \nmemcpy(Var7->memberVar11,Var31,Var33); \nelse \nFUNC13(STRING,Var33); \nchar *Var41=strdup(Var2+2); \nchar  Var17=*Var42; \nSTRUCT1  Var32=FUNC9(Var7->memberVar5,Var2+2); \nchar *Var14=FUNC14(Var7,Var2+2); \nSTRUCT5 *Var38=FUNC11(Var20,Var34); \nSTRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); \nchar *Var43=FUNC15(Var7->memberVar12,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var44=strchr(Var2+2,); \nint  Var45=FUNC9(Var7->memberVar5,Var44); \nconst STRUCT3 *Var20=(const STRUCT3 *) FUNC16(Var2+2); \nSTRUCT5 *Var38=FUNC11(Var20,Var34); \nSTRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); \nchar *Var46=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC17((STRUCT3) Var2[1])&&!Var32){\nif (!FUNC18(Var7->memberVar13,Var2+1)){\nelse \nchar  Var17=*Var47; \nif (Var5){\nchar *Var48=Var2+3; \nchar *Var49=Var2+3; \nSTRUCT1  Var50=FUNC9(Var7->memberVar5,Var49); \nSTRUCT1  Var51=FUNC9(Var7->memberVar5,Var52+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 571,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3209,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nint  Var26=-1; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nSTRUCT3  Var27=Var28; \nchar *Var29,*Var30; \nif (Var21){\nif (!Var30||!*Var30){\nelse \nchar *Var31=strchr(Var2,; ); \nFUNC4(Var1,Var2); \nif (!Var31){\nif (*Var30){\nif (Var30[1]== ||(Var30[1]&&Var30[2]== )){\nchar *Var32=strchr(Var30+1,); \nVar27=Var1->memberVar6; \nFUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); \nconst bool  Var33=Var30[2]== >; \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC7(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var29); \nif (Var27 !=  Var28){\nFUNC5(Var1,Var27,1); \nif (!Var30){\nif (Var20){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC8(Var1,Var34); \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (FUNC9(Var1,Var2) == -1){\nVar15=FUNC9(Var1,Var2); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\nVar2=FUNC10(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nFUNC8(Var1,Var36); \nelse \n}else if (!FUNC11(Var7+1,STRING,1)){//STRING\nVar18=FUNC12(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar19=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,Var37); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC14(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var38=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var39=FUNC15(Var1->memberVar1,Var7+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar18=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,0); \nVar19=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,Var37); \nVar7=(char *) FUNC16(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var40){\nVar7=strchr(Var2,&); \nFUNC17(Var1->memberVar9); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nif (*Var2 != ){\nint  Var41=0; \nFUNC18(Var1,Var41,Var2); \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nif (Var7){\nif (FUNC19()->memberVar1){\nif (Var7[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var42[1024]; \nint  Var15; \nif (FUNC20(stdin)){\nVar1->memberVar10  STRUCT5  Var15; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var42,Var9)){\nstrcat((char *) Var1->memberVar9,Var42); \nif (!*Var9){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC21(Var9,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var7 ==  Var2){\nreturn FUNC22(Var1,(const char *) Var1->memberVar9); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nFUNC8(Var1,Var34); \nint  Var43=1; \nint  Var44=FUNC12(Var1->memberVar8,STRING); \nint  Var45=false ; \nint  Var46=FUNC12(Var1->memberVar8,STRING); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC23(Var7[-2])){\nchar *Var47=Var7-1; \nif (*Var47 ==  Var48){//STRING\nVar18=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var9,STRING)){\nFUNC13(Var1->memberVar8,STRING,Var37); \nconst bool  Var49=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var50=FUNC24(Var1,Var2); \nif (Var49){\nchar *Var51=FUNC25(Var1->memberVar5,Var9,1); \nif (Var51){\nchar *Var52=FUNC26(STRING,Var51,Var50); \nif (Var52){\nFUNC27(Var1->memberVar5,Var9,Var52,1); \nelse \nchar *Var53=FUNC26(STRING,Var50); \nFUNC27(Var1->memberVar5,Var9,Var53,1); \nelse \nchar *Var53=FUNC26(STRING,Var50); \nFUNC27(Var1->memberVar5,Var9,Var53,1); \nelse \n}else if (Var43>0){\nif (Var16 != -1){\nif (!Var44){\nFUNC13(Var1->memberVar8,STRING,Var37); \nVar15=FUNC9(Var1,Var2); \nif (!Var44){\nFUNC13(Var1->memberVar8,STRING,Var46); \nif (Var45){\nconst char *Var54=FUNC28(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,Var46); \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nVar1->memberVar11->memberVar1=false ; \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var55=false ; \nif (Var55){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC29(Var1,Var7+1); \nelse \nint  Var46=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar9=FUNC24(Var1,Var7+1); \nVar1->memberVar12=false ; \nFUNC13(Var1->memberVar8,STRING,Var46); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar15=FUNC9(Var1,Var2); \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (*Var2 != &&*Var2){\nconst char *Var56=strstr(Var2,STRING); \nif (Var56){\nbool  Var57=false ; \nif (Var57){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar13=Var7 true false ; \nint  Var58=0; \nif (Var7){\nchar *Var59,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var60=Var1->memberVar6; \nbool  Var61=false ; \nchar *Var62=NULL ; \nconst char *Var63=NULL ; \nbool  Var64=false ; \nbool  Var65=false ; \nchar *Var66=NULL ; \nchar *Var67=NULL ; \nbool  Var68=false ; \nint  Var69=-1; \nint  Var70,Var71; \nSTRUCT6 *Var42; \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var72=strdup(Var7+2); \nchar *Var73=strchr(Var72,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+4); \nFUNC31(Var1,FUNC32((Var74) Var60-(Var74) Var1->memberVar6)); \nelse \nVar60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+3); \nFUNC5(Var1,Var60,1); \nVar24=Var1->memberVar13=true ; \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar68=FUNC33(Var1->memberVar14,Var7+2); \nint  Var75=(int ) FUNC6(Var1->memberVar7,Var7+2); \nSTRUCT7 *Var76=FUNC34(Var1->memberVar15,Var1->memberVar6); \nif (Var76){\nif (Var75 >= 0&&Var75<Var76->memberVar1){\nSTRUCT8  Var77=FUNC35(Var76,Var75); \nFUNC5(Var1,Var76->memberVar2+Var77,1); \nVar24=Var1->memberVar13=true ; \nif (Var59){\nSTRUCT9 *Var78=FUNC36((const STRUCT6 *) Var59,Var70); \nSTRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,1); \nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); \nVar42=malloc(Var70); \nif (Var42){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var42; \nVar1->memberVar4=Var70; \nmemcpy(Var1->memberVar16,Var59,Var70); \nif (Var7[1]== ){\nSTRUCT3  Var81; \nchar *Var82=strdup(Var7+2); \nchar *Var83=FUNC40(Var82); \nif (Var83){\nchar  Var35=*Var83; \nVar81=FUNC41(Var1->memberVar17,Var82); \nVar81=FUNC6(Var1->memberVar7,Var84); \nelse \nVar81=FUNC41(Var1->memberVar17,Var7+2); \nFUNC5(Var1,Var81,1); \nVar24=Var1->memberVar13=true ; \nVar64=FUNC42(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var62); \nVar26=FUNC12(Var1->memberVar8,STRING); \nFUNC13(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); \nif (memberVar2){\nFUNC14(Var1,STRING,Var7+2); \nVar24=Var1->memberVar13=true ; \nchar *Var2=FUNC43(Var1,Var7+2); \nif (Var7[1]== ){\nif (Var42){\nFUNC31(Var1,FUNC32(Var71)); \nif (Var71>0){\nSTRUCT9 *Var78=FUNC36(Var42,Var71); \nSTRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); \nif (Var79){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,1); \nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); \nFUNC31(Var1,Var71); \nFUNC44(Var1); \nchar *Var85=FUNC45(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var85){\nFUNC5(Var1,FUNC6(Var1->memberVar7,Var85),1); \nif (Var7[1]== ){\nVar69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC46(Var1->memberVar1,FUNC47(Var7+2)); \nif (Var7[1]== ){\nchar *Var32=strchr(Var7+2,); \nif (Var32){\nint  Var86=FUNC6(Var1->memberVar7,Var32); \nVar64=FUNC42(Var1,Var86,&Var62); \nVar65=FUNC48(Var1,Var7+2,&Var67); \nFUNC31(Var1,Var71); \nconst STRUCT6 *Var42=(const STRUCT6 *) FUNC49(Var7+2); \nif (Var71>0){\nSTRUCT9 *Var78=FUNC36(Var42,Var71); \nSTRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC13(Var1->memberVar8,STRING,1); \nif (Var79){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,1); \nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); \nFUNC31(Var1,Var71); \nchar *Var87=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nFUNC31(\nVar1,FUNC6(Var1->memberVar7,Var8+1)); \nmemberVar2=FUNC6(Var1->memberVar7,Var63); \nif (FUNC50((STRUCT6) Var7[1])&&!memberVar2){\nif (!FUNC51(Var1->memberVar14,Var7+1)){\nelse \nchar  Var35=*Var63; \nif (Var35 == -||Var35 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var79=Var12; \nif (Var79){\nFUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC52(Var79)); \nif (Var10){\nVar1->memberVar19=!!Var12; \nif (Var1->memberVar19){\nFUNC44(Var1); \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var88=Var7+3; \nVar15=FUNC53(Var1,Var2,Var88); \nelse \nVar15=FUNC54(Var1,Var2,Var7+2); \nelse \nbool  memberVar13=false ; \nconst char *Var89[]={STRING,STRING,STRING,\nconst char *Var90[]={STRING,STRING,STRING,\nSTRUCT3  Var91[FUNC55(Var89)-1],Var92[FUNC55(Var90)-1]; \nif (Var7[1]== (){\nchar *Var93=Var7+3; \nchar *Var30=strchr(Var93,); \nif (!Var30){\nSTRUCT3  Var94=FUNC6(Var1->memberVar7,Var93); \nSTRUCT3  Var95=FUNC6(Var1->memberVar7,Var30+1); \nfor (Var14=0; Var89[Var14]; Var14  Var40){\nVar91[Var14]=FUNC12(Var1->memberVar8,Var89[Var14]); \nfor (Var14=0; Var90[Var14]; Var14  Var40){\nVar92[Var14]=FUNC12(Var1->memberVar8,Var90[Var14]); \nfor (Var14=0; Var89[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var89[Var14],Var94); \nfor (Var14=0; Var90[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var90[Var14],Var95); \nif (Var17){\nif (Var61){\nVar1->memberVar6=memberVar2; \nVar15=FUNC3(Var1->memberVar5,FUNC56(Var2)); \nelse \nif (Var61){\nif (Var7[1]){\nFUNC5(Var1,memberVar2,1); \nFUNC44(Var1); \nVar15=FUNC3(Var1->memberVar5,FUNC56(Var2)); \nif (memberVar13){\nfor (Var14=0; Var89[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var89[Var14],Var91[Var14]); \nfor (Var14=0; Var90[Var14]; Var14  Var40){\nFUNC13(Var1->memberVar8,Var90[Var14],Var92[Var14]); \nif (Var8){\nFUNC31(Var1,Var25); \nif (Var65){\nVar1->memberVar2=Var22; \nFUNC57(Var1->memberVar8,STRING,Var67); \nif (Var69 != -1){\nFUNC46(Var1->memberVar1,Var69); \nif (Var12){\nif (Var13){\nFUNC13(Var1->memberVar8,STRING,0); \nif (Var64){\nFUNC57(Var1->memberVar8,STRING,Var62); \nVar1->memberVar3=Var23; \nif (Var25 !=  Var1->memberVar4){\nFUNC31(Var1,Var25); \nif (Var66){\nFUNC4(Var1,Var66); \nif (Var68){\nFUNC58(Var1->memberVar14); \nVar58=Var2 FUNC3(Var1->memberVar5,FUNC56(Var2)) false ; \nif (Var18 != -1){\nFUNC13(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC13(Var1->memberVar8,STRING,Var19); \nVar1->memberVar2=Var22; \nVar1->memberVar3=Var23; \nif (Var26 != -1){\nFUNC13(Var1->memberVar8,STRING,Var26); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 572,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 3212,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nint  Var26=-1; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nSTRUCT3  Var27=Var28; \nchar *Var29,*Var30; \nif (Var21){\nif (!Var30||!*Var30){\nelse \nchar *Var31=strchr(Var2,; ); \nFUNC4(Var1,Var2); \nif (!Var31){\nif (*Var30){\nif (Var30[1]== ||(Var30[1]&&Var30[2]== )){\nchar *Var32=strchr(Var30+1,); \nVar27=Var1->memberVar6; \nFUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); \nconst bool  Var33=Var30[2]== >; \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC7(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var29); \nif (Var27 !=  Var28){\nFUNC5(Var1,Var27,1); \nif (!Var30){\nif (Var20){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC8(Var1,Var34); \nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37\nif (Var7&&(Var7[1]== ||Var7[1]==  Var38)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (FUNC10(Var1,Var2) == -1){\nVar15=FUNC10(Var1,Var2); \nVar7=(char *) FUNC11(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC12(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nFUNC8(Var1,Var40); \nelse \n}else if (!FUNC13(Var7+1,STRING,1)){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC16(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var42=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var43=FUNC17(Var1->memberVar1,Var7+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nVar7=(char *) FUNC11(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){\nVar7=strchr(Var2,&); \nFUNC18(Var1->memberVar9); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var45=0; \nFUNC19(Var1,Var45,Var2); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC20()->memberVar1){\nif (Var7[1]== <){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var46[1024]; \nint  Var15; \nif (FUNC21(stdin)){\nVar1->memberVar10  STRUCT5  Var15; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var46,Var9)){\nstrcat((char *) Var1->memberVar9,Var46); \nif (!*Var9){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC22(Var9,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var7 ==  Var2){\nreturn FUNC23(Var1,(const char *) Var1->memberVar9); \nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nif (Var7[0]&&Var7[1]== ){\nFUNC8(Var1,Var34); \nint  Var47=1; \nint  Var48=FUNC14(Var1->memberVar8,STRING); \nint  Var49=false ; \nint  Var50=FUNC14(Var1->memberVar8,STRING); \n*Var7=0; \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC24(Var7[-2])){\nchar *Var51=Var7-1; \nif (*Var51 ==  Var52){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var9,STRING)){\nFUNC15(Var1->memberVar8,STRING,Var41); \nconst bool  Var53=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var54=FUNC25(Var1,Var2); \nif (Var53){\nchar *Var55=FUNC26(Var1->memberVar5,Var9,1); \nif (Var55){\nchar *Var56=FUNC27(STRING,Var55,Var54); \nif (Var56){\nFUNC28(Var1->memberVar5,Var9,Var56,1); \nelse \nchar *Var57=FUNC27(STRING,Var54); \nFUNC28(Var1->memberVar5,Var9,Var57,1); \nelse \nchar *Var57=FUNC27(STRING,Var54); \nFUNC28(Var1->memberVar5,Var9,Var57,1); \nelse \n}else if (Var47>0){\nif (Var16 != -1){\nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var41); \nVar15=FUNC10(Var1,Var2); \nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var49){\nconst char *Var58=FUNC29(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar11->memberVar1=false ; \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nbool  Var59=false ; \nif (Var59){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC30(Var1,Var7+1); \nelse \nint  Var50=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar9=FUNC25(Var1,Var7+1); \nVar1->memberVar12=false ; \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar15=FUNC10(Var1,Var2); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (*Var2 != &&*Var2){\nconst char *Var60=strstr(Var2,STRING); \nif (Var60){\nbool  Var61=false ; \nif (Var61){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar13=Var7 true false ; \nint  Var62=0; \nif (Var7){\nchar *Var63,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var64=Var1->memberVar6; \nbool  Var65=false ; \nchar *Var66=NULL ; \nconst char *Var67=NULL ; \nbool  Var68=false ; \nbool  Var69=false ; \nchar *Var70=NULL ; \nchar *Var71=NULL ; \nbool  Var72=false ; \nint  Var73=-1; \nint  Var74,Var75; \nSTRUCT6 *Var46; \n*Var7  Var44=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var44){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var76; \nVar7=FUNC31(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var77=strdup(Var7+2); \nchar *Var78=strchr(Var77,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+4); \nFUNC33(Var1,FUNC34((Var79) Var64-(Var79) Var1->memberVar6)); \nelse \nVar64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+3); \nFUNC5(Var1,Var64,1); \nVar24=Var1->memberVar13=true ; \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar72=FUNC35(Var1->memberVar14,Var7+2); \nint  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); \nSTRUCT7 *Var81=FUNC36(Var1->memberVar15,Var1->memberVar6); \nif (Var81){\nif (Var80 >= 0&&Var80<Var81->memberVar1){\nSTRUCT8  Var82=FUNC37(Var81,Var80); \nFUNC5(Var1,Var81->memberVar2+Var82,1); \nVar24=Var1->memberVar13=true ; \nVar63=FUNC22(Var7+2,&Var74); \nif (Var63){\nSTRUCT9 *Var83=FUNC38((const STRUCT6 *) Var63,Var74); \nSTRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); \nVar46=malloc(Var74); \nif (Var46){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var46; \nVar1->memberVar4=Var74; \nmemcpy(Var1->memberVar16,Var63,Var74); \nelse \nFUNC42(STRING,Var74); \nfree(Var63); \nif (Var7[1]== ){\nSTRUCT3  Var86; \nchar *Var87=strdup(Var7+2); \nchar *Var88=FUNC43(Var87); \nif (Var88){\nchar  Var39=*Var88; \nVar86=FUNC44(Var1->memberVar17,Var87); \nVar86=FUNC6(Var1->memberVar7,Var89); \nelse \nVar86=FUNC44(Var1->memberVar17,Var7+2); \nFUNC5(Var1,Var86,1); \nVar24=Var1->memberVar13=true ; \nVar68=FUNC45(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); \nVar26=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); \nif (memberVar2){\nFUNC16(Var1,STRING,Var7+2); \nVar24=Var1->memberVar13=true ; \nchar *Var2=FUNC46(Var1,Var7+2); \nif (Var7[1]== ){\nif (Var46){\nFUNC33(Var1,FUNC34(Var75)); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC38(Var46,Var75); \nSTRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); \nFUNC33(Var1,Var75); \nFUNC47(Var1); \nchar *Var90=FUNC48(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var90){\nFUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); \nif (Var7[1]== ){\nVar73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC49(Var1->memberVar1,FUNC50(Var7+2)); \nif (Var7[1]== ){\nchar *Var32=strchr(Var7+2,); \nif (Var32){\nint  Var91=FUNC6(Var1->memberVar7,Var32); \nVar68=FUNC45(Var1,Var91,&Var66); \nVar69=FUNC51(Var1,Var7+2,&Var71); \nFUNC33(Var1,Var75); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC52(Var7+2); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC38(Var46,Var75); \nSTRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC15(Var1->memberVar8,STRING,1); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); \nFUNC33(Var1,Var75); \n*Var7=; \nchar *Var92=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nFUNC33(\nVar1,FUNC6(Var1->memberVar7,Var8+1)); \nmemberVar2=FUNC6(Var1->memberVar7,Var67); \nif (FUNC53((STRUCT6) Var7[1])&&!memberVar2){\nif (!FUNC54(Var1->memberVar14,Var7+1)){\nelse \nchar  Var39=*Var67; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var84=Var12; \nif (Var84){\nFUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC55(Var84)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar19=!!Var12; \nif (Var1->memberVar19){\nFUNC47(Var1); \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var93=Var7+3; \nVar15=FUNC56(Var1,Var2,Var93); \nelse \nVar15=FUNC57(Var1,Var2,Var7+2); \nelse \nbool  memberVar13=false ; \nconst char *Var94[]={STRING,STRING,STRING,\nconst char *Var95[]={STRING,STRING,STRING,\nSTRUCT3  Var96[FUNC58(Var94)-1],Var97[FUNC58(Var95)-1]; \nif (Var7[1]== (){\nchar *Var98=Var7+3; \nchar *Var30=strchr(Var98,); \nif (!Var30){\nSTRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); \nSTRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nVar96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nVar97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var99); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var100); \nif (Var17){\nif (Var65){\nVar1->memberVar6=memberVar2; \nVar15=FUNC3(Var1->memberVar5,FUNC59(Var2)); \nelse \nif (Var65){\nif (Var7[1]){\nFUNC5(Var1,memberVar2,1); \nFUNC47(Var1); \nVar15=FUNC3(Var1->memberVar5,FUNC59(Var2)); \nif (memberVar13){\nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); \nif (Var8){\nFUNC33(Var1,Var25); \nif (Var69){\nVar1->memberVar2=Var22; \nFUNC60(Var1->memberVar8,STRING,Var71); \nif (Var73 != -1){\nFUNC49(Var1->memberVar1,Var73); \nif (Var12){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,0); \nif (Var68){\nFUNC60(Var1->memberVar8,STRING,Var66); \nVar1->memberVar3=Var23; \nif (Var25 !=  Var1->memberVar4){\nFUNC33(Var1,Var25); \nif (Var70){\nFUNC4(Var1,Var70); \nif (Var72){\nFUNC61(Var1->memberVar14); \nVar62=Var2 FUNC3(Var1->memberVar5,FUNC59(Var2)) false ; \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar2=Var22; \nVar1->memberVar3=Var23; \nif (Var26 != -1){\nFUNC15(Var1->memberVar8,STRING,Var26); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 573,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3217,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var20=strchr(Var2,; ); \nchar *Var21=strchr(Var22+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25\nif (Var7&&(Var7[1]== ||Var7[1]==  Var26)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var28=Var1->memberVar5->memberVar1; \nelse \nchar *Var29=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nchar  Var31[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var32=FUNC9(Var1->memberVar7,STRING); \nint  Var33=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var34=Var7-1; \nconst bool  Var35=(Var7[1]== >); \nchar *Var36=FUNC10(Var1,Var2); \nchar *Var37=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var38=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nbool  Var39=false ; \nif (Var39){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var33=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var40=strstr(Var2,STRING); \nif (Var40){\nbool  Var41=false ; \nif (Var41){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var42,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var43=Var1->memberVar9; \nchar *Var44=NULL ; \nconst char *Var45=NULL ; \nchar *Var46=NULL ; \nchar *Var47=NULL ; \nint  Var48,Var49; \nSTRUCT5 *Var31; \n*Var7  Var30=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var30){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var50; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var51=strdup(Var7+2); \nchar *Var52=strchr(Var51,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); \nVar42=FUNC17(Var7+2,&Var48); \nif (Var42){\nSTRUCT7 *Var55=FUNC18((const STRUCT5 *) Var42,Var48); \nSTRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); \nif (Var31){\nmemcpy(Var1->memberVar11,Var42,Var48); \nfree(Var42); \nchar *Var58=strdup(Var7+2); \nchar  Var27=*Var59; \nSTRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC20(Var1,Var7+2); \nSTRUCT7 *Var55=FUNC18(Var31,Var49); \nSTRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); \nchar *Var60=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var21=strchr(Var7+2,); \nint  Var61=FUNC15(Var1->memberVar5,Var21); \nconst STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); \nSTRUCT7 *Var55=FUNC18(Var31,Var49); \nSTRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); \n*Var7=; \nchar *Var62=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC23((STRUCT5) Var7[1])&&!Var43){\nif (!FUNC24(Var1->memberVar13,Var7+1)){\nelse \nchar  Var27=*Var45; \nSTRUCT2 *Var56=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var7+3; \nchar *Var22=strchr(Var66,); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); \nSTRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 574,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3226,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \n*Var72=0; \nVar70=FUNC27(Var1->memberVar13,Var71); \n*Var72=Var33; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nfree(Var71); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar53=FUNC37(Var7+1); \nif (FUNC38((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC39(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC40(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 575,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3235,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tfree (numexpr);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nint  Var6=!Var7->memberVar1->memberVar1; \nint  Var8,Var9=0,Var10; \nbool  Var11=Var7->memberVar2; \nbool  Var12=Var7->memberVar3; \nSTRUCT1  Var13=Var7->memberVar4; \nif (!Var14){\nswitch (*Var14){\nif (Var14[1]== ){/*STRUCT2 */\nelse \nchar *Var15=strchr(Var14,; ); \nif (Var14[1]!= *&&!strstr(Var14,STRING)){\nif (Var14[1]== >){\nif (*Var14 != ){\nif (Var16&&Var2){\nint  Var9; \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nchar *Var3=strchr(Var14,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var18=Var7->memberVar5->memberVar1; \nelse \nchar *Var19=FUNC2(Var7->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var9 == -1){\nif (Var2&&(Var2 ==  Var14||Var2[-1]!= )){\nif (*Var14 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nint  Var9; \nif (!*Var4){\nif (!Var7->memberVar6){\nelse \n}else if (Var2 ==  Var14){\nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var20=FUNC4(Var7->memberVar7,STRING); \nint  Var21=FUNC4(Var7->memberVar7,STRING); \nif (!*Var4){\nchar *Var22=Var2-1; \nconst bool  Var23=(Var2[1]== >); \nchar *Var24=FUNC5(Var7,Var14); \nchar *Var25=FUNC6(Var7->memberVar8,Var4,1); \nconst char *Var26=FUNC7(Var7->memberVar7,STRING); \nif (Var2){\nif (Var2>Var14){\nchar *Var17=Var2-1; \nif (*Var17 == ){\nbool  Var27=false ; \nif (Var27){\nelse \nint  memberVar1=Var7->memberVar5->memberVar1; \nelse \nint  Var21=FUNC4(Var7->memberVar7,STRING); \nif (*Var14 != &&*Var14){\nconst char *Var28=strstr(Var14,STRING); \nif (Var28){\nbool  Var29=false ; \nif (Var29){\nif (Var2){\nchar *Var30,*Var3=strchr(Var2+1,!); \nSTRUCT1  Var31=Var7->memberVar9; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var32=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT1  Var31=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var33=(int ) FUNC9(Var7->memberVar5,Var2+2); \nSTRUCT3 *Var34=FUNC10(Var7->memberVar10,Var7->memberVar9); \nSTRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); \nif (Var2[1]== ){\nchar *Var38=strdup(Var2+2); \nchar *Var39=FUNC12(Var38); \nif (Var39){\nchar  Var17=*Var39; \nfree(Var40); \nSTRUCT1  Var31=FUNC9(Var7->memberVar5,Var2+2); \nchar *Var14=FUNC13(Var7,Var2+2); \nSTRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); \nchar *Var41=FUNC14(Var7->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var42=strchr(Var2+2,); \nint  Var43=FUNC9(Var7->memberVar5,Var42); \nconst STRUCT5 *Var44=(const STRUCT5 *) FUNC15(Var2+2); \nSTRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); \nchar *Var45=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC16((STRUCT5) Var2[1])&&!Var31){\nif (!FUNC17(Var7->memberVar12,Var2+1)){\nelse \nchar  Var17=*Var46; \nif (Var5){\nchar *Var47=Var2+3; \nchar *Var48=Var2+3; \nSTRUCT1  Var49=FUNC9(Var7->memberVar5,Var48); \nSTRUCT1  Var50=FUNC9(Var7->memberVar5,Var51+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 576,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3241,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var20=strchr(Var2,; ); \nchar *Var21=strchr(Var22+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25\nif (Var7&&(Var7[1]== ||Var7[1]==  Var26)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var28=Var1->memberVar5->memberVar1; \nelse \nchar *Var29=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var31=FUNC9(Var1->memberVar7,STRING); \nint  Var32=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var33=Var7-1; \nconst bool  Var34=(Var7[1]== >); \nchar *Var35=FUNC10(Var1,Var2); \nchar *Var36=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var37=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nbool  Var38=false ; \nif (Var38){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var32=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var39=strstr(Var2,STRING); \nif (Var39){\nbool  Var40=false ; \nif (Var40){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var41,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var42=Var1->memberVar9; \nchar *Var43=NULL ; \nconst char *Var44=NULL ; \nchar *Var45=NULL ; \nchar *Var46=NULL ; \n*Var7  Var30=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var30){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var47; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var48=strdup(Var7+2); \nchar *Var49=strchr(Var48,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var42=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var50=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT5 *Var51=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); \nif (Var7[1]== ){\nSTRUCT3  Var55; \nchar *Var56=strdup(Var7+2); \nchar *Var57=FUNC18(Var56); \nif (Var57){\nchar  Var27=*Var57; \nVar55=FUNC19(Var1->memberVar11,Var56); \nfree(Var56); \nSTRUCT3  Var42=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC20(Var1,Var7+2); \nSTRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); \nchar *Var58=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var21=strchr(Var7+2,); \nint  Var59=FUNC15(Var1->memberVar5,Var21); \nconst STRUCT6 *Var60=(const STRUCT6 *) FUNC22(Var7+2); \nSTRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); \n*Var7=; \nchar *Var61=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC23((STRUCT6) Var7[1])&&!Var42){\nif (!FUNC24(Var1->memberVar13,Var7+1)){\nelse \nchar  Var27=*Var44; \nSTRUCT2 *Var52=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var62=Var7+3; \nconst char *Var63[]={STRING,STRING,STRING,\nconst char *Var64[]={STRING,STRING,STRING,\nchar *Var65=Var7+3; \nchar *Var22=strchr(Var65,); \nSTRUCT3  Var66=FUNC15(Var1->memberVar5,Var65); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 577,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3266,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nchar *0=strstr(Var2,STRING); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nchar *Var24,*Var25; \nVar19=*Var2 == ; \nif (Var19){\nVar2  Var26; \nVar25=*Var2 FUNC4(Var2) NULL ; \nif (!Var25||!*Var25){\nFUNC5(STRINGFUNC6(%Var27).,Var2); \nelse \nchar *Var28=strchr(Var2,; ); \nFUNC7(Var1,Var2); \nif (!Var28){\nchar *Var29=strchr(Var25+1,); \nconst bool  Var30=Var25[2]== >; \nVar24=strdup(Var2); \nif (Var25&&*Var25&&Var25[1]== |){\nFUNC8(Var1,Var2,Var9); \nif (!Var25){\nif (Var18){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nVar7=(char *) FUNC10(Var2,; ,Var5); \nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC10(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC11(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC12(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC13(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar6->memberVar1; \nif (*Var2){\nFUNC8(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC14(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC10(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nFUNC5(STRING,Var2); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var38=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC15(Var1,Var38,Var2); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC16()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar7){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var39=1; \nint  Var40=FUNC17(Var1->memberVar8,STRING); \nint  Var41=false ; \nint  Var42=FUNC17(Var1->memberVar8,STRING); \n*Var7=0; \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC18(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var45=FUNC19(Var1,Var2); \nchar *Var46=FUNC20(Var1->memberVar5,Var9,1); \nchar *Var47=FUNC21(STRING,Var46,Var45); \nelse \nchar *Var48=FUNC21(STRING,Var45); \nelse \nchar *Var48=FUNC21(STRING,Var45); \nelse \n}else if (Var39>0){\nif (Var16 != -1){\nVar15=FUNC22(Var1,Var2); \nconst char *Var49=FUNC23(Var1->memberVar8,STRING); \nVar7=strchr(Var2,); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var50=false ; \nif (Var50){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar6->memberVar1; \nelse \nint  Var42=FUNC17(Var1->memberVar8,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar2=FUNC24(strdup(Var2),Var9); \nVar15=FUNC22(Var1,Var2); \nfree(Var2); \nif (*Var2 != &&*Var2){\nconst char *Var27=strstr(Var2,STRING); \nif (Var27){\nbool  Var51=false ; \nif (Var51){\nif (*Var2 != .){\nVar11=FUNC25(Var2,Var5); \nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nint  Var52=0; \nif (Var7){\nchar *Var53,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var54=Var1->memberVar9; \nbool  Var55=false ; \nchar *Var56=NULL ; \nconst char *Var57=NULL ; \nbool  Var58=false ; \nbool  Var59=false ; \nchar *Var60=NULL ; \nchar *Var61=NULL ; \nbool  Var62=false ; \n*Var7  Var26=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var26){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var63; \nVar7=FUNC26(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var64=strdup(Var7+2); \nchar *Var65=strchr(Var64,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var66=(int ) FUNC28(Var1->memberVar6,Var7+2); \nSTRUCT5 *Var67=FUNC29(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); \nchar *Var71=strdup(Var7+2); \nchar  Var35=*Var72; \nSTRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (!Var60){\nVar60=Var2; \nelse \nVar60=FUNC32(Var60,Var2); \nfree(Var2); \nSTRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); \nchar *Var73=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var29=strchr(Var7+2,); \nint  Var74=FUNC28(Var1->memberVar6,Var29); \nconst STRUCT6 *Var75=(const STRUCT6 *) FUNC34(Var7+2); \nSTRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); \n*Var7=; \nchar *Var76=Var7-2; \nwhile (Var76>Var2){\nif (!FUNC35(*Var76)){\nVar2=FUNC11(Var2); \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC36((STRUCT6) Var7[1])&&!Var54){\nif (!FUNC37(Var1->memberVar12,Var7+1)){\nelse \nchar  Var35=*Var57; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var77=Var7+3; \nVar15=FUNC38(Var1,Var2,Var77); \nelse \nVar15=FUNC39(Var1,Var2,Var7+2); \nelse \nbool  Var4=false ; \nconst char *Var78[]={STRING,STRING,STRING,\nconst char *Var79[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var80=Var7+3; \nchar *Var25=strchr(Var80,); \nif (!Var25){\nSTRUCT3  Var81=FUNC28(Var1->memberVar6,Var80); \nSTRUCT3  Var82=FUNC28(Var1->memberVar6,Var25+1); \nif (Var17){\nVar15=FUNC3(Var1->memberVar5,FUNC40(Var2)); \nVar15=FUNC3(Var1->memberVar5,FUNC40(Var2)); \nVar52=Var2 FUNC3(Var1->memberVar5,FUNC40(Var2)) false ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 578,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3272,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var38){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var38){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=FUNC11(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nchar *Var45=FUNC13(Var1,Var2); \nchar *Var46=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var47=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC11(Var1->memberVar7,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar9=Var7 true false ; \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar10; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nint  Var62=-1; \nint  Var63,Var64; \nSTRUCT5 *Var39; \n*Var7  Var38=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var38){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var65; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var66=strdup(Var7+2); \nchar *Var67=strchr(Var66,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar61=FUNC18(Var1->memberVar11,Var7+2); \nint  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var70=FUNC21(Var69,Var68); \nVar52=FUNC22(Var7+2,&Var63); \nif (Var52){\nSTRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nelse \nFUNC26(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var74; \nchar *Var75=strdup(Var7+2); \nchar *Var76=FUNC27(Var75); \nif (Var76){\nchar  Var35=*Var76; \nelse \nVar74=FUNC28(Var1->memberVar13,Var7+2); \nVar57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); \nSTRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); \nif (Var53){\nFUNC30(Var1,STRING,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar64=FUNC32(Var7+2,Var39); \nFUNC33(Var1,FUNC34(Var64)); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nVar12=Var72; \nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); \nFUNC33(Var1,Var64); \nfree(Var39); \nchar *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC38(Var1->memberVar1,FUNC39(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var78=FUNC19(Var1->memberVar5,Var29); \nVar58=FUNC40(Var1,Var7+2,&Var60); \nVar64=strlen(Var7+2); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \n*Var7=; \nchar *Var79=Var7-2; \nVar7=FUNC42(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar56=FUNC42(Var7+1); \nif (FUNC43((STRUCT5) Var7[1])&&!Var53){\nif (!FUNC44(Var1->memberVar11,Var7+1)){\nFUNC26(STRING,Var7+1); \nelse \nchar  Var35=*Var56; \nif (Var53){\nSTRUCT2 *Var72=Var12; \nif (Var72){\nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar15=!!Var12; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var80=Var7+3; \nelse \nVar15=FUNC46(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var81[]={STRING,STRING,STRING,\nconst char *Var82[]={STRING,STRING,STRING,\nSTRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; \nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var27=strchr(Var85,); \nif (!Var27){\nSTRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); \nSTRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nVar83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nVar84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var86); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var87); \nif (Var17){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nelse \nif (Var54){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nif (memberVar9){\nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); \nif (Var62 != -1){\nFUNC38(Var1->memberVar1,Var62); \nif (Var12){\nif (Var13){\nFUNC48(Var1->memberVar7,STRING,0); \nFUNC25(Var12); \nif (Var57){\nFUNC50(Var1->memberVar7,STRING,Var55); \nif (Var61){\nFUNC51(Var1->memberVar11); \n*Var7=; \nVar51=Var15; \nif (Var18 != -1){\nFUNC48(Var1->memberVar7,STRING,Var18); \nif (Var19 != -1){\nFUNC48(Var1->memberVar7,STRING,Var19); \nif (Var12){\nFUNC25(Var12); \nreturn  Var51; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 579,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3272,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var38){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var38){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=FUNC11(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nchar *Var45=FUNC13(Var1,Var2); \nchar *Var46=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var47=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC11(Var1->memberVar7,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar9=Var7 true false ; \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar10; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nint  Var62=-1; \nint  Var63,Var64; \nSTRUCT5 *Var39; \n*Var7  Var38=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var38){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var65; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var66=strdup(Var7+2); \nchar *Var67=strchr(Var66,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar61=FUNC18(Var1->memberVar11,Var7+2); \nint  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var70=FUNC21(Var69,Var68); \nVar52=FUNC22(Var7+2,&Var63); \nif (Var52){\nSTRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nelse \nFUNC26(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var74; \nchar *Var75=strdup(Var7+2); \nchar *Var76=FUNC27(Var75); \nif (Var76){\nchar  Var35=*Var76; \nelse \nVar74=FUNC28(Var1->memberVar13,Var7+2); \nVar57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); \nSTRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); \nif (Var53){\nFUNC30(Var1,STRING,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar64=FUNC32(Var7+2,Var39); \nFUNC33(Var1,FUNC34(Var64)); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nVar12=Var72; \nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); \nFUNC33(Var1,Var64); \nfree(Var39); \nchar *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC38(Var1->memberVar1,FUNC39(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var78=FUNC19(Var1->memberVar5,Var29); \nVar58=FUNC40(Var1,Var7+2,&Var60); \nVar64=strlen(Var7+2); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \n*Var7=; \nchar *Var79=Var7-2; \nVar7=FUNC42(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar56=FUNC42(Var7+1); \nif (FUNC43((STRUCT5) Var7[1])&&!Var53){\nif (!FUNC44(Var1->memberVar11,Var7+1)){\nFUNC26(STRING,Var7+1); \nelse \nchar  Var35=*Var56; \nif (Var53){\nSTRUCT2 *Var72=Var12; \nif (Var72){\nFUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar15=!!Var12; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var80=Var7+3; \nelse \nVar15=FUNC46(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var81[]={STRING,STRING,STRING,\nconst char *Var82[]={STRING,STRING,STRING,\nSTRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; \nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var27=strchr(Var85,); \nif (!Var27){\nSTRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); \nSTRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nVar83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nVar84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var86); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var87); \nif (Var17){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nelse \nif (Var54){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nif (memberVar9){\nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); \nif (Var62 != -1){\nFUNC38(Var1->memberVar1,Var62); \nif (Var12){\nif (Var13){\nFUNC48(Var1->memberVar7,STRING,0); \nFUNC25(Var12); \nif (Var57){\nFUNC50(Var1->memberVar7,STRING,Var55); \nif (Var61){\nFUNC51(Var1->memberVar11); \n*Var7=; \nVar51=Var15; \nif (Var18 != -1){\nFUNC48(Var1->memberVar7,STRING,Var18); \nif (Var19 != -1){\nFUNC48(Var1->memberVar7,STRING,Var19); \nif (Var12){\nFUNC25(Var12); \nreturn  Var51; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 580,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3294,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var20=strchr(Var2,; ); \nchar *Var21=strchr(Var22+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25\nif (Var7&&(Var7[1]== ||Var7[1]==  Var26)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var28=Var1->memberVar5->memberVar1; \nelse \nchar *Var29=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nchar  Var31[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var32=FUNC9(Var1->memberVar7,STRING); \nint  Var33=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var34=Var7-1; \nconst bool  Var35=(Var7[1]== >); \nchar *Var36=FUNC10(Var1,Var2); \nchar *Var37=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var38=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var27=Var7-1; \nif (*Var27 == ){\nbool  Var39=false ; \nif (Var39){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var33=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var40=strstr(Var2,STRING); \nif (Var40){\nbool  Var41=false ; \nif (Var41){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var42,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var43=Var1->memberVar9; \nchar *Var44=NULL ; \nconst char *Var45=NULL ; \nchar *Var46=NULL ; \nchar *Var47=NULL ; \nint  Var48,Var49; \nSTRUCT5 *Var31; \n*Var7  Var30=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var30){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var50; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var51=strdup(Var7+2); \nchar *Var52=strchr(Var51,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT7 *Var55=FUNC17((const STRUCT5 *) Var42,Var48); \nSTRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); \nchar *Var58=strdup(Var7+2); \nchar  Var27=*Var59; \nSTRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC19(Var1,Var7+2); \nif (Var7[1]== ){\nVar31=malloc(strlen(Var7+2)+1); \nif (Var31){\nVar49=FUNC20(Var7+2,Var31); \nif (Var49>0){\nSTRUCT7 *Var55=FUNC17(Var31,Var49); \nSTRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); \nfree(Var31); \nchar *Var60=FUNC21(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var21=strchr(Var7+2,); \nint  Var61=FUNC15(Var1->memberVar5,Var21); \nconst STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); \nSTRUCT7 *Var55=FUNC17(Var31,Var49); \nSTRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); \n*Var7=; \nchar *Var62=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC23((STRUCT5) Var7[1])&&!Var43){\nif (!FUNC24(Var1->memberVar12,Var7+1)){\nelse \nchar  Var27=*Var45; \nSTRUCT2 *Var56=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nchar *Var66=Var7+3; \nchar *Var22=strchr(Var66,); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); \nSTRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 581,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3307,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nelse \nchar *Var24=strchr(Var2,; ); \nchar *Var25=strchr(Var26+1,); \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var27  Var28  Var5  Var29\nif (Var7&&(Var7[1]== ||Var7[1]==  Var30)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var31=Var7-1; \nif (*Var31 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var32=Var1->memberVar5->memberVar1; \nelse \nchar *Var33=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var34){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nchar  Var35[1024]; \nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var31=Var7-1; \nif (*Var31 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var36=FUNC9(Var1->memberVar7,STRING); \nint  Var37=false ; \nint  Var38=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var39=Var7-1; \nconst bool  Var40=(Var7[1]== >); \nchar *Var41=FUNC10(Var1,Var2); \nchar *Var42=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var43=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var31=Var7-1; \nif (*Var31 == ){\nbool  Var44=false ; \nif (Var44){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var38=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var45=strstr(Var2,STRING); \nif (Var45){\nbool  Var46=false ; \nif (Var46){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var47,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var48=Var1->memberVar10; \nbool  Var49=false ; \nchar *Var50=NULL ; \nconst char *Var51=NULL ; \nbool  Var52=false ; \nbool  Var53=false ; \nchar *Var54=NULL ; \nchar *Var55=NULL ; \nbool  Var56=false ; \nint  Var57,Var58; \nSTRUCT5 *Var35; \n*Var7  Var34=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var34){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var59; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var60=strdup(Var7+2); \nchar *Var61=strchr(Var60,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var48=FUNC14(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var62=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var63=FUNC16(Var1->memberVar11,Var1->memberVar10); \nif (Var63){\nif (Var62 >= 0&&Var62<Var63->memberVar1){\nSTRUCT7  Var64=FUNC17(Var63,Var62); \nVar22=Var1->memberVar9=true ; \nif (Var47){\nSTRUCT8 *Var65=FUNC18((const STRUCT5 *) Var47,Var57); \nSTRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); \nif (Var35){\nVar1->memberVar4=Var57; \nif (Var7[1]== ){\nchar *Var68=strdup(Var7+2); \nchar  Var31=*Var69; \nVar22=Var1->memberVar9=true ; \nSTRUCT3  Var48=FUNC15(Var1->memberVar5,Var7+2); \nif (Var48){\nVar22=Var1->memberVar9=true ; \nchar *Var2=FUNC20(Var1,Var7+2); \nSTRUCT8 *Var65=FUNC18(Var35,Var58); \nSTRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); \nchar *Var70=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var70){\nFUNC22(Var1,FUNC15(Var1->memberVar5,Var70),1); \nfree(Var70); \nchar *Var25=strchr(Var7+2,); \nint  Var71=FUNC15(Var1->memberVar5,Var25); \nconst STRUCT5 *Var35=(const STRUCT5 *) FUNC23(Var7+2); \nSTRUCT8 *Var65=FUNC18(Var35,Var58); \nSTRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); \n*Var7=; \nchar *Var72=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC24((STRUCT5) Var7[1])&&!Var48){\nif (!FUNC25(Var1->memberVar13,Var7+1)){\nelse \nchar  Var31=*Var51; \nSTRUCT2 *Var66=Var12; \nif (Var10){\nVar7=Var10+1; \nchar *Var73=Var7+3; \nelse \nbool  memberVar9=false ; \nconst char *Var74[]={STRING,STRING,STRING,\nconst char *Var75[]={STRING,STRING,STRING,\nchar *Var76=Var7+3; \nchar *Var26=strchr(Var76,); \nSTRUCT3  Var77=FUNC15(Var1->memberVar5,Var76); \nSTRUCT3  Var78=FUNC15(Var1->memberVar5,Var26+1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 582,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 3315,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nint  Var26=-1; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nreturn FUNC3(Var1->memberVar5,Var2); \nfor (; *Var2; ){\nint  Var16=-1; \nSTRUCT3  Var27=Var28; \nchar *Var29,*Var30; \nif (Var21){\nif (!Var30||!*Var30){\nelse \nchar *Var31=strchr(Var2,; ); \nFUNC4(Var1,Var2); \nif (!Var31){\nif (*Var30){\nif (Var30[1]== ||(Var30[1]&&Var30[2]== )){\nchar *Var32=strchr(Var30+1,); \nVar27=Var1->memberVar6; \nFUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); \nconst bool  Var33=Var30[2]== >; \nif (Var30&&*Var30&&Var30[1]== |){\nFUNC7(Var1,Var2,Var9); \nelse \nFUNC3(Var1->memberVar5,Var29); \nif (Var27 !=  Var28){\nFUNC5(Var1,Var27,1); \nif (!Var30){\nif (Var20){\nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nreturn FUNC3(Var1->memberVar5,Var2); \nif (Var2[1]== >){\nFUNC8(Var1,Var34); \nif (*Var2 != ){\nVar7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37\nif (Var7&&(Var7[1]== ||Var7[1]==  Var38)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nif (FUNC10(Var1,Var2) == -1){\nVar15=FUNC10(Var1,Var2); \nVar7=(char *) FUNC11(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nmemmove(Var39,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC12(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nFUNC8(Var1,Var40); \nelse \n}else if (!FUNC13(Var7+1,STRING,1)){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nVar15=*Var2 FUNC16(Var1,STRING,Var2) 0; \nelse \n}else if (Var7[1]){//STRING\nint  Var42=Var1->memberVar7->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var43=FUNC17(Var1->memberVar1,Var7+1); \nVar1->memberVar7->memberVar1=memberVar1; \nelse \nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar19=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var41); \nVar7=(char *) FUNC11(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nVar15=FUNC3(Var1->memberVar5,Var2); \nif (Var15 == -1){\nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){\nVar7=strchr(Var2,&); \nFUNC18(Var1->memberVar9); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nint  Var45=0; \nif (Var2<Var7&&Var7[-1]== ){\nFUNC19(Var1,Var45,Var2); \nFUNC20(Var7+2,STRING); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC21()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var44){\nfree(Var1->memberVar9); \nVar1->memberVar9=malloc(1); \nif (Var1->memberVar9){\nVar1->memberVar9[0]=0; \nVar1->memberVar10=0; \nchar  Var46[1024]; \nint  Var15; \nif (FUNC22(stdin)){\nVar1->memberVar10  STRUCT5  Var15; \nVar1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); \nif (Var1->memberVar9){\nif (!strcmp(Var46,Var9)){\nstrcat((char *) Var1->memberVar9,Var46); \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var44){\nif (!*Var9){\nfree(Var1->memberVar9); \nVar1->memberVar9=(STRUCT6 *) FUNC23(Var9,&Var1->memberVar10); \nif (!Var1->memberVar9){\nelse \n}else if (Var7 ==  Var2){\nreturn FUNC24(Var1,(const char *) Var1->memberVar9); \nVar7=(char *) FUNC9(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nmemmove(Var39,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nFUNC8(Var1,Var34); \nint  Var47=1; \nint  Var48=FUNC14(Var1->memberVar8,STRING); \nint  Var49=false ; \nint  Var50=FUNC14(Var1->memberVar8,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC25(Var7[-2])){\nchar *Var51=Var7-1; \nif (*Var51 ==  Var52){//STRING\nVar18=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,true ); \nif (!strcmp(Var9,STRING)){\nFUNC15(Var1->memberVar8,STRING,Var41); \nconst bool  Var53=(Var7[1]== >); \nif (*Var9 == ){\nchar *Var54=FUNC26(Var1,Var2); \nif (Var53){\nchar *Var55=FUNC27(Var1->memberVar5,Var9,1); \nif (Var55){\nchar *Var56=FUNC28(STRING,Var55,Var54); \nif (Var56){\nFUNC29(Var1->memberVar5,Var9,Var56,1); \nelse \nchar *Var57=FUNC28(STRING,Var54); \nFUNC29(Var1->memberVar5,Var9,Var57,1); \nelse \nchar *Var57=FUNC28(STRING,Var54); \nFUNC29(Var1->memberVar5,Var9,Var57,1); \nelse \n}else if (Var47>0){\nif (Var16 != -1){\nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var41); \nVar15=FUNC10(Var1,Var2); \nif (!Var48){\nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var49){\nconst char *Var58=FUNC30(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar11->memberVar1=false ; \nif (Var7){\nif (Var7>Var2){\nchar *Var39=Var7-1; \nif (*Var39 == ){\nbool  Var59=false ; \nif (Var59){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar7->memberVar1; \nif (Var7[1]== !){\nVar9=FUNC31(Var1,Var7+1); \nelse \nint  Var50=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,0); \nVar1->memberVar12=true ; \nVar9=FUNC26(Var1,Var7+1); \nVar1->memberVar12=false ; \nFUNC15(Var1->memberVar8,STRING,Var50); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nVar1->memberVar7->memberVar1=memberVar1; \nVar15=FUNC10(Var1,Var2); \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (*Var2 != &&*Var2){\nconst char *Var60=strstr(Var2,STRING); \nif (Var60){\nbool  Var61=false ; \nif (Var61){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar13=Var7 true false ; \nint  Var62=0; \nif (Var7){\nchar *Var63,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var64=Var1->memberVar6; \nbool  Var65=false ; \nchar *Var66=NULL ; \nconst char *Var67=NULL ; \nbool  Var68=false ; \nbool  Var69=false ; \nchar *Var70=NULL ; \nchar *Var71=NULL ; \nbool  Var72=false ; \nint  Var73=-1; \nint  Var74,Var75; \nSTRUCT6 *Var46; \n*Var7  Var44=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var44){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var76; \nVar7=FUNC32(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var77=strdup(Var7+2); \nchar *Var78=strchr(Var77,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+4); \nFUNC34(Var1,FUNC35((Var79) Var64-(Var79) Var1->memberVar6)); \nelse \nVar64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+3); \nFUNC5(Var1,Var64,1); \nVar24=Var1->memberVar13=true ; \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar72=FUNC36(Var1->memberVar14,Var7+2); \nint  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); \nSTRUCT7 *Var81=FUNC37(Var1->memberVar15,Var1->memberVar6); \nif (Var81){\nif (Var80 >= 0&&Var80<Var81->memberVar1){\nSTRUCT8  Var82=FUNC38(Var81,Var80); \nFUNC5(Var1,Var81->memberVar2+Var82,1); \nVar24=Var1->memberVar13=true ; \nVar63=FUNC23(Var7+2,&Var74); \nif (Var63){\nSTRUCT9 *Var83=FUNC39((const STRUCT6 *) Var63,Var74); \nSTRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); \nif (Var46){\nfree(Var1->memberVar16); \nVar1->memberVar16=Var46; \nVar1->memberVar4=Var74; \nmemcpy(Var1->memberVar16,Var63,Var74); \nelse \nFUNC43(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var86; \nchar *Var87=strdup(Var7+2); \nchar *Var88=FUNC44(Var87); \nif (Var88){\nchar  Var39=*Var88; \nVar86=FUNC45(Var1->memberVar17,Var87); \nVar86=FUNC6(Var1->memberVar7,Var89); \nelse \nVar86=FUNC45(Var1->memberVar17,Var7+2); \nFUNC5(Var1,Var86,1); \nVar24=Var1->memberVar13=true ; \nVar68=FUNC46(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); \nVar26=FUNC14(Var1->memberVar8,STRING); \nFUNC15(Var1->memberVar8,STRING,1); \nSTRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); \nif (memberVar2){\nFUNC16(Var1,STRING,Var7+2); \nVar24=Var1->memberVar13=true ; \nchar *Var2=FUNC47(Var1,Var7+2); \nif (Var7[1]== ){\nVar46=malloc(strlen(Var7+2)+1); \nif (Var46){\nVar75=FUNC48(Var7+2,Var46); \nFUNC34(Var1,FUNC35(Var75)); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC39(Var46,Var75); \nSTRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); \nFUNC34(Var1,Var75); \nFUNC49(Var1); \nchar *Var90=FUNC50(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var90){\nFUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); \nif (Var7[1]== ){\nVar73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; \nFUNC51(Var1->memberVar1,FUNC52(Var7+2)); \nif (Var7[1]== ){\nchar *Var32=strchr(Var7+2,); \nif (Var32){\nint  Var91=FUNC6(Var1->memberVar7,Var32); \nVar68=FUNC46(Var1,Var91,&Var66); \nVar69=FUNC53(Var1,Var7+2,&Var71); \nVar75=strlen(Var7+2); \nFUNC34(Var1,Var75); \nconst STRUCT6 *Var46=(const STRUCT6 *) FUNC54(Var7+2); \nif (Var75>0){\nSTRUCT9 *Var83=FUNC39(Var46,Var75); \nSTRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); \nif (!Var1->memberVar1->memberVar1){\nFUNC15(Var1->memberVar8,STRING,1); \nif (Var84){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,1); \nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); \nFUNC34(Var1,Var75); \n*Var7=; \nchar *Var92=Var7-2; \nVar7=FUNC55(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nFUNC34(\nVar1,FUNC6(Var1->memberVar7,Var8+1)); \nVar67=FUNC55(Var7+1); \nmemberVar2=FUNC6(Var1->memberVar7,Var67); \nif (FUNC56((STRUCT6) Var7[1])&&!memberVar2){\nif (!FUNC57(Var1->memberVar14,Var7+1)){\nFUNC43(STRING,Var7+1); \nelse \nchar  Var39=*Var67; \nif (Var39 == -||Var39 == +){\nmemberVar2=Var1->memberVar6+memberVar2; \nif (memberVar2){\nSTRUCT2 *Var84=Var12; \nif (Var84){\nFUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC58(Var84)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar19=!!Var12; \nif (Var1->memberVar19){\nFUNC49(Var1); \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var93=Var7+3; \nVar15=FUNC59(Var1,Var2,Var93); \nelse \nVar15=FUNC60(Var1,Var2,Var7+2); \nelse \nbool  memberVar13=false ; \nconst char *Var94[]={STRING,STRING,STRING,\nconst char *Var95[]={STRING,STRING,STRING,\nSTRUCT3  Var96[FUNC61(Var94)-1],Var97[FUNC61(Var95)-1]; \nif (Var7[1]== (){\nchar *Var98=Var7+3; \nchar *Var30=strchr(Var98,); \nif (!Var30){\nSTRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); \nSTRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nVar96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nVar97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); \nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var99); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var100); \nif (Var17){\nif (Var65){\nVar1->memberVar6=memberVar2; \nVar15=FUNC3(Var1->memberVar5,FUNC55(Var2)); \nelse \nif (Var65){\nif (Var7[1]){\nFUNC5(Var1,memberVar2,1); \nFUNC49(Var1); \nVar15=FUNC3(Var1->memberVar5,FUNC55(Var2)); \nif (memberVar13){\nfor (Var14=0; Var94[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); \nfor (Var14=0; Var95[Var14]; Var14  Var44){\nFUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); \nif (Var8){\nFUNC34(Var1,Var25); \nif (Var69){\nVar1->memberVar2=Var22; \nFUNC62(Var1->memberVar8,STRING,Var71); \nif (Var73 != -1){\nFUNC51(Var1->memberVar1,Var73); \nif (Var12){\nif (Var13){\nFUNC15(Var1->memberVar8,STRING,0); \nif (Var68){\nFUNC62(Var1->memberVar8,STRING,Var66); \nVar1->memberVar3=Var23; \nif (Var25 !=  Var1->memberVar4){\nFUNC34(Var1,Var25); \nif (Var70){\nFUNC4(Var1,Var70); \nif (Var72){\nFUNC63(Var1->memberVar14); \n*Var7=; \nVar62=Var2 FUNC3(Var1->memberVar5,FUNC55(Var2)) false ; \nif (Var18 != -1){\nFUNC15(Var1->memberVar8,STRING,Var18); \nif (Var19 != -1){\nFUNC15(Var1->memberVar8,STRING,Var19); \nVar1->memberVar2=Var22; \nVar1->memberVar3=Var23; \nif (Var26 != -1){\nFUNC15(Var1->memberVar8,STRING,Var26); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 583,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3320,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nif (Var27){\n*Var27  Var36=0; \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar54=FUNC28(Var1,Var74,&Var52); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar53=FUNC37(Var7+1); \nif (FUNC38((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC39(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC40(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 584,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3333,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nint  Var18=-1; \nint  Var19=-1; \nbool  Var20=false ; \nbool  Var21=false ; \nbool  Var22=Var1->memberVar2; \nbool  Var23=Var1->memberVar3; \nbool  Var24=false ; \nSTRUCT3  Var25=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var26,*Var27; \nelse \nchar *Var28=strchr(Var2,; ); \nchar *Var29=strchr(Var27+1,); \nconst bool  Var30=Var27[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33\nif (Var7&&(Var7[1]== ||Var7[1]==  Var34)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var36=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var37=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var38){\nchar  Var39[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var38){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nmemmove(Var35,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var40=FUNC11(Var1->memberVar7,STRING); \nint  Var41=false ; \nint  Var42=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var43=Var7-1; \nconst bool  Var44=(Var7[1]== >); \nchar *Var45=FUNC13(Var1,Var2); \nchar *Var46=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var47=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var35=Var7-1; \nif (*Var35 == ){\nbool  Var48=false ; \nif (Var48){\nelse \n}else if (!Var8){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var42=FUNC11(Var1->memberVar7,STRING); \nif (!Var9){\nif (*Var9 == |||*Var9 == *){\nif (*Var2 != &&*Var2){\nconst char *Var49=strstr(Var2,STRING); \nif (Var49){\nbool  Var50=false ; \nif (Var50){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar24=Var1->memberVar9=Var7 true false ; \nint  Var51=0; \nif (Var7){\nchar *Var52,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var53=Var1->memberVar10; \nbool  Var54=false ; \nchar *Var55=NULL ; \nconst char *Var56=NULL ; \nbool  Var57=false ; \nbool  Var58=false ; \nchar *Var59=NULL ; \nchar *Var60=NULL ; \nbool  Var61=false ; \nint  Var62=-1; \nint  Var63,Var64; \nSTRUCT5 *Var39; \n*Var7  Var38=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var38){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var65; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var66=strdup(Var7+2); \nchar *Var67=strchr(Var66,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar61=FUNC18(Var1->memberVar11,Var7+2); \nint  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var70=FUNC21(Var69,Var68); \nVar52=FUNC22(Var7+2,&Var63); \nif (Var52){\nSTRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nelse \nFUNC26(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var74; \nchar *Var75=strdup(Var7+2); \nchar *Var76=FUNC27(Var75); \nif (Var76){\nchar  Var35=*Var76; \nelse \nVar74=FUNC28(Var1->memberVar13,Var7+2); \nVar57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); \nSTRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); \nif (Var53){\nFUNC30(Var1,STRING,Var7+2); \nchar *Var2=FUNC31(Var1,Var7+2); \nif (Var7[1]== ){\nVar39=malloc(strlen(Var7+2)+1); \nif (Var39){\nVar64=FUNC32(Var7+2,Var39); \nFUNC33(Var1,FUNC34(Var64)); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nFUNC33(Var1,Var64); \nchar *Var77=FUNC35(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC36(Var1->memberVar1,FUNC37(Var7+2)); \nif (Var7[1]== ){\nchar *Var29=strchr(Var7+2,); \nint  Var78=FUNC19(Var1->memberVar5,Var29); \nVar58=FUNC38(Var1,Var7+2,&Var60); \nVar64=strlen(Var7+2); \nFUNC33(Var1,Var64); \nconst STRUCT5 *Var39=(const STRUCT5 *) FUNC39(Var7+2); \nif (Var64>0){\nSTRUCT8 *Var71=FUNC23(Var39,Var64); \nSTRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); \nif (Var72){\nif (Var12){\nFUNC25(Var12); \nVar12=Var72; \nFUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC41(Var71)); \nFUNC33(Var1,Var64); \n*Var7=; \nchar *Var79=Var7-2; \nVar7=FUNC42(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nVar56=FUNC42(Var7+1); \nif (FUNC43((STRUCT5) Var7[1])&&!Var53){\nif (!FUNC44(Var1->memberVar11,Var7+1)){\nFUNC26(STRING,Var7+1); \nelse \nchar  Var35=*Var56; \nif (Var53){\nSTRUCT2 *Var72=Var12; \nif (Var72){\nFUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); \nif (Var10){\nVar7=Var10+1; \nVar1->memberVar15=!!Var12; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var80=Var7+3; \nelse \nVar15=FUNC46(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var81[]={STRING,STRING,STRING,\nconst char *Var82[]={STRING,STRING,STRING,\nSTRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; \nif (Var7[1]== (){\nchar *Var85=Var7+3; \nchar *Var27=strchr(Var85,); \nif (!Var27){\nSTRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); \nSTRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nVar83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nVar84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); \nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var86); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var87); \nif (Var17){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nelse \nif (Var54){\nVar15=FUNC49(Var1->memberVar8,FUNC42(Var2)); \nif (memberVar9){\nfor (Var14=0; Var81[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); \nfor (Var14=0; Var82[Var14]; Var14  Var38){\nFUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); \nif (Var62 != -1){\nFUNC36(Var1->memberVar1,Var62); \nif (Var12){\nif (Var13){\nFUNC48(Var1->memberVar7,STRING,0); \nFUNC25(Var12); \nif (Var57){\nFUNC50(Var1->memberVar7,STRING,Var55); \nif (Var61){\nFUNC51(Var1->memberVar11); \n*Var7=; \nVar51=Var15; \nif (Var18 != -1){\nFUNC48(Var1->memberVar7,STRING,Var18); \nif (Var19 != -1){\nFUNC48(Var1->memberVar7,STRING,Var19); \nif (Var12){\nFUNC25(Var12); \nreturn  Var51; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 585,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 586,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 587,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 588,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 589,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3382,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 590,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3382,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=false ; \nbool  Var18=false ; \nbool  Var19=false ; \nbool  Var20=Var1->memberVar2; \nbool  Var21=Var1->memberVar3; \nbool  Var22=false ; \nSTRUCT3  Var23=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var24,*Var25; \nelse \nchar *Var26=strchr(Var2,; ); \nchar *Var27=strchr(Var25+1,); \nconst bool  Var28=Var25[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31\nif (Var7&&(Var7[1]== ||Var7[1]==  Var32)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var34=Var1->memberVar5->memberVar1; \nif (*Var2){\nFUNC7(Var1,Var2,Var7+1); \nelse \nchar *Var35=FUNC8(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nif (Var2<Var7&&Var7[-1]== ){\nFUNC9(Var7+2,STRING); \nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC10()->memberVar1){\nif (Var7[1]== <){\nfor (Var9=Var7+2; Var9[0]== ; Var9  Var36){\nchar  Var37[1024]; \nint  Var15; \nelse \nfor (Var9=Var7+1; *Var9 == ; Var9  Var36){\nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nmemmove(Var33,Var7,strlen(Var7)+1); \nif (Var7[0]&&Var7[1]== ){\nint  Var38=FUNC11(Var1->memberVar7,STRING); \nint  Var39=false ; \nint  Var40=FUNC11(Var1->memberVar7,STRING); \n*Var7=0; \nVar9=FUNC2(Var7+1+(Var7[1]== >)); \nif (!*Var9){\nif (Var7>(Var2+1)&&FUNC12(Var7[-2])){\nchar *Var41=Var7-1; \nconst bool  Var42=(Var7[1]== >); \nchar *Var43=FUNC13(Var1,Var2); \nchar *Var44=FUNC14(Var1->memberVar8,Var9,1); \nconst char *Var45=FUNC15(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var33=Var7-1; \nif (*Var33 == ){\nbool  Var46=false ; \nif (Var46){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var40=FUNC11(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var47=strstr(Var2,STRING); \nif (Var47){\nbool  Var48=false ; \nif (Var48){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nVar22=Var1->memberVar9=Var7 true false ; \nif (Var7){\nchar *Var49,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var50=Var1->memberVar10; \nbool  Var51=false ; \nchar *Var52=NULL ; \nconst char *Var53=NULL ; \nbool  Var54=false ; \nbool  Var55=false ; \nchar *Var56=NULL ; \nchar *Var57=NULL ; \nbool  Var58=false ; \nint  Var59,Var60; \nSTRUCT5 *Var37; \n*Var7  Var36=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var36){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var61; \nVar7=FUNC16(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var62=strdup(Var7+2); \nchar *Var63=strchr(Var62,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nif (Var7[3]== .){//STRING\nSTRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); \nelse \nVar50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nVar58=FUNC18(Var1->memberVar11,Var7+2); \nint  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); \nSTRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); \nSTRUCT7  Var66=FUNC21(Var65,Var64); \nVar49=FUNC22(Var7+2,&Var59); \nif (Var49){\nSTRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nelse \nFUNC25(STRING,Var7+3); \nif (Var7[1]== ){\nSTRUCT3  Var70; \nchar *Var71=strdup(Var7+2); \nchar *Var72=FUNC26(Var71); \nif (Var72){\nchar  Var33=*Var72; \nelse \nVar70=FUNC27(Var1->memberVar13,Var7+2); \nVar54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); \nSTRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); \nif (Var50){\nFUNC29(Var1,STRING,Var7+2); \nchar *Var2=FUNC30(Var1,Var7+2); \nif (Var7[1]== ){\nVar37=malloc(strlen(Var7+2)+1); \nif (Var37){\nVar60=FUNC31(Var7+2,Var37); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \nchar *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var7[1]== ){\nFUNC33(Var1->memberVar1,FUNC34(Var7+2)); \nif (Var7[1]== ){\nchar *Var27=strchr(Var7+2,); \nint  Var74=FUNC19(Var1->memberVar5,Var27); \nVar55=FUNC35(Var1,Var7+2,&Var57); \nVar60=strlen(Var7+2); \nconst STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); \nSTRUCT8 *Var67=FUNC23(Var37,Var60); \nSTRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); \n*Var7=; \nchar *Var75=Var7-2; \nVar7=FUNC37(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nelse \n*Var8=0; \nif (!Var8[1]){\nFUNC38(\nVar1,FUNC19(Var1->memberVar5,Var8+1)); \nVar53=FUNC37(Var7+1); \nif (FUNC39((STRUCT5) Var7[1])&&!Var50){\nif (!FUNC40(Var1->memberVar11,Var7+1)){\nFUNC25(STRING,Var7+1); \nelse \nchar  Var33=*Var53; \nSTRUCT2 *Var68=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nif (Var7[2]== ){\nchar *Var76=Var7+3; \nelse \nVar15=FUNC41(Var1,Var2,Var7+2); \nelse \nbool  memberVar9=false ; \nconst char *Var77[]={STRING,STRING,STRING,\nconst char *Var78[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var79=Var7+3; \nchar *Var25=strchr(Var79,); \nif (!Var25){\nSTRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); \nSTRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); \nif (Var17){\nelse \nif (Var51){\nif (Var8){\n*Var8=!; \n*Var7=; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 591,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3449,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var20,*Var21; \nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var21+1,); \nconst bool  Var24=Var21[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27\nif (Var7&&(Var7[1]== ||Var7[1]==  Var28)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var33=FUNC9(Var1->memberVar7,STRING); \nint  Var34=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var35=Var7-1; \nconst bool  Var36=(Var7[1]== >); \nchar *Var37=FUNC10(Var1,Var2); \nchar *Var38=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var39=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var43,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var7  Var32=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var32){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var49; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var50=strdup(Var7+2); \nchar *Var51=strchr(Var50,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var7+2); \nchar  Var29=*Var58; \nSTRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var23=strchr(Var7+2,); \nint  Var60=FUNC15(Var1->memberVar5,Var23); \nconst STRUCT6 *Var61=(const STRUCT6 *) FUNC20(Var7+2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \n*Var7=; \nchar *Var62=Var7-2; \nVar7=FUNC21(Var7+1)-1; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC22((STRUCT6) Var7[1])&&!Var44){\nif (!FUNC23(Var1->memberVar12,Var7+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT2 *Var54=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nSTRUCT3  Var66[FUNC24(Var64)-1],Var67[FUNC24(Var65)-1]; \nif (Var7[1]== (){\nchar *Var68=Var7+3; \nchar *Var21=strchr(Var68,); \nif (!Var21){\n*Var21=Var69; \nSTRUCT3  Var70=FUNC15(Var1->memberVar5,Var68); \nSTRUCT3  Var71=FUNC15(Var1->memberVar5,Var21+1); \nfor (Var14=0; Var65[Var14]; Var14  Var32){\nFUNC25(Var1->memberVar7,Var65[Var14],Var71); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 592,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3452,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n"
    ],
    "tokenized": "static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){\nconst char *Var5=STRING; \nconst char *Var6=NULL ; \nchar *Var7,*Var8,*Var9; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT2 *Var12=NULL ; \nint  Var13=!Var1->memberVar1->memberVar1; \nint  Var14,Var15=0,Var16; \nbool  Var17=Var1->memberVar2; \nbool  Var18=Var1->memberVar3; \nSTRUCT3  Var19=Var1->memberVar4; \nif (!Var2){\nVar2=FUNC2(Var2); \nswitch (*Var2){\nif (Var2[1]== ){/*STRUCT4 */\nchar *Var20,*Var21; \nelse \nchar *Var22=strchr(Var2,; ); \nchar *Var23=strchr(Var21+1,); \nconst bool  Var24=Var21[2]== >; \nif (Var2[1]!= *&&!strstr(Var2,STRING)){\nif (Var2[1]== >){\nif (*Var2 != ){\nVar7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27\nif (Var7&&(Var7[1]== ||Var7[1]==  Var28)){\n*Var7=0; \nif (*Var2 != ){\nif (Var3&&Var7){\nint  Var15; \nVar7=(char *) FUNC4(Var2,|,Var5); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nchar *Var8=strchr(Var2,); \nif (!Var8||(Var8&&Var8>Var7)){\nif (!Var6||(Var6&&Var6>Var7)){\n*Var7=0; \nVar2=FUNC5(Var2); \nif (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!FUNC6(Var7+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var7+1,STRING)){//STRING\nelse \n}else if (Var7[1]){//STRING\nint  Var30=Var1->memberVar5->memberVar1; \nelse \nchar *Var31=FUNC7(Var1->memberVar1,Var7+1); \nVar7=(char *) FUNC4(Var2,&,Var5); \nwhile (Var7&&*Var7&&Var7[1]== &){\n*Var7=0; \nif (Var15 == -1){\nfor (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){\nVar7=strchr(Var2,&); \nVar7=strstr(Var2,STRING); \nif (Var7&&(Var7 ==  Var2||Var7[-1]!= )){\nVar7[0]=0; \nif (*Var2 != ){\nVar7=strchr(Var2,<); \nif (Var7){\nVar7[0]=0; \nif (FUNC8()->memberVar1){\nif (Var7[1]== <){\nint  Var15; \nif (!*Var9){\nif (!Var1->memberVar6){\nelse \n}else if (Var7 ==  Var2){\nVar7=(char *) FUNC3(Var2,>,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nif (Var7[0]&&Var7[1]== ){\nint  Var33=FUNC9(Var1->memberVar7,STRING); \nint  Var34=FUNC9(Var1->memberVar7,STRING); \n*Var7=0; \nif (!*Var9){\nchar *Var35=Var7-1; \nconst bool  Var36=(Var7[1]== >); \nchar *Var37=FUNC10(Var1,Var2); \nchar *Var38=FUNC11(Var1->memberVar8,Var9,1); \nconst char *Var39=FUNC12(Var1->memberVar7,STRING); \nif (Var7){\nif (Var7>Var2){\nchar *Var29=Var7-1; \nif (*Var29 == ){\nbool  Var40=false ; \nif (Var40){\nelse \nint  memberVar1=Var1->memberVar5->memberVar1; \nelse \nint  Var34=FUNC9(Var1->memberVar7,STRING); \nif (*Var2 != &&*Var2){\nconst char *Var41=strstr(Var2,STRING); \nif (Var41){\nbool  Var42=false ; \nif (Var42){\nif (*Var2 != ){\nVar7=strchr(Var2,); \nif (Var7 ==  Var2+1&&*Var2 == ){\nVar7=NULL ; \nelse \nVar7=NULL ; \nif (Var7){\nchar *Var43,*Var8=strchr(Var7+1,!); \nSTRUCT3  Var44=Var1->memberVar9; \nchar *Var45=NULL ; \nconst char *Var46=NULL ; \nchar *Var47=NULL ; \nchar *Var48=NULL ; \n*Var7  Var32=0; \nVar10=(Var7[0]&&Var7[1]&&Var7[2])\nfor (; *Var7 == ; Var7  Var32){\nif (*Var7&&Var7[1]== ){\nelse \nVar7  Var49; \nVar7=FUNC13(Var7); \nif (Var7[1]== ){\nelse \n}else if (Var7[1]== %){//STRING\nchar *Var50=strdup(Var7+2); \nchar *Var51=strchr(Var50,=); \nelse \n}else if (Var7[1]== .){//STRING\nif (Var7[2]== .){//STRING\nSTRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); \nelse \n}else if (Var7[0]&&Var7[1]== &&Var7[2]){\nswitch (Var7[0]){\nint  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); \nSTRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var57=strdup(Var7+2); \nchar  Var29=*Var58; \nSTRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); \nchar *Var2=FUNC18(Var1,Var7+2); \nif (!Var47){\nVar47=Var2; \nelse \nVar47=FUNC19(Var47,Var2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \nchar *Var59=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); \nchar *Var23=strchr(Var7+2,); \nint  Var60=FUNC15(Var1->memberVar5,Var23); \nconst STRUCT6 *Var61=(const STRUCT6 *) FUNC21(Var7+2); \nSTRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); \n*Var7=; \nchar *Var62=Var7-2; \nif (Var8){\nif (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&\n!memcmp(Var7+1,STRING,2)&&\n!memcmp(Var8+1,STRING,2)){\nelse \n}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){\nif (!Var8[1]){\nif (FUNC22((STRUCT6) Var7[1])&&!Var44){\nif (!FUNC23(Var1->memberVar12,Var7+1)){\nelse \nchar  Var29=*Var46; \nSTRUCT2 *Var54=Var12; \nif (Var10){\nVar7=Var10+1; \nif (Var7[1]== ){\nchar *Var63=Var7+3; \nconst char *Var64[]={STRING,STRING,STRING,\nconst char *Var65[]={STRING,STRING,STRING,\nif (Var7[1]== (){\nchar *Var66=Var7+3; \nchar *Var21=strchr(Var66,); \nif (!Var21){\nfree(Var47); \nSTRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); \nSTRUCT3  Var68=FUNC15(Var1->memberVar5,Var21+1); \nif (Var47){\nFUNC24(Var1,Var47); \nFUNC25(Var47); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 593,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3453,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpasm);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\t\tR_FREE (tmpasm);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nSTRUCT1 *Var7=NULL ; \nint  Var8=!Var9->memberVar1->memberVar1; \nint  Var10,Var11=0,Var12; \nbool  Var13=Var9->memberVar2; \nbool  Var14=Var9->memberVar3; \nSTRUCT2  Var15=Var9->memberVar4; \nif (!Var16){\nswitch (*Var16){\nif (Var16[1]== ){/*STRUCT3 */\nchar *Var17,*Var18; \nelse \nchar *Var19=strchr(Var16,; ); \nchar *Var20=strchr(Var18+1,); \nconst bool  Var21=Var18[2]== >; \nif (Var16[1]!= *&&!strstr(Var16,STRING)){\nif (Var16[1]== >){\nif (*Var16 != ){\nif (Var22&&Var2){\nint  Var11; \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nchar *Var3=strchr(Var16,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var24=Var9->memberVar5->memberVar1; \nelse \nchar *Var25=FUNC2(Var9->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var11 == -1){\nif (Var2&&(Var2 ==  Var16||Var2[-1]!= )){\nif (*Var16 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nint  Var11; \nif (!*Var4){\nif (!Var9->memberVar6){\nelse \n}else if (Var2 ==  Var16){\nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var26=FUNC4(Var9->memberVar7,STRING); \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (!*Var4){\nchar *Var28=Var2-1; \nconst bool  Var29=(Var2[1]== >); \nchar *Var30=FUNC5(Var9,Var16); \nchar *Var31=FUNC6(Var9->memberVar8,Var4,1); \nconst char *Var32=FUNC7(Var9->memberVar7,STRING); \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nbool  Var33=false ; \nif (Var33){\nelse \nint  memberVar1=Var9->memberVar5->memberVar1; \nelse \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (*Var16 != &&*Var16){\nconst char *Var34=strstr(Var16,STRING); \nif (Var34){\nbool  Var35=false ; \nif (Var35){\nif (Var2){\nchar *Var36,*Var3=strchr(Var2+1,!); \nSTRUCT2  Var37=Var9->memberVar9; \nchar *Var38=NULL ; \nconst char *Var39=NULL ; \nbool  Var40=false ; \nchar *Var41=NULL ; \nchar *Var42=NULL ; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var43=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); \nSTRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var49=strdup(Var2+2); \nchar  Var23=*Var50; \nSTRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); \nchar *Var16=FUNC12(Var9,Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var20=strchr(Var2+2,); \nint  Var52=FUNC9(Var9->memberVar5,Var20); \nconst STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var54=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC15((STRUCT5) Var2[1])&&!Var37){\nif (!FUNC16(Var9->memberVar12,Var2+1)){\nelse \nchar  Var23=*Var39; \nSTRUCT1 *Var46=Var7; \nif (Var5){\nif (Var2[1]== ){\nchar *Var55=Var2+3; \nconst char *Var56[]={STRING,STRING,STRING,\nconst char *Var57[]={STRING,STRING,STRING,\nif (Var2[1]== (){\nchar *Var58=Var2+3; \nchar *Var18=strchr(Var58,); \nif (!Var18){\nfree(Var42); \nSTRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); \nSTRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); \nif (Var40){\nFUNC17(Var9->memberVar7,STRING,Var42); \nFUNC18(Var42); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 594,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3454,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpbits);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n"
    ],
    "tokenized": "const char *Var1=NULL ; \nchar *Var2,*Var3,*Var4; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nSTRUCT1 *Var7=NULL ; \nint  Var8=!Var9->memberVar1->memberVar1; \nint  Var10,Var11=0,Var12; \nbool  Var13=Var9->memberVar2; \nbool  Var14=Var9->memberVar3; \nSTRUCT2  Var15=Var9->memberVar4; \nif (!Var16){\nswitch (*Var16){\nif (Var16[1]== ){/*STRUCT3 */\nchar *Var17,*Var18; \nelse \nchar *Var19=strchr(Var16,; ); \nchar *Var20=strchr(Var18+1,); \nconst bool  Var21=Var18[2]== >; \nif (Var16[1]!= *&&!strstr(Var16,STRING)){\nif (Var16[1]== >){\nif (*Var16 != ){\nif (Var22&&Var2){\nint  Var11; \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nchar *Var3=strchr(Var16,); \nif (!Var3||(Var3&&Var3>Var2)){\nif (!Var1||(Var1&&Var1>Var2)){\nif (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!FUNC1(Var2+1,STRING,1)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (!strcmp(Var2+1,STRING)){//STRING\nelse \n}else if (Var2[1]){//STRING\nint  Var24=Var9->memberVar5->memberVar1; \nelse \nchar *Var25=FUNC2(Var9->memberVar1,Var2+1); \nwhile (Var2&&*Var2&&Var2[1]== &){\nif (Var11 == -1){\nif (Var2&&(Var2 ==  Var16||Var2[-1]!= )){\nif (*Var16 != ){\nif (Var2){\nif (FUNC3()->memberVar1){\nif (Var2[1]== <){\nint  Var11; \nif (!*Var4){\nif (!Var9->memberVar6){\nelse \n}else if (Var2 ==  Var16){\nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nif (Var2[0]&&Var2[1]== ){\nint  Var26=FUNC4(Var9->memberVar7,STRING); \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (!*Var4){\nchar *Var28=Var2-1; \nconst bool  Var29=(Var2[1]== >); \nchar *Var30=FUNC5(Var9,Var16); \nchar *Var31=FUNC6(Var9->memberVar8,Var4,1); \nconst char *Var32=FUNC7(Var9->memberVar7,STRING); \nif (Var2){\nif (Var2>Var16){\nchar *Var23=Var2-1; \nif (*Var23 == ){\nbool  Var33=false ; \nif (Var33){\nelse \nint  memberVar1=Var9->memberVar5->memberVar1; \nelse \nint  Var27=FUNC4(Var9->memberVar7,STRING); \nif (*Var16 != &&*Var16){\nconst char *Var34=strstr(Var16,STRING); \nif (Var34){\nbool  Var35=false ; \nif (Var35){\nif (Var2){\nchar *Var36,*Var3=strchr(Var2+1,!); \nSTRUCT2  Var37=Var9->memberVar9; \nchar *Var38=NULL ; \nconst char *Var39=NULL ; \nbool  Var40=false ; \nchar *Var41=NULL ; \nchar *Var42=NULL ; \nif (Var2[1]== ){\nelse \n}else if (Var2[1]== %){//STRING\nchar *Var43=strdup(Var2+2); \nelse \n}else if (Var2[1]== .){//STRING\nif (Var2[2]== .){//STRING\nSTRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); \nelse \n}else if (Var2[0]&&Var2[1]== &&Var2[2]){\nswitch (Var2[0]){\nint  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); \nSTRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var49=strdup(Var2+2); \nchar  Var23=*Var50; \nSTRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); \nchar *Var16=FUNC12(Var9,Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); \nchar *Var20=strchr(Var2+2,); \nint  Var52=FUNC9(Var9->memberVar5,Var20); \nconst STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); \nSTRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); \nchar *Var54=Var2-2; \nif (Var3){\nif (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&\n!memcmp(Var2+1,STRING,2)&&\n!memcmp(Var3+1,STRING,2)){\nelse \n}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){\nif (!Var3[1]){\nif (FUNC15((STRUCT5) Var2[1])&&!Var37){\nif (!FUNC16(Var9->memberVar12,Var2+1)){\nelse \nchar  Var23=*Var39; \nSTRUCT1 *Var46=Var7; \nif (Var5){\nif (Var2[1]== ){\nchar *Var55=Var2+3; \nconst char *Var56[]={STRING,STRING,STRING,\nconst char *Var57[]={STRING,STRING,STRING,\nif (Var2[1]== (){\nchar *Var58=Var2+3; \nchar *Var18=strchr(Var58,); \nif (!Var18){\nfree(Var38); \nSTRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); \nSTRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); \nif (Var40){\nFUNC17(Var9->memberVar7,STRING,Var38); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreach_comment",
    "Source": false,
    "Sink": false,
    "idx": 595,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3578,
    "label": -3,
    "slices": [
      "static int foreach_comment(void *user, const char *k, const char *v) {\n",
      "\tif (!strncmp (k, \"meta.C.\", 7)) {\n",
      "\t\tchar *cmt = (char *)sdb_decode (v, 0);\n",
      "\t\tif (cmt) {\n",
      "\t\t\tfree (cmt);\n"
    ],
    "tokenized": "static int FUNC1(void *Var1,const char *Var2,const char *Var3){\nif (!FUNC2(Var2,STRING,7)){\nchar *Var4=(char *) FUNC3(Var3,0); \nif (Var4){\nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreach_pairs",
    "Source": false,
    "Sink": false,
    "idx": 596,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3601,
    "label": -3,
    "slices": [
      "static void foreach_pairs(RCore *core, const char *cmd, const char *each) {\n",
      "\tconst char *arg;\n",
      "\tint pair = 0;\n",
      "\tfor (arg = each ; ; ) {\n",
      "\t\tchar *next = strchr (arg, ' ');\n",
      "\t\tif (next) {\n",
      "\t\t\t*next = 0;\n",
      "\t\tif (arg && *arg) {\n",
      "\t\t\tut64 n = r_num_get (NULL, arg);\n",
      "\t\t\tif (pair%2) {\n",
      "\t\t\t\tr_core_block_size (core, n);\n",
      "else\n",
      "\t\t\t\tr_core_seek (core, n, 1);\n",
      "\t\tif (!next) {\n",
      "\t\targ = next + 1;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nconst char *Var4; \nint  Var5=0; \nfor (Var4=Var3; ; ){\nchar *Var6=strchr(Var4,); \nif (Var6){\n*Var6=0; \nif (Var4&&*Var4){\nSTRUCT2  Var7=FUNC2(NULL ,Var4); \nif (Var5%2){\nFUNC3(Var1,Var7); \nelse \nFUNC4(Var1,Var7,1); \nif (!Var6){\nVar4=Var6+1; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 597,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3644,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\tif (filter) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tforeach_pairs (core, cmd, arg);\n",
      "\t\t\tfree (arg);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING\nSTRUCT2 *Var5=Var2->memberVar1; \nconst char *Var6=NULL ; \nif (Var4[1]== ){\nVar6=Var4+2; \nswitch (Var4[0]){\nif (Var6){\nchar *Var7=FUNC2(Var2,Var6); \nFUNC3(Var2,Var3,Var7); \nfree(Var7); \nint  Var8=FUNC4(Var2->memberVar2); \nSTRUCT3 *Var9=FUNC5(Var2->memberVar2,Var8); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var11=FUNC6(Var2->memberVar4,Var12); \nSTRUCT5 *Var13=FUNC7(Var2->memberVar5); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var14=Var2->memberVar6; \nSTRUCT5 *Var13=FUNC7(Var2->memberVar5); \nint  Var15=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nchar *Var17=Var6 FUNC8(Var6) NULL ; \nSTRUCT4  Var18=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT6 *Var19=FUNC9(Var2->memberVar7,Var2->memberVar3,0); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 598,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3730,
    "label": -3,
    "slices": [
      "\tRDebug *dbg = core->dbg;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRBinImport *imp;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tchar *impflag = r_str_newf (\"sym.imp.%s\", imp->name);\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\t\tfree (impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 addr = sec->vaddr;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ],
    "tokenized": "STRUCT1 *Var1=Var2->memberVar1; \nswitch (Var3[0]){\nchar *Var4=FUNC1(Var2,Var5); \nint  Var6=FUNC2(Var2->memberVar2); \nSTRUCT2 *Var7=FUNC3(Var2->memberVar2,Var6); \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT4 *Var9; \nSTRUCT3  Var8=Var2->memberVar3; \nchar *Var10=FUNC4(STRING,Var9->memberVar1); \nSTRUCT3  Var11=FUNC5(Var2->memberVar4,Var10); \nfree(Var10); \nSTRUCT5 *Var12=FUNC6(Var2->memberVar5); \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var13=Var2->memberVar6; \nSTRUCT5 *Var12=FUNC6(Var2->memberVar5); \nint  Var14=Var2->memberVar6; \nSTRUCT3  Var11=Var15->memberVar1; \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var17=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var16=Var2->memberVar6; \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT6 *Var18=FUNC7(Var2->memberVar7,Var2->memberVar3,0); \nSTRUCT3  Var8=Var2->memberVar3; \nSTRUCT3  Var16=Var2->memberVar6; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 599,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3821,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tr_flag_foreach_glob (core->flags, glob, exec_command_on_flag, &u);\n",
      "\t\t\tfree (glob);\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING\nSTRUCT2 *Var5=Var2->memberVar1; \nconst char *Var6=NULL ; \nif (Var4[1]== ){\nVar6=Var4+2; \nswitch (Var4[0]){\nchar *Var7=FUNC2(Var2,Var6); \nint  Var8=FUNC3(Var2->memberVar2); \nSTRUCT3 *Var9=FUNC4(Var2->memberVar2,Var8); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var11=FUNC5(Var2->memberVar4,Var12); \nSTRUCT5 *Var13=FUNC6(Var2->memberVar5); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var14=Var2->memberVar6; \nSTRUCT5 *Var13=FUNC6(Var2->memberVar5); \nint  Var15=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nchar *Var17=Var6 FUNC7(Var6) NULL ; \nSTRUCT4  Var18=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \nFUNC8(Var2->memberVar7,Var17,Var19,&Var20); \nfree(Var17); \nSTRUCT4  Var16=Var2->memberVar6; \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT6 *Var21=FUNC9(Var2->memberVar8,Var2->memberVar3,0); \nSTRUCT4  Var10=Var2->memberVar3; \nSTRUCT4  Var16=Var2->memberVar6; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 600,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3869,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=strdup(Var2); \nwhile (Var3){\nif (!*Var3){\nchar *Var5=strchr(Var3,Var6); \nwhile (Var3&&*Var3){\nchar *Var7=strchr(Var3,); \nif (Var7){\nelse \nif (!*Var3){\nFUNC2(Var1,Var4,0); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 601,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3883,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=NULL ; \nSTRUCT2  Var5; \nwhile (Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nif (!*Var3){\nchar *Var7=strchr(Var3,Var8); \nif (Var7){\n*Var7=0; \nVar4=Var7+1; \nelse \nVar4=NULL ; \nVar7=strchr(Var3,); \nif (Var7){\n*Var7=0; \nwhile (Var3&&*Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nchar *Var9=strchr(Var3,); \nif (Var9){\n*Var9=0; \nVar5=FUNC2(Var1->memberVar1,Var3); \n*Var9=; \nVar3=Var9+1; \nelse \nif (!*Var3){\nVar5=FUNC2(Var1->memberVar1,Var3); \nFUNC3(Var1,Var5,1); \nVar3=Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 602,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3891,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\teach = nextLine;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=NULL ; \nSTRUCT2  Var5; \nwhile (Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nif (!*Var3){\nchar *Var7=strchr(Var3,Var8); \nif (Var7){\n*Var7=0; \nVar4=Var7+1; \nelse \nVar4=NULL ; \nVar7=strchr(Var3,); \nif (Var7){\n*Var7=0; \nwhile (Var3&&*Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nchar *Var9=strchr(Var3,); \nif (Var9){\nVar5=FUNC2(Var1->memberVar1,Var3); \nelse \nif (!*Var3){\nVar5=FUNC2(Var1->memberVar1,Var3); \nVar3=Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 603,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3901,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = NULL;\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=NULL ; \nSTRUCT2  Var5; \nwhile (Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nif (!*Var3){\nchar *Var7=strchr(Var3,Var8); \nif (Var7){\nVar4=Var7+1; \nelse \nVar4=NULL ; \nVar7=strchr(Var3,); \nwhile (Var3&&*Var3){\nwhile (*Var3 == ){\nVar3  Var6; \nchar *Var9=strchr(Var3,); \nif (Var9){\n*Var9=0; \nVar5=FUNC2(Var1->memberVar1,Var3); \n*Var9=; \nVar3=Var9+1; \nelse \nif (!*Var3){\nVar5=FUNC2(Var1->memberVar1,Var3); \nVar3=NULL ; \nFUNC3(Var1,Var5,1); \nVar3=Var4; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 604,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3920,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ],
    "tokenized": "static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){\nchar *Var4=strdup(Var2); \nwhile (Var3){\nif (!*Var3){\nchar *Var5=strchr(Var3,Var6); \nwhile (Var3&&*Var3){\nchar *Var7=strchr(Var3,); \nif (Var7){\nelse \nif (!*Var3){\nFUNC2(Var1,Var4,0); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 605,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3955,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\t\tfree (out);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar  Var7; \nchar *Var8=NULL ; \nchar *Var9,*Var10=NULL ; \nSTRUCT2  Var11,Var12; \nVar10=Var9=strdup(Var4); \nswitch (Var4[0]){\nchar *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2,Var4); \nfree(Var10); \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var15=Var2->memberVar4; \nif (Var14){\nif (FUNC5()){\nchar *Var9=Var4+1; \nif (*Var9 == ||*Var9 == ){\nVar9  Var16; \nint  Var17=FUNC6(Var9,); \nif (Var17 == 3){\nSTRUCT2  Var18=FUNC7(Var2->memberVar5,FUNC8(Var9,0)); \nSTRUCT2  Var19=FUNC7(Var2->memberVar5,FUNC8(Var9,1)); \nSTRUCT2  Var20=FUNC7(Var2->memberVar5,FUNC8(Var9,2)); \nint  Var5; \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT3 *Var14; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var14->memberVar1,Var4+2)){\nif (FUNC5()){\nelse \nSTRUCT3 *Var14; \nif (Var2->memberVar2){\nSTRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC5()){\nint  Var23=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var25=FUNC11(Var2,Var4+2); \nFUNC12(Var2,Var3,Var9+1); \nif (Var4[1]==  Var26&&Var4[2]==  Var27){\nSTRUCT2  Var11=Var2->memberVar3; \nchar *Var28=FUNC13(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var28){\nVar4=Var28; \nwhile (*Var4 == ){\nVar4  Var16; \nif (!*Var4){\nVar9=strchr(Var4,); \nif (Var9){\n*Var9=0; \nmemberVar1=FUNC7(Var2->memberVar5,Var4); \n*Var9=; \nelse \nmemberVar1=FUNC7(Var2->memberVar5,Var4); \nVar4=Var9+1; \nFUNC14(Var2,memberVar1,1); \n}while (Var9 != NULL ); \nfree(Var28); \nif (Var4[1]== (){\nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){\nif (FUNC5()){\nFUNC15(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nSTRUCT6 *Var29=FUNC16(Var4+1,STRING); \nif (Var29){\nelse \nFUNC17(STRING,Var4+1); \nfor (; *Var4 == ; Var4  Var16){\nwhile (Var9[Var5]){\nVar7=Var9[Var5]; \nVar9[Var5]=0; \nVar8=strdup(Var9+Var6); \nif (!Var8){\nVar9[Var5]=Var7; \nconst STRUCT7 *Var30=FUNC18(Var2->memberVar10); \nSTRUCT5 *Var31=FUNC19((Var32) Var33); \nif (!Var31){\nif (FUNC5()){\nchar *Var34=NULL ; \nconst char *Var35=NULL ; \nFUNC20(Var8); \nfree(Var8); \nfree(Var10); \nfree(Var10); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 606,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3960,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tRFlagItem *flag;\n",
      "\tut64 oseek, addr;\n",
      "\toseek = core->offset;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmd);\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\tr_core_cmd_help (core, help_msg_at_at);\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tr_core_block_size (core, bb->size);\n",
      "\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tr_core_block_size (core, bs);\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 cur;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\t\tfor (cur = from; cur < to; cur += step) {\n",
      "\t\t\t\t\t(void)r_core_seek (core, cur, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tcore->cons->context->grep = grep;\n",
      "\t\t\tRDebugPid *p;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_debug_select (core->dbg, pid, pid);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\t\tRDebugFrame *frame;\n",
      "\t\t\tRList *list;\n",
      "\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n",
      "\t\t\t\tswitch (each[3]) {\n",
      "\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_core_seek (core, oseek, 0);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\t\taddr = core->rcmd->macro._brk_value;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n",
      "\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "\t\t\t\t\tcore->rcmd->macro.counter++;\n",
      "\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\tr_flag_foreach_space (core->flags, flagspace, duplicate_flag, &u);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\tcore->rcmd->macro.counter++ ;\n",
      "\tcore->offset = oseek;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar *Var7=NULL ; \nchar *Var8,*Var9=NULL ; \nSTRUCT2 *Var10; \nSTRUCT3  Var11,Var12; \nVar11=Var2->memberVar1; \nswitch (Var4[0]){\nchar *Var13=strdup(FUNC2(Var2->memberVar2,STRING)); \nFUNC3(Var2->memberVar2,STRING,Var3); \nFUNC4(Var2,Var4); \nFUNC3(Var2->memberVar2,STRING,Var13); \nfree(Var13); \nFUNC5(Var2,Var14); \nSTRUCT4 *Var15; \nSTRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); \nint  Var17=Var2->memberVar4; \nif (Var16){\nFUNC7(Var2,Var15->size ); \nFUNC8(Var2,Var15->memberVar1,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nFUNC7(Var2,Var17); \nchar *Var8=Var4+1; \nint  Var18=FUNC11(Var8,); \nif (Var18 == 3){\nSTRUCT3  Var19; \nSTRUCT3  Var20=FUNC12(Var2->memberVar5,FUNC13(Var8,0)); \nSTRUCT3  Var21=FUNC12(Var2->memberVar5,FUNC13(Var8,1)); \nSTRUCT3  Var22=FUNC12(Var2->memberVar5,FUNC13(Var8,2)); \nfor (Var19=Var20; Var19<Var21; Var19  STRUCT6  Var22){\n(void ) FUNC8(Var2,Var19,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nSTRUCT4 *Var15; \nint  Var5; \nSTRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); \nif (Var16){\nfor (Var5=0; Var5<Var15->memberVar2; Var5  Var23){\nSTRUCT3  memberVar1=Var15->memberVar1+Var15->memberVar3[Var5]; \nFUNC8(Var2,memberVar1,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nif (Var4[1]== ){\nSTRUCT5 *Var16; \nif (Var2->memberVar3){\nif (Var4[2]&&strstr(Var16->memberVar1,Var4+2)){\nFUNC8(Var2,Var16->memberVar2,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nelse \nSTRUCT5 *Var16; \nif (Var2->memberVar3){\nSTRUCT7  Var24=Var2->memberVar6->memberVar1->memberVar1; \nchar *Var25; \nFUNC8(Var2,Var16->memberVar2,1); \nFUNC9(Var2,Var3,0); \nif (FUNC10()){\nVar2->memberVar6->memberVar1->memberVar1=memberVar1; \nSTRUCT8 *Var26; \nint  Var27=Var2->memberVar7->memberVar1; \nif (Var2->memberVar7->memberVar2&&Var2->memberVar7->memberVar2->memberVar1){\nSTRUCT9 *Var28=Var2->memberVar7->memberVar2->memberVar1(Var2->memberVar7,FUNC14(0,memberVar1)); \nFUNC15(Var2->memberVar7,Var26->memberVar1,Var26->memberVar1); \nFUNC9(Var2,Var3,0); \nFUNC15(Var2->memberVar7,memberVar1,memberVar1); \nif (Var4[1]== ){\nchar *Var29=FUNC16(Var2,Var4+2); \nif (Var29){\nFUNC17(Var2,Var3,Var29); \nFUNC17(Var2,Var3,Var8+1); \nif (Var4[1]==  Var30&&Var4[2]==  Var31){\nSTRUCT3  Var11=Var2->memberVar1; \nSTRUCT10 *Var32; \nSTRUCT9 *Var28; \nVar28=FUNC18(Var2->memberVar7,Var33); \nswitch (Var4[3]){\nFUNC8(Var2,Var32->memberVar1,1); \nFUNC8(Var2,Var32->memberVar2,1); \nFUNC8(Var2,Var32->memberVar3,1); \nFUNC9(Var2,Var3,0); \nFUNC8(Var2,Var11,0); \nchar *Var34=FUNC19(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nif (Var34){\nif (!*Var4){\nif (Var8){\nmemberVar3=FUNC12(Var2->memberVar5,Var4); \nelse \nmemberVar3=FUNC12(Var2->memberVar5,Var4); \nFUNC8(Var2,memberVar3,1); \nFUNC9(Var2,Var3,0); \n}while (Var8 != NULL ); \nif (Var4[1]== (){\nchar  Var35[1024]; \nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var23){\nif (FUNC10()){\nFUNC20(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nmemberVar3=Var2->memberVar9->memberVar1.memberVar3; \nFUNC8(Var2,memberVar3,1); \nFUNC9(Var2,Var35,0); \nelse \nchar  Var25[1024]; \nchar  Var35[1024]; \nSTRUCT11 *Var36=FUNC21(Var4+1,STRING); \nif (Var36){\nVar2->memberVar9->memberVar1.memberVar1=0; \nwhile (!FUNC22(Var36)){\nif (!fgets(Var25,sizeof (Var25),Var36)){\nmemberVar3=FUNC12(Var2->memberVar5,Var25); \nFUNC8(Var2,memberVar3,1); //Var37\nFUNC9(Var2,Var35,0); \nVar2->memberVar9->memberVar1.memberVar1  Var23; \nVar2->memberVar9->memberVar1.memberVar1=0; \nwhile (Var8[Var5]){\nif (!Var7){\nconst STRUCT12 *Var38=FUNC23(Var2->memberVar10); \nSTRUCT9 *Var39=FUNC24((Var40) Var41); \nif (!Var39){\nFUNC25(Var2->memberVar10,Var38,Var42,&Var43); \nif (FUNC10()){\nchar *Var25=NULL ; \nconst char *Var44=NULL ; \nFUNC8(Var2,Var10->memberVar1,1); \nFUNC9(Var2,Var3,0); \nVar2->memberVar9->memberVar1.memberVar1  Var23; \nVar2->memberVar1=Var11; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 607,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3964,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nswitch (Var4[0]){\nchar *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2->memberVar1,STRING,Var5); \nfree(Var5); \nSTRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var7=Var2->memberVar4; \nchar *Var8=Var4+1; \nSTRUCT3  Var9=FUNC5(Var2->memberVar5,FUNC6(Var8,0)); \nSTRUCT3  Var10=FUNC5(Var2->memberVar5,FUNC6(Var8,1)); \nSTRUCT3  Var11=FUNC5(Var2->memberVar5,FUNC6(Var8,2)); \nSTRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; \nint  Var13=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); \nchar *Var15=FUNC9(Var2,Var4+2); \nSTRUCT3  Var16=Var2->memberVar3; \nchar *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nSTRUCT6 *Var18=FUNC11(Var4+1,STRING); \nconst STRUCT7 *Var19=FUNC12(Var2->memberVar9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 608,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3966,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nVar6=Var5=strdup(Var4); \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nfree(Var6); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nif (Var8){\nif (FUNC4()){\nchar *Var5=Var4+1; \nint  Var10=FUNC5(Var5,); \nSTRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); \nSTRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nif (Var4[1]== ){\nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nSTRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var15=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var17=FUNC10(Var2,Var4+2); \nSTRUCT3  Var18=Var2->memberVar3; \nchar *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); \nSTRUCT6 *Var20=FUNC12(Var4+1,STRING); \nconst STRUCT7 *Var21=FUNC13(Var2->memberVar9); \nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 609,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 4045,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar *Var7,*Var8=NULL ; \nVar8=Var7=strdup(Var4); \nswitch (Var4[0]){\nchar *Var9=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2,Var4); \nSTRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var11=Var2->memberVar4; \nchar *Var7=Var4+1; \nint  Var12=FUNC5(Var7,); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var7,0)); \nSTRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var7,1)); \nSTRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var7,2)); \nint  Var5; \nSTRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT2 *Var10; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var10->memberVar1,Var4+2)){\nFUNC8(Var2,Var10->memberVar2,1); \nelse \nSTRUCT2 *Var10; \nSTRUCT4  Var18=Var2->memberVar6->memberVar1->memberVar1; \nint  Var19=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var20=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var21=FUNC11(Var2,Var4+2); \nif (Var4[1]==  Var22&&Var4[2]==  Var23){\nSTRUCT3  Var24=Var2->memberVar3; \nchar *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var7+((Var7[1]) 21)); \nif (Var4[1]== (){\nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var26){\nif (FUNC13()){\nFUNC14(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nSTRUCT6 *Var27=FUNC15(Var4+1,STRING); \nif (Var27){\nelse \nFUNC16(STRING,Var4+1); \nfor (; *Var4 == ; Var4  Var26){\nconst STRUCT7 *Var28=FUNC17(Var2->memberVar10); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 610,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4067,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "switch (Var1[0]){\nchar *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nint  Var5=Var3->memberVar4; \nchar *Var6=Var1+1; \nSTRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); \nSTRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); \nSTRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nif (Var1[1]== ){\nif (Var3->memberVar2){\nSTRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; \nchar *Var11; \nVar11=(char *) FUNC5(); \nif (Var11){\nVar11=strdup(Var11); \nFUNC6(Var11); \nfree(Var11); \nint  Var12=Var3->memberVar7->memberVar1; \nSTRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); \nchar *Var14=FUNC9(Var3,Var1+2); \nSTRUCT2  Var15=Var3->memberVar3; \nchar *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); \nelse \nchar  Var11[1024]; \nSTRUCT5 *Var17=FUNC11(Var1+1,STRING); \nconst STRUCT6 *Var18=FUNC12(Var3->memberVar9); \nchar *Var11=NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 611,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4071,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "switch (Var1[0]){\nchar *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nint  Var5=Var3->memberVar4; \nchar *Var6=Var1+1; \nSTRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); \nSTRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); \nSTRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); \nSTRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); \nif (Var1[1]== ){\nif (Var3->memberVar2){\nSTRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; \nchar *Var11; \nVar11=(char *) FUNC5(); \nif (Var11){\nVar11=strdup(Var11); \nFUNC6(Var11); \nfree(Var11); \nint  Var12=Var3->memberVar7->memberVar1; \nSTRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); \nchar *Var14=FUNC9(Var3,Var1+2); \nSTRUCT2  Var15=Var3->memberVar3; \nchar *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); \nelse \nchar  Var11[1024]; \nSTRUCT5 *Var17=FUNC11(Var1+1,STRING); \nconst STRUCT6 *Var18=FUNC12(Var3->memberVar9); \nchar *Var11=NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 612,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4104,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\t\t\tfree (arg);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nswitch (Var4[0]){\nchar *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var7=Var2->memberVar4; \nchar *Var8=Var4+1; \nSTRUCT3  Var9=FUNC4(Var2->memberVar5,FUNC5(Var8,0)); \nSTRUCT3  Var10=FUNC4(Var2->memberVar5,FUNC5(Var8,1)); \nSTRUCT3  Var11=FUNC4(Var2->memberVar5,FUNC5(Var8,2)); \nSTRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; \nint  Var13=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var15=FUNC8(Var2,Var4+2); \nif (Var15){\nFUNC9(Var2,Var3,Var15); \nfree(Var15); \nSTRUCT3  Var16=Var2->memberVar3; \nchar *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nSTRUCT6 *Var18=FUNC11(Var4+1,STRING); \nconst STRUCT7 *Var19=FUNC12(Var2->memberVar9); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 613,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4155,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar  Var7; \nchar *Var8=NULL ; \nchar *Var9,*Var10=NULL ; \nSTRUCT2  Var11,Var12; \nVar10=Var9=strdup(Var4); \nswitch (Var4[0]){\nchar *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); \nFUNC3(Var2,Var4); \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nint  Var15=Var2->memberVar4; \nchar *Var9=Var4+1; \nif (*Var9 == ||*Var9 == ){\nVar9  Var16; \nint  Var17=FUNC5(Var9,); \nif (Var17 == 3){\nSTRUCT2  Var18=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); \nSTRUCT2  Var19=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); \nSTRUCT2  Var20=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); \nint  Var5; \nSTRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT3 *Var14; \nif (Var2->memberVar2){\nelse \nSTRUCT3 *Var14; \nSTRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; \nint  Var23=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nif (Var4[1]== ){\nchar *Var25=FUNC10(Var2,Var4+2); \nFUNC11(Var2,Var3,Var9+1); \nif (Var4[1]==  Var26&&Var4[2]==  Var27){\nSTRUCT2  Var11=Var2->memberVar3; \nchar *Var28=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); \nif (Var28){\nVar4=Var28; \nwhile (*Var4 == ){\nVar4  Var16; \nif (!*Var4){\nVar9=strchr(Var4,); \nif (Var9){\n*Var9=0; \nmemberVar1=FUNC6(Var2->memberVar5,Var4); \n*Var9=; \nelse \nmemberVar1=FUNC6(Var2->memberVar5,Var4); \nVar4=Var9+1; \nFUNC13(Var2,memberVar1,1); \n}while (Var9 != NULL ); \nif (Var4[1]== (){\nfor (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){\nif (FUNC14()){\nFUNC15(&Var2->memberVar9->memberVar1,Var4+2); \nif (!Var2->memberVar9->memberVar1.memberVar2){\nSTRUCT6 *Var29=FUNC16(Var4+1,STRING); \nif (Var29){\nelse \nFUNC17(STRING,Var4+1); \nfor (; *Var4 == ; Var4  Var16){\nwhile (Var9[Var5]){\nVar7=Var9[Var5]; \nVar9[Var5]=0; \nVar8=strdup(Var9+Var6); \nif (!Var8){\nVar9[Var5]=Var7; \nconst STRUCT7 *Var30=FUNC18(Var2->memberVar10); \nSTRUCT5 *Var31=FUNC19((Var32) Var33); \nif (!Var31){\nif (FUNC14()){\nchar *Var34=NULL ; \nconst char *Var35=NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 614,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4169,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\tfree (out);\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5=NULL ; \nchar *Var6,*Var7=NULL ; \nVar7=Var6=strdup(Var4); \nswitch (Var4[0]){\nchar *Var8=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var10=Var2->memberVar4; \nchar *Var6=Var4+1; \nint  Var11=FUNC4(Var6,); \nSTRUCT3  Var12=FUNC5(Var2->memberVar5,FUNC6(Var6,0)); \nSTRUCT3  Var13=FUNC5(Var2->memberVar5,FUNC6(Var6,1)); \nSTRUCT3  Var14=FUNC5(Var2->memberVar5,FUNC6(Var6,2)); \nSTRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT4  Var15=Var2->memberVar6->memberVar1->memberVar1; \nint  Var16=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var17=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); \nchar *Var18=FUNC9(Var2,Var4+2); \nSTRUCT3  Var19=Var2->memberVar3; \nchar *Var20=FUNC10(Var2->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); \nif (Var20){\nVar4=Var20; \nfree(Var20); \nSTRUCT6 *Var21=FUNC11(Var4+1,STRING); \nconst STRUCT7 *Var22=FUNC12(Var2->memberVar9); \nchar *Var23=NULL ; \nconst char *Var24=NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 615,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 4201,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tut64 oseek, addr;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tbuf[0] = '\\0';\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nSTRUCT2  Var5,Var6; \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nchar *Var10=Var4+1; \nSTRUCT2  Var11=FUNC4(Var2->memberVar5,FUNC5(Var10,0)); \nSTRUCT2  Var12=FUNC4(Var2->memberVar5,FUNC5(Var10,1)); \nSTRUCT2  Var13=FUNC4(Var2->memberVar5,FUNC5(Var10,2)); \nSTRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT2  Var6=Var14->memberVar1+Var14->memberVar2[Var15]; \nSTRUCT4  Var16=Var2->memberVar6->memberVar1->memberVar1; \nchar *Var17; \nint  Var18=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var19=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); \nchar *Var20=FUNC8(Var2,Var4+2); \nSTRUCT2  Var5=Var2->memberVar3; \nchar *Var21=FUNC9(Var2->memberVar8,NULL ,0,Var10+((Var10[1]) 21)); \nif (Var4[1]== (){\nelse \nchar  Var17[1024]; \nSTRUCT6 *Var22=FUNC10(Var4+1,STRING); \nif (Var22){\nwhile (!FUNC11(Var22)){\nVar17[0]=0; \nif (!fgets(Var17,sizeof (Var17),Var22)){\nmemberVar1=FUNC4(Var2->memberVar5,Var17); \nfclose(Var22); \nconst STRUCT7 *Var23=FUNC12(Var2->memberVar9); \nchar *Var17=NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 616,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 4211,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nswitch (Var4[0]){\nchar *Var5=Var4+1; \nchar *Var6; \nchar *Var7=FUNC2(Var2,Var4+2); \nif (Var4[1]== (){\nelse \nchar  Var6[1024]; \nSTRUCT2 *Var8=FUNC3(Var4+1,STRING); \nif (Var8){\nwhile (!FUNC4(Var8)){\nif (!fgets(Var6,sizeof (Var6),Var8)){\nfclose(Var8); \nchar *Var6=NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 617,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4233,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar  Var7; \nchar *Var8=NULL ; \nchar *Var9,*Var10=NULL ; \nVar10=Var9=strdup(Var4); \nswitch (Var4[0]){\nchar *Var11=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var13=Var2->memberVar4; \nif (Var12){\nif (FUNC4()){\nchar *Var9=Var4+1; \nint  Var14=FUNC5(Var9,); \nSTRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); \nSTRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); \nSTRUCT3  Var17=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); \nint  Var5; \nSTRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT3  Var18=Var19->memberVar1+Var19->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT2 *Var12; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var12->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var12; \nif (Var2->memberVar2){\nSTRUCT4  Var20=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var21=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var22=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var23=FUNC10(Var2,Var4+2); \nFUNC11(Var2,Var3,Var9+1); \nSTRUCT3  Var24=Var2->memberVar3; \nchar *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); \nSTRUCT6 *Var26=FUNC13(Var4+1,STRING); \nVar5=0; \nwhile (Var9[Var5]){\nVar6=Var5; \nfor (; Var9[Var6]&&Var9[Var6]== ; Var6  Var27){\nfor (Var5=Var6; Var9[Var5]&&Var9[Var5]!= ; Var5  Var27){\nVar7=Var9[Var5]; \nVar9[Var5]=0; \nVar8=strdup(Var9+Var6); \nif (!Var8){\nVar9[Var5]=Var7; \nconst STRUCT7 *Var28=FUNC14(Var2->memberVar9); \nSTRUCT5 *Var29=FUNC15((Var30) Var31); \nif (!Var29){\nif (FUNC4()){\nchar *Var32=NULL ; \nconst char *Var33=NULL ; \nFUNC16(Var8); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 618,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4267,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tr_cons_break_push (NULL, NULL); //pop on return\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t} while (str != NULL);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4,*Var5=NULL ; \nFUNC1(NULL ,NULL ); //Var6  STRUCT1 return \nswitch (Var7[0]){\nchar *Var8=strdup(FUNC2(Var9->memberVar1,STRING)); \nSTRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); \nint  Var11=Var9->memberVar4; \nchar *Var4=Var7+1; \nint  Var12=FUNC4(Var4,); \nSTRUCT3  Var13=FUNC5(Var9->memberVar5,FUNC6(Var4,0)); \nSTRUCT3  Var14=FUNC5(Var9->memberVar5,FUNC6(Var4,1)); \nSTRUCT3  Var15=FUNC5(Var9->memberVar5,FUNC6(Var4,2)); \nint  Var1; \nSTRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); \nSTRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var1]; \nSTRUCT4  Var18=Var9->memberVar6->memberVar1->memberVar1; \nchar *Var19; \nint  Var20=Var9->memberVar7->memberVar1; \nSTRUCT5 *Var21=Var9->memberVar7->memberVar2->FUNC7(Var9->memberVar7,FUNC8(0,memberVar1)); \nchar *Var22=FUNC9(Var9,Var7+2); \nSTRUCT3  Var23=Var9->memberVar3; \nchar *Var24=FUNC10(Var9->memberVar8,NULL ,0,Var4+((Var4[1]) 21)); \nif (Var24){\nif (!*Var7){\n}while (Var4 != NULL ); \nelse \nchar  Var19[1024]; \nSTRUCT6 *Var25=FUNC11(Var7+1,STRING); \nwhile (Var4[Var1]){\nif (!Var3){\nconst STRUCT7 *Var26=FUNC12(Var9->memberVar9); \nSTRUCT5 *Var27=FUNC13((Var28) Var29); \nif (!Var27){\nif (FUNC14()){\nchar *Var19=NULL ; \nconst char *Var30=NULL ; \nVar30=FUNC15(); \nVar19=Var30 strdup(Var30) NULL ; \nFUNC16(Var19); \nfree(Var19); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 619,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4270,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4,*Var5=NULL ; \nswitch (Var6[0]){\nchar *Var7=strdup(FUNC1(Var8->memberVar1,STRING)); \nchar *Var4=Var6+1; \nint  Var9=FUNC2(Var4,); \nSTRUCT1  Var10=FUNC3(Var8->memberVar2,FUNC4(Var4,0)); \nSTRUCT1  Var11=FUNC3(Var8->memberVar2,FUNC4(Var4,1)); \nSTRUCT1  Var12=FUNC3(Var8->memberVar2,FUNC4(Var4,2)); \nint  Var1; \nSTRUCT1  Var13=Var14->memberVar1+Var14->memberVar2[Var1]; \nchar *Var15; \nchar *Var16=FUNC5(Var8,Var6+2); \nchar *Var17=FUNC6(Var8->memberVar3,NULL ,0,Var4+((Var4[1]) 21)); \nelse \nchar  Var15[1024]; \nSTRUCT2 *Var18=FUNC7(Var6+1,STRING); \nwhile (Var4[Var1]){\nif (!Var3){\nSTRUCT3 *Var19=FUNC8((Var20) Var21); \nif (!Var19){\nif (FUNC9()){\nchar *Var15=NULL ; \nconst char *Var22=NULL ; \nVar22=FUNC10(); \nVar15=Var22 strdup(Var22) NULL ; \nFUNC11(Var15); \nfree(Var15); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 620,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4283,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nint  Var5,Var6; \nchar *Var7=NULL ; \nchar *Var8,*Var9=NULL ; \nVar9=Var8=strdup(Var4); \nswitch (Var4[0]){\nchar *Var10=strdup(FUNC2(Var2->memberVar1,STRING)); \nSTRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var12=Var2->memberVar4; \nif (Var11){\nif (FUNC4()){\nchar *Var8=Var4+1; \nint  Var13=FUNC5(Var8,); \nSTRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var8,0)); \nSTRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var8,1)); \nSTRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var8,2)); \nint  Var5; \nSTRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nSTRUCT3  Var17=Var18->memberVar1+Var18->memberVar2[Var5]; \nif (Var4[1]== ){\nSTRUCT2 *Var11; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var11->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var11; \nif (Var2->memberVar2){\nSTRUCT4  Var19=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var20=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var21=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var22=FUNC10(Var2,Var4+2); \nSTRUCT3  Var23=Var2->memberVar3; \nchar *Var24=FUNC11(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); \nSTRUCT6 *Var25=FUNC12(Var4+1,STRING); \nVar5=0; \nwhile (Var8[Var5]){\nVar6=Var5; \nfor (; Var8[Var6]&&Var8[Var6]== ; Var6  Var26){\nfor (Var5=Var6; Var8[Var5]&&Var8[Var5]!= ; Var5  Var26){\nVar7=strdup(Var8+Var6); \nif (!Var7){\nconst STRUCT7 *Var27=FUNC13(Var2->memberVar9); \nSTRUCT5 *Var28=FUNC14((Var29) Var30); \nif (!Var28){\nif (FUNC4()){\nchar *Var31=NULL ; \nconst char *Var32=NULL ; \nFUNC15(Var7); \nfree(Var7); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 621,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4284,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nVar6=Var5=strdup(Var4); \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nfree(Var6); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nif (Var8){\nif (FUNC4()){\nchar *Var5=Var4+1; \nint  Var10=FUNC5(Var5,); \nSTRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); \nSTRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nif (Var4[1]== ){\nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nSTRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var15=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var17=FUNC10(Var2,Var4+2); \nSTRUCT3  Var18=Var2->memberVar3; \nchar *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); \nSTRUCT6 *Var20=FUNC12(Var4+1,STRING); \nconst STRUCT7 *Var21=FUNC13(Var2->memberVar9); \nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 622,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4287,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){\nchar *Var5,*Var6=NULL ; \nVar6=Var5=strdup(Var4); \nswitch (Var4[0]){\nchar *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); \nfree(Var6); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nint  Var9=Var2->memberVar4; \nif (Var8){\nif (FUNC4()){\nchar *Var5=Var4+1; \nint  Var10=FUNC5(Var5,); \nSTRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); \nSTRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); \nSTRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); \nSTRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); \nif (Var4[1]== ){\nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nif (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){\nif (FUNC4()){\nelse \nSTRUCT2 *Var8; \nif (Var2->memberVar2){\nSTRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; \nif (FUNC4()){\nint  Var15=Var2->memberVar7->memberVar1; \nSTRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); \nchar *Var17=FUNC10(Var2,Var4+2); \nSTRUCT3  Var18=Var2->memberVar3; \nchar *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); \nSTRUCT6 *Var20=FUNC12(Var4+1,STRING); \nconst STRUCT7 *Var21=FUNC13(Var2->memberVar9); \nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "run_pending_anal",
    "Source": false,
    "Sink": false,
    "idx": 623,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4299,
    "label": -3,
    "slices": [
      "R_API void run_pending_anal(RCore *core) {\n",
      "\tcore->ev->incall = false;\n",
      "\tif (core && core->anal && core->anal->cmdtail) {\n",
      "\t\tchar *res = core->anal->cmdtail;\n",
      "\t\tr_core_cmd_lines (core, res);\n",
      "\t\tfree (res);\n"
    ],
    "tokenized": "Var1 void FUNC1(STRUCT1 *Var2){\nVar2->memberVar1->memberVar1=false ; \nif (Var2&&Var2->memberVar2&&Var2->memberVar2->memberVar1){\nchar *Var3=Var2->memberVar2->memberVar1; \nFUNC2(Var2,Var3); \nfree(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 624,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4310,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 625,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4315,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nVar2->memberVar4=false ; \nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nfree(Var2->memberVar5); \nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nVar2->memberVar6->memberVar1->memberVar1  Var15; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nif (!Var7){\nFUNC9(Var2); \nVar2->memberVar6->memberVar1->memberVar1  Var12; \nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nif (FUNC10(Var2->memberVar9)){\nFUNC11(Var2->memberVar10); \nFUNC9(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 626,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4325,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nint  Var5=false ,Var6; \nif (Var2->memberVar1){\nconst char *Var7=STRING; \nfor (Var6=0; Var7[Var6]; Var6  Var8){\nif (strchr(Var3,Var7[Var6])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var9&&FUNC2(Var3,STRING,2)){\nchar *Var10=FUNC3(Var2->memberVar3,Var3); \nif (Var10){\nFUNC4(STRING,Var10); \nfree(Var10); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 627,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4349,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nVar2->memberVar4=false ; \nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nfree(Var2->memberVar5); \nVar2->memberVar5=strdup(Var3); \nif (!Var6){\nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC5(Var2->memberVar7); \nVar2->memberVar8=0; \nVar2->memberVar6->memberVar1->memberVar1  Var15; \nVar9=FUNC6(Var2,Var8); \nif (Var9 == -1){\nif (!Var7){\nFUNC7(Var2); \nVar2->memberVar6->memberVar1->memberVar1  Var12; \nFUNC5(Var2->memberVar7); \nVar2->memberVar8=0; \nif (FUNC8(Var2->memberVar9)){\nFUNC9(Var2->memberVar10); \nFUNC7(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 628,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4350,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nVar2->memberVar4=false ; \nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nfree(Var2->memberVar5); \nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nVar2->memberVar6->memberVar1->memberVar1  Var15; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nif (!Var7){\nFUNC9(Var2); \nVar2->memberVar6->memberVar1->memberVar1  Var12; \nFUNC7(Var2->memberVar7); \nVar2->memberVar8=0; \nif (FUNC10(Var2->memberVar9)){\nFUNC11(Var2->memberVar10); \nFUNC9(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 629,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 4353,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(STRING,Var5); \nfree(Var6); \nfor (Var8=Var5; ; ){\nVar7=strchr(Var8,Var15); \nif (Var7){\n*Var7=0; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nFUNC7(STRING,Var8,*Var8); \nif (!Var7){\nVar8=Var7+1; \nfree(Var6); \nreturn  Var9; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 630,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4353,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nif (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){\nVar2->memberVar5=strdup(Var3); \nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nFUNC5(Var5,Var3); \nif (Var4){\nFUNC6(Var3); \nif (Var2->memberVar6->memberVar1->memberVar1<1){\nFUNC7(STRING,Var5); \nfree(Var6); \nfor (Var8=Var5; ; ){\nVar7=strchr(Var8,Var15); \nif (Var7){\n*Var7=0; \nVar9=FUNC8(Var2,Var8); \nif (Var9 == -1){\nFUNC7(STRING,Var8,*Var8); \nif (!Var7){\nVar8=Var7+1; \nfree(Var6); \nreturn  Var9; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 631,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4364,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nif (Var2->memberVar5->memberVar1->memberVar1<1){\nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 632,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4371,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\treturn ret;\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nif (Var2->memberVar5->memberVar1->memberVar1<1){\nfor (Var8=Var5; ; ){\nVar7=strchr(Var8,Var15); \nif (Var7){\n*Var7=0; \nVar9=FUNC5(Var2,Var8); \nif (Var9 == -1){\nFUNC6(STRING,Var8,*Var8); \nif (!Var7){\nVar8=Var7+1; \nreturn  Var9; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 633,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4388,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){\nchar *Var5,*Var6,*Var7,*Var8; \nint  Var9=false ,Var10; \nif (Var2->memberVar1){\nconst char *Var11=STRING; \nfor (Var10=0; Var11[Var10]; Var10  Var12){\nif (strchr(Var3,Var11[Var10])){\nif (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){\nif (Var2->memberVar2){\nif (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){\nchar *Var14=FUNC3(Var2->memberVar3,Var3); \nif (!Var3||(*Var3 == |&&Var3[1]!= )){\nif (!FUNC2(Var3,STRING,2)){\nif (FUNC4(0)){\nelse \n}else if (!FUNC2(Var3,STRING,2)){\nif (Var2->memberVar4){\nVar6=Var5=malloc(strlen(Var3)+4096); \nif (!Var6){\nif (Var2->memberVar5->memberVar1->memberVar1<1){\nfree(Var6); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 634,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4414,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \n*Var6=0; \nVar4=FUNC3(Var2,Var7,0); \nif (Var4<0){/Var10=-1){\nVar7=Var6+1; \nif (Var7[0]==  Var11){\nVar7=Var6+1; \nVar7=Var6+1; \n}while ((Var6=strchr(Var7,Var9))); \nif (Var5 >= 0&&Var7&&*Var7){\nFUNC3(Var2,Var7,0); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 635,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4418,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \n*Var6=0; \nVar4=FUNC3(Var2,Var7,0); \nif (Var4<0){/Var10=-1){\nVar7=Var6+1; \nif (Var7[0]==  Var11){\nVar7=Var6+1; \nVar7=Var6+1; \n}while ((Var6=strchr(Var7,Var9))); \nif (Var5 >= 0&&Var7&&*Var7){\nFUNC3(Var2,Var7,0); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 636,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4423,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \nif (Var4<0){/Var10=-1){\nif (Var7[0]==  Var11){\n}while ((Var6=strchr(Var7,Var9))); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 637,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4445,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\n*Var6=0; \nVar4=FUNC3(Var2,Var7,0); \nif (Var4<0){/Var10=-1){\nVar7=Var6+1; \nif (Var7[0]==  Var11){\nVar7=Var6+1; \nVar7=Var6+1; \n}while ((Var6=strchr(Var7,Var9))); \nif (Var5 >= 0&&Var7&&*Var7){\nFUNC3(Var2,Var7,0); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 638,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4451,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nint  Var4,Var5=true ; \nchar *Var6,*Var7,*Var8; \nif (!Var3||!*Var3){\nVar7=Var8=strdup(Var3); \nif (!Var8){\nVar6=strchr(Var8,Var9); \nif (Var6){\nif (FUNC2()){\nfree(Var8); \nif (Var4<0){/Var10=-1){\nif (Var7[0]==  Var11){\n}while ((Var6=strchr(Var7,Var9))); \nfree(Var8); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 639,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4461,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tfree (data);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4=FUNC2(Var3); \nif (!Var4){\nchar *Var5=FUNC3(Var4,NULL ); \nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 640,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4467,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4=FUNC2(Var3); \nif (!Var4){\nchar *Var5=FUNC3(Var4,NULL ); \nif (!Var5){\nif (!FUNC4(Var2,Var5)){\nfree(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 641,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4470,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4=FUNC2(Var3); \nif (!Var4){\nchar *Var5=FUNC3(Var4,NULL ); \nif (!Var5){\nif (!FUNC4(Var2,Var5)){\nfree(Var5); \nfree(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 642,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4480,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\t\tfree (cmd);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6; \nchar *Var7=FUNC2(Var2,Var3); \nVar5=Var6=Var4=FUNC3(Var7,0,&Var8); \nif (!Var4){\nfree(Var7); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 643,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4485,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\tfree (buf);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6; \nchar *Var7=FUNC2(Var2,Var3); \nVar5=Var6=Var4=FUNC3(Var7,0,&Var8); \nif (!Var4){\nfree(Var4); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_disassemble_instr",
    "Source": false,
    "Sink": false,
    "idx": 644,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4495,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (Var1){\nVar2=FUNC1(Var3,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_disassemble_bytes",
    "Source": false,
    "Sink": false,
    "idx": 645,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4505,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (Var1){\nVar2=FUNC1(Var3,Var1); \nfree(Var1); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 646,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4511,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\n*Var4=0; \nFUNC2(Var2,Var5,0); \nVar5=Var4+1; \nVar4=strchr(Var6,Var7); \nFUNC2(Var2,Var5,0); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 647,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4516,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\n*Var4=0; \nFUNC2(Var2,Var5,0); \nVar5=Var4+1; \nVar4=strchr(Var6,Var7); \nFUNC2(Var2,Var5,0); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 648,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4521,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\n*Var4=0; \nFUNC2(Var2,Var5,0); \nVar5=Var4+1; \nVar4=strchr(Var6,Var7); \nFUNC2(Var2,Var5,0); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 649,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4524,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tfree (str);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){\nchar *Var4,*Var5,*Var6=strdup(Var3); \nif (!Var6){\nVar5=Var6; \nVar4=strchr(Var6,Var7); \nwhile (Var4){\nVar4=strchr(Var6,Var7); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmdf",
    "Source": false,
    "Sink": false,
    "idx": 650,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4533,
    "label": -3,
    "slices": [
      "R_API int r_core_cmdf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tint ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd (core, string, 0);\n",
      "\tva_end (ap);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,...){\nchar  Var4[4096]; \nint  Var5; \nSTRUCT2  Var6; \nFUNC2(Var6,Var3); \nvsnprintf(Var4,sizeof (Var4),Var3,Var6); \nVar5=FUNC3(Var2,Var4,0); \nFUNC4(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 651,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4552,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\treturn NULL;\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nreturn FUNC3(Var1,Var2); \nif (FUNC6(STRING,&Var4) != -1){\nint  Var11=FUNC7(Var4,1,0); \nif (Var11 == -1){\nreturn FUNC3(Var1,Var2); \nchar *Var12=strdup(Var2); \nVar3=FUNC8(Var4,NULL ); \nif (Var3){\nreturn FUNC3(Var1,Var2); \nreturn NULL ; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 652,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4557,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\t\treturn hres;\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\treturn ret;\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nfree(Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nfree(Var7); \nreturn  Var8; \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nfree(Var6); \nreturn  Var10; \nreturn FUNC3(Var1,Var2); \nif (FUNC6(STRING,&Var4) != -1){\nint  Var11=FUNC7(Var4,1,0); \nif (Var11 == -1){\nreturn FUNC3(Var1,Var2); \nchar *Var12=strdup(Var2); \nif (Var3){\nreturn FUNC3(Var1,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 653,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4559,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nchar *Var9=FUNC3(Var1,Var6); \nint  Var10=FUNC5(Var4,1,0); \nchar *Var11=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 654,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4561,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nif (FUNC2(0)){\nchar *Var3=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var3){\nchar *Var4=strdup(Var2); \nVar4[Var3-Var2]=0; \nif (!strcmp(Var3+1,STRING)){\nchar *Var5=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var6=FUNC4(Var5,NULL ); \nelse \nint  Var7=FUNC5(Var1->memberVar1,STRING); \nchar *Var8=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var9=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 655,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4563,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nif (!strcmp(Var5+1,STRING)){\nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nfree(Var7); \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nchar *Var11=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 656,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4570,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nif (FUNC2(0)){\nchar *Var3=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var3){\nchar *Var4=strdup(Var2); \nVar4[Var3-Var2]=0; \nif (!strcmp(Var3+1,STRING)){\nchar *Var5=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var6=FUNC4(Var5,NULL ); \nelse \nint  Var7=FUNC5(Var1->memberVar1,STRING); \nchar *Var8=FUNC3(Var1,Var4); \nfree(Var4); \nchar *Var9=strdup(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 657,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4583,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (FUNC1(0)){\nchar *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; \nchar *Var4=FUNC2(Var5,NULL ); \nif (FUNC3(STRING,&Var2) != -1){\nint  Var6=FUNC4(Var2,1,0); \nif (Var6 == -1){\nFUNC5(Var2); \nfree(Var2); \nVar1=FUNC6(Var2,NULL ); \nif (Var1){\nFUNC5(Var2); \nfree(Var2); \nFUNC7(STRING,Var2); \nFUNC5(Var2); \nfree(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 658,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4586,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nif (Var5){\nchar *Var6=strdup(Var2); \nVar6[Var5-Var2]=0; \nchar *Var7=FUNC3(Var1,Var6); \nchar *Var8=FUNC4(Var7,NULL ); \nelse \nint  Var9=FUNC5(Var1->memberVar1,STRING); \nchar *Var10=FUNC3(Var1,Var6); \nreturn FUNC3(Var1,Var2); \nif (FUNC6(STRING,&Var4) != -1){\nint  Var11=FUNC7(Var4,1,0); \nif (Var11 == -1){\nreturn FUNC3(Var1,Var2); \nchar *Var12=strdup(Var2); \nFUNC8(Var1,Var12); \nif (Var3){\nfree(Var12); \nfree(Var12); \nreturn FUNC3(Var1,Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 659,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4594,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (FUNC1(0)){\nchar *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; \nchar *Var4=FUNC2(Var5,NULL ); \nif (FUNC3(STRING,&Var2) != -1){\nint  Var6=FUNC4(Var2,1,0); \nif (Var6 == -1){\nFUNC5(Var2); \nfree(Var2); \nVar1=FUNC6(Var2,NULL ); \nif (Var1){\nFUNC5(Var2); \nfree(Var2); \nFUNC7(STRING,Var2); \nFUNC5(Var2); \nfree(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 660,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4595,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nchar *Var6=strdup(Var2); \nchar *Var7=FUNC3(Var1,Var6); \nelse \nint  Var8=FUNC4(Var1->memberVar1,STRING); \nchar *Var9=FUNC3(Var1,Var6); \nif (FUNC5(STRING,&Var4) != -1){\nint  Var10=FUNC6(Var4,1,0); \nif (Var10 == -1){\nchar *Var11=strdup(Var2); \nFUNC7(Var1,Var11); \nif (Var3){\nfree(Var11); \nfree(Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 661,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4600,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ],
    "tokenized": "char *Var1,*Var2=NULL ; \nif (FUNC1(0)){\nchar *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; \nchar *Var4=FUNC2(Var5,NULL ); \nif (FUNC3(STRING,&Var2) != -1){\nint  Var6=FUNC4(Var2,1,0); \nif (Var6 == -1){\nFUNC5(Var2); \nfree(Var2); \nVar1=FUNC6(Var2,NULL ); \nif (Var1){\nFUNC5(Var2); \nfree(Var2); \nFUNC7(STRING,Var2); \nFUNC5(Var2); \nfree(Var2); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 662,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4601,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){\nchar *Var3,*Var4=NULL ; \nif (FUNC2(0)){\nchar *Var5=(*Var2 != ) strchr(Var2,|) NULL ; \nchar *Var6=strdup(Var2); \nchar *Var7=FUNC3(Var1,Var6); \nelse \nint  Var8=FUNC4(Var1->memberVar1,STRING); \nchar *Var9=FUNC3(Var1,Var6); \nif (FUNC5(STRING,&Var4) != -1){\nint  Var10=FUNC6(Var4,1,0); \nif (Var10 == -1){\nchar *Var11=strdup(Var2); \nFUNC7(Var1,Var11); \nif (Var3){\nfree(Var11); \nfree(Var11); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_strf",
    "Source": false,
    "Sink": false,
    "idx": 663,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4614,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tchar *ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd_str (core, string);\n",
      "\tva_end (ap);\n"
    ],
    "tokenized": "STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2,...){\nchar  Var3[4096]; \nchar *Var4; \nSTRUCT3  Var5; \nFUNC2(Var5,Var2); \nvsnprintf(Var3,sizeof (Var3),Var2,Var5); \nVar4=FUNC3(Var1,Var3); \nFUNC4(Var5); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str",
    "Source": false,
    "Sink": false,
    "idx": 664,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4631,
    "label": -3,
    "slices": [
      "\tconst char *static_str;\n",
      "\tchar *retstr = NULL;\n",
      "\tif (r_core_cmd (core, cmd, 0) == -1) {\n",
      "\tstatic_str = r_cons_get_buffer ();\n",
      "\tretstr = strdup (static_str? static_str: \"\");\n",
      "\treturn retstr;\n"
    ],
    "tokenized": "const char *Var1; \nchar *Var2=NULL ; \nif (FUNC1(Var3,Var4,0) == -1){\nVar1=FUNC2(); \nVar2=strdup(Var1  Var1 STRING); \nreturn  Var2; \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 665,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4684,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){\nSTRUCT2 *Var5=Var2->memberVar1; \nchar *Var6=strdup(Var3); \nif (!Var6){\nVar5->memberVar1=Var6; \nint  Var7=FUNC2(Var2,Var5); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 666,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4692,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ],
    "tokenized": "Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){\nSTRUCT2 *Var5=Var2->memberVar1; \nchar *Var6=strdup(Var3); \nif (!Var6){\nVar5->memberVar1=Var6; \nint  Var7=FUNC2(Var2,Var5); \nfree(Var6); \n"
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "compare_cmd_descriptor_name",
    "Source": false,
    "Sink": false,
    "idx": 667,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4701,
    "label": -3,
    "slices": [
      "static int compare_cmd_descriptor_name(const void *a, const void *b) {\n",
      "\treturn strcmp (((RCmdDescriptor *)a)->cmd, ((RCmdDescriptor *)b)->cmd);\n"
    ],
    "tokenized": "static int FUNC1(const void *Var1,const void *Var2){\nreturn strcmp(((STRUCT1 *) Var1)->memberVar1,((STRUCT1 *) Var2)->memberVar1); \n"
  }
]
