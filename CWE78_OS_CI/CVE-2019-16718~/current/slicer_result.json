[
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 0,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 361,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 1,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 379,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 2,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 390,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 3,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 391,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 4,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 395,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 5,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 399,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\tlines = atoi (arg);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 6,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 417,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 7,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 422,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 8,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 435,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n",
      "\t\tr_core_cmdf (data, \"s-%s\", input + 1);\n",
      "\t\tr_core_cmdf (data, \"wc%s\", input + 1);\n",
      "\t\tif (input[1] == 'i' && input[2] == 'q') {\n",
      "\t\t\tcmd_uniq (core, input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 9,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 436,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 10,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 444,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 11,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 504,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 12,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 505,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 13,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 510,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 14,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 511,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 15,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 512,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 16,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 513,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 17,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 518,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 18,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 526,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 19,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 531,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 20,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 546,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 21,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 563,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\t\tif (buf[2] == '*') {\n",
      "else\n",
      "\t\t\t\tr_cons_printf (\"%s=base64:%s\\n\", keys[i], q);\n",
      "\t\t\tfree (q);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 22,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 584,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 23,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 592,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_rap",
    "Source": false,
    "Sink": false,
    "idx": 24,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 648,
    "label": -3,
    "slices": [
      "static int cmd_rap(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '=') {\n",
      "else\n",
      "\t\t\tchar *res = r_io_system (core->io, input + 1);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\tconst char *arg = r_str_trim_ro (input + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 25,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 705,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n",
      "\t\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 26,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 706,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 27,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 738,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tcore->num->value = r_buf_size (core->yank_buf);\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_paste (core, n, 0);\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n",
      "\t\tr_core_cmd_help (core, help_msg_y);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 28,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 742,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 29,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 749,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 30,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 803,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 31,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 804,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (sig);\n",
      "\t\t\tfree (data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 32,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strtok",
    "line": 807,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 33,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 809,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 34,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 810,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 35,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 839,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 36,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 843,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 37,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 847,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 38,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 861,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 39,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 866,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 40,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 868,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 41,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 872,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 42,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 876,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 43,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 880,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tfree (absfile);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 44,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 884,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 45,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 895,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_strcat (out);\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tret = out? true: false;\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 46,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 914,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 47,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 918,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 48,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 920,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 49,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 928,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 50,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 930,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 51,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 934,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 52,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 936,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 53,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 940,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 54,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 942,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 55,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 946,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 56,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 948,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 57,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 952,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 58,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 954,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 59,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 958,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 60,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 960,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 61,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 964,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 62,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 966,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 63,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 970,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 64,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 973,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 65,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 980,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 66,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 982,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 67,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 985,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 68,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 989,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 69,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 991,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 70,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 995,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 71,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1005,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tfree (lang);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 72,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1006,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 73,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1009,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\tfree (abspath);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 74,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1016,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 75,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1022,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (arg) {\n",
      "\t\t\tr_core_cmdf (core, \"cat %s~..\", arg);\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 76,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1047,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 77,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1057,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 78,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1058,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 79,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1063,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 80,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1087,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg1) {\n",
      "\t\t\targ1 = \"\";\n",
      "\t\tif (!arg2) {\n",
      "\t\t\targ2 = \"\";\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 81,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1118,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\t*ptr = 0;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 82,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1123,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\t*eol = 0;\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 83,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1135,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "else\n",
      "\t\t\t\thost = \"localhost\";\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 84,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1149,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\tr_core_cmd (core, str, 0);\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 85,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1158,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 86,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1159,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 87,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1166,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 88,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1206,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n",
      "\t\tfree (str);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 89,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1207,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 90,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1225,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 91,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1230,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 92,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1232,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 93,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1241,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 94,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1242,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 95,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1258,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 96,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1259,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 97,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1268,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 98,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1269,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 99,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1295,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tr_cons_printf (\"\\n\\n\\\"%s\\\" : [\", cur_cmd);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 100,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1314,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 101,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1329,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 102,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1330,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 103,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1338,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\tfree (out);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 104,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1354,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 105,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1357,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 106,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1363,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 107,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1384,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 108,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1385,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 109,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1403,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 110,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1408,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 111,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1430,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 112,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1441,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 113,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1442,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 114,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1455,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 115,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1470,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 116,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1472,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 117,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1478,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 118,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1480,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 119,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1544,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tint argc = 0;\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (args);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 120,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1545,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (a);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 121,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1578,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 122,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1584,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 123,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 124,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 125,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1727,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 126,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1730,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 127,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1823,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "else\n",
      "\t\tret = r_core_cmdf (core, \"?v [%s]\", input);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 128,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1824,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 129,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1835,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_autocomplete",
    "Source": false,
    "Sink": false,
    "idx": 130,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 1950,
    "label": -3,
    "slices": [
      "static void cmd_autocomplete(RCore *core, const char *input) {\n",
      "\tRCoreAutocomplete* b = core->autocomplete;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\tchar arg[256];\n",
      "\tif (!*input) {\n",
      "\tif (*input == '?') {\n",
      "\tif (*input == '-') {\n",
      "\t\tconst char *arg = input + 1;\n",
      "\t\tif (!*input) {\n",
      "\t\tr_core_autocomplete_remove (b, arg);\n",
      "\twhile (b) {\n",
      "\t\tconst char* end = r_str_trim_wp (input);\n",
      "\t\tif (!end) {\n",
      "\t\tif ((end - input) >= sizeof (arg)) {\n",
      "\t\tif (end == input) {\n",
      "\t\tmemcpy (arg, input, end - input);\n",
      "\t\targ[end - input] = 0;\n",
      "\t\tRCoreAutocomplete* a = r_core_autocomplete_find (b, arg, true);\n",
      "\t\tinput = r_str_trim_ro (end);\n",
      "\t\tif (input && *input && !a) {\n",
      "\t\t\tif (b->type == R_CORE_AUTOCMPLT_DFLT && !(b = r_core_autocomplete_add (b, arg, R_CORE_AUTOCMPLT_DFLT, false))) {\n",
      "else\n",
      "\t\t\t} else if (b->type != R_CORE_AUTOCMPLT_DFLT) {\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && !a) {\n",
      "\t\t\tif (arg[0] == '$') {\n",
      "\t\t\t\tint type = autocomplete_type (arg);\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && a) {\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 131,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2032,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t(void)r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 132,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2048,
    "label": -3,
    "slices": [
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tint olen;\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_cons_memcat (out, olen);\n",
      "\t\t\t\t\tfree (out);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 133,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2049,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 134,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2071,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tcmd = r_str_replace (cmd, \" \", \"\\\\ \", true);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\\ \", \" \", false);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\"\", \"'\", false);\n",
      "\t\tret = r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\tfree (cmd);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 135,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 2075,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '?') {\n",
      "else\n",
      "\t\t\tif (!r_sandbox_enable (0)) {\n",
      "\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_core_sysenv_end (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tn = atoi (input);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_sysenv_end (core, input);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 136,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2089,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tret = r_sys_cmd (cmd);\n",
      "\t\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 137,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2138,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 138,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "calloc",
    "line": 2142,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 139,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2167,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tclose (1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 140,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2168,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 141,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2185,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tfd_out = -1;\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 142,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2189,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tcons_out = dup (1);\n",
      "\tif (cons_out != -1) {\n",
      "\t\tdup2 (cons_out, 1);\n",
      "\t\tclose (cons_out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 143,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2191,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 144,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2192,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\t_shell_cmd_ = r_sys_conv_utf8_to_win (_shell_cmd);\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tfree (_shell_cmd_);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 145,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2222,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tstr = r_core_cmd_str (core, radare_cmd);\n",
      "\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n",
      "\t\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 146,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2224,
    "label": -3,
    "slices": [
      "\tint si, olen, ret = -1, pipecolor = -1;\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tout = NULL;\n",
      "\t\tr_cons_memcat (out, olen);\n",
      "\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 147,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 2231,
    "label": -3,
    "slices": [
      "\tif (r_sandbox_enable (0)) {\n",
      "\tsignal (SIGPIPE, SIG_IGN);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 148,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2238,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 149,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2241,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 150,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2242,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 151,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2245,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tclose (1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 152,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2248,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 153,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2250,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 154,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2254,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 155,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2278,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n",
      "\tfree (s);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 156,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2280,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 157,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2282,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 158,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2283,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 159,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2291,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 160,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2300,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 161,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2301,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 162,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2305,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 163,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2312,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 164,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 165,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 166,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2325,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\tif (http) {\n",
      "\t\t\t*http = 0;\n",
      "\t\t\thttp--;\n",
      "\t\t\tif (*http == ' ') {\n",
      "\t\t\t\t*http = 0;\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 167,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2342,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n",
      "\t\t*cmt = 0;\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\tfree (icmd);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 168,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2364,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 169,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2365,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 170,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2416,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 171,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2420,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 172,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2424,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 173,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2434,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 174,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2457,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\tfree (icmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 175,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2474,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\t\treturn q;\n",
      "\treturn strchr (p, '-');\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 176,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2478,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\treturn strchr (p, '-');\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "tmpenvs_free",
    "Source": false,
    "Sink": false,
    "idx": 177,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2483,
    "label": -3,
    "slices": [
      "static void tmpenvs_free(void *item) {\n",
      "\tr_sys_setenv (item, NULL);\n",
      "\tfree (item);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "set_tmp_arch",
    "Source": false,
    "Sink": false,
    "idx": 178,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2490,
    "label": -3,
    "slices": [
      "static bool set_tmp_arch(RCore *core, char *arch, char **tmparch) {\n",
      "\t*tmparch = strdup (r_config_get (core->config, \"asm.arch\"));\n",
      "\tr_config_set (core->config, \"asm.arch\", arch);\n",
      "\tcore->fixedarch = true;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "set_tmp_bits",
    "Source": false,
    "Sink": false,
    "idx": 179,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2500,
    "label": -3,
    "slices": [
      "static bool set_tmp_bits(RCore *core, int bits, char **tmpbits) {\n",
      "\t*tmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n",
      "\tr_config_set_i (core->config, \"asm.bits\", bits);\n",
      "\tcore->fixedbits = true;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 180,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2533,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 181,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2535,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tchar *$1 = strchr ($0 + 2, ')');\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 182,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 183,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 184,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2572,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 185,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2592,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 186,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2603,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 187,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2617,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 188,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2628,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p + 1;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 189,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2660,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 190,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2711,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 191,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2711,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 192,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2715,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 193,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2720,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 194,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2727,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 195,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2731,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 196,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2743,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\t\tif (res) {\n",
      "\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\t\t\t\tfree (res);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 197,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2781,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\t\treturn ret;\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\t\t\t*fdnum = 0;\n",
      "else\n",
      "\t\t\t\tif (IS_DIGIT (*fdnum)) {\n",
      "\t\t\t\t\tfdn = *fdnum - '0';\n",
      "\t\t\t\t*fdnum = 0;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tfree (str);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tr_cons_grep_process (grep);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 198,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2787,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 199,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2814,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 200,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2826,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 201,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 2827,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 202,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 2835,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\twrite (1, \"> \", 2);\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 203,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 2836,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 204,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2840,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 205,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2841,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 206,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "realloc",
    "line": 2843,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 207,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2845,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 208,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcat",
    "line": 2848,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 209,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2860,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 210,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2883,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 211,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2883,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 212,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2920,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 213,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2936,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 214,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2941,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 215,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2946,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 216,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2949,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 217,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2975,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 218,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2990,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 219,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2995,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 220,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2995,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 221,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 3002,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 222,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3002,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 223,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3006,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 224,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3033,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 225,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3044,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 226,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3047,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 227,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3051,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 228,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 3059,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 229,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 3069,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 230,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3087,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 231,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3098,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 232,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3114,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_break_push (NULL, NULL);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\t\tarroba = NULL;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\ttmpdesc = NULL;\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\t\ttmpdesc = NULL;\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 233,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3134,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 234,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3135,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 235,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3141,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 236,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3205,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 237,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3207,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 238,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 3210,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 239,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3215,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 240,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3224,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 241,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3233,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tfree (numexpr);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 242,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3239,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 243,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3264,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 244,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3270,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 245,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3270,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 246,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3292,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 247,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3305,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 248,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 3313,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 249,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3318,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 250,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3331,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 251,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 252,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 253,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 254,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3376,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 255,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3380,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 256,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3380,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 257,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3447,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 258,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3450,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 259,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3451,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpasm);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\t\tR_FREE (tmpasm);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 260,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3452,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpbits);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreach_comment",
    "Source": false,
    "Sink": false,
    "idx": 261,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3576,
    "label": -3,
    "slices": [
      "static int foreach_comment(void *user, const char *k, const char *v) {\n",
      "\tif (!strncmp (k, \"meta.C.\", 7)) {\n",
      "\t\tchar *cmt = (char *)sdb_decode (v, 0);\n",
      "\t\tif (cmt) {\n",
      "\t\t\tfree (cmt);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreach_pairs",
    "Source": false,
    "Sink": false,
    "idx": 262,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3599,
    "label": -3,
    "slices": [
      "static void foreach_pairs(RCore *core, const char *cmd, const char *each) {\n",
      "\tconst char *arg;\n",
      "\tint pair = 0;\n",
      "\tfor (arg = each ; ; ) {\n",
      "\t\tchar *next = strchr (arg, ' ');\n",
      "\t\tif (next) {\n",
      "\t\t\t*next = 0;\n",
      "\t\tif (arg && *arg) {\n",
      "\t\t\tut64 n = r_num_get (NULL, arg);\n",
      "\t\t\tif (pair%2) {\n",
      "\t\t\t\tr_core_block_size (core, n);\n",
      "else\n",
      "\t\t\t\tr_core_seek (core, n, 1);\n",
      "\t\tif (!next) {\n",
      "\t\targ = next + 1;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 263,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3642,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\tif (filter) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tforeach_pairs (core, cmd, arg);\n",
      "\t\t\tfree (arg);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 264,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3728,
    "label": -3,
    "slices": [
      "\tRDebug *dbg = core->dbg;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRBinImport *imp;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tchar *impflag = r_str_newf (\"sym.imp.%s\", imp->name);\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\t\tfree (impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 addr = sec->vaddr;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 265,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3819,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tr_flag_foreach_glob (core->flags, glob, exec_command_on_flag, &u);\n",
      "\t\t\tfree (glob);\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 266,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3867,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 267,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3881,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 268,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3889,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\teach = nextLine;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 269,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3899,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = NULL;\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 270,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3918,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 271,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3953,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\t\tfree (out);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 272,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3958,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tRFlagItem *flag;\n",
      "\tut64 oseek, addr;\n",
      "\toseek = core->offset;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmd);\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\tr_core_cmd_help (core, help_msg_at_at);\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tr_core_block_size (core, bb->size);\n",
      "\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tr_core_block_size (core, bs);\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 cur;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\t\tfor (cur = from; cur < to; cur += step) {\n",
      "\t\t\t\t\t(void)r_core_seek (core, cur, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tcore->cons->context->grep = grep;\n",
      "\t\t\tRDebugPid *p;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_debug_select (core->dbg, pid, pid);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\t\tRDebugFrame *frame;\n",
      "\t\t\tRList *list;\n",
      "\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n",
      "\t\t\t\tswitch (each[3]) {\n",
      "\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_core_seek (core, oseek, 0);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\t\taddr = core->rcmd->macro._brk_value;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n",
      "\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "\t\t\t\t\tcore->rcmd->macro.counter++;\n",
      "\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\tr_flag_foreach_space (core->flags, flagspace, duplicate_flag, &u);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\tcore->rcmd->macro.counter++ ;\n",
      "\tcore->offset = oseek;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 273,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3962,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 274,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3964,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 275,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 4043,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 276,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4065,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 277,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4069,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 278,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4102,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\t\t\tfree (arg);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 279,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4153,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 280,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4167,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\tfree (out);\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 281,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 4199,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tut64 oseek, addr;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tbuf[0] = '\\0';\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 282,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 4209,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 283,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4231,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 284,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4265,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tr_cons_break_push (NULL, NULL); //pop on return\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t} while (str != NULL);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 285,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4268,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 286,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4281,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 287,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4282,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 288,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4285,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "run_pending_anal",
    "Source": false,
    "Sink": false,
    "idx": 289,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4297,
    "label": -3,
    "slices": [
      "R_API void run_pending_anal(RCore *core) {\n",
      "\tcore->ev->incall = false;\n",
      "\tif (core && core->anal && core->anal->cmdtail) {\n",
      "\t\tchar *res = core->anal->cmdtail;\n",
      "\t\tr_core_cmd_lines (core, res);\n",
      "\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 290,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4308,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 291,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4313,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 292,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4323,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 293,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4347,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 294,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4348,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 295,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 4351,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 296,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4351,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 297,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4362,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 298,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4369,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 299,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4386,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 300,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4412,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 301,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4416,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 302,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4421,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 303,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4443,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 304,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4449,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 305,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4459,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tfree (data);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 306,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4465,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 307,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4468,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 308,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4478,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 309,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4483,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_disassemble_instr",
    "Source": false,
    "Sink": false,
    "idx": 310,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4493,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_disassemble_bytes",
    "Source": false,
    "Sink": false,
    "idx": 311,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4503,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 312,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4509,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 313,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4514,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 314,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4519,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 315,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4522,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmdf",
    "Source": false,
    "Sink": false,
    "idx": 316,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4531,
    "label": -3,
    "slices": [
      "R_API int r_core_cmdf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tint ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd (core, string, 0);\n",
      "\tva_end (ap);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 317,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4550,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\treturn NULL;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 318,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4555,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\t\treturn hres;\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\treturn ret;\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 319,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4557,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 320,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4559,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 321,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4561,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 322,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4568,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 323,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4581,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 324,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4584,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 325,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4592,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 326,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4593,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 327,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4598,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 328,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4599,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_strf",
    "Source": false,
    "Sink": false,
    "idx": 329,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4612,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tchar *ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd_str (core, string);\n",
      "\tva_end (ap);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_str",
    "Source": false,
    "Sink": false,
    "idx": 330,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4629,
    "label": -3,
    "slices": [
      "\tconst char *static_str;\n",
      "\tchar *retstr = NULL;\n",
      "\tif (r_core_cmd (core, cmd, 0) == -1) {\n",
      "\tstatic_str = r_cons_get_buffer ();\n",
      "\tretstr = strdup (static_str? static_str: \"\");\n",
      "\treturn retstr;\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 331,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4682,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 332,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4690,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "before_cmd.c",
    "Caller": "compare_cmd_descriptor_name",
    "Source": false,
    "Sink": false,
    "idx": 333,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4699,
    "label": -3,
    "slices": [
      "static int compare_cmd_descriptor_name(const void *a, const void *b) {\n",
      "\treturn strcmp (((RCmdDescriptor *)a)->cmd, ((RCmdDescriptor *)b)->cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 334,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 361,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uniq",
    "Source": false,
    "Sink": false,
    "idx": 335,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 379,
    "label": -3,
    "slices": [
      "static int cmd_uniq(void *data, const char *input) { // \"uniq\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_uniq (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 336,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 390,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 337,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 391,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 338,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 395,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\t*count = 0;\t// split the count and file name\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 339,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 399,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\tlines = atoi (arg);\n",
      "\tswitch (*input) {\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 340,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 417,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tint lines = 5;\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "\tchar *tmp, *count;\n",
      "\tif (arg) {\n",
      "\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains \"count filename\"\n",
      "\t\tcount = strchr (arg, ' ');\n",
      "\t\tif (count) {\n",
      "\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n",
      "\t\t\tlines = atoi (arg);\n",
      "\t\t\targ = tmp;\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_head",
    "Source": false,
    "Sink": false,
    "idx": 341,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 422,
    "label": -3,
    "slices": [
      "static int cmd_head (void *data, const char *_input) { // \"head\"\n",
      "\tchar *input = strdup (_input);\n",
      "\tchar *arg = strchr (input, ' ');\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_head (arg, lines);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 342,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 435,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n",
      "\t\tr_core_cmdf (data, \"s-%s\", input + 1);\n",
      "\t\tr_core_cmdf (data, \"wc%s\", input + 1);\n",
      "\t\tif (input[1] == 'i' && input[2] == 'q') {\n",
      "\t\t\tcmd_uniq (core, input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 343,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 436,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\t*rcmd++ = 0;\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\t\tr_core_undo_push (core, undo);\n",
      "\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_uname",
    "Source": false,
    "Sink": false,
    "idx": 344,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 444,
    "label": -3,
    "slices": [
      "static int cmd_uname(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tchar *cmd = strdup (input + 2);\n",
      "\t\t\tchar *rcmd = strchr (cmd, ',');\n",
      "\t\t\tif (rcmd) {\n",
      "\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n",
      "\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 345,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 504,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 346,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 505,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tr_cons_println (v);\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "\t\t\t\tr_cons_strcat (v + 1);\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\t\tr_core_cmd0 (core, v);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 347,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 510,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 348,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 511,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "else\n",
      "\t\tif (q) {\n",
      "\t\t\t*q = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 349,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 512,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 350,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 513,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\t*desc = 0;\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 351,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 518,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 352,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 526,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\t*def++ = 0;\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n",
      "\t\t\tdef[len - 1] = 0x00;\n",
      "\t\t\tdef++;\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 353,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 531,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "\t\t\t\t\t\tfree (n);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 354,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 546,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 355,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 563,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "\t\t\tif (buf[2] == '*') {\n",
      "else\n",
      "\t\t\t\tr_cons_printf (\"%s=base64:%s\\n\", keys[i], q);\n",
      "\t\t\tfree (q);\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 356,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 584,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tif (*v == '$') {\n",
      "else\n",
      "\t\t\t} else if (q) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "\t\t\t\tr_core_cmd0 (core, out);\n",
      "\t\t\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_alias",
    "Source": false,
    "Sink": false,
    "idx": 357,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 592,
    "label": -3,
    "slices": [
      "static int cmd_alias(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tif (*input == '?') {\n",
      "\tint i = strlen (input);\n",
      "\tchar *buf = malloc (i + 2);\n",
      "\tif (!buf) {\n",
      "\t*buf = '$'; // prefix aliases with a dollar\n",
      "\tmemcpy (buf + 1, input, i + 1);\n",
      "\tchar *q = strchr (buf, ' ');\n",
      "\tchar *def = strchr (buf, '=');\n",
      "\tchar *desc = strchr (buf, '?');\n",
      "\tif ((def && q && (def < q)) || (def && !q)) {\n",
      "\t\tsize_t len = strlen (def);\n",
      "\t\tif (!q || (q && q > def)) {\n",
      "\t\t\tif (*def) {\n",
      "\t\t\t\tif (!strcmp (def, \"-\")) {\n",
      "\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n",
      "\t\t\t\t\tif (n) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n",
      "else\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n",
      "else\n",
      "\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n",
      "else\n",
      "\t} else if (desc && !q) {\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\tfree (buf);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "else\n",
      "\t} else if (buf[1] == '*') {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tfor (i = 0; i < count; i++) {\n",
      "\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n",
      "\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n",
      "else\n",
      "\t} else if (!buf[1]) {\n",
      "\t\tint i, count = 0;\n",
      "\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n",
      "\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n",
      "\t\tif (v) {\n",
      "\t\t\t\tchar *out = r_str_newf (\"%s %s\", v, q + 1);\n",
      "else\n",
      "\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_rap",
    "Source": false,
    "Sink": false,
    "idx": 358,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 648,
    "label": -3,
    "slices": [
      "static int cmd_rap(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '=') {\n",
      "else\n",
      "\t\t\tchar *res = r_io_system (core->io, input + 1);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\tconst char *arg = r_str_trim_ro (input + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 359,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 705,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n",
      "\t\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_rap_run",
    "Source": false,
    "Sink": false,
    "idx": 360,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 706,
    "label": -3,
    "slices": [
      "static int cmd_rap_run(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tchar *res = r_io_system (core->io, input);\n",
      "\tif (res) {\n",
      "\t\tint ret = atoi (res);\n",
      "\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 361,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 738,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tcore->num->value = r_buf_size (core->yank_buf);\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_paste (core, n, 0);\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n",
      "\t\tr_core_cmd_help (core, help_msg_y);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 362,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 742,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tut64 n;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\twhile (input[1] == ' ') {\n",
      "\t\t\tinput++;\n",
      "\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n",
      "\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n",
      "\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n",
      "\t\tif (input[1] == 'f') { // \"wtf\"\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "else\n",
      "\t\t} else if (input[1] == ' ') {\n",
      "\t\t\tr_core_yank_to (core, input + 1);\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tr_core_yank_file_ex (core, input + 1);\n",
      "\t\t\tr_core_yank_hexpair (core, input + 2);\n",
      "\t\t\tr_core_yank_file_all (core, input + 2);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\tr_core_yank_dump (core, 0, input[0]);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 363,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 749,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\tswitch (input[1]) {\n",
      "\t\t\tif (input[2] == ' ') {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n",
      "\t\t\t\tfree (out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 364,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 803,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 365,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 804,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (sig);\n",
      "\t\t\tfree (data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 366,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strtok",
    "line": 807,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 367,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 809,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tfree (sig);\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\tfree (sig);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_yank",
    "Source": false,
    "Sink": false,
    "idx": 368,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 810,
    "label": -3,
    "slices": [
      "static int cmd_yank(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\t\tchar *out = strdup (input + 3);\n",
      "\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n",
      "\t\t\tchar *sig = r_core_cmd_str (core, \"y*\");\n",
      "\t\t\tif (!sig || !*sig) {\n",
      "\t\t\t\tsig = strdup (\"wx 10203040\");\n",
      "\t\t\tchar *data = r_core_editor (core, NULL, sig);\n",
      "\t\t\t(void) strtok (data, \";\\n\");\n",
      "\t\t\tr_core_cmdf (core, \"y%s\", data);\n",
      "\t\t\tfree (data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 369,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 839,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 370,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 843,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\tif (nl) {\n",
      "\t\t\t\t*nl = 0;\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "langFromHashbang",
    "Source": false,
    "Sink": false,
    "idx": 371,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 847,
    "label": -3,
    "slices": [
      "\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n",
      "\tif (fd != -1) {\n",
      "\t\tchar firstLine[128] = {0};\n",
      "\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n",
      "\t\tfirstLine[len] = 0;\n",
      "\t\tif (!strncmp (firstLine, \"#!/\", 3)) {\n",
      "\t\t\tchar *nl = strchr (firstLine, '\\n');\n",
      "\t\t\tnl = strchr (firstLine, ' ');\n",
      "\t\t\treturn strdup (firstLine + 2);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 372,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 861,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 373,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 866,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 374,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 868,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 375,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 872,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 376,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 876,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 377,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 880,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tfree (absfile);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 378,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 884,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "\t\tfree (httpIndex);\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 379,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 895,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_strcat (out);\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "\t\t\tfree (out);\n",
      "\t\tret = out? true: false;\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 380,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 914,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 381,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 918,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 382,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 920,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 383,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 928,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 384,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 930,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 385,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 934,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 386,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 936,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 387,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 940,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 388,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 942,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 389,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 946,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 390,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 948,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 391,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 952,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 392,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 954,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 393,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 958,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 394,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 960,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 395,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 964,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 396,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 966,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 397,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 970,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 398,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 973,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 399,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 980,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 400,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 982,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (!shell) {\n",
      "\t\t\t\t\t\tshell = strdup (\"sh\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tfree (shell);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 401,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 985,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 402,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 989,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 403,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 991,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 404,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 995,
    "label": -3,
    "slices": [
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 405,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1005,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tfree (lang);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 406,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1006,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 407,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1009,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (p) {\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\tfree (abspath);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_run_script",
    "Source": false,
    "Sink": false,
    "idx": 408,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1016,
    "label": -3,
    "slices": [
      "R_API bool r_core_run_script(RCore *core, const char *file) {\n",
      "\tbool ret = false;\n",
      "\tRLangPlugin *p;\n",
      "\tchar *name;\n",
      "\t\tif (!strcmp (file, name)) {\n",
      "\tr_list_push (core->scriptstack, strdup (file));\n",
      "\tif (!strcmp (file, \"-\")) {\n",
      "\t\tchar *out = r_core_editor (core, NULL, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tret = r_core_cmd_lines (core, out);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".html\")) {\n",
      "\t\tconst bool httpSandbox = r_config_get_i (core->config, \"http.sandbox\");\n",
      "\t\tchar *httpIndex = strdup (r_config_get (core->config, \"http.index\"));\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", 0);\n",
      "\t\tchar *absfile = r_file_abspath (file);\n",
      "\t\tr_config_set (core->config, \"http.index\", absfile);\n",
      "\t\tr_core_cmdf (core, \"=H\");\n",
      "\t\tr_config_set_i (core->config, \"http.sandbox\", httpSandbox);\n",
      "\t\tr_config_set (core->config, \"http.index\", httpIndex);\n",
      "else\n",
      "\t} else if (r_str_endswith (file, \".c\")) {\n",
      "\t\tr_core_cmd_strf (core, \"#!c %s\", file);\n",
      "else\n",
      "\t} else if (r_file_is_c (file)) {\n",
      "\t\tconst char *dir = r_config_get (core->config, \"dir.types\");\n",
      "\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n",
      "\t\tif (out) {\n",
      "\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n",
      "else\n",
      "\t\tp = r_lang_get_by_extension (core->lang, file);\n",
      "\t\tif (p) {\n",
      "\t\t\tr_lang_use (core->lang, p->name);\n",
      "\t\t\tret = lang_run_file (core, core->lang, file);\n",
      "\t\t\tconst char *p = r_str_lchr (file, '.');\n",
      "\t\t\tif (p) {\n",
      "\t\t\t\tconst char *ext = p + 1;\n",
      "\t\t\t\tif (!strcmp (ext, \"js\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"zig\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"zig run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"ruby\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"vala\")) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"vala\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, file);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"sh\")) {\n",
      "\t\t\t\t\tchar *shell = r_sys_getenv (\"SHELL\");\n",
      "\t\t\t\t\tif (shell) {\n",
      "\t\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", shell, file);\n",
      "\t\t\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n",
      "\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "else\n",
      "\t\t\t\tchar *abspath = r_file_path (file);\n",
      "\t\t\t\tchar *lang = langFromHashbang (core, file);\n",
      "\t\t\t\tif (lang) {\n",
      "\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n",
      "\t\t\t\t\tchar *cmd = r_str_newf (\"%s '%s'\", lang, file);\n",
      "\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n",
      "\t\t\tif (!ret) {\n",
      "\t\t\t\tret = r_core_cmd_file (core, file);\n",
      "\tfree (r_list_pop (core->scriptstack));\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 409,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1022,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (arg) {\n",
      "\t\t\tr_core_cmdf (core, \"cat %s~..\", arg);\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "\t\t\tr_core_cmdf (core, \"md %s\", arg);\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_ls",
    "Source": false,
    "Sink": false,
    "idx": 410,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1047,
    "label": -3,
    "slices": [
      "static int cmd_ls(void *data, const char *input) { // \"ls\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *arg = strchr (input, ' ');\n",
      "\tif (arg) {\n",
      "\t\targ = r_str_trim_ro (arg + 1);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg) {\n",
      "\t\t\targ = \"\";\n",
      "\t\tif (r_fs_check (core->fs, arg)) {\n",
      "else\n",
      "\t\t\tchar *res = r_syscmd_ls (arg);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 411,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1057,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 412,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1058,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tR_FREE (tmp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 413,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1063,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\t*end = '\\0';\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_join",
    "Source": false,
    "Sink": false,
    "idx": 414,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1087,
    "label": -3,
    "slices": [
      "static int cmd_join(void *data, const char *input) { // \"join\"\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tconst char *tmp = strdup (input);\n",
      "\tconst char *arg1 = strchr (tmp, ' ');\n",
      "\tif (!arg1) {\n",
      "\targ1 = r_str_trim_ro (arg1);\n",
      "\tchar *end = strchr (arg1, ' ');\n",
      "\tif (!end) {\n",
      "\tconst char *arg2 = end+1;\n",
      "\tif (!arg2) {\n",
      "\targ2 = r_str_trim_ro (arg2);\n",
      "\tswitch (*input) {\n",
      "\t\tif (!arg1) {\n",
      "\t\t\targ1 = \"\";\n",
      "\t\tif (!arg2) {\n",
      "\t\t\targ2 = \"\";\n",
      "\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n",
      "\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_print (res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 415,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1118,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\t*ptr = 0;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 416,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1123,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\t*eol = 0;\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 417,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1135,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = eol + 1;\n",
      "else\n",
      "\t\t\t\thost = \"localhost\";\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n",
      "\t\t\tif (rbuf) {\n",
      "\t\t\t\tr_cons_print (rbuf);\n",
      "\t\t\t\tfree (rbuf);\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 418,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1149,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\tr_core_cmd (core, str, 0);\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 419,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1158,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 420,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1159,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (sp) {\n",
      "\t\t\t\t*sp = 0;\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 421,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1166,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n",
      "\t\t\t\tr_core_run_script (core, s);\n",
      "\t\t\tfree (s);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 422,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1206,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tconst char *host, *port, *cmd;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif ((ptr = strchr (input + 1, ' '))) {\n",
      "\t\t\teol = strchr (input + 1, ':');\n",
      "\t\t\tif (eol) {\n",
      "\t\t\t\thost = input + 1;\n",
      "\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n",
      "else\n",
      "\t\t\tr_core_rtr_cmds (core, input + 1);\n",
      "\t\tif (input[1] == '.') { // \"...\" run the last command repeated\n",
      "else\n",
      "\t\t} else if (input[1]) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tr_core_cmd_command (core, input + 1);\n",
      "\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n",
      "\t\tfree (str);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 423,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1207,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 424,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1225,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (eol) {\n",
      "\t\t\t\t\t*eol = '\\0';\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 425,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1230,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = 0;\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (filter) {\n",
      "\t\t\t*filter = '~';\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 426,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1232,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\tif (ptr) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\teol = strchr (ptr, '\\n');\n",
      "\t\t\t\tif (*ptr) {\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\t\t\t\tr_core_cmd0 (core, p);\n",
      "\t\t\t\t\tfree (p);\n",
      "\t\t\t\tif (!eol) {\n",
      "\t\t\t\tptr = eol + 1;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 427,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1241,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_interpret",
    "Source": false,
    "Sink": false,
    "idx": 428,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1242,
    "label": -3,
    "slices": [
      "static int cmd_interpret(void *data, const char *input) {\n",
      "\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n",
      "\tRCore *core = (RCore *)data;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n",
      "\t\t\tconst char *a = r_str_trim_ro (input + 1);\n",
      "\t\t\tchar *s = strdup (a);\n",
      "\t\t\tchar *sp = strchr (s, ' ');\n",
      "\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n",
      "\t\tif (*input >= 0 && *input <= 9) {\n",
      "\t\tinp = strdup (input);\n",
      "\t\tfilter = strchr (inp, '~');\n",
      "\t\tptr = str = r_core_cmd_str (core, inp);\n",
      "\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 429,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1258,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_up",
    "Source": false,
    "Sink": false,
    "idx": 430,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1259,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_up(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 431,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1268,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_line_hist_sdb_down",
    "Source": false,
    "Sink": false,
    "idx": 432,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1269,
    "label": -3,
    "slices": [
      "R_API int r_line_hist_sdb_down(RLine *line) {\n",
      "\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n",
      "\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n",
      "\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n",
      "\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 433,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1295,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tr_cons_printf (\"\\n\\n\\\"%s\\\" : [\", cur_cmd);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 434,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1314,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\tr_cons_printf (\"\\\"%s\\\",\", temp_cmd);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 435,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1329,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (next_cmd);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 436,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1330,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, \"anal/**\");\n",
      "\t\tif (!out) {\n",
      "\t\twhile (*out) {\n",
      "\t\t\tcur_pos = strchr (out, '\\n');\n",
      "\t\t\tif (!cur_pos) {\n",
      "\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n",
      "\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", cur_cmd);\n",
      "\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n",
      "\t\t\tif (!temp_storage) {\n",
      "\t\t\t\tout += cur_pos - out + 1;\n",
      "\t\t\twhile (*temp_storage) {\n",
      "\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n",
      "\t\t\t\tif (!temp_pos) {\n",
      "\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n",
      "\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n",
      "\t\t\tout += cur_pos - out + 1;\n",
      "\t\tfree (temp_storage);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 437,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1338,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\tfree (out);\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 438,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1354,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 439,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1357,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n",
      "\t\t\t\tif (n) {\n",
      "\t\t\t\t\t*n++ = 0;\n",
      "\t\t\t\ts = sdb_ns (s, o, 1);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tif (out) {\n",
      "\t\t\t\tr_cons_println (out);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 440,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1363,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tfor (n = o = p; n; o = n) {\n",
      "\t\t\tfree (p);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tr_line_set_prompt (p);\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 441,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1384,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 442,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1385,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst int buflen = sizeof (buf) - 1;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (!line->sdbshell_hist) {\n",
      "\t\t\tline->sdbshell_hist = r_list_newf (free);\n",
      "\t\tRList *sdb_hist = line->sdbshell_hist;\n",
      "\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n",
      "\t\t\tif (!*buf) {\n",
      "\t\t\tif (sdb_hist) {\n",
      "\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n",
      "\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n",
      "\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n",
      "\t\t\tout = sdb_querys (s, NULL, 0, buf);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 443,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1403,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 444,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1408,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 445,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1430,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 446,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1441,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\tif (r_file_exists (fn)) {\n",
      "\t\t\t\t\tif (db) {\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\t\t\t\t\tif (newdb) {\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 447,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1442,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\t*ns++ = 0;\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\t\t\tsdb_sync (db);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"Cannot find sdb '%s'\\n\", ns);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 448,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1455,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tswitch (input[0]) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db;\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\tif (ns) {\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\t\t\t\tif (db) {\n",
      "\t\t\t\t\tsdb_file (db, fn);\n",
      "\t\t\tfree (fn);\n",
      "\t\tchar *inp = strdup (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 449,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1470,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 450,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1472,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tout = sdb_querys (s, NULL, 0, input + 1);\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 451,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1478,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tchar buf[1024], *out;\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n",
      "\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tsp = strchr (input + 1, ' ');\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n",
      "\t\tif (out) {\n",
      "\t\t\tr_cons_println (out);\n",
      "\t\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_kuery",
    "Source": false,
    "Sink": false,
    "idx": 452,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1480,
    "label": -3,
    "slices": [
      "static int cmd_kuery(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tconst char *sp, *p = \"[sdb]> \";\n",
      "\tSdb *s = core->sdb;\n",
      "\tswitch (input[0]) {\n",
      "\t\tif (core->http_up) {\n",
      "\t\tif (!r_cons_is_interactive ()) {\n",
      "\t\t\tchar *n, *o, *p = strdup (input + 2);\n",
      "\t\tRLine *line = core->cons->line;\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\tif (input[1] == ' ') {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tif (!fn) {\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tchar *fn = strdup (input + 2);\n",
      "\t\t\tchar *ns = strchr (fn, ' ');\n",
      "\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n",
      "\tif (input[0] == '\\0') {\n",
      "\tif (sp) {\n",
      "\t\tchar *inp = strdup (input);\n",
      "\t\tinp [(size_t)(sp - input)] = 0;\n",
      "\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n",
      "\t\tfree (inp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 453,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1544,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tint argc = 0;\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (args);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "__runMain",
    "Source": false,
    "Sink": false,
    "idx": 454,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1545,
    "label": -3,
    "slices": [
      "static int __runMain(RMainCallback cb, const char *arg) {\n",
      "\tchar *a = r_str_trim_dup (arg);\n",
      "\tchar **args = r_str_argv (a, &argc);\n",
      "\tint res = cb (argc, args);\n",
      "\tfree (a);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 455,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1578,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_r2cmd",
    "Source": false,
    "Sink": false,
    "idx": 456,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1584,
    "label": -3,
    "slices": [
      "static bool cmd_r2cmd(RCore *core, const char *_input) {\n",
      "\tchar *input = r_str_newf (\"r%s\", _input);\n",
      "\tint rc = 0;\n",
      "\tif (r_str_startswith (input, \"rax2\")) {\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radare2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rasm2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"rabin2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"ragg2\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"r2pm\")) {\n",
      "\t\tr_sys_cmdf (\"%s\", input);\n",
      "else\n",
      "\t} else if (r_str_startswith (input, \"radiff2\")) {\n",
      "\t\trc = __runMain (core->r_main_radiff2, input);\n",
      "else\n",
      "\t\tconst char *r2cmds[] = {\n",
      "\t\tint i;\n",
      "\t\tfor (i = 0; r2cmds[i]; i++) {\n",
      "\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n",
      "\t\t\t\tfree (input);\n",
      "\tfree (input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 457,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_resize",
    "Source": false,
    "Sink": false,
    "idx": 458,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1653,
    "label": -3,
    "slices": [
      "\tRCore *core = (RCore *)data;\n",
      "\tif (cmd_r2cmd (core, input)) {\n",
      "\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tconst char *file = r_str_trim_ro (input + 2);\n",
      "\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 459,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1727,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pipein",
    "Source": false,
    "Sink": false,
    "idx": 460,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1730,
    "label": -3,
    "slices": [
      "static int cmd_pipein(void *user, const char *input) {\n",
      "\tchar *buf = strdup (input);\n",
      "\tint len = r_str_unescape (buf);\n",
      "\tr_cons_readpush (buf, len);\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 461,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 1823,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "else\n",
      "\t\tret = r_core_cmdf (core, \"?v [%s]\", input);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 462,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 1824,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\t*eq++ = 0;\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_pointer",
    "Source": false,
    "Sink": false,
    "idx": 463,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 1835,
    "label": -3,
    "slices": [
      "static int cmd_pointer(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*) data;\n",
      "\tint ret = true;\n",
      "\tchar *str, *eq;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\twhile (*input == ' ') {\n",
      "\t\tinput++;\n",
      "\tif (!*input || *input == '?') {\n",
      "\tstr = strdup (input);\n",
      "\teq = strchr (str, '=');\n",
      "\tif (eq) {\n",
      "\t\tif (!strncmp (eq, \"0x\", 2)) {\n",
      "\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n",
      "else\n",
      "\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_autocomplete",
    "Source": false,
    "Sink": false,
    "idx": 464,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 1950,
    "label": -3,
    "slices": [
      "static void cmd_autocomplete(RCore *core, const char *input) {\n",
      "\tRCoreAutocomplete* b = core->autocomplete;\n",
      "\tinput = r_str_trim_ro (input);\n",
      "\tchar arg[256];\n",
      "\tif (!*input) {\n",
      "\tif (*input == '?') {\n",
      "\tif (*input == '-') {\n",
      "\t\tconst char *arg = input + 1;\n",
      "\t\tif (!*input) {\n",
      "\t\tr_core_autocomplete_remove (b, arg);\n",
      "\twhile (b) {\n",
      "\t\tconst char* end = r_str_trim_wp (input);\n",
      "\t\tif (!end) {\n",
      "\t\tif ((end - input) >= sizeof (arg)) {\n",
      "\t\tif (end == input) {\n",
      "\t\tmemcpy (arg, input, end - input);\n",
      "\t\targ[end - input] = 0;\n",
      "\t\tRCoreAutocomplete* a = r_core_autocomplete_find (b, arg, true);\n",
      "\t\tinput = r_str_trim_ro (end);\n",
      "\t\tif (input && *input && !a) {\n",
      "\t\t\tif (b->type == R_CORE_AUTOCMPLT_DFLT && !(b = r_core_autocomplete_add (b, arg, R_CORE_AUTOCMPLT_DFLT, false))) {\n",
      "else\n",
      "\t\t\t} else if (b->type != R_CORE_AUTOCMPLT_DFLT) {\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && !a) {\n",
      "\t\t\tif (arg[0] == '$') {\n",
      "\t\t\t\tint type = autocomplete_type (arg);\n",
      "else\n",
      "\t\t} else if ((!input || !*input) && a) {\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 465,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2032,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t(void)r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 466,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2048,
    "label": -3,
    "slices": [
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tint olen;\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_cons_memcat (out, olen);\n",
      "\t\t\t\t\tfree (out);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 467,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2049,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *out = NULL;\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n",
      "\t\t\t\t\tfree (cmd);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 468,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2071,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tcmd = r_str_replace (cmd, \" \", \"\\\\ \", true);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\\ \", \" \", false);\n",
      "\t\tcmd = r_str_replace (cmd, \"\\\"\", \"'\", false);\n",
      "\t\tret = r_core_cmdf (core, \"\\\"#!pipe %s\\\"\", cmd);\n",
      "\t\tfree (cmd);\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 469,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 2075,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tswitch (*input) {\n",
      "\t\tif (input[1] == '?') {\n",
      "else\n",
      "\t\t\tif (!r_sandbox_enable (0)) {\n",
      "\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n",
      "\t\tif (input[1] == '!') { // !!! & !!!-\n",
      "else\n",
      "\t\t} else if (input[1] == '?') {\n",
      "else\n",
      "\t\t} else if (input[1] == '*') {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "else\n",
      "\t\t\tif (r_sandbox_enable (0)) {\n",
      "\t\t\tif (input[1]) {\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\t\tif (cmd) {\n",
      "\t\t\t\t\tr_core_sysenv_end (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tn = atoi (input);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tr_core_sysenv_end (core, input);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "cmd_system",
    "Source": false,
    "Sink": false,
    "idx": 470,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2089,
    "label": -3,
    "slices": [
      "static int cmd_system(void *data, const char *input) {\n",
      "\tRCore *core = (RCore*)data;\n",
      "\tut64 n;\n",
      "\tint ret = 0;\n",
      "\tswitch (*input) {\n",
      "\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\tchar *cmd = r_str_trim_dup (input + 1);\n",
      "\t\tif (*input == '0' || n > 0) {\n",
      "\t\t\tconst char *cmd = r_line_hist_get (n);\n",
      "else\n",
      "\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n",
      "\t\t\tif (cmd) {\n",
      "\t\t\t\tret = r_sys_cmd (cmd);\n",
      "\t\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 471,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2138,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 472,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "calloc",
    "line": 2142,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 473,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2167,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tclose (1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 474,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2168,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 475,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2185,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n",
      "\tif (fd_out == -1) {\n",
      "\tdup2 (fd_out, 1);\n",
      "\tclose (fd_out);\n",
      "\tfd_out = -1;\n",
      "\tif (fd_out != -1) {\n",
      "\t\tclose (fd_out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 476,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2189,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tint fd_out = -1, cons_out = -1;\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n",
      "\tif (fd_out == -1) {\n",
      "\tcons_out = dup (1);\n",
      "\tif (cons_out != -1) {\n",
      "\t\tdup2 (cons_out, 1);\n",
      "\t\tclose (cons_out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 477,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2191,
    "label": -3,
    "slices": [
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\t_tcscat_s (systemdir, MAX_PATH, TEXT(\"\\\\cmd.exe\"));\n",
      "\tfree (systemdir);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_w32_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 478,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2192,
    "label": -3,
    "slices": [
      "static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tHANDLE pipe[2] = {NULL, NULL};\n",
      "\tchar *_shell_cmd = NULL;\n",
      "\tLPTSTR _shell_cmd_ = NULL;\n",
      "\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n",
      "\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n",
      "\tchar *tmp = r_str_newf (\"/Q /c \\\"%s\\\"\", shell_cmd);\n",
      "\tif (!tmp) {\n",
      "\t_shell_cmd = tmp;\n",
      "\t_shell_cmd_ = r_sys_conv_utf8_to_win (_shell_cmd);\n",
      "\tif (!_shell_cmd_) {\n",
      "\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n",
      "\tif (!systemdir) {\n",
      "\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n",
      "\tif (!ret) {\n",
      "\tfree (_shell_cmd_);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 479,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2222,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tstr = r_core_cmd_str (core, radare_cmd);\n",
      "\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n",
      "\t\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 480,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2224,
    "label": -3,
    "slices": [
      "\tint si, olen, ret = -1, pipecolor = -1;\n",
      "\tchar *str, *out = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (*shell_cmd=='!') {\n",
      "\t\tout = NULL;\n",
      "\t\tr_cons_memcat (out, olen);\n",
      "\t\tfree (out);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 481,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 2231,
    "label": -3,
    "slices": [
      "\tif (r_sandbox_enable (0)) {\n",
      "\tsignal (SIGPIPE, SIG_IGN);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 482,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2238,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 483,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2241,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 484,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2242,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 485,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2245,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tclose (1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 486,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2248,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 487,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2250,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (fds[1], 1);\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tclose (fds[0]);\n",
      "else\n",
      "\t\t\t\tclose (fds[1]);\n",
      "\t\t\t\tdup2 (fds[0], 0);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_pipe",
    "Source": false,
    "Sink": false,
    "idx": 488,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 2254,
    "label": -3,
    "slices": [
      "\tint stdout_fd, fds[2];\n",
      "\tint child;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\tstdout_fd = dup (1);\n",
      "\tif (stdout_fd != -1) {\n",
      "\t\tif (pipe (fds) == 0) {\n",
      "\t\t\tif (child == -1) {\n",
      "else\n",
      "\t\t\t} else if (child) {\n",
      "\t\t\t\tdup2 (stdout_fd, 1);\n",
      "\t\t\t\tclose (stdout_fd);\n",
      "\t\t\t\tclose (stdout_fd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 489,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2278,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n",
      "\tfree (s);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 490,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2280,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 491,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2282,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 492,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2283,
    "label": -3,
    "slices": [
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 493,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2291,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\teq = strchr (kv, '=');\n",
      "\t\tif (eq) {\n",
      "\t\t\t*eq = 0;\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tr_config_set (core->config, kv, eq + 1);\n",
      "\t\t\t*eq = '=';\n",
      "else\n",
      "\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 494,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2300,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 495,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2301,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (res);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\treturn res;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 496,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2305,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\tres = r_str_prepend (res, cmd);\n",
      "\t\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "parse_tmp_evals",
    "Source": false,
    "Sink": false,
    "idx": 497,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2312,
    "label": -3,
    "slices": [
      "static char *parse_tmp_evals(RCore *core, const char *str) {\n",
      "\tchar *s = strdup (str);\n",
      "\tint i, argc = r_str_split (s, ',');\n",
      "\tchar *res = strdup (\"\");\n",
      "\tif (!s || !res) {\n",
      "\t\tfree (s);\n",
      "\tfor (i = 0; i < argc; i++) {\n",
      "\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n",
      "\t\tif (!kv) {\n",
      "\t\tif (eq) {\n",
      "\t\t\tconst char *ov = r_config_get (core->config, kv);\n",
      "\t\t\tif (!ov) {\n",
      "\t\t\tchar *cmd = r_str_newf (\"e %s=%s;\", kv, ov);\n",
      "\t\t\tif (!cmd) {\n",
      "\t\t\t\tfree (s);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 498,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 499,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2324,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 500,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2325,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\tif (http) {\n",
      "\t\t\t*http = 0;\n",
      "\t\t\thttp--;\n",
      "\t\t\tif (*http == ' ') {\n",
      "\t\t\t\t*http = 0;\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\t\tchar *cr = strdup (cmdrep);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 501,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2342,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n",
      "\t\t*cmt = 0;\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\tfree (icmd);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 502,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2364,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 503,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2365,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\t\treturn r_core_cmd0 (core, cmd);\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n",
      "\t\t\tif ((colon = strchr (cmd, ';'))) {\n",
      "\t\t\t\t*colon = 0;\n",
      "\tif (rep > 0) {\n",
      "\t\twhile (IS_DIGIT (*cmd)) {\n",
      "\t\t\tcmd++;\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\t\tfor (++colon; *colon == ';'; colon++) {\n",
      "\t\tr_core_cmd_subst (core, colon);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 504,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2416,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 505,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2420,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 506,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2424,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 507,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2434,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n",
      "\t\tcore->prompt_offset = core->offset;\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (core->break_loop) {\n",
      "\t\t\tfree (cr);\n",
      "\t\tif (cr && *cr && orep > 1) {\n",
      "\t\t\t(void)r_core_cmd0 (core, cr);\n",
      "\t\tfree (cr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst",
    "Source": false,
    "Sink": false,
    "idx": 508,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2457,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst(RCore *core, char *cmd) {\n",
      "\tut64 rep = strtoull (cmd, NULL, 10);\n",
      "\tint ret = 0, orep;\n",
      "\tchar *cmt, *colon = NULL, *icmd = NULL;\n",
      "\tbool original_tmpseek = core->tmpseek;\n",
      "\tif (r_str_startswith (cmd, \"GET /cmd/\")) {\n",
      "\t\tchar *http = strstr (cmd, \"HTTP\");\n",
      "\tut64 orig_offset = core->offset;\n",
      "\ticmd = strdup (cmd);\n",
      "\tcmd = r_str_trim_head_tail (icmd);\n",
      "\tif (!*cmd) {\n",
      "\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n",
      "\tcmt = *icmd ? (char *)r_str_firstbut (icmd, '#', \"\\\"\"): NULL;\n",
      "\tif (rep > 0) {\n",
      "\t\tif (!*cmd) {\n",
      "\tif (rep > 1 && r_sandbox_enable (0)) {\n",
      "else\n",
      "\t\tif (rep > INTERACTIVE_MAX_REP) {\n",
      "\t\t\tif (r_cons_is_interactive ()) {\n",
      "\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";\n",
      "\tint ocur_enabled = core->print && core->print->cur_enabled;\n",
      "\twhile (rep-- && *cmd) {\n",
      "\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tchar *cr = strdup (cmdrep);\n",
      "\t\tif (ret && *cmd == 'q') {\n",
      "\t\tif (core->break_loop) {\n",
      "\tif (colon && colon[1]) {\n",
      "\tfree (icmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 509,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2474,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\t\treturn q;\n",
      "\treturn strchr (p, '-');\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "findSeparator",
    "Source": false,
    "Sink": false,
    "idx": 510,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2478,
    "label": -3,
    "slices": [
      "static char* findSeparator(char *p) {\n",
      "\tchar *q = strchr (p, '+');\n",
      "\tif (q) {\n",
      "\treturn strchr (p, '-');\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "tmpenvs_free",
    "Source": false,
    "Sink": false,
    "idx": 511,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2483,
    "label": -3,
    "slices": [
      "static void tmpenvs_free(void *item) {\n",
      "\tr_sys_setenv (item, NULL);\n",
      "\tfree (item);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "set_tmp_arch",
    "Source": false,
    "Sink": false,
    "idx": 512,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2490,
    "label": -3,
    "slices": [
      "static bool set_tmp_arch(RCore *core, char *arch, char **tmparch) {\n",
      "\t*tmparch = strdup (r_config_get (core->config, \"asm.arch\"));\n",
      "\tr_config_set (core->config, \"asm.arch\", arch);\n",
      "\tcore->fixedarch = true;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "set_tmp_bits",
    "Source": false,
    "Sink": false,
    "idx": 513,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2500,
    "label": -3,
    "slices": [
      "static bool set_tmp_bits(RCore *core, int bits, char **tmpbits) {\n",
      "\t*tmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n",
      "\tr_config_set_i (core->config, \"asm.bits\", bits);\n",
      "\tcore->fixedbits = true;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 514,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2533,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 515,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2535,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tchar *$1 = strchr ($0 + 2, ')');\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 516,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 517,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2539,
    "label": -3,
    "slices": [
      "\tif (!cmd) {\n",
      "\tif ($0) {\n",
      "\t\tif ($1) {\n",
      "\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 518,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2572,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tchar op0 = 0;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\top0 = *q;\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\t\t\t*p = op0;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 519,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2593,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tchar op0 = 0;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\top0 = *q;\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\t\t\t*p = op0;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 520,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2605,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (sc) {\n",
      "\t\t\t\t\t*sc = 0;\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tchar op0 = 0;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\top0 = *q;\n",
      "\t\t\t\t\t\t*q = 0;\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*p = '\"';\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\tif (p && *p && p[1] == '>') {\n",
      "\t\t\t\t\tstr = p + 2;\n",
      "\t\t\t\t\twhile (*str == '>') {\n",
      "\t\t\t\t\t\tstr++;\n",
      "\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tstr = p + 2;\n",
      "\t\t\t\twhile (IS_WHITESPACE (*str)) {\n",
      "\t\t\t\t\tstr++;\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\t\t\t*p = op0;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 521,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 2619,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 522,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2630,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t*p++ = 0;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\tcmd = sc + 1;\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[0] == '@') {\n",
      "\t\t\t\t\tp--;\n",
      "\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n",
      "\t\t\t\t\tp++;\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tp = q;\n",
      "else\n",
      "\t\t\t\t\t\tp = strchr (p + 1, ';');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tfree (line);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (*p == ';') {\n",
      "\t\t\t\t\tcmd = p + 1;\n",
      "else\n",
      "\t\t\t\t\tif (*p == '\"') {\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "\t\t\t\t\t\tcmd = p;\n",
      "else\n",
      "\t\t\t\tcmd = p + 1;\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 523,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2662,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 524,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2713,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 525,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2713,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 526,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2717,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 527,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2722,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 528,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2729,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 529,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2733,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 530,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2745,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\t\tif (res) {\n",
      "\t\t\t\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\t\t\t\tfree (res);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 531,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2783,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\t\treturn ret;\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\t\t\t*fdnum = 0;\n",
      "else\n",
      "\t\t\t\tif (IS_DIGIT (*fdnum)) {\n",
      "\t\t\t\t\tfdn = *fdnum - '0';\n",
      "\t\t\t\t*fdnum = 0;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t\tr_cons_pipe_close (pipefd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tfree (str);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tr_cons_grep_process (grep);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 532,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 2789,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 533,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2816,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 534,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2828,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 535,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 2829,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 536,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "write",
    "line": 2837,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\twrite (1, \"> \", 2);\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 537,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 2838,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 538,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2842,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 539,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2843,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\t\treturn ret;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 540,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "realloc",
    "line": 2845,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 541,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2847,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 542,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcat",
    "line": 2850,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 543,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2862,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 544,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2885,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 545,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2885,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 546,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 2922,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 547,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2938,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tret = strlen (buf);\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "\t\t\t\t\t\tfree (two);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tut8 *buf;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 548,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2943,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\t\tfree (n);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 549,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2948,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "\t\t\t\tfree (n);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 550,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2951,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 551,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 2977,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tint pipefd = -1;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tstr = r_file_temp (\"dumpedit\");\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tif (editor && *editor) {\n",
      "\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n",
      "\t\t\t\tr_file_rm (str);\n",
      "\t\t\tfree (str);\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 552,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 2992,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 553,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 2997,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 554,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 2997,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 555,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memmove",
    "line": 3004,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 556,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3004,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 557,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3008,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\t*ptr2 = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 558,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3035,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 559,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3046,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\t\t\tfree (str);\n",
      "\t\t\treturn ret;\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 560,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3049,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 561,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3053,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tint oneline = 1;\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\t\tfree (str);\n",
      "\t\t\tif (oneline && str) {\n",
      "\t\t\t\tfor (i = 0; str[i]; i++) {\n",
      "\t\t\t\t\tif (str[i] == '\\n') {\n",
      "\t\t\t\t\t\tstr[i] = ' ';\n",
      "\t\t\tstr = r_str_append (str, ptr2 + 1);\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tfree (str);\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 562,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 3061,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 563,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 3071,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tif (cmd == s) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 564,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3089,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tcmd = ptr + 1;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\t*ptr = ';';\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tbool empty = false;\n",
      "\t\tif (ptr[1] == '`') {\n",
      "\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n",
      "\t\tptr2 = strchr (ptr + 1, '`');\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "else\n",
      "\t\t\t\t\t\t\teprintf (\"The current basic block has %d instructions\\n\", bb->ninstr);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\tif (tmpseek) {\n",
      "\t\t*tmpseek = cmd_tmpseek;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 565,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3100,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 566,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3116,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\thaveQuote = q != NULL;\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_break_push (NULL, NULL);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tif (arroba) {\n",
      "\t\t\t*arroba = 0;\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index < 0) {\n",
      "\t\t\t\t\t\t\tindex = bb->ninstr + index;\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\t\t\t*trim = 0;\n",
      "\t\t\t\ttrim--;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t*arroba = '@';\n",
      "\t\t\tarroba = NULL;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\twhile (*rule && *rule == ' ') {\n",
      "\t\t\t\t\trule++;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\ttmpdesc = NULL;\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\t\ttmpdesc = NULL;\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 567,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3136,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 568,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3137,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\t*v++ = 0;\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 569,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3143,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "\t\t\tif (v) {\n",
      "\t\t\t\tr_sys_setenv (k, v);\n",
      "\t\t\t\tr_list_append (tmpenvs, k);\n",
      "else\n",
      "\t\t\t\tfree (k);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 570,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3207,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 571,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3209,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 572,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcpy",
    "line": 3212,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tbuf = malloc (sz);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 573,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3217,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "\t\t\t\t\tfree (f);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 574,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3226,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\t*sep = 0;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\t*sep = ch;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 575,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3235,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tfree (numexpr);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (arroba) {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 576,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3241,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\tfree (mander);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 577,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3266,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tchar *$0 = strstr (cmd, \"$(\");\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\thaveQuote = *cmd == '\"';\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tcmd++;\n",
      "\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tline = strdup (cmd);\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"command error(%s)\\n\", cmd);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tptr = strchr (cmd, '`');\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcmd = r_str_append (strdup (cmd), str);\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tfree (cmd);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '.') {\n",
      "\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\tfree (cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\t\twhile (trim > cmd) {\n",
      "\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n",
      "\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 578,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 3272,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 579,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3272,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 580,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3294,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tfree (buf);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 581,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3307,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\t\t\tfree (out);\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 582,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 3315,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tint cmd_ignbithints = -1;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tfor (; *cmd; ) {\n",
      "\t\t\tint pipefd = -1;\n",
      "\t\t\tut64 oseek = UT64_MAX;\n",
      "\t\t\tchar *line, *p;\n",
      "\t\t\tif (haveQuote) {\n",
      "\t\t\t\tif (!p || !*p) {\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\tr_core_cmd0 (core, cmd);\n",
      "\t\t\t\tif (!sc) {\n",
      "\t\t\tif (*p) {\n",
      "\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\toseek = core->offset;\n",
      "\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\t\tif (p && *p && p[1] == '|') {\n",
      "\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n",
      "else\n",
      "\t\t\t\tr_cmd_call (core->rcmd, line);\n",
      "\t\t\tif (oseek != UT64_MAX) {\n",
      "\t\t\t\tr_core_seek (core, oseek, 1);\n",
      "\t\t\tif (!p) {\n",
      "\t\t\tif (eos) {\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\t\treturn r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "\t\t\t\t\tret = *cmd ? r_core_cmdf (core, \".%s\", cmd) : 0;\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\t\t\t\t\tcore->num->value = value;\n",
      "else\n",
      "\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n",
      "\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tret = r_cmd_call (core->rcmd, cmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tR_FREE (core->oobi);\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tint detail = 0;\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\trecursive_help (core, detail, cmd);\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\t\tif (scr_color != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = malloc (1);\n",
      "\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\tcore->oobi[0] = '\\0';\n",
      "\t\t\t\tcore->oobi_len = 0;\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\t\tif (feof (stdin)) {\n",
      "\t\t\t\t\tcore->oobi_len += ret;\n",
      "\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n",
      "\t\t\t\t\tif (core->oobi) {\n",
      "\t\t\t\t\t\tif (!strcmp (buf, str)) {\n",
      "\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tfree (core->oobi);\n",
      "\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n",
      "\t\tint fdn = 1;\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\t\tif (*fdnum == 'H') { // \"H>\"\n",
      "\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n",
      "\t\tif (!strcmp (str, \"-\")) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\tif (*str == '$') {\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\tif (appendResult) {\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\t\tif (oldText) {\n",
      "\t\t\t\t\tchar *two = r_str_newf (\"%s%s\", oldText, o);\n",
      "\t\t\t\t\tif (two) {\n",
      "\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n",
      "else\n",
      "\t\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t\t\tchar *n = r_str_newf (\"$%s\", o);\n",
      "\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n",
      "else\n",
      "\t\t} else if (fdn > 0) {\n",
      "\t\t\tif (pipefd != -1) {\n",
      "\t\t\t\tif (!pipecolor) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n",
      "\t\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\tif (!pipecolor) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (use_editor) {\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\tif (scr_html != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\t\tif (scr_color != -1) {\n",
      "\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\t\tcore->cons->use_tts = false;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "\t\t\tif (ptr[1] == '!') {\n",
      "\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n",
      "\t\t\t\tcore->cmd_in_backticks = true;\n",
      "\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n",
      "\t\t\t\tcore->cmd_in_backticks = false;\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\t\t\tcore->num->value = value;\n",
      "\t\t\tret = r_core_cmd_subst (core, cmd);\n",
      "\t\t\tif (scr_html != -1) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\tif (bb) {\n",
      "\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n",
      "\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tfree (core->block);\n",
      "\t\t\t\t\t\tcore->block = buf;\n",
      "\t\t\t\t\t\tcore->blocksize = sz;\n",
      "\t\t\t\t\t\tmemcpy (core->block, f, sz);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n",
      "\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\t\tr_core_seek (core, regval, 1);\n",
      "\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, \"anal.ignbithints\");\n",
      "\t\t\t\tr_config_set_i (core->config, \"anal.ignbithints\", 1);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tif (out) {\n",
      "\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (!core->io->va) {\n",
      "\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (pamode) {\n",
      "\t\t\t\t\t\t\t\tr_config_set_i (core->config, \"io.va\", 1);\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\taddr = r_num_math (core->num, offstr);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tif (ch == '-' || ch == '+') {\n",
      "\t\t\t\taddr = core->offset + addr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (core->fixedblock) {\n",
      "\t\t\tr_core_block_read (core);\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tcore->offset = addr;\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\t\tif (ptr[1]) {\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_block_read (core);\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tcore->fixedarch = oldfixedarch;\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\t\tcore->fixedbits = oldfixedbits;\n",
      "\t\tif (tmpbsz != core->blocksize) {\n",
      "\t\t\tr_core_block_size (core, tmpbsz);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tcore->fixedarch = oldfixedarch;\n",
      "\tcore->fixedbits = oldfixedbits;\n",
      "\tif (cmd_ignbithints != -1) {\n",
      "\t\tr_config_set_i (core->config, \"anal.ignbithints\", cmd_ignbithints);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 583,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3320,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\tif (q) {\n",
      "\t\t\t\t\t\t*q++ = 0;\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 584,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3333,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tint scr_html = -1;\n",
      "\tint scr_color = -1;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t} else if (!ptr2) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\tif (!str) {\n",
      "\t\t\tif (*str == '|' || *str == '*') {\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tint rc = 0;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint tmpfd = -1;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n",
      "\t\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\tif (len > 0) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\t\tif (d) {\n",
      "\t\t\t\t\t\t\tif (tmpdesc) {\n",
      "\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\t\t\t\t\t\ttmpdesc = d;\n",
      "\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n",
      "\t\t\t\t\t\t\tr_core_block_size (core, len);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\tif (addr) {\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\t\tif (d) {\n",
      "\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tcore->fixedblock = !!tmpdesc;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n",
      "\t\t\tif (usemyblock) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n",
      "\t\t\tif (tmpseek) {\n",
      "\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n",
      "\t\tif (tmpfd != -1) {\n",
      "\t\t\tr_io_use_fd (core->io, tmpfd);\n",
      "\t\tif (tmpdesc) {\n",
      "\t\t\tif (pamode) {\n",
      "\t\t\t\tr_config_set_i (core->config, \"io.va\", 0);\n",
      "\t\t\tr_io_desc_close (tmpdesc);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n",
      "\t\tif (flgspc_changed) {\n",
      "\t\t\tr_flag_space_pop (core->flags);\n",
      "\t\t*ptr = '@';\n",
      "\t\trc = ret;\n",
      "\tif (scr_html != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n",
      "\tif (scr_color != -1) {\n",
      "\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n",
      "\tif (tmpdesc) {\n",
      "\t\tr_io_desc_close (tmpdesc);\n",
      "\treturn rc;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 585,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 586,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 587,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 588,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memcmp",
    "line": 3378,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 589,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3382,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 590,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 3382,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool usemyblock = false;\n",
      "\tbool eos = false;\n",
      "\tbool haveQuote = false;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tbool cmd_tmpseek = false;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "\t\t\t\t\tif (*cmd) {\n",
      "\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n",
      "\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n",
      "\t\t\t\t\tchar buf[1024];\n",
      "\t\t\t\t\tint ret;\n",
      "else\n",
      "\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint use_editor = false;\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n",
      "\t\tif (!*str) {\n",
      "\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tbool addr_is_set = false;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tbool flgspc_changed = false;\n",
      "\t\tint sz, len;\n",
      "\t\tut8 *buf;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\tif (ptr[3] == '.') { // \"@...\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n",
      "\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n",
      "\t\t\t\tif (f) {\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "else\n",
      "\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tut64 regval;\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\tchar *sep = findSeparator (mander);\n",
      "\t\t\t\t\tif (sep) {\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "else\n",
      "\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n",
      "\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tif (addr) {\n",
      "\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n",
      "\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n",
      "\t\t\t\tif (ptr[1] == ':') {\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n",
      "\t\t\t\t\tlen = strlen (ptr + 2);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "else\n",
      "\t\t\t\t*ptr2 = '\\0';\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n",
      "\t\toffstr = r_str_trim_head (ptr + 1);\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\tif (ptr[2] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "else\n",
      "\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n",
      "else\n",
      "\t\t\tbool tmpseek = false;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\tif (usemyblock) {\n",
      "else\n",
      "\t\t\t\tif (addr_is_set) {\n",
      "\t\tif (ptr2) {\n",
      "\t\t\t*ptr2 = '!';\n",
      "\t\t*ptr = '@';\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 591,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3449,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tptr = r_str_trim_head (ptr + 1) - 1;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t*p = '\\x00';\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\t\t\tfor (i = 0; tovars[i]; i++) {\n",
      "\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 592,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3452,
    "label": -3,
    "slices": [
      "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n",
      "\tconst char *quotestr = \"`\";\n",
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tcmd = r_str_trim_head_tail (cmd);\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tptr = (char *)r_str_firstbut (cmd, '#', \"`\\\"\"); // TODO: use quotestr here\n",
      "\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\t*ptr = '\\0';\n",
      "\t\t\t\tcmd = r_str_trim_nc (cmd);\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (ret == -1) {\n",
      "\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n",
      "\t\tptr = strchr (cmd, '&');\n",
      "\tptr = strstr (cmd, \"?*\");\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tptr[0] = 0;\n",
      "\t\tif (*cmd != '#') {\n",
      "\tptr = strchr (cmd, '<');\n",
      "\tif (ptr) {\n",
      "\t\tptr[0] = '\\0';\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tptr = (char *)r_str_firstbut (cmd, '>', \"\\\"\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (*cmd != '\"') {\n",
      "\t\tptr = strchr (cmd, '@');\n",
      "\t\tif (ptr == cmd + 1 && *cmd == '?') {\n",
      "\t\t\tptr = NULL;\n",
      "else\n",
      "\t\tptr = NULL;\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\t*ptr++ = '\\0';\n",
      "\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n",
      "\t\tfor (; *ptr == ' '; ptr++) {\n",
      "\t\tif (*ptr && ptr[1] == ':') {\n",
      "else\n",
      "\t\t\tptr--;\n",
      "\t\tptr = r_str_trim_tail (ptr);\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "\t\t\tchar *v = strchr (k, '=');\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\tif (!tmpeval) {\n",
      "\t\t\t\t\t\ttmpeval = cmd;\n",
      "else\n",
      "\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t*ptr = '@';\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\t\tptr = arroba + 1;\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpeval);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (tmpeval) {\n",
      "\t\t\tr_core_cmd0 (core, tmpeval);\n",
      "\t\t\tR_FREE (tmpeval);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 593,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3453,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_arch_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpasm);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_arch_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n",
      "\t\t\tR_FREE (tmpasm);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_subst_i",
    "Source": false,
    "Sink": false,
    "idx": 594,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3454,
    "label": -3,
    "slices": [
      "\tconst char *tick = NULL;\n",
      "\tchar *ptr, *ptr2, *str;\n",
      "\tchar *arroba = NULL;\n",
      "\tchar *grep = NULL;\n",
      "\tRIODesc *tmpdesc = NULL;\n",
      "\tint pamode = !core->io->va;\n",
      "\tint i, ret = 0, pipefd;\n",
      "\tbool oldfixedarch = core->fixedarch;\n",
      "\tbool oldfixedbits = core->fixedbits;\n",
      "\tut64 tmpbsz = core->blocksize;\n",
      "\tif (!cmd) {\n",
      "\tswitch (*cmd) {\n",
      "\t\tif (cmd[1] == '\"') { /* interpret */\n",
      "\t\t\tchar *line, *p;\n",
      "else\n",
      "\t\t\t\tchar *sc = strchr (cmd, ';');\n",
      "\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n",
      "\t\t\t\t\tconst bool append = p[2] == '>';\n",
      "\t\tif (cmd[1] != '*' && !strstr (cmd, \")()\")) {\n",
      "\t\tif (cmd[1] == '>') {\n",
      "\tif (*cmd != '#') {\n",
      "\t\tif (colon && ptr) {\n",
      "\t\t\tint ret ;\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tchar *ptr2 = strchr (cmd, '`');\n",
      "\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n",
      "\t\t\tif (!tick || (tick && tick > ptr)) {\n",
      "\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n",
      "else\n",
      "\t\t\t\t} else if (!strncmp (ptr + 1, \"H\", 1)) { // \"|H\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \"T\")) { // \"|T\"\n",
      "else\n",
      "\t\t\t\t} else if (!strcmp (ptr + 1, \".\")) { // \"|.\"\n",
      "else\n",
      "\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n",
      "\t\t\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n",
      "\twhile (ptr && *ptr && ptr[1] == '&') {\n",
      "\t\tif (ret == -1) {\n",
      "\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n",
      "\t\tif (*cmd != '#') {\n",
      "\tif (ptr) {\n",
      "\t\tif (r_cons_singleton ()->is_interactive) {\n",
      "\t\t\tif (ptr[1] == '<') {\n",
      "\t\t\t\t\tint ret;\n",
      "\t\t\t\tif (!*str) {\n",
      "\t\t\t\tif (!core->oobi) {\n",
      "else\n",
      "\t\t\t\t} else if (ptr == cmd) {\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tif (ptr[0] && ptr[1] == '?') {\n",
      "\t\tint pipecolor = r_config_get_i (core->config, \"scr.color.pipe\");\n",
      "\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\tif (!*str) {\n",
      "\t\t\tchar *fdnum = ptr - 1;\n",
      "\t\tconst bool appendResult = (ptr[1] == '>');\n",
      "\t\t\tchar *o = r_core_cmd_str (core, cmd);\n",
      "\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n",
      "\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n",
      "\tif (ptr) {\n",
      "\t\tif (ptr > cmd) {\n",
      "\t\t\tchar *ch = ptr - 1;\n",
      "\t\t\tif (*ch == '\\\\') {\n",
      "\t\tbool empty = false;\n",
      "\t\tif (empty) {\n",
      "else\n",
      "\t\t\tint value = core->num->value;\n",
      "else\n",
      "\t\t\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n",
      "\tif (*cmd != '\"' && *cmd) {\n",
      "\t\tconst char *s = strstr (cmd, \"~?\");\n",
      "\t\tif (s) {\n",
      "\t\t\tbool showHelp = false;\n",
      "\t\t\tif (showHelp) {\n",
      "\tif (ptr) {\n",
      "\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n",
      "\t\tut64 addr = core->offset;\n",
      "\t\tchar *tmpbits = NULL;\n",
      "\t\tconst char *offstr = NULL;\n",
      "\t\tbool is_bits_set = false;\n",
      "\t\tchar *tmpeval = NULL;\n",
      "\t\tchar *tmpasm = NULL;\n",
      "\t\tif (ptr[1] == '?') {\n",
      "else\n",
      "\t\t} else if (ptr[1] == '%') { // \"@%\"\n",
      "\t\t\tchar *k = strdup (ptr + 2);\n",
      "else\n",
      "\t\t} else if (ptr[1] == '.') { // \"@.\"\n",
      "\t\t\tif (ptr[2] == '.') { // \"@..\"\n",
      "\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n",
      "else\n",
      "\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n",
      "\t\t\tswitch (ptr[0]) {\n",
      "\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *mander = strdup (ptr + 2);\n",
      "\t\t\t\t\t\tchar ch = *sep;\n",
      "\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n",
      "\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n",
      "\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n",
      "\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n",
      "\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n",
      "\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n",
      "\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n",
      "\t\t\tchar *trim = ptr - 2;\n",
      "\t\tif (ptr2) {\n",
      "\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, \"0x\", 2)) {\n",
      "else\n",
      "\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n",
      "\t\t\t\tif (!ptr2[1]) {\n",
      "\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n",
      "\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n",
      "else\n",
      "\t\t\tchar ch = *offstr;\n",
      "\t\t\tRIODesc *d = tmpdesc;\n",
      "\t\tif (arroba) {\n",
      "\t\tif (ptr[1] == '@') {\n",
      "\t\t\t\tchar *rule = ptr + 3;\n",
      "\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n",
      "\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n",
      "\t\t\tif (ptr[1] == '(') {\n",
      "\t\t\t\tchar *range = ptr + 3;\n",
      "\t\t\t\tchar *p = strchr (range, ' ');\n",
      "\t\t\t\tif (!p) {\n",
      "\t\t\t\t\tfree (tmpbits);\n",
      "\t\t\t\tut64 from = r_num_math (core->num, range);\n",
      "\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n",
      "\t\tif (is_bits_set) {\n",
      "\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreach_comment",
    "Source": false,
    "Sink": false,
    "idx": 595,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3578,
    "label": -3,
    "slices": [
      "static int foreach_comment(void *user, const char *k, const char *v) {\n",
      "\tif (!strncmp (k, \"meta.C.\", 7)) {\n",
      "\t\tchar *cmt = (char *)sdb_decode (v, 0);\n",
      "\t\tif (cmt) {\n",
      "\t\t\tfree (cmt);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreach_pairs",
    "Source": false,
    "Sink": false,
    "idx": 596,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3601,
    "label": -3,
    "slices": [
      "static void foreach_pairs(RCore *core, const char *cmd, const char *each) {\n",
      "\tconst char *arg;\n",
      "\tint pair = 0;\n",
      "\tfor (arg = each ; ; ) {\n",
      "\t\tchar *next = strchr (arg, ' ');\n",
      "\t\tif (next) {\n",
      "\t\t\t*next = 0;\n",
      "\t\tif (arg && *arg) {\n",
      "\t\t\tut64 n = r_num_get (NULL, arg);\n",
      "\t\t\tif (pair%2) {\n",
      "\t\t\t\tr_core_block_size (core, n);\n",
      "else\n",
      "\t\t\t\tr_core_seek (core, n, 1);\n",
      "\t\tif (!next) {\n",
      "\t\targ = next + 1;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 597,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3644,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\tif (filter) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tforeach_pairs (core, cmd, arg);\n",
      "\t\t\tfree (arg);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 598,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3730,
    "label": -3,
    "slices": [
      "\tRDebug *dbg = core->dbg;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRBinImport *imp;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tchar *impflag = r_str_newf (\"sym.imp.%s\", imp->name);\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\t\tfree (impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 addr = sec->vaddr;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach3",
    "Source": false,
    "Sink": false,
    "idx": 599,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3821,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // \"@@@\"\n",
      "\tRDebug *dbg = core->dbg;\n",
      "\tconst char *filter = NULL;\n",
      "\tif (each[1] == ':') {\n",
      "\t\tfilter = each + 2;\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, filter);\n",
      "\t\t\tint fd = r_io_fd_get_current (core->io);\n",
      "\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 bszorig = core->blocksize;\n",
      "\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n",
      "\t\t\tint cbsz = core->blocksize;\n",
      "\t\t\t\tut64 offorig = core->offset;\n",
      "\t\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n",
      "\t\t\tut64 off = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tr_flag_foreach_glob (core->flags, glob, exec_command_on_flag, &u);\n",
      "\t\t\tfree (glob);\n",
      "\t\t\tut64 obs = core->blocksize;\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n",
      "\t\t\tut64 offorig = core->offset;\n",
      "\t\t\tut64 obs = core->blocksize;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 600,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3869,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 601,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3883,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 602,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3891,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\tif (nl) {\n",
      "\t\t\t*nl = 0;\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\teach = nextLine;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 603,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 3901,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *nextLine = NULL;\n",
      "\tut64 addr;\n",
      "\twhile (each) {\n",
      "\t\twhile (*each == ' ') {\n",
      "\t\t\teach++;\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\tif (nl) {\n",
      "\t\t\tnextLine = nl + 1;\n",
      "else\n",
      "\t\t\tnextLine = NULL;\n",
      "\t\tnl = strchr (each, '#');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\teach++;\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "\t\t\t\t*str = '\\0';\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t*str = ' ';\n",
      "\t\t\t\teach = str + 1;\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = NULL;\n",
      "\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\teach = nextLine;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "foreachOffset",
    "Source": false,
    "Sink": false,
    "idx": 604,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3920,
    "label": -3,
    "slices": [
      "static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n",
      "\tchar *cmd = strdup (_cmd);\n",
      "\twhile (each) {\n",
      "\t\tif (!*each) {\n",
      "\t\tchar *nl = strchr (each, '\\n');\n",
      "\t\twhile (each && *each) {\n",
      "\t\t\tchar *str = strchr (each, ' ');\n",
      "\t\t\tif (str) {\n",
      "else\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 605,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3955,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\t\tfree (out);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 606,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 3960,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tRFlagItem *flag;\n",
      "\tut64 oseek, addr;\n",
      "\toseek = core->offset;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmd);\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\tr_core_cmd_help (core, help_msg_at_at);\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tr_core_block_size (core, bb->size);\n",
      "\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tr_core_block_size (core, bs);\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 cur;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\t\tfor (cur = from; cur < to; cur += step) {\n",
      "\t\t\t\t\t(void)r_core_seek (core, cur, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tRAnalBlock *bb;\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tcore->cons->context->grep = grep;\n",
      "\t\t\tRDebugPid *p;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_debug_select (core->dbg, pid, pid);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\t\tRDebugFrame *frame;\n",
      "\t\t\tRList *list;\n",
      "\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n",
      "\t\t\t\tswitch (each[3]) {\n",
      "\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n",
      "\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\tr_core_seek (core, oseek, 0);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\t\taddr = core->rcmd->macro._brk_value;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tchar cmd2[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n",
      "\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n",
      "\t\t\t\t\tcore->rcmd->macro.counter++;\n",
      "\t\tcore->rcmd->macro.counter = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\tr_flag_foreach_space (core->flags, flagspace, duplicate_flag, &u);\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n",
      "\t\t\t\t\tr_core_cmd (core, cmd, 0);\n",
      "\t\t\t\tcore->rcmd->macro.counter++ ;\n",
      "\tcore->offset = oseek;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 607,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3964,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n",
      "\t\tfree (cmdhit);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 608,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 3966,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 609,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strstr",
    "line": 4045,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 610,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4067,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 611,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4071,
    "label": -3,
    "slices": [
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n",
      "\t\t\t\t\tif (buf) {\n",
      "\t\t\t\t\t\tbuf = strdup (buf);\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 612,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4104,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tif (arg) {\n",
      "\t\t\t\tforeachOffset (core, cmd, arg);\n",
      "\t\t\t\tfree (arg);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 613,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4155,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tut64 oseek, addr;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tr_core_cmd0 (core, each);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tif (*str == ':' || *str == ' ') {\n",
      "\t\t\t\tstr++;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\tif (count == 3) {\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\tif (each[1] == 'b' && each[2] == 't') {\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\t\twhile (*each == ' ') {\n",
      "\t\t\t\t\teach++;\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t\tstr = strchr (each, ' ');\n",
      "\t\t\t\tif (str) {\n",
      "\t\t\t\t\t*str = '\\0';\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\t\t*str = ' ';\n",
      "else\n",
      "\t\t\t\t\taddr = r_num_math (core->num, each);\n",
      "\t\t\t\teach = str + 1;\n",
      "\t\t\t\tr_core_seek (core, addr, 1);\n",
      "\t\t\t} while (str != NULL);\n",
      "\t\tif (each[1] == '(') {\n",
      "\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n",
      "\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n",
      "\t\t\t\tif (!core->rcmd->macro.brk_value) {\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "else\n",
      "\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n",
      "\t\tfor (; *each == ' '; each++) {\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 614,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4169,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\teach = out;\n",
      "\t\t\tfree (out);\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 615,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fgets",
    "line": 4201,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tut64 oseek, addr;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tbuf[0] = '\\0';\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\t\taddr = r_num_math (core->num, buf);\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 616,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 4211,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tswitch (each[0]) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tif (each[1] == '(') {\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\tif (fd) {\n",
      "\t\t\t\twhile (!feof (fd)) {\n",
      "\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n",
      "\t\t\t\tfclose (fd);\n",
      "\t\t\t\t\tchar *buf = NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 617,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4233,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar ch;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tforeachOffset (core, cmd, str + 1);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tch = str[i];\n",
      "\t\t\tstr[i] = '\\0';\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\tstr[i] = ch;\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 618,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4267,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tr_cons_break_push (NULL, NULL); //pop on return\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\tif (out) {\n",
      "\t\t\t\tif (!*each) {\n",
      "\t\t\t} while (str != NULL);\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 619,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4270,
    "label": -3,
    "slices": [
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\t\t\t\tchar *buf;\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "else\n",
      "\t\t\tchar buf[1024];\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\t\ttmp = r_cons_get_buffer ();\n",
      "\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n",
      "\t\t\t\t\tr_cons_strcat (buf);\n",
      "\t\t\t\t\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 620,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4283,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tint i, j;\n",
      "\tchar *word = NULL;\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tint i;\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\ti = 0;\n",
      "\t\twhile (str[i]) {\n",
      "\t\t\tj = i;\n",
      "\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n",
      "\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n",
      "\t\t\tword = strdup (str + j);\n",
      "\t\t\tif (!word) {\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n",
      "\t\t\t\tif (!match_flag_items) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\t\tchar *buf = NULL;\n",
      "\t\t\t\t\tconst char *tmp = NULL;\n",
      "\t\t\t\tR_FREE (word);\n",
      "\tfree (word);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 621,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4284,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_foreach",
    "Source": false,
    "Sink": false,
    "idx": 622,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4287,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n",
      "\tchar *str, *ostr = NULL;\n",
      "\tostr = str = strdup (each);\n",
      "\tswitch (each[0]) {\n",
      "\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n",
      "\t\tfree (ostr);\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\t\tint bs = core->blocksize;\n",
      "\t\t\tif (fcn) {\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tchar *str = each + 1;\n",
      "\t\t\tint count = r_str_split (str, ' ');\n",
      "\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n",
      "\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n",
      "\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n",
      "\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n",
      "\t\tif (each[1] == ':') {\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n",
      "\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "else\n",
      "\t\t\tRAnalFunction *fcn;\n",
      "\t\t\tif (core->anal) {\n",
      "\t\t\t\tRConsGrep grep = core->cons->context->grep;\n",
      "\t\t\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\tint pid = core->dbg->pid;\n",
      "\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n",
      "\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n",
      "\t\t\tut64 oseek = core->offset;\n",
      "\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n",
      "\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n",
      "\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n",
      "\tfree (ostr);\n",
      "\tfree (ostr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "run_pending_anal",
    "Source": false,
    "Sink": false,
    "idx": 623,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4299,
    "label": -3,
    "slices": [
      "R_API void run_pending_anal(RCore *core) {\n",
      "\tcore->ev->incall = false;\n",
      "\tif (core && core->anal && core->anal->cmdtail) {\n",
      "\t\tchar *res = core->anal->cmdtail;\n",
      "\t\tr_core_cmd_lines (core, res);\n",
      "\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 624,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4310,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 625,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4315,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 626,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4325,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\t\t\tif (res) {\n",
      "\t\t\t\tr_cons_printf (\"%s\\n\", res);\n",
      "\t\t\t\tfree (res);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 627,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4349,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 628,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4350,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\t\tcore->incomment = false;\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tfree (core->lastcmd);\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tR_FREE (core->oobi);\n",
      "\t\tcore->oobi_len = 0;\n",
      "\tcore->cons->context->cmd_depth--;\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\tif (!ptr) {\n",
      "\trun_pending_anal (core);\n",
      "\tcore->cons->context->cmd_depth++;\n",
      "\tR_FREE (core->oobi);\n",
      "\tcore->oobi_len = 0;\n",
      "\tif (r_list_empty (core->tasks)) {\n",
      "\t\tr_th_lock_leave (core->lock);\n",
      "\trun_pending_anal (core);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 629,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "malloc",
    "line": 4353,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 630,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 4353,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n",
      "\t\tcore->lastcmd = strdup (cstr);\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tr_str_cpy (cmd, cstr);\n",
      "\tif (log) {\n",
      "\t\tr_line_hist_add (cstr);\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n",
      "\t\tfree (ocmd);\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\tfree (ocmd);\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 631,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4364,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 632,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4371,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\tfor (rcmd = cmd;;) {\n",
      "\t\tptr = strchr (rcmd, '\\n');\n",
      "\t\tif (ptr) {\n",
      "\t\t\t*ptr = '\\0';\n",
      "\t\tret = r_core_cmd_subst (core, rcmd);\n",
      "\t\tif (ret == -1) {\n",
      "\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n",
      "\t\tif (!ptr) {\n",
      "\t\trcmd = ptr + 1;\n",
      "\treturn ret;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd",
    "Source": false,
    "Sink": false,
    "idx": 633,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4388,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n",
      "\tchar *cmd, *ocmd, *ptr, *rcmd;\n",
      "\tint ret = false, i;\n",
      "\tif (core->cmdfilter) {\n",
      "\t\tconst char *invalid_chars = \";|>`@\";\n",
      "\t\tfor (i = 0; invalid_chars[i]; i++) {\n",
      "\t\t\tif (strchr (cstr, invalid_chars[i])) {\n",
      "\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n",
      "\tif (core->cmdremote) {\n",
      "\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n",
      "\t\t\tchar *res = r_io_system (core->io, cstr);\n",
      "\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n",
      "\tif (!strncmp (cstr, \"/*\", 2)) {\n",
      "\t\tif (r_sandbox_enable (0)) {\n",
      "else\n",
      "\t} else if (!strncmp (cstr, \"*/\", 2)) {\n",
      "\tif (core->incomment) {\n",
      "\tocmd = cmd = malloc (strlen (cstr) + 4096);\n",
      "\tif (!ocmd) {\n",
      "\tif (core->cons->context->cmd_depth < 1) {\n",
      "\t\tfree (ocmd);\n",
      "\tfree (ocmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 634,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4414,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 635,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4418,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 636,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4423,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 637,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4445,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t*nl = '\\0';\n",
      "\t\t\tr = r_core_cmd (core, data, 0);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t\t\tdata = nl + 1;\n",
      "\t\t\tdata = nl + 1;\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tif (ret >= 0 && data && *data) {\n",
      "\t\tr_core_cmd (core, data, 0);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_lines",
    "Source": false,
    "Sink": false,
    "idx": 638,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4451,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n",
      "\tint r, ret = true;\n",
      "\tchar *nl, *data, *odata;\n",
      "\tif (!lines || !*lines) {\n",
      "\tdata = odata = strdup (lines);\n",
      "\tif (!odata) {\n",
      "\tnl = strchr (odata, '\\n');\n",
      "\tif (nl) {\n",
      "\t\t\tif (r_cons_is_breaked ()) {\n",
      "\t\t\t\tfree (odata);\n",
      "\t\t\tif (r < 0) { //== -1) {\n",
      "\t\t\tif (data[0] == 'q') {\n",
      "\t\t} while ((nl = strchr (data, '\\n')));\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 639,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4461,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tfree (data);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 640,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4467,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_file",
    "Source": false,
    "Sink": false,
    "idx": 641,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4470,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_file(RCore *core, const char *file) {\n",
      "\tchar *data = r_file_abspath (file);\n",
      "\tif (!data) {\n",
      "\tchar *odata = r_file_slurp (data, NULL);\n",
      "\tif (!odata) {\n",
      "\tif (!r_core_cmd_lines (core, odata)) {\n",
      "\t\tfree (odata);\n",
      "\tfree (odata);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 642,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4480,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_command",
    "Source": false,
    "Sink": false,
    "idx": 643,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4485,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_command(RCore *core, const char *command) {\n",
      "\tchar *buf, *rcmd, *ptr;\n",
      "\tchar *cmd = r_core_sysenv_begin (core, command);\n",
      "\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n",
      "\tif (!buf) {\n",
      "\tfree (buf);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_disassemble_instr",
    "Source": false,
    "Sink": false,
    "idx": 644,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4495,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_disassemble_bytes",
    "Source": false,
    "Sink": false,
    "idx": 645,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4505,
    "label": -3,
    "slices": [
      "\tchar *cmd, *ret = NULL;\n",
      "\tif (cmd) {\n",
      "\t\tret = r_core_cmd_str (core, cmd);\n",
      "\t\tfree (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 646,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4511,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 647,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4516,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 648,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4521,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\t*ptr = '\\0';\n",
      "\t\tr_core_cmd (core, optr, 0);\n",
      "\t\toptr = ptr + 1;\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tr_core_cmd (core, optr, 0);\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_buffer",
    "Source": false,
    "Sink": false,
    "idx": 649,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4524,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n",
      "\tchar *ptr, *optr, *str = strdup (buf);\n",
      "\tif (!str) {\n",
      "\toptr = str;\n",
      "\tptr = strchr (str, '\\n');\n",
      "\twhile (ptr) {\n",
      "\t\tptr = strchr (str, '\\n');\n",
      "\tfree (str);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmdf",
    "Source": false,
    "Sink": false,
    "idx": 650,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4533,
    "label": -3,
    "slices": [
      "R_API int r_core_cmdf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tint ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd (core, string, 0);\n",
      "\tva_end (ap);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 651,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strchr",
    "line": 4552,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\treturn NULL;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 652,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4557,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "\t\t\t\treturn hres;\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\treturn ret;\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tif (s) {\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 653,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4559,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 654,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4561,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 655,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4563,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\t\t\t\tfree (res);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 656,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4570,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\tif (!strcmp (p + 1, \"H\")) {\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\t\t\tfree (c);\n",
      "\t\tchar *_cmd = strdup (cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 657,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4583,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 658,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4586,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\tif (p) {\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\tc[p - cmd] = 0;\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\treturn r_core_cmd_str (core, cmd);\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n",
      "\t\treturn r_core_cmd_str (core, cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 659,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4594,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 660,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4595,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 661,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4600,
    "label": -3,
    "slices": [
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\ts = r_file_slurp (tmp, NULL);\n",
      "\t\tif (s) {\n",
      "\t\t\tr_file_rm (tmp);\n",
      "\t\t\tfree (tmp);\n",
      "\t\teprintf (\"slurp %s fails\\n\", tmp);\n",
      "\t\tr_file_rm (tmp);\n",
      "\t\tfree (tmp);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str_pipe",
    "Source": false,
    "Sink": false,
    "idx": 662,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4601,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n",
      "\tchar *s, *tmp = NULL;\n",
      "\tif (r_sandbox_enable (0)) {\n",
      "\t\tchar *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;\n",
      "\t\t\tchar *c = strdup (cmd);\n",
      "\t\t\t\tchar *res = r_core_cmd_str (core, c);\n",
      "else\n",
      "\t\t\t\tint sh = r_config_get_i (core->config, \"scr.color\");\n",
      "\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n",
      "\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n",
      "\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n",
      "\t\tif (pipefd == -1) {\n",
      "\t\tchar *_cmd = strdup (cmd);\n",
      "\t\tr_core_cmd_subst (core, _cmd);\n",
      "\t\tif (s) {\n",
      "\t\t\tfree (_cmd);\n",
      "\t\tfree (_cmd);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_strf",
    "Source": false,
    "Sink": false,
    "idx": 663,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "vsnprintf",
    "line": 4614,
    "label": -3,
    "slices": [
      "R_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n",
      "\tchar string[4096];\n",
      "\tchar *ret;\n",
      "\tva_list ap;\n",
      "\tva_start (ap, fmt);\n",
      "\tvsnprintf (string, sizeof (string), fmt, ap);\n",
      "\tret = r_core_cmd_str (core, string);\n",
      "\tva_end (ap);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_str",
    "Source": false,
    "Sink": false,
    "idx": 664,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4631,
    "label": -3,
    "slices": [
      "\tconst char *static_str;\n",
      "\tchar *retstr = NULL;\n",
      "\tif (r_core_cmd (core, cmd, 0) == -1) {\n",
      "\tstatic_str = r_cons_get_buffer ();\n",
      "\tretstr = strdup (static_str? static_str: \"\");\n",
      "\treturn retstr;\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 665,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 4684,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "r_core_cmd_task_sync",
    "Source": false,
    "Sink": false,
    "idx": 666,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "free",
    "line": 4692,
    "label": -3,
    "slices": [
      "R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n",
      "\tRCoreTask *task = core->main_task;\n",
      "\tchar *s = strdup (cmd);\n",
      "\tif (!s) {\n",
      "\ttask->cmd = s;\n",
      "\tint res = r_core_task_run_sync (core, task);\n",
      "\tfree (s);\n"
    ]
  },
  {
    "FileName": "after_cmd.c",
    "Caller": "compare_cmd_descriptor_name",
    "Source": false,
    "Sink": false,
    "idx": 667,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 4701,
    "label": -3,
    "slices": [
      "static int compare_cmd_descriptor_name(const void *a, const void *b) {\n",
      "\treturn strcmp (((RCmdDescriptor *)a)->cmd, ((RCmdDescriptor *)b)->cmd);\n"
    ]
  }
]
