FileName,Caller,Source,Sink,idx,CWE-ID,category,criterion,line,label,slices,tokenized,token_length,predict
before_cmd.c,cmd_uniq,False,False,0,CWE-,CallExpression,strchr,361,-3,"['static int cmd_uniq(void *data, const char *input) { // ""uniq""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_uniq (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (FUNC3(Var3->memberVar1,Var4)){
FUNC4(Var3,STRING,Var4); 
else 
char *Var5=FUNC5(Var4); 
if (Var5){
FUNC6(Var5); 
free(Var5); 
",159,0
before_cmd.c,cmd_uniq,False,False,1,CWE-,CallExpression,free,379,-3,"['static int cmd_uniq(void *data, const char *input) { // ""uniq""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (!arg) {\n', '\t\t\targ = """";\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', 'else\n', '\t\t\tchar *res = r_syscmd_uniq (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (!Var4){
Var4=STRING; 
if (FUNC3(Var3->memberVar1,Var4)){
else 
char *Var5=FUNC4(Var4); 
if (Var5){
FUNC5(Var5); 
free(Var5); 
",161,0
before_cmd.c,cmd_head,False,False,2,CWE-,CallExpression,strdup,390,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\t*count = 0;\t// split the count and file name\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\tfree (input);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var12=FUNC6(Var6,Var4); 
if (Var12){
FUNC7(Var12); 
free(Var12); 
free(Var5); 
",294,0
before_cmd.c,cmd_head,False,False,3,CWE-,CallExpression,strchr,391,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\t*count = 0;\t// split the count and file name\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\tfree (input);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var12=FUNC6(Var6,Var4); 
if (Var12){
FUNC7(Var12); 
free(Var12); 
free(Var5); 
",294,0
before_cmd.c,cmd_head,False,False,4,CWE-,CallExpression,strchr,395,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\t*count = 0;\t// split the count and file name\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var12=FUNC6(Var6,Var4); 
if (Var12){
FUNC7(Var12); 
free(Var12); 
",287,0
before_cmd.c,cmd_head,False,False,5,CWE-,CallExpression,atoi,399,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\tlines = atoi (arg);\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
Var4=FUNC3(Var6); 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var9=FUNC6(Var6,Var4); 
if (Var9){
FUNC7(Var9); 
free(Var9); 
",235,0
before_cmd.c,cmd_head,False,False,6,CWE-,CallExpression,free,417,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (!arg) {\n', '\t\t\targ = """";\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (!Var6){
Var6=STRING; 
if (FUNC4(Var3->memberVar1,Var6)){
else 
char *Var9=FUNC5(Var6,Var4); 
if (Var9){
FUNC6(Var9); 
free(Var9); 
",263,0
before_cmd.c,cmd_head,False,False,7,CWE-,CallExpression,free,422,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\tfree (input);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
char *Var3=strdup(Var2); 
char *Var4=strchr(Var3,); 
else 
char *Var5=FUNC2(Var4,Var6); 
free(Var3); 
",78,1
before_cmd.c,cmd_uname,False,False,8,CWE-,CallExpression,strdup,435,-3,"['static int cmd_uname(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', '\t\t\tchar *cmd = strdup (input + 2);\n', ""\t\t\tchar *rcmd = strchr (cmd, ',');\n"", '\t\t\tif (rcmd) {\n', '\t\t\t\t*rcmd++ = 0;\n', '\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n', '\t\t\t\tr_core_undo_push (core, undo);\n', '\t\t\tfree (cmd);\n', '\t\tr_core_cmdf (data, ""s-%s"", input + 1);\n', '\t\tr_core_cmdf (data, ""wc%s"", input + 1);\n', ""\t\tif (input[1] == 'i' && input[2] == 'q') {\n"", '\t\t\tcmd_uniq (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
char *Var4=strdup(Var2+2); 
char *Var5=strchr(Var4,,); 
if (Var5){
*Var5  Var6=0; 
STRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); 
FUNC3(Var3,Var7); 
free(Var4); 
FUNC4(Var1,STRING,Var2+1); 
FUNC4(Var1,STRING,Var2+1); 
if (Var2[1]==  Var8&&Var2[2]==  Var9){
FUNC5(Var3,Var2); 
",219,0
before_cmd.c,cmd_uname,False,False,9,CWE-,CallExpression,strchr,436,-3,"['static int cmd_uname(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', '\t\t\tchar *cmd = strdup (input + 2);\n', ""\t\t\tchar *rcmd = strchr (cmd, ',');\n"", '\t\t\tif (rcmd) {\n', '\t\t\t\t*rcmd++ = 0;\n', '\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n', '\t\t\t\tr_core_undo_push (core, undo);\n', '\t\t\tfree (cmd);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
char *Var4=strdup(Var2+2); 
char *Var5=strchr(Var4,,); 
if (Var5){
*Var5  Var6=0; 
STRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); 
FUNC3(Var3,Var7); 
free(Var4); 
",152,1
before_cmd.c,cmd_uname,False,False,10,CWE-,CallExpression,free,444,-3,"['static int cmd_uname(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', '\t\t\tchar *cmd = strdup (input + 2);\n', ""\t\t\tchar *rcmd = strchr (cmd, ',');\n"", '\t\t\tif (rcmd) {\n', '\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n', '\t\t\tfree (cmd);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
char *Var4=strdup(Var2+2); 
char *Var5=strchr(Var4,,); 
if (Var5){
STRUCT2 *Var6=FUNC2(Var3->memberVar1,Var4,Var5); 
free(Var4); 
",131,1
before_cmd.c,cmd_alias,False,False,11,CWE-,CallExpression,strlen,504,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', '\t\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\t*desc = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tr_cons_println (v);\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', 'else\n', '\t\tif (q) {\n', '\t\t\t*q = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", '\t\t\t\tr_cons_strcat (v + 1);\n', 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n', 'else\n', '\t\t\t\tr_core_cmd0 (core, v);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
*Var11  Var13=0; 
size_t  Var14=strlen(Var11); 
if (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){
Var11[Var14-1]=0; 
Var11  Var13; 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
char *Var16=FUNC3(NULL ,Var15); 
if (Var16){
FUNC4(Var3->memberVar1,Var5,Var16,0); 
free(Var16); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
*Var12=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
FUNC6(Var15); 
free(Var5); 
else 
FUNC7(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
for (Var4=0; Var4<Var17; Var4  Var13){
char *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); 
char *Var10=FUNC9(Var15,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
else 
if (Var10){
*Var10=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
if (*Var15 == ){
FUNC10(Var15+1); 
else 
}else if (Var10){
char *Var19=FUNC11(STRING,Var15,Var10+1); 
FUNC12(Var3,Var19); 
free(Var19); 
else 
FUNC12(Var3,Var15); 
else 
FUNC7(STRING,Var5); 
free(Var5); 
",840,0
before_cmd.c,cmd_alias,False,False,12,CWE-,CallExpression,malloc,505,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', '\t\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\t*desc = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tr_cons_println (v);\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', 'else\n', '\t\tif (q) {\n', '\t\t\t*q = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", '\t\t\t\tr_cons_strcat (v + 1);\n', 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n', 'else\n', '\t\t\t\tr_core_cmd0 (core, v);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
*Var11  Var13=0; 
size_t  Var14=strlen(Var11); 
if (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){
Var11[Var14-1]=0; 
Var11  Var13; 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
char *Var16=FUNC3(NULL ,Var15); 
if (Var16){
FUNC4(Var3->memberVar1,Var5,Var16,0); 
free(Var16); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
*Var12=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
FUNC6(Var15); 
free(Var5); 
else 
FUNC7(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
for (Var4=0; Var4<Var17; Var4  Var13){
char *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); 
char *Var10=FUNC9(Var15,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
else 
if (Var10){
*Var10=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
if (*Var15 == ){
FUNC10(Var15+1); 
else 
}else if (Var10){
char *Var19=FUNC11(STRING,Var15,Var10+1); 
FUNC12(Var3,Var19); 
free(Var19); 
else 
FUNC12(Var3,Var15); 
else 
FUNC7(STRING,Var5); 
free(Var5); 
",840,0
before_cmd.c,cmd_alias,False,False,13,CWE-,CallExpression,memcpy,510,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",671,0
before_cmd.c,cmd_alias,False,False,14,CWE-,CallExpression,strchr,511,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', 'else\n', '\t\tif (q) {\n', '\t\t\t*q = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
else 
if (Var10){
*Var10=0; 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
if (*Var14 == ){
else 
}else if (Var10){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
FUNC10(Var3,Var19); 
free(Var19); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",731,0
before_cmd.c,cmd_alias,False,False,15,CWE-,CallExpression,strchr,512,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
*Var11  Var13=0; 
size_t  Var14=strlen(Var11); 
if (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){
Var11[Var14-1]=0; 
Var11  Var13; 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
char *Var16=FUNC3(NULL ,Var15); 
if (Var16){
FUNC4(Var3->memberVar1,Var5,Var16,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var17=0; 
char **Var18=FUNC7(Var3->memberVar1,&Var17); 
for (Var4=0; Var4<Var17; Var4  Var13){
char *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); 
char *Var10=FUNC8(Var15,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var17=0; 
char **Var18=FUNC7(Var3->memberVar1,&Var17); 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
char *Var19=FUNC9(STRING,Var15,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",735,0
before_cmd.c,cmd_alias,False,False,16,CWE-,CallExpression,strchr,513,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\t*desc = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
*Var12=0; 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",678,0
before_cmd.c,cmd_alias,False,False,17,CWE-,CallExpression,strlen,518,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
*Var7  Var9=0; 
size_t  Var10=strlen(Var7); 
if (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){
Var7[Var10-1]=0; 
Var7  Var9; 
if (!Var6||(Var6&&Var6>Var7)){
if (*Var7){
if (!strcmp(Var7,STRING)){
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
else 
FUNC3(Var3->memberVar1,Var5,Var7,0); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var11,-1); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
char *Var14=FUNC6(STRING,Var11,Var6+1); 
",503,0
before_cmd.c,cmd_alias,False,False,18,CWE-,CallExpression,strcmp,526,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
*Var7  Var9=0; 
size_t  Var10=strlen(Var7); 
if (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){
Var7[Var10-1]=0; 
Var7  Var9; 
if (!Var6||(Var6&&Var6>Var7)){
if (*Var7){
if (!strcmp(Var7,STRING)){
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
else 
FUNC3(Var3->memberVar1,Var5,Var7,0); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var11,-1); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
char *Var14=FUNC6(STRING,Var11,Var6+1); 
",503,0
before_cmd.c,cmd_alias,False,False,19,CWE-,CallExpression,free,531,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', '\t\t\t\t\t\tfree (n);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
size_t  Var9=strlen(Var7); 
if (!Var6||(Var6&&Var6>Var7)){
if (*Var7){
if (!strcmp(Var7,STRING)){
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var11=FUNC3(NULL ,Var10); 
if (Var11){
FUNC4(Var3->memberVar1,Var5,Var11,0); 
free(Var11); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
int  Var4,Var12=0; 
char **Var13=FUNC5(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC6(Var10,-1); 
int  Var4,Var12=0; 
char **Var13=FUNC5(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var14=FUNC7(STRING,Var10,Var6+1); 
",469,0
before_cmd.c,cmd_alias,False,False,20,CWE-,CallExpression,free,546,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",671,0
before_cmd.c,cmd_alias,False,False,21,CWE-,CallExpression,free,563,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', ""\t\t\tif (buf[2] == '*') {\n"", 'else\n', '\t\t\t\tr_cons_printf (""%s=base64:%s\\n"", keys[i], q);\n', '\t\t\tfree (q);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
size_t  Var9=strlen(Var7); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var11=FUNC3(NULL ,Var10); 
else 
}else if (Var8&&!Var6){
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
else 
}else if (Var5[1]== *){
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
for (Var4=0; Var4<Var12; Var4  Var14){
char *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var10,-1); 
if (Var5[2]== *){
else 
FUNC6(STRING,Var13[Var4],Var6); 
free(Var6); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC7(STRING,Var10,Var6+1); 
",491,0
before_cmd.c,cmd_alias,False,False,22,CWE-,CallExpression,free,584,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
size_t  Var9=strlen(Var7); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var11=FUNC3(NULL ,Var10); 
else 
}else if (Var8&&!Var6){
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
else 
}else if (Var5[1]== *){
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var10,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
if (Var10){
if (*Var10 == ){
else 
}else if (Var6){
char *Var14=FUNC6(STRING,Var10,Var6+1); 
FUNC7(Var3,Var14); 
free(Var14); 
",495,0
before_cmd.c,cmd_alias,False,False,23,CWE-,CallExpression,free,592,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",671,0
before_cmd.c,cmd_rap,False,False,24,CWE-,CallExpression,free,648,-3,"['static int cmd_rap(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '=') {\n"", 'else\n', '\t\t\tchar *res = r_io_system (core->io, input + 1);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_printf (""%s\\n"", res);\n', '\t\t\t\tfree (res);\n', 'else\n', '\t\t\tconst char *arg = r_str_trim_ro (input + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
if (Var2[1]== =){
else 
char *Var4=FUNC2(Var3->memberVar1,Var2+1); 
if (Var4){
FUNC3(STRING,Var4); 
free(Var4); 
else 
const char *Var5=FUNC4(Var2+1); 
",132,0
before_cmd.c,cmd_rap_run,False,False,25,CWE-,CallExpression,atoi,705,-3,"['static int cmd_rap_run(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tchar *res = r_io_system (core->io, input);\n', '\tif (res) {\n', '\t\tint ret = atoi (res);\n', '\t\tfree (res);\n', '\t\treturn ret;\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
char *Var4=FUNC2(Var3->memberVar1,Var2); 
if (Var4){
int  Var5=FUNC3(Var4); 
free(Var4); 
return  Var5; 
",94,0
before_cmd.c,cmd_rap_run,False,False,26,CWE-,CallExpression,free,706,-3,"['static int cmd_rap_run(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tchar *res = r_io_system (core->io, input);\n', '\tif (res) {\n', '\t\tint ret = atoi (res);\n', '\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
char *Var4=FUNC2(Var3->memberVar1,Var2); 
if (Var4){
int  Var5=FUNC3(Var4); 
free(Var4); 
",88,0
before_cmd.c,cmd_yank,False,False,27,CWE-,CallExpression,strlen,738,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tut64 n;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n', '\t\tcore->num->value = r_buf_size (core->yank_buf);\n', ""\t\twhile (input[1] == ' ') {\n"", '\t\t\tinput++;\n', '\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n', '\t\tr_core_yank_paste (core, n, 0);\n', '\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n', ""\t\t\tif (input[2] == ' ') {\n"", '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\t\tif (len > 0) {\n', '\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n', '\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n', '\t\tif (input[1] == \'f\') { // ""wtf""\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', 'else\n', ""\t\t} else if (input[1] == ' ') {\n"", '\t\t\tr_core_yank_to (core, input + 1);\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_file_ex (core, input + 1);\n', '\t\t\tr_core_yank_hexpair (core, input + 2);\n', '\t\t\tr_core_yank_file_all (core, input + 2);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\tr_core_yank_dump (core, 0, input[0]);\n', '\t\tr_core_cmd_help (core, help_msg_y);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1  Var3; 
STRUCT2 *Var4=(STRUCT2 *) Var1; 
switch (Var2[0]){
FUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
Var4->memberVar2->memberVar1=FUNC4(Var4->memberVar3); 
while (Var2[1]== ){
Var2  Var5; 
Var3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; 
FUNC5(Var4,Var3,0); 
FUNC6(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC7(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
switch (Var2[1]){
FUNC8(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); 
if (Var2[2]== ){
char *Var6=strdup(Var2+3); 
int  Var7=FUNC9(Var2+3,(STRUCT3 *) Var6); 
if (Var7>0){
FUNC8(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); 
FUNC10(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC11(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
if (Var2[1]==  Var8){//STRING
const char *Var9=FUNC12(Var2+2); 
const STRUCT3 *Var10=FUNC13(Var4->memberVar3,&Var11); 
else 
}else if (Var2[1]== ){
FUNC14(Var4,Var2+1); 
switch (Var2[1]){
FUNC15(Var4,Var2+1); 
FUNC16(Var4,Var2+2); 
FUNC17(Var4,Var2+2); 
char *Var12=FUNC18(Var4,STRING); 
char *Var1=FUNC19(Var4,NULL ,Var12); 
FUNC20(Var4,STRING,Var1); 
FUNC21(Var4,0,Var2[0]); 
FUNC22(Var4,Var13); 
",620,0
before_cmd.c,cmd_yank,False,False,28,CWE-,CallExpression,strdup,742,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tut64 n;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n', ""\t\twhile (input[1] == ' ') {\n"", '\t\t\tinput++;\n', '\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n', '\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n', ""\t\t\tif (input[2] == ' ') {\n"", '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\t\tif (len > 0) {\n', '\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n', '\t\t\t\tfree (out);\n', '\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n', '\t\tif (input[1] == \'f\') { // ""wtf""\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', 'else\n', ""\t\t} else if (input[1] == ' ') {\n"", '\t\t\tr_core_yank_to (core, input + 1);\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_file_ex (core, input + 1);\n', '\t\t\tr_core_yank_hexpair (core, input + 2);\n', '\t\t\tr_core_yank_file_all (core, input + 2);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\tr_core_yank_dump (core, 0, input[0]);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1  Var3; 
STRUCT2 *Var4=(STRUCT2 *) Var1; 
switch (Var2[0]){
FUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
while (Var2[1]== ){
Var2  Var5; 
Var3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; 
FUNC4(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC5(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
switch (Var2[1]){
FUNC6(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); 
if (Var2[2]== ){
char *Var6=strdup(Var2+3); 
int  Var7=FUNC7(Var2+3,(STRUCT3 *) Var6); 
if (Var7>0){
FUNC6(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); 
free(Var6); 
FUNC8(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC9(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
if (Var2[1]==  Var8){//STRING
const char *Var9=FUNC10(Var2+2); 
const STRUCT3 *Var10=FUNC11(Var4->memberVar3,&Var11); 
else 
}else if (Var2[1]== ){
FUNC12(Var4,Var2+1); 
switch (Var2[1]){
FUNC13(Var4,Var2+1); 
FUNC14(Var4,Var2+2); 
FUNC15(Var4,Var2+2); 
char *Var12=FUNC16(Var4,STRING); 
char *Var1=FUNC17(Var4,NULL ,Var12); 
FUNC18(Var4,0,Var2[0]); 
",570,0
before_cmd.c,cmd_yank,False,False,29,CWE-,CallExpression,free,749,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', ""\t\t\tif (input[2] == ' ') {\n"", '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\t\tif (len > 0) {\n', '\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n', '\t\t\t\tfree (out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
if (Var2[2]== ){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
if (Var5>0){
FUNC3(Var3,Var3->memberVar1,(const STRUCT2 *) Var4,Var5); 
free(Var4); 
const char *Var6=FUNC4(Var2+2); 
const STRUCT2 *Var7=FUNC5(Var3->memberVar2,&Var8); 
char *Var9=FUNC6(Var3,STRING); 
char *Var1=FUNC7(Var3,NULL ,Var9); 
",239,0
before_cmd.c,cmd_yank,False,False,30,CWE-,CallExpression,free,803,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tfree (sig);\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\tfree (sig);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
free(Var9); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
free(Var9); 
",198,0
before_cmd.c,cmd_yank,False,False,31,CWE-,CallExpression,strdup,804,-3,"['\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\t(void) strtok (data, "";\\n"");\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\t\tfree (sig);\n', '\t\t\tfree (data);\n']","STRUCT1 *Var1=(STRUCT1 *) Var2; 
switch (Var3[0]){
char *Var4=strdup(Var3+3); 
int  Var5=FUNC1(Var3+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC2(Var3+2); 
const STRUCT2 *Var7=FUNC3(Var1->memberVar1,&Var8); 
char *Var9=FUNC4(Var1,STRING); 
if (!Var9||!*Var9){
Var9=strdup(STRING); 
char *Var2=FUNC5(Var1,NULL ,Var9); 
(void ) strtok(Var2,STRING); 
FUNC6(Var1,STRING,Var2); 
free(Var9); 
free(Var2); 
",211,0
before_cmd.c,cmd_yank,False,False,32,CWE-,CallExpression,strtok,807,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\t(void) strtok (data, "";\\n"");\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\t\tfree (data);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
Var9=strdup(STRING); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
(void ) strtok(Var1,STRING); 
FUNC7(Var3,STRING,Var1); 
free(Var1); 
",227,0
before_cmd.c,cmd_yank,False,False,33,CWE-,CallExpression,free,809,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tfree (sig);\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\tfree (sig);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
free(Var9); 
Var9=strdup(STRING); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
free(Var9); 
",207,0
before_cmd.c,cmd_yank,False,False,34,CWE-,CallExpression,free,810,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\t(void) strtok (data, "";\\n"");\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\t\tfree (data);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
Var9=strdup(STRING); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
(void ) strtok(Var1,STRING); 
FUNC7(Var3,STRING,Var1); 
free(Var1); 
",227,0
before_cmd.c,langFromHashbang,False,False,35,CWE-,CallExpression,strchr,839,-3,"['\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n', '\tif (fd != -1) {\n', '\t\tchar firstLine[128] = {0};\n', '\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n', '\t\tfirstLine[len] = 0;\n', '\t\tif (!strncmp (firstLine, ""#!/"", 3)) {\n', ""\t\t\tchar *nl = strchr (firstLine, '\\n');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', ""\t\t\tnl = strchr (firstLine, ' ');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', '\t\t\treturn strdup (firstLine + 2);\n']","int  Var1=FUNC1(Var2,Var3,0); 
if (Var1 != -1){
char  Var4[128]={0}; 
int  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); 
Var4[Var5]=0; 
if (!FUNC3(Var4,STRING,3)){
char *Var6=strchr(Var4,Var7); 
if (Var6){
*Var6=0; 
Var6=strchr(Var4,); 
if (Var6){
*Var6=0; 
return strdup(Var4+2); 
",170,0
before_cmd.c,langFromHashbang,False,False,36,CWE-,CallExpression,strchr,843,-3,"['\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n', '\tif (fd != -1) {\n', '\t\tchar firstLine[128] = {0};\n', '\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n', '\t\tfirstLine[len] = 0;\n', '\t\tif (!strncmp (firstLine, ""#!/"", 3)) {\n', ""\t\t\tchar *nl = strchr (firstLine, '\\n');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', ""\t\t\tnl = strchr (firstLine, ' ');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', '\t\t\treturn strdup (firstLine + 2);\n']","int  Var1=FUNC1(Var2,Var3,0); 
if (Var1 != -1){
char  Var4[128]={0}; 
int  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); 
Var4[Var5]=0; 
if (!FUNC3(Var4,STRING,3)){
char *Var6=strchr(Var4,Var7); 
if (Var6){
*Var6=0; 
Var6=strchr(Var4,); 
if (Var6){
*Var6=0; 
return strdup(Var4+2); 
",170,0
before_cmd.c,langFromHashbang,False,False,37,CWE-,CallExpression,strdup,847,-3,"['\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n', '\tif (fd != -1) {\n', '\t\tchar firstLine[128] = {0};\n', '\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n', '\t\tfirstLine[len] = 0;\n', '\t\tif (!strncmp (firstLine, ""#!/"", 3)) {\n', ""\t\t\tchar *nl = strchr (firstLine, '\\n');\n"", ""\t\t\tnl = strchr (firstLine, ' ');\n"", '\t\t\treturn strdup (firstLine + 2);\n']","int  Var1=FUNC1(Var2,Var3,0); 
if (Var1 != -1){
char  Var4[128]={0}; 
int  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); 
Var4[Var5]=0; 
if (!FUNC3(Var4,STRING,3)){
char *Var6=strchr(Var4,Var7); 
Var6=strchr(Var4,); 
return strdup(Var4+2); 
",140,0
before_cmd.c,r_core_run_script,False,False,38,CWE-,CallExpression,strcmp,861,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\t\t\teprintf (""WARNING: ignored nested source: %s\\n"", file);\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(STRING,Var3); 
FUNC3(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC4(Var2,NULL ,NULL ); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
char *Var10=FUNC8(Var3); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC9(Var2,STRING,Var3); 
else 
}else if (FUNC10(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); 
else 
Var5=FUNC12(Var2->memberVar4,Var3); 
if (Var5){
Var4=FUNC13(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC14(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC16(STRING,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC13(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC17(STRING); 
if (Var14){
char *Var13=FUNC16(STRING,Var14,Var3); 
char *Var13=FUNC15(STRING); 
char *Var13=FUNC15(STRING); 
else 
char *Var15=FUNC18(Var3); 
char *memberVar4=FUNC19(Var2,Var3); 
if (memberVar4){
char *Var13=FUNC16(STRING,memberVar4,Var3); 
if (!Var4){
Var4=FUNC20(Var2,Var3); 
",840,0
before_cmd.c,r_core_run_script,False,False,39,CWE-,CallExpression,strdup,866,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\t\t\teprintf (""WARNING: ignored nested source: %s\\n"", file);\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", 0);\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tr_core_cmdf (core, ""=H"");\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", httpSandbox);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tr_lang_use (core->lang, p->name);\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""vala"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n', '\tfree (r_list_pop (core->scriptstack));\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(STRING,Var3); 
FUNC3(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC4(Var2,NULL ,NULL ); 
if (Var7){
Var4=FUNC5(Var2,Var7); 
else 
}else if (FUNC6(Var3,STRING)){
const bool  Var8=FUNC7(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC8(Var2->memberVar2,STRING)); 
FUNC9(Var2->memberVar2,STRING,0); 
char *Var10=FUNC10(Var3); 
FUNC11(Var2->memberVar2,STRING,Var10); 
FUNC12(Var2,STRING); 
FUNC9(Var2->memberVar2,STRING,Var8); 
FUNC11(Var2->memberVar2,STRING,Var9); 
else 
}else if (FUNC6(Var3,STRING)){
FUNC13(Var2,STRING,Var3); 
else 
}else if (FUNC14(Var3)){
const char *Var11=FUNC8(Var2->memberVar2,STRING); 
char *Var7=FUNC15(Var2->memberVar3,Var3,Var11,NULL ); 
if (Var7){
FUNC16(Var2->memberVar3->memberVar1,Var7); 
else 
Var5=FUNC17(Var2->memberVar4,Var3); 
if (Var5){
FUNC18(Var2->memberVar4,Var5->memberVar1); 
Var4=FUNC19(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC20(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC22(STRING,Var3); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC23(STRING); 
if (Var14){
FUNC18(Var2->memberVar4,STRING); 
char *Var13=FUNC22(STRING,Var14,Var3); 
if (Var13){
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
char *Var15=FUNC24(Var3); 
char *memberVar4=FUNC25(Var2,Var3); 
if (memberVar4){
FUNC18(Var2->memberVar4,STRING); 
char *Var13=FUNC22(STRING,memberVar4,Var3); 
FUNC19(Var2,Var2->memberVar4,Var13); 
if (!Var4){
Var4=FUNC26(Var2,Var3); 
free(FUNC27(Var2->memberVar1)); 
",1410,0
before_cmd.c,r_core_run_script,False,False,40,CWE-,CallExpression,strcmp,868,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\t\t\teprintf (""WARNING: ignored nested source: %s\\n"", file);\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(STRING,Var3); 
FUNC3(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC4(Var2,NULL ,NULL ); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
char *Var10=FUNC8(Var3); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC9(Var2,STRING,Var3); 
else 
}else if (FUNC10(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); 
else 
Var5=FUNC12(Var2->memberVar4,Var3); 
if (Var5){
Var4=FUNC13(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC14(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC16(STRING,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC13(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC17(STRING); 
if (Var14){
char *Var13=FUNC16(STRING,Var14,Var3); 
char *Var13=FUNC15(STRING); 
char *Var13=FUNC15(STRING); 
else 
char *Var15=FUNC18(Var3); 
char *memberVar4=FUNC19(Var2,Var3); 
if (memberVar4){
char *Var13=FUNC16(STRING,memberVar4,Var3); 
if (!Var4){
Var4=FUNC20(Var2,Var3); 
",840,0
before_cmd.c,r_core_run_script,False,False,41,CWE-,CallExpression,free,872,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', '\t\t\tfree (out);\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
if (Var6){
Var4=FUNC3(Var2,Var6); 
free(Var6); 
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC7(Var2->memberVar2,Var3,Var10,NULL ); 
const char *Var11=FUNC8(Var3,.); 
char *Var12=FUNC9(STRING,Var3); 
char *Var12=FUNC9(STRING,Var13,Var3); 
else 
char *Var14=FUNC10(Var3); 
char *Var15=FUNC11(Var2,Var3); 
char *Var12=FUNC9(STRING,Var15,Var3); 
",326,0
before_cmd.c,r_core_run_script,False,False,42,CWE-,CallExpression,strdup,876,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", 0);\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tr_core_cmdf (core, ""=H"");\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", httpSandbox);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', '\t\tfree (httpIndex);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tr_lang_use (core->lang, p->name);\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""vala"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n', '\tfree (r_list_pop (core->scriptstack));\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC3(Var2,NULL ,NULL ); 
if (Var7){
Var4=FUNC4(Var2,Var7); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
FUNC8(Var2->memberVar2,STRING,0); 
char *Var10=FUNC9(Var3); 
FUNC10(Var2->memberVar2,STRING,Var10); 
FUNC11(Var2,STRING); 
FUNC8(Var2->memberVar2,STRING,Var8); 
FUNC10(Var2->memberVar2,STRING,Var9); 
free(Var9); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC12(Var2,STRING,Var3); 
else 
}else if (FUNC13(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); 
if (Var7){
FUNC15(Var2->memberVar3->memberVar1,Var7); 
else 
Var5=FUNC16(Var2->memberVar4,Var3); 
if (Var5){
FUNC17(Var2->memberVar4,Var5->memberVar1); 
Var4=FUNC18(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC19(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING,Var3); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC22(STRING); 
if (Var14){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,Var14,Var3); 
if (Var13){
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
char *Var15=FUNC23(Var3); 
char *memberVar4=FUNC24(Var2,Var3); 
if (memberVar4){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,memberVar4,Var3); 
FUNC18(Var2,Var2->memberVar4,Var13); 
if (!Var4){
Var4=FUNC25(Var2,Var3); 
free(FUNC26(Var2->memberVar1)); 
",1407,0
before_cmd.c,r_core_run_script,False,False,43,CWE-,CallExpression,free,880,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tfree (absfile);\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4; 
if (!strcmp(Var3,Var4)){
if (!strcmp(Var3,STRING)){
char *Var5=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var6=FUNC4(Var2->memberVar1,STRING); 
char *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var8=FUNC6(Var3); 
FUNC7(Var2->memberVar1,STRING,Var8); 
free(Var8); 
const char *Var9=FUNC5(Var2->memberVar1,STRING); 
char *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); 
const char *Var10=FUNC9(Var3,.); 
char *Var11=FUNC10(STRING,Var3); 
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
char *Var13=FUNC11(Var3); 
char *Var14=FUNC12(Var2,Var3); 
char *Var11=FUNC10(STRING,Var14,Var3); 
",330,0
before_cmd.c,r_core_run_script,False,False,44,CWE-,CallExpression,free,884,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', '\t\tfree (httpIndex);\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4; 
if (!strcmp(Var3,Var4)){
if (!strcmp(Var3,STRING)){
char *Var5=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var6=FUNC4(Var2->memberVar1,STRING); 
char *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var8=FUNC6(Var3); 
FUNC7(Var2->memberVar1,STRING,Var7); 
free(Var7); 
const char *Var9=FUNC5(Var2->memberVar1,STRING); 
char *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); 
const char *Var10=FUNC9(Var3,.); 
char *Var11=FUNC10(STRING,Var3); 
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
char *Var13=FUNC11(Var3); 
char *Var14=FUNC12(Var2,Var3); 
char *Var11=FUNC10(STRING,Var14,Var3); 
",330,0
before_cmd.c,r_core_run_script,False,False,45,CWE-,CallExpression,free,895,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tr_cons_strcat (out);\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', '\t\t\tfree (out);\n', '\t\tret = out? true: false;\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var6){
FUNC9(Var6); 
FUNC10(Var2->memberVar2->memberVar1,Var6); 
free(Var6); 
Var4=Var6 true false ; 
const char *Var11=FUNC11(Var3,.); 
char *Var12=FUNC12(STRING,Var3); 
char *Var12=FUNC12(STRING,Var13,Var3); 
else 
char *Var14=FUNC13(Var3); 
char *Var15=FUNC14(Var2,Var3); 
char *Var12=FUNC12(STRING,Var15,Var3); 
",404,0
before_cmd.c,r_core_run_script,False,False,46,CWE-,CallExpression,strcmp,914,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,47,CWE-,CallExpression,free,918,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC10(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC11(STRING,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC11(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC11(STRING,memberVar3,Var3); 
",511,0
before_cmd.c,r_core_run_script,False,False,48,CWE-,CallExpression,strcmp,920,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,49,CWE-,CallExpression,free,928,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC11(STRING,Var3); 
FUNC12(Var2,Var2->memberVar3,Var12); 
free(Var12); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var13,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC13(Var3); 
char *memberVar3=FUNC14(Var2,Var3); 
char *Var12=FUNC11(STRING,memberVar3,Var3); 
",555,0
before_cmd.c,r_core_run_script,False,False,50,CWE-,CallExpression,strcmp,930,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,51,CWE-,CallExpression,free,934,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",549,0
before_cmd.c,r_core_run_script,False,False,52,CWE-,CallExpression,strcmp,936,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,53,CWE-,CallExpression,free,940,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",568,0
before_cmd.c,r_core_run_script,False,False,54,CWE-,CallExpression,strcmp,942,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,55,CWE-,CallExpression,free,946,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",587,0
before_cmd.c,r_core_run_script,False,False,56,CWE-,CallExpression,strcmp,948,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,57,CWE-,CallExpression,free,952,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",606,0
before_cmd.c,r_core_run_script,False,False,58,CWE-,CallExpression,strcmp,954,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,59,CWE-,CallExpression,free,958,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",625,0
before_cmd.c,r_core_run_script,False,False,60,CWE-,CallExpression,strcmp,960,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,61,CWE-,CallExpression,free,964,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",644,0
before_cmd.c,r_core_run_script,False,False,62,CWE-,CallExpression,strcmp,966,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,63,CWE-,CallExpression,strcmp,970,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,64,CWE-,CallExpression,strdup,973,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (!shell) {\n', '\t\t\t\t\t\tshell = strdup (""sh"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\t\tfree (shell);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
else 
}else if (!strcmp(Var10,STRING)){
char *Var12=FUNC11(STRING); 
if (!Var12){
Var12=strdup(STRING); 
if (Var12){
char *Var11=FUNC10(STRING,Var12,Var3); 
if (Var11){
FUNC12(Var5,Var5->memberVar3,Var11); 
free(Var11); 
free(Var12); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC13(Var3); 
char *memberVar3=FUNC14(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",736,0
before_cmd.c,r_core_run_script,False,False,65,CWE-,CallExpression,free,980,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (!shell) {\n', '\t\t\t\t\t\tshell = strdup (""sh"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC11(STRING,Var3); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
else 
}else if (!strcmp(Var11,STRING)){
char *Var13=FUNC12(STRING); 
if (!Var13){
Var13=strdup(STRING); 
if (Var13){
char *Var12=FUNC11(STRING,Var13,Var3); 
if (Var12){
FUNC13(Var2,Var2->memberVar3,Var12); 
free(Var12); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC14(Var3); 
char *memberVar3=FUNC15(Var2,Var3); 
char *Var12=FUNC11(STRING,memberVar3,Var3); 
",754,0
before_cmd.c,r_core_run_script,False,False,66,CWE-,CallExpression,free,982,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (!shell) {\n', '\t\t\t\t\t\tshell = strdup (""sh"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tfree (shell);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC1(Var3,STRING)){
char *Var4=strdup(FUNC2(Var5->memberVar1,STRING)); 
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC1(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var5->memberVar2,Var3,Var8,NULL ); 
if (Var1){
const char *Var1=FUNC6(Var3,.); 
if (Var1){
const char *Var9=Var1+1; 
if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC8(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var11=FUNC9(STRING); 
if (!Var11){
Var11=strdup(STRING); 
if (Var11){
char *Var10=FUNC8(STRING,Var11,Var3); 
free(Var11); 
char *Var10=FUNC7(STRING); 
char *Var10=FUNC7(STRING); 
else 
char *Var12=FUNC10(Var3); 
char *Var13=FUNC11(Var5,Var3); 
char *Var10=FUNC8(STRING,Var13,Var3); 
",643,0
before_cmd.c,r_core_run_script,False,False,67,CWE-,CallExpression,strcmp,985,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,68,CWE-,CallExpression,free,989,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",701,0
before_cmd.c,r_core_run_script,False,False,69,CWE-,CallExpression,strcmp,991,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
before_cmd.c,r_core_run_script,False,False,70,CWE-,CallExpression,free,995,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",720,0
before_cmd.c,r_core_run_script,False,False,71,CWE-,CallExpression,free,1005,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tfree (lang);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var13,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC12(Var3); 
char *Var15=FUNC13(Var2,Var3); 
if (Var15){
char *Var12=FUNC11(STRING,Var15,Var3); 
free(Var15); 
",513,0
before_cmd.c,r_core_run_script,False,False,72,CWE-,CallExpression,free,1006,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var13,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC12(Var3); 
char *Var15=FUNC13(Var2,Var3); 
if (Var15){
char *Var12=FUNC11(STRING,Var15,Var3); 
FUNC14(Var2,Var2->memberVar3,Var12); 
free(Var12); 
",530,0
before_cmd.c,r_core_run_script,False,False,73,CWE-,CallExpression,free,1009,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\tfree (abspath);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
char *Var10=FUNC7(STRING,Var3); 
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
free(Var12); 
",305,0
before_cmd.c,r_core_run_script,False,False,74,CWE-,CallExpression,free,1016,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", 0);\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tr_core_cmdf (core, ""=H"");\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", httpSandbox);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tr_lang_use (core->lang, p->name);\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""vala"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n', '\tfree (r_list_pop (core->scriptstack));\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC3(Var2,NULL ,NULL ); 
if (Var7){
Var4=FUNC4(Var2,Var7); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
FUNC8(Var2->memberVar2,STRING,0); 
char *Var10=FUNC9(Var3); 
FUNC10(Var2->memberVar2,STRING,Var10); 
FUNC11(Var2,STRING); 
FUNC8(Var2->memberVar2,STRING,Var8); 
FUNC10(Var2->memberVar2,STRING,Var9); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC12(Var2,STRING,Var3); 
else 
}else if (FUNC13(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); 
if (Var7){
FUNC15(Var2->memberVar3->memberVar1,Var7); 
else 
Var5=FUNC16(Var2->memberVar4,Var3); 
if (Var5){
FUNC17(Var2->memberVar4,Var5->memberVar1); 
Var4=FUNC18(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC19(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING,Var3); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC22(STRING); 
if (Var14){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,Var14,Var3); 
if (Var13){
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
char *Var15=FUNC23(Var3); 
char *memberVar4=FUNC24(Var2,Var3); 
if (memberVar4){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,memberVar4,Var3); 
FUNC18(Var2,Var2->memberVar4,Var13); 
if (!Var4){
Var4=FUNC25(Var2,Var3); 
free(FUNC26(Var2->memberVar1)); 
",1400,0
before_cmd.c,cmd_ls,False,False,75,CWE-,CallExpression,strchr,1022,-3,"['static int cmd_ls(void *data, const char *input) { // ""ls""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (arg) {\n', '\t\t\tr_core_cmdf (core, ""cat %s~.."", arg);\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_ls (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (Var4){
FUNC3(Var3,STRING,Var4); 
if (FUNC4(Var3->memberVar1,Var4)){
FUNC3(Var3,STRING,Var4); 
else 
char *Var5=FUNC5(Var4); 
if (Var5){
FUNC6(Var5); 
free(Var5); 
",180,0
before_cmd.c,cmd_ls,False,False,76,CWE-,CallExpression,free,1047,-3,"['static int cmd_ls(void *data, const char *input) { // ""ls""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (!arg) {\n', '\t\t\targ = """";\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', 'else\n', '\t\t\tchar *res = r_syscmd_ls (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (!Var4){
Var4=STRING; 
if (FUNC3(Var3->memberVar1,Var4)){
else 
char *Var5=FUNC4(Var4); 
if (Var5){
FUNC5(Var5); 
free(Var5); 
",161,0
before_cmd.c,cmd_join,False,False,77,CWE-,CallExpression,strdup,1057,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', ""\t*end = '\\0';\n"", '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\t\t\tR_FREE (tmp);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
*Var6=0; 
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
FUNC6(Var4); 
",249,0
before_cmd.c,cmd_join,False,False,78,CWE-,CallExpression,strchr,1058,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', ""\t*end = '\\0';\n"", '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\t\t\tR_FREE (tmp);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
*Var6=0; 
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
FUNC6(Var4); 
",249,0
before_cmd.c,cmd_join,False,False,79,CWE-,CallExpression,strchr,1063,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', ""\t*end = '\\0';\n"", '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
*Var6=0; 
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
",241,0
before_cmd.c,cmd_join,False,False,80,CWE-,CallExpression,free,1087,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!arg1) {\n', '\t\t\targ1 = """";\n', '\t\tif (!arg2) {\n', '\t\t\targ2 = """";\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!Var5){
Var5=STRING; 
if (!Var7){
Var7=STRING; 
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
",264,0
before_cmd.c,cmd_interpret,False,False,81,CWE-,CallExpression,strchr,1118,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", '\t\t\tcmd = ptr + 1;\n', '\t\t\t*ptr = 0;\n', ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\thost = input + 1;\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", '\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n', '\t\t\tif (rbuf) {\n', '\t\t\t\tr_cons_print (rbuf);\n', '\t\t\t\tfree (rbuf);\n', 'else\n', '\t\t\tr_core_rtr_cmds (core, input + 1);\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tr_core_cmd_command (core, input + 1);\n', '\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var11=Var4+1; 
*Var4=0; 
Var5=strchr(Var2+1,); 
if (Var5){
Var9=Var2+1; 
Var10=Var2+((Var2[1]== ) 21); 
Var6=FUNC2(Var12,Var9,Var10,Var11); 
if (Var6){
FUNC3(Var6); 
free(Var6); 
else 
FUNC4(Var12,Var2+1); 
if (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16
else 
}else if (Var2[1]){
char *Var3=FUNC5(Var12,FUNC6(Var2)); 
const char *Var17=FUNC6(Var2+1); 
char *Var18=strdup(Var17); 
char *Var19=strchr(Var18,); 
const char *Var20=FUNC6(Var2+1); 
FUNC7(Var12,Var2+1); 
FUNC8(&Var12->memberVar1->memberVar1,Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
char *Var21=FUNC9(strdup(Var4),Var7); 
",451,0
before_cmd.c,cmd_interpret,False,False,82,CWE-,CallExpression,strchr,1123,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\t*eol = 0;\n', '\t\t\t\thost = input + 1;\n', '\t\t\t\tport = eol + 1;\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", '\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n', '\t\t\tif (rbuf) {\n', '\t\t\t\tr_cons_print (rbuf);\n', '\t\t\t\tfree (rbuf);\n', 'else\n', '\t\t\tr_core_rtr_cmds (core, input + 1);\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tr_core_cmd_command (core, input + 1);\n', '\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var5=strchr(Var2+1,); 
if (Var5){
*Var5=0; 
Var9=Var2+1; 
Var10=Var5+1; 
Var10=Var2+((Var2[1]== ) 21); 
Var6=FUNC2(Var12,Var9,Var10,Var11); 
if (Var6){
FUNC3(Var6); 
free(Var6); 
else 
FUNC4(Var12,Var2+1); 
if (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16
else 
}else if (Var2[1]){
char *Var3=FUNC5(Var12,FUNC6(Var2)); 
const char *Var17=FUNC6(Var2+1); 
char *Var18=strdup(Var17); 
char *Var19=strchr(Var18,); 
const char *Var20=FUNC6(Var2+1); 
FUNC7(Var12,Var2+1); 
FUNC8(&Var12->memberVar1->memberVar1,Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
char *Var21=FUNC9(strdup(Var4),Var7); 
",451,0
before_cmd.c,cmd_interpret,False,False,83,CWE-,CallExpression,free,1135,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", '\t\t\tcmd = ptr + 1;\n', ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\thost = input + 1;\n', '\t\t\t\tport = eol + 1;\n', 'else\n', '\t\t\t\thost = ""localhost"";\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", '\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n', '\t\t\tif (rbuf) {\n', '\t\t\t\tr_cons_print (rbuf);\n', '\t\t\t\tfree (rbuf);\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var11=Var4+1; 
Var5=strchr(Var2+1,); 
if (Var5){
Var9=Var2+1; 
Var10=Var5+1; 
else 
Var9=STRING; 
Var10=Var2+((Var2[1]== ) 21); 
Var6=FUNC2(Var12,Var9,Var10,Var11); 
if (Var6){
FUNC3(Var6); 
free(Var6); 
char *Var3=FUNC4(Var12,FUNC5(Var2)); 
const char *Var13=FUNC5(Var2+1); 
char *Var14=strchr(Var15,); 
const char *Var16=FUNC5(Var2+1); 
char *Var17=FUNC6(strdup(Var4),Var7); 
",322,0
before_cmd.c,cmd_interpret,False,False,84,CWE-,CallExpression,free,1149,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tif (str) {\n', '\t\t\t\tr_core_cmd (core, str, 0);\n', '\t\t\t\tfree (str);\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
if (Var2[1]== .){//STRING Var10  Var11  Var12  STRUCT2  Var13
else 
}else if (Var2[1]){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
if (Var3){
FUNC4(Var9,Var3,0); 
free(Var3); 
const char *Var14=FUNC3(Var2+1); 
const char *Var15=FUNC3(Var2+1); 
",209,0
before_cmd.c,cmd_interpret,False,False,85,CWE-,CallExpression,strdup,1158,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tif (sp) {\n', '\t\t\t\t*sp = 0;\n', '\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n', '\t\t\t\tr_core_run_script (core, s);\n', '\t\t\tfree (s);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var4=FUNC2(Var3,FUNC3(Var2)); 
const char *Var5=FUNC3(Var2+1); 
char *Var6=strdup(Var5); 
char *Var7=strchr(Var6,); 
if (Var7){
*Var7=0; 
if (FUNC4(Var6)){
FUNC5(Var3,Var6); 
free(Var6); 
const char *Var8=FUNC3(Var2+1); 
char *Var9=FUNC6(strdup(Var10),Var11); 
",198,1
before_cmd.c,cmd_interpret,False,False,86,CWE-,CallExpression,strchr,1159,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tif (sp) {\n', '\t\t\t\t*sp = 0;\n', '\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n', '\t\t\t\tr_core_run_script (core, s);\n', '\t\t\tfree (s);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var4=FUNC2(Var3,FUNC3(Var2)); 
const char *Var5=FUNC3(Var2+1); 
char *Var6=strdup(Var5); 
char *Var7=strchr(Var6,); 
if (Var7){
*Var7=0; 
if (FUNC4(Var6)){
FUNC5(Var3,Var6); 
free(Var6); 
const char *Var8=FUNC3(Var2+1); 
char *Var9=FUNC6(strdup(Var10),Var11); 
",198,1
before_cmd.c,cmd_interpret,False,False,87,CWE-,CallExpression,free,1166,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n', '\t\t\t\tr_core_run_script (core, s);\n', '\t\t\tfree (s);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var4=FUNC2(Var3,FUNC3(Var2)); 
const char *Var5=FUNC3(Var2+1); 
char *Var6=strdup(Var5); 
char *Var7=strchr(Var6,); 
if (FUNC4(Var6)){
FUNC5(Var3,Var6); 
free(Var6); 
const char *Var8=FUNC3(Var2+1); 
char *Var9=FUNC6(strdup(Var10),Var11); 
",183,1
before_cmd.c,cmd_interpret,False,False,88,CWE-,CallExpression,strdup,1206,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\thost = input + 1;\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", 'else\n', '\t\t\tr_core_rtr_cmds (core, input + 1);\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tr_core_cmd_command (core, input + 1);\n', '\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tif (filter) {\n', '\t\t\t*filter = 0;\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (filter) {\n', ""\t\t\t*filter = '~';\n"", '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (eol) {\n', ""\t\t\t\t\t*eol = '\\0';\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n', '\t\tfree (str);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var5=strchr(Var2+1,); 
if (Var5){
Var9=Var2+1; 
Var10=Var2+((Var2[1]== ) 21); 
else 
FUNC2(Var12,Var2+1); 
if (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16
else 
}else if (Var2[1]){
char *Var3=FUNC3(Var12,FUNC4(Var2)); 
const char *Var17=FUNC4(Var2+1); 
char *Var18=strdup(Var17); 
char *Var19=strchr(Var18,); 
const char *Var20=FUNC4(Var2+1); 
FUNC5(Var12,Var2+1); 
FUNC6(&Var12->memberVar1->memberVar1,Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
if (Var7){
*Var7=0; 
Var4=Var3=FUNC7(Var12,Var8); 
if (Var7){
*Var7=; 
if (Var4){
if (FUNC8()){
Var5=strchr(Var4,Var21); 
if (Var5){
*Var5=0; 
if (*Var4){
char *Var22=FUNC9(strdup(Var4),Var7); 
FUNC10(Var12,Var22); 
free(Var22); 
if (!Var5){
Var4=Var5+1; 
free(Var3); 
free(Var8); 
",554,0
before_cmd.c,cmd_interpret,False,False,89,CWE-,CallExpression,strchr,1207,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tif (filter) {\n', '\t\t\t*filter = 0;\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (filter) {\n', ""\t\t\t*filter = '~';\n"", '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
if (Var7){
*Var7=0; 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var7){
*Var7=; 
if (Var4){
if (FUNC5()){
if (*Var4){
char *Var14=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var14); 
free(Var14); 
if (!Var5){
free(Var8); 
",328,0
before_cmd.c,cmd_interpret,False,False,90,CWE-,CallExpression,strchr,1225,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (eol) {\n', ""\t\t\t\t\t*eol = '\\0';\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var4){
if (FUNC5()){
Var5=strchr(Var4,Var14); 
if (Var5){
*Var5=0; 
if (*Var4){
char *Var15=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var15); 
free(Var15); 
if (!Var5){
Var4=Var5+1; 
",318,0
before_cmd.c,cmd_interpret,False,False,91,CWE-,CallExpression,strdup,1230,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tif (filter) {\n', '\t\t\t*filter = 0;\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (filter) {\n', ""\t\t\t*filter = '~';\n"", '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
if (Var7){
*Var7=0; 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var7){
*Var7=; 
if (Var4){
if (FUNC5()){
Var5=strchr(Var4,Var14); 
if (*Var4){
char *Var15=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var15); 
free(Var15); 
if (!Var5){
Var4=Var5+1; 
",343,0
before_cmd.c,cmd_interpret,False,False,92,CWE-,CallExpression,free,1232,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var4){
if (FUNC5()){
Var5=strchr(Var4,Var14); 
if (*Var4){
char *Var15=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var15); 
free(Var15); 
if (!Var5){
Var4=Var5+1; 
",314,0
before_cmd.c,cmd_interpret,False,False,93,CWE-,CallExpression,free,1241,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\tfree (str);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
const char *Var12=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var4=Var3=FUNC4(Var9,Var8); 
char *Var13=FUNC5(strdup(Var4),Var7); 
free(Var3); 
",220,0
before_cmd.c,cmd_interpret,False,False,94,CWE-,CallExpression,free,1242,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
Var4=Var3=FUNC4(Var9,Var8); 
char *Var14=FUNC5(strdup(Var4),Var7); 
free(Var8); 
",245,0
before_cmd.c,r_line_hist_sdb_up,False,False,95,CWE-,CallExpression,strncpy,1258,-3,"['R_API int r_line_hist_sdb_up(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
before_cmd.c,r_line_hist_sdb_up,False,False,96,CWE-,CallExpression,strlen,1259,-3,"['R_API int r_line_hist_sdb_up(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
before_cmd.c,r_line_hist_sdb_down,False,False,97,CWE-,CallExpression,strncpy,1268,-3,"['R_API int r_line_hist_sdb_down(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
before_cmd.c,r_line_hist_sdb_down,False,False,98,CWE-,CallExpression,strlen,1269,-3,"['R_API int r_line_hist_sdb_down(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
before_cmd.c,cmd_kuery,False,False,99,CWE-,CallExpression,strchr,1295,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tr_cons_printf (""\\n\\n\\""%s\\"" : ["", cur_cmd);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\twhile (*temp_storage) {\n', ""\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n"", '\t\t\t\tif (!temp_pos) {\n', '\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n', '\t\t\t\tr_cons_printf (""\\""%s\\"","", temp_cmd);\n', '\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (next_cmd);\n', '\t\tfree (temp_storage);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
FUNC4(STRING%Var6 STRING,Var8); 
Var9=FUNC5(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
while (*Var12){
Var10=strchr(Var12,Var13); 
if (!Var10){
Var11=FUNC3(Var12,Var10-Var12); 
FUNC4(STRING%Var6 STRING,Var11); 
Var12  STRUCT3  Var10-Var12+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var9); 
free(Var12); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC6(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",521,0
before_cmd.c,cmd_kuery,False,False,100,CWE-,CallExpression,strchr,1314,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\twhile (*temp_storage) {\n', ""\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n"", '\t\t\t\tif (!temp_pos) {\n', '\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n', '\t\t\t\tr_cons_printf (""\\""%s\\"","", temp_cmd);\n', '\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (temp_storage);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
Var9=FUNC4(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
while (*Var12){
Var10=strchr(Var12,Var13); 
if (!Var10){
Var11=FUNC3(Var12,Var10-Var12); 
FUNC5(STRING%Var6 STRING,Var11); 
Var12  STRUCT3  Var10-Var12+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var12); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC6(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",499,0
before_cmd.c,cmd_kuery,False,False,101,CWE-,CallExpression,free,1329,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (next_cmd);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
Var9=FUNC4(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var9); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC5(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",421,0
before_cmd.c,cmd_kuery,False,False,102,CWE-,CallExpression,free,1330,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\twhile (*temp_storage) {\n', ""\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n"", '\t\t\t\tif (!temp_pos) {\n', '\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n', '\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (temp_storage);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
Var9=FUNC4(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
while (*Var12){
Var10=strchr(Var12,Var13); 
if (!Var10){
Var11=FUNC3(Var12,Var10-Var12); 
Var12  STRUCT3  Var10-Var12+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var12); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC5(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",484,0
before_cmd.c,cmd_kuery,False,False,103,CWE-,CallExpression,free,1338,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\tfree (out);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,Var2+1); 
if (Var4){
FUNC3(Var4); 
free(Var4); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT3 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
STRUCT2 *Var18=FUNC4(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
STRUCT2 *Var19=FUNC5(Var5->memberVar1,Var20,0); 
char *Var21=strdup(Var2); 
",284,1
before_cmd.c,cmd_kuery,False,False,104,CWE-,CallExpression,strdup,1354,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tfor (n = o = p; n; o = n) {\n', ""\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n"", '\t\t\t\tif (n) {\n', '\t\t\t\t\t*n++ = 0;\n', '\t\t\t\ts = sdb_ns (s, o, 1);\n', '\t\t\tfree (p);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tr_line_set_prompt (p);\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tif (out) {\n', '\t\t\t\tr_cons_println (out);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
const int  Var8=sizeof (Var3)-1; 
STRUCT2 *Var9=Var5->memberVar1; 
char *Var10,*Var11,*Var12=NULL ; 
char *Var13,*Var14,*Var15=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var9,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var16,*Var17,*Var7=strdup(Var2+2); 
for (Var16=Var17=Var7; Var16; Var17=Var16){
Var16=strchr(Var17,/); //STRUCT3  Var18
if (Var16){
*Var16  Var19=0; 
Var9=FUNC4(Var9,Var17,1); 
free(Var7); 
STRUCT4 *Var20=Var5->memberVar3->memberVar1; 
FUNC5(Var7); 
if (FUNC6(Var3,Var8,0,NULL )<1){
if (!*Var3){
Var4=FUNC2(Var9,NULL ,0,Var3); 
if (Var4){
FUNC7(Var4); 
if (FUNC8(0)){
if (Var2[1]== ){
char *Var21=strdup(Var2+2); 
if (!Var21){
char *Var22=strchr(Var21,); 
STRUCT2 *Var23=FUNC9(NULL ,Var21,0); 
if (FUNC8(0)){
if (Var2[1]== ){
char *Var21=strdup(Var2+2); 
char *Var22=strchr(Var21,); 
STRUCT2 *Var24=FUNC10(Var5->memberVar1,Var22,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var25=strdup(Var2); 
Var25[(size_t )(Var6-Var2)]=0; 
",627,0
before_cmd.c,cmd_kuery,False,False,105,CWE-,CallExpression,strchr,1357,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tfor (n = o = p; n; o = n) {\n', ""\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n"", '\t\t\t\tif (n) {\n', '\t\t\t\t\t*n++ = 0;\n', '\t\t\t\ts = sdb_ns (s, o, 1);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tif (out) {\n', '\t\t\t\tr_cons_println (out);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
const int  Var8=sizeof (Var3)-1; 
STRUCT2 *Var9=Var5->memberVar1; 
char *Var10,*Var11,*Var12=NULL ; 
char *Var13,*Var14,*Var15=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
if (Var2[1]== ){
char *Var16,*Var17,*Var7=strdup(Var2+2); 
for (Var16=Var17=Var7; Var16; Var17=Var16){
Var16=strchr(Var17,/); //STRUCT3  Var18
if (Var16){
*Var16  Var19=0; 
Var9=FUNC3(Var9,Var17,1); 
STRUCT4 *Var20=Var5->memberVar3->memberVar1; 
if (FUNC4(Var3,Var8,0,NULL )<1){
if (!*Var3){
Var4=FUNC5(Var9,NULL ,0,Var3); 
if (Var4){
FUNC6(Var4); 
char *Var21=strdup(Var2+2); 
char *Var22=strchr(Var21,); 
STRUCT2 *Var23=FUNC7(NULL ,Var21,0); 
char *Var21=strdup(Var2+2); 
char *Var22=strchr(Var21,); 
STRUCT2 *Var24=FUNC8(Var5->memberVar1,Var22,0); 
char *Var25=strdup(Var2); 
",481,0
before_cmd.c,cmd_kuery,False,False,106,CWE-,CallExpression,free,1363,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tfor (n = o = p; n; o = n) {\n', '\t\t\tfree (p);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tr_line_set_prompt (p);\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
const int  Var8=sizeof (Var3)-1; 
STRUCT2 *Var9=Var5->memberVar1; 
char *Var10,*Var11,*Var12=NULL ; 
char *Var13,*Var14,*Var15=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
if (Var2[1]== ){
char *Var16,*Var17,*Var7=strdup(Var2+2); 
for (Var16=Var17=Var7; Var16; Var17=Var16){
free(Var7); 
STRUCT3 *Var18=Var5->memberVar3->memberVar1; 
FUNC3(Var7); 
if (FUNC4(Var3,Var8,0,NULL )<1){
if (!*Var3){
char *Var19=strdup(Var2+2); 
STRUCT2 *Var20=FUNC5(NULL ,Var19,0); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var21=FUNC6(Var5->memberVar1,Var22,0); 
char *Var23=strdup(Var2); 
",379,0
before_cmd.c,cmd_kuery,False,False,107,CWE-,CallExpression,strcmp,1384,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (!line->sdbshell_hist) {\n', '\t\t\tline->sdbshell_hist = r_list_newf (free);\n', '\t\tRList *sdb_hist = line->sdbshell_hist;\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tif (sdb_hist) {\n', '\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n', '\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n', '\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const int  Var6=sizeof (Var3)-1; 
STRUCT2 *Var7=Var5->memberVar1; 
char *Var8,*Var9,*Var10=NULL ; 
char *Var11,*Var12,*Var13=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
char *Var14,*Var15,*Var16=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (!memberVar1->memberVar1){
memberVar1->memberVar1=FUNC3(free); 
STRUCT4 *Var18=memberVar1->memberVar1; 
if (FUNC4(Var3,Var6,0,NULL )<1){
if (!*Var3){
if (Var18){
if ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){
FUNC7(Var18,1,strdup(Var3)); 
memberVar1->memberVar2=Var18->memberVar1; 
Var4=FUNC8(Var7,NULL ,0,Var3); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var20=FUNC9(NULL ,Var19,0); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); 
char *Var23=strdup(Var2); 
",451,0
before_cmd.c,cmd_kuery,False,False,108,CWE-,CallExpression,strdup,1385,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (!line->sdbshell_hist) {\n', '\t\t\tline->sdbshell_hist = r_list_newf (free);\n', '\t\tRList *sdb_hist = line->sdbshell_hist;\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tif (sdb_hist) {\n', '\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n', '\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n', '\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const int  Var6=sizeof (Var3)-1; 
STRUCT2 *Var7=Var5->memberVar1; 
char *Var8,*Var9,*Var10=NULL ; 
char *Var11,*Var12,*Var13=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
char *Var14,*Var15,*Var16=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (!memberVar1->memberVar1){
memberVar1->memberVar1=FUNC3(free); 
STRUCT4 *Var18=memberVar1->memberVar1; 
if (FUNC4(Var3,Var6,0,NULL )<1){
if (!*Var3){
if (Var18){
if ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){
FUNC7(Var18,1,strdup(Var3)); 
memberVar1->memberVar2=Var18->memberVar1; 
Var4=FUNC8(Var7,NULL ,0,Var3); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var20=FUNC9(NULL ,Var19,0); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); 
char *Var23=strdup(Var2); 
",451,0
before_cmd.c,cmd_kuery,False,False,109,CWE-,CallExpression,strdup,1403,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', '\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', 'else\n', '\t\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\tfree (fn);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
if (Var19){
STRUCT2 *Var20; 
*Var19  Var21=0; 
if (FUNC5(Var18)){
Var20=FUNC6(Var5->memberVar1,Var19,1); 
if (Var20){
STRUCT2 *Var22=FUNC7(NULL ,Var18,0); 
if (Var22){
FUNC8(Var20,Var22); 
else 
FUNC9(STRING,Var18); 
else 
FUNC9(STRING,Var19); 
free(Var18); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
if (Var19){
STRUCT2 *Var20=FUNC6(Var5->memberVar1,Var19,0); 
if (Var20){
FUNC10(Var20,Var18); 
free(Var18); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var23=strdup(Var2); 
Var23[(size_t )(Var6-Var2)]=0; 
",598,0
before_cmd.c,cmd_kuery,False,False,110,CWE-,CallExpression,strchr,1408,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', '\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', 'else\n', '\t\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2 *Var4=Var3->memberVar1; 
char *Var5,*Var6,*Var7=NULL ; 
char *Var8,*Var9,*Var10=NULL ; 
switch (Var2[0]){
char *Var11,*Var12,*Var13=strdup(Var2+2); 
STRUCT3 *Var14=Var3->memberVar2->memberVar1; 
if (FUNC2(0)){
if (Var2[1]== ){
char *Var15=strdup(Var2+2); 
if (!Var15){
char *Var16=strchr(Var15,); 
if (Var16){
STRUCT2 *Var17; 
*Var16  Var18=0; 
if (FUNC3(Var15)){
Var17=FUNC4(Var3->memberVar1,Var16,1); 
if (Var17){
STRUCT2 *Var19=FUNC5(NULL ,Var15,0); 
if (Var19){
FUNC6(Var17,Var19); 
else 
FUNC7(STRING,Var15); 
else 
FUNC7(STRING,Var16); 
free(Var15); 
char *Var15=strdup(Var2+2); 
char *Var16=strchr(Var15,); 
STRUCT2 *Var17=FUNC4(Var3->memberVar1,Var16,0); 
char *Var20=strdup(Var2); 
",403,0
before_cmd.c,cmd_kuery,False,False,111,CWE-,CallExpression,free,1430,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', '\t\t\tfree (fn);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5=NULL ; 
char *Var6,*Var7,*Var8=NULL ; 
switch (Var2[0]){
char *Var9,*Var10,*Var11=strdup(Var2+2); 
if (FUNC2(0)){
if (Var2[1]== ){
char *Var12=strdup(Var2+2); 
if (!Var12){
char *Var13=strchr(Var12,); 
if (Var13){
STRUCT1 *Var14; 
if (FUNC3(Var12)){
if (Var14){
STRUCT1 *Var15=FUNC4(NULL ,Var12,0); 
if (Var15){
else 
FUNC5(STRING,Var12); 
free(Var12); 
char *Var12=strdup(Var2+2); 
char *Var13=strchr(Var12,); 
STRUCT1 *Var14=FUNC6(Var16->memberVar1,Var13,0); 
char *Var17=strdup(Var2); 
",302,0
before_cmd.c,cmd_kuery,False,False,112,CWE-,CallExpression,strdup,1441,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', '\t\t\tfree (fn);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\t\t\tsdb_sync (db);\n', 'else\n', '\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
if (Var19){
STRUCT2 *Var20; 
if (FUNC5(Var18)){
if (Var20){
STRUCT2 *Var21=FUNC6(NULL ,Var18,0); 
if (Var21){
else 
FUNC7(STRING,Var18); 
free(Var18); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
if (Var19){
*Var19  Var22=0; 
STRUCT2 *Var20=FUNC8(Var5->memberVar1,Var19,0); 
if (Var20){
FUNC9(Var20,Var18); 
FUNC10(Var20); 
else 
FUNC7(STRING,Var19); 
free(Var18); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var23=strdup(Var2); 
Var23[(size_t )(Var6-Var2)]=0; 
",576,0
before_cmd.c,cmd_kuery,False,False,113,CWE-,CallExpression,strchr,1442,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db;\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\t\t\tsdb_sync (db);\n', 'else\n', '\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2 *Var4=Var3->memberVar1; 
switch (Var2[0]){
char *Var5,*Var6,*Var7=strdup(Var2+2); 
STRUCT3 *Var8=Var3->memberVar2->memberVar1; 
char *Var9=strdup(Var2+2); 
char *Var10=strchr(Var9,); 
STRUCT2 *Var11; 
STRUCT2 *Var12=FUNC2(NULL ,Var9,0); 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var9=strdup(Var2+2); 
char *Var10=strchr(Var9,); 
if (Var10){
*Var10  Var13=0; 
STRUCT2 *Var11=FUNC4(Var3->memberVar1,Var10,0); 
if (Var11){
FUNC5(Var11,Var9); 
FUNC6(Var11); 
else 
FUNC7(STRING,Var10); 
free(Var9); 
char *Var14=strdup(Var2); 
",315,0
before_cmd.c,cmd_kuery,False,False,114,CWE-,CallExpression,free,1455,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db;\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\tfree (fn);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
switch (Var2[0]){
char *Var3,*Var4,*Var5=strdup(Var2+2); 
char *Var6=strdup(Var2+2); 
char *Var7=strchr(Var6,); 
STRUCT1 *Var8; 
STRUCT1 *Var9=FUNC2(NULL ,Var6,0); 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var6=strdup(Var2+2); 
char *Var7=strchr(Var6,); 
if (Var7){
STRUCT1 *Var8=FUNC4(Var10->memberVar1,Var7,0); 
if (Var8){
FUNC5(Var8,Var6); 
free(Var6); 
char *Var11=strdup(Var2); 
",236,0
before_cmd.c,cmd_kuery,False,False,115,CWE-,CallExpression,strchr,1470,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n', '\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\t\tfree (out);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
STRUCT2 *Var20=FUNC5(NULL ,Var18,0); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
STRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var22=strdup(Var2); 
Var22[(size_t )(Var6-Var2)]=0; 
Var4=FUNC2(Var8,NULL ,0,Var6+1); 
if (Var4){
FUNC7(Var4); 
free(Var4); 
",493,0
before_cmd.c,cmd_kuery,False,False,116,CWE-,CallExpression,strdup,1472,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n', '\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n', '\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\t\tfree (out);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
STRUCT2 *Var20=FUNC5(NULL ,Var18,0); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
STRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var22=strdup(Var2); 
Var22[(size_t )(Var6-Var2)]=0; 
Var8=FUNC7(Var5->memberVar1,Var22+1,1); 
Var4=FUNC2(Var8,NULL ,0,Var6+1); 
if (Var4){
FUNC8(Var4); 
free(Var4); 
free(Var22); 
",521,0
before_cmd.c,cmd_kuery,False,False,117,CWE-,CallExpression,free,1478,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n', '\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\t\tfree (out);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
STRUCT2 *Var20=FUNC4(NULL ,Var18,0); 
if (FUNC3(0)){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
STRUCT2 *Var21=FUNC5(Var5->memberVar1,Var19,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var22=strdup(Var2); 
Var8=FUNC6(Var5->memberVar1,Var22+1,1); 
Var4=FUNC7(Var8,NULL ,0,Var6+1); 
if (Var4){
FUNC8(Var4); 
free(Var4); 
",448,0
before_cmd.c,cmd_kuery,False,False,118,CWE-,CallExpression,free,1480,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n', '\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4,*Var5=STRING; 
STRUCT2 *Var6=Var3->memberVar1; 
switch (Var2[0]){
if (Var3->memberVar2){
if (!FUNC2()){
char *Var7,*Var8,*Var5=strdup(Var2+2); 
STRUCT3 *Var9=Var3->memberVar3->memberVar1; 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var10=strdup(Var2+2); 
if (!Var10){
char *Var11=strchr(Var10,); 
STRUCT2 *Var12=FUNC4(NULL ,Var10,0); 
if (FUNC3(0)){
char *Var10=strdup(Var2+2); 
char *Var11=strchr(Var10,); 
STRUCT2 *Var13=FUNC5(Var3->memberVar1,Var11,0); 
if (Var2[0]== 0){
if (Var4){
char *Var14=strdup(Var2); 
Var14[(size_t )(Var4-Var2)]=0; 
Var6=FUNC6(Var3->memberVar1,Var14+1,1); 
free(Var14); 
",368,0
before_cmd.c,__runMain,False,False,119,CWE-,CallExpression,free,1544,-3,"['static int __runMain(RMainCallback cb, const char *arg) {\n', '\tchar *a = r_str_trim_dup (arg);\n', '\tint argc = 0;\n', '\tchar **args = r_str_argv (a, &argc);\n', '\tint res = cb (argc, args);\n', '\tfree (args);\n']","static int FUNC1(STRUCT1  Var1,const char *Var2){
char *Var3=FUNC2(Var2); 
int  Var4=0; 
char **Var5=FUNC3(Var3,&Var4); 
int  Var6=Var1(Var4,Var5); 
free(Var5); 
",86,1
before_cmd.c,__runMain,False,False,120,CWE-,CallExpression,free,1545,-3,"['static int __runMain(RMainCallback cb, const char *arg) {\n', '\tchar *a = r_str_trim_dup (arg);\n', '\tchar **args = r_str_argv (a, &argc);\n', '\tint res = cb (argc, args);\n', '\tfree (a);\n']","static int FUNC1(STRUCT1  Var1,const char *Var2){
char *Var3=FUNC2(Var2); 
char **Var4=FUNC3(Var3,&Var5); 
int  Var6=Var1(Var5,Var4); 
free(Var3); 
",78,1
before_cmd.c,cmd_r2cmd,False,False,121,CWE-,CallExpression,free,1578,-3,"['static bool cmd_r2cmd(RCore *core, const char *_input) {\n', '\tchar *input = r_str_newf (""r%s"", _input);\n', '\tint rc = 0;\n', '\tif (r_str_startswith (input, ""rax2"")) {\n', 'else\n', '\t} else if (r_str_startswith (input, ""radare2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rasm2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rabin2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""ragg2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""r2pm"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""radiff2"")) {\n', '\t\trc = __runMain (core->r_main_radiff2, input);\n', 'else\n', '\t\tconst char *r2cmds[] = {\n', '\t\tint i;\n', '\t\tfor (i = 0; r2cmds[i]; i++) {\n', '\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n', '\t\t\t\tfree (input);\n', '\tfree (input);\n']","static bool FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=FUNC2(STRING,Var2); 
int  Var4=0; 
if (FUNC3(Var3,STRING)){
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
Var4=FUNC5(Var1->memberVar1,Var3); 
else 
const char *Var5[]={
int  Var6; 
for (Var6=0; Var5[Var6]; Var6  Var7){
if (FUNC3(Var3,Var5[Var6])){
free(Var3); 
free(Var3); 
",320,0
before_cmd.c,cmd_r2cmd,False,False,122,CWE-,CallExpression,free,1584,-3,"['static bool cmd_r2cmd(RCore *core, const char *_input) {\n', '\tchar *input = r_str_newf (""r%s"", _input);\n', '\tint rc = 0;\n', '\tif (r_str_startswith (input, ""rax2"")) {\n', 'else\n', '\t} else if (r_str_startswith (input, ""radare2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rasm2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rabin2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""ragg2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""r2pm"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""radiff2"")) {\n', '\t\trc = __runMain (core->r_main_radiff2, input);\n', 'else\n', '\t\tconst char *r2cmds[] = {\n', '\t\tint i;\n', '\t\tfor (i = 0; r2cmds[i]; i++) {\n', '\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n', '\t\t\t\tfree (input);\n', '\tfree (input);\n']","static bool FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=FUNC2(STRING,Var2); 
int  Var4=0; 
if (FUNC3(Var3,STRING)){
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
Var4=FUNC5(Var1->memberVar1,Var3); 
else 
const char *Var5[]={
int  Var6; 
for (Var6=0; Var5[Var6]; Var6  Var7){
if (FUNC3(Var3,Var5[Var6])){
free(Var3); 
free(Var3); 
",320,0
before_cmd.c,cmd_resize,False,False,123,CWE-,CallExpression,write,1653,-3,"['\tRCore *core = (RCore *)data;\n', '\tif (cmd_r2cmd (core, input)) {\n', '\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n', '\tswitch (*input) {\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n']","STRUCT1 *Var1=(STRUCT1 *) Var2; 
if (FUNC1(Var1,Var3)){
STRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; 
switch (*Var3){
const char *memberVar1=FUNC3(Var3+2); 
write(1,Var5,strlen(Var5)); 
",109,0
before_cmd.c,cmd_resize,False,False,124,CWE-,CallExpression,strlen,1653,-3,"['\tRCore *core = (RCore *)data;\n', '\tif (cmd_r2cmd (core, input)) {\n', '\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n', '\tswitch (*input) {\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n']","STRUCT1 *Var1=(STRUCT1 *) Var2; 
if (FUNC1(Var1,Var3)){
STRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; 
switch (*Var3){
const char *memberVar1=FUNC3(Var3+2); 
write(1,Var5,strlen(Var5)); 
",109,0
before_cmd.c,cmd_pipein,False,False,125,CWE-,CallExpression,strdup,1727,-3,"['static int cmd_pipein(void *user, const char *input) {\n', '\tchar *buf = strdup (input);\n', '\tint len = r_str_unescape (buf);\n', '\tr_cons_readpush (buf, len);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4=FUNC2(Var3); 
FUNC3(Var3,Var4); 
free(Var3); 
",66,1
before_cmd.c,cmd_pipein,False,False,126,CWE-,CallExpression,free,1730,-3,"['static int cmd_pipein(void *user, const char *input) {\n', '\tchar *buf = strdup (input);\n', '\tint len = r_str_unescape (buf);\n', '\tr_cons_readpush (buf, len);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4=FUNC2(Var3); 
FUNC3(Var3,Var4); 
free(Var3); 
",66,1
before_cmd.c,cmd_pointer,False,False,127,CWE-,CallExpression,strdup,1823,-3,"['static int cmd_pointer(void *data, const char *input) {\n', '\tRCore *core = (RCore*) data;\n', '\tint ret = true;\n', '\tchar *str, *eq;\n', '\tinput = r_str_trim_ro (input);\n', ""\twhile (*input == ' ') {\n"", '\t\tinput++;\n', ""\tif (!*input || *input == '?') {\n"", '\tstr = strdup (input);\n', ""\teq = strchr (str, '=');\n"", '\tif (eq) {\n', '\t\t*eq++ = 0;\n', '\t\tif (!strncmp (eq, ""0x"", 2)) {\n', '\t\t\tret = r_core_cmdf (core, ""wv %s@%s"", eq, str);\n', 'else\n', '\t\t\tret = r_core_cmdf (core, ""wx %s@%s"", eq, str);\n', 'else\n', '\t\tret = r_core_cmdf (core, ""?v [%s]"", input);\n', '\tfree (str);\n', '\treturn ret;\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=true ; 
char *Var5,*Var6; 
Var2=FUNC2(Var2); 
while (*Var2 == ){
Var2  Var7; 
if (!*Var2||*Var2 == ){
Var5=strdup(Var2); 
Var6=strchr(Var5,=); 
if (Var6){
*Var6  Var7=0; 
if (!FUNC3(Var6,STRING,2)){
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var2); 
free(Var5); 
return  Var4; 
",236,0
before_cmd.c,cmd_pointer,False,False,128,CWE-,CallExpression,strchr,1824,-3,"['static int cmd_pointer(void *data, const char *input) {\n', '\tRCore *core = (RCore*) data;\n', '\tint ret = true;\n', '\tchar *str, *eq;\n', '\tinput = r_str_trim_ro (input);\n', ""\twhile (*input == ' ') {\n"", '\t\tinput++;\n', ""\tif (!*input || *input == '?') {\n"", '\tstr = strdup (input);\n', ""\teq = strchr (str, '=');\n"", '\tif (eq) {\n', '\t\t*eq++ = 0;\n', '\t\tif (!strncmp (eq, ""0x"", 2)) {\n', '\t\t\tret = r_core_cmdf (core, ""wv %s@%s"", eq, str);\n', 'else\n', '\t\t\tret = r_core_cmdf (core, ""wx %s@%s"", eq, str);\n', '\tfree (str);\n', '\treturn ret;\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=true ; 
char *Var5,*Var6; 
Var2=FUNC2(Var2); 
while (*Var2 == ){
Var2  Var7; 
if (!*Var2||*Var2 == ){
Var5=strdup(Var2); 
Var6=strchr(Var5,=); 
if (Var6){
*Var6  Var7=0; 
if (!FUNC3(Var6,STRING,2)){
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var6,Var5); 
free(Var5); 
return  Var4; 
",218,0
before_cmd.c,cmd_pointer,False,False,129,CWE-,CallExpression,free,1835,-3,"['static int cmd_pointer(void *data, const char *input) {\n', '\tRCore *core = (RCore*) data;\n', '\tint ret = true;\n', '\tchar *str, *eq;\n', '\tinput = r_str_trim_ro (input);\n', ""\twhile (*input == ' ') {\n"", '\t\tinput++;\n', ""\tif (!*input || *input == '?') {\n"", '\tstr = strdup (input);\n', ""\teq = strchr (str, '=');\n"", '\tif (eq) {\n', '\t\tif (!strncmp (eq, ""0x"", 2)) {\n', '\t\t\tret = r_core_cmdf (core, ""wv %s@%s"", eq, str);\n', 'else\n', '\t\t\tret = r_core_cmdf (core, ""wx %s@%s"", eq, str);\n', '\tfree (str);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=true ; 
char *Var5,*Var6; 
Var2=FUNC2(Var2); 
while (*Var2 == ){
Var2  Var7; 
if (!*Var2||*Var2 == ){
Var5=strdup(Var2); 
Var6=strchr(Var5,=); 
if (Var6){
if (!FUNC3(Var6,STRING,2)){
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var6,Var5); 
free(Var5); 
",202,0
before_cmd.c,cmd_autocomplete,False,False,130,CWE-,CallExpression,memcpy,1950,-3,"['static void cmd_autocomplete(RCore *core, const char *input) {\n', '\tRCoreAutocomplete* b = core->autocomplete;\n', '\tinput = r_str_trim_ro (input);\n', '\tchar arg[256];\n', '\tif (!*input) {\n', ""\tif (*input == '?') {\n"", ""\tif (*input == '-') {\n"", '\t\tconst char *arg = input + 1;\n', '\t\tif (!*input) {\n', '\t\tr_core_autocomplete_remove (b, arg);\n', '\twhile (b) {\n', '\t\tconst char* end = r_str_trim_wp (input);\n', '\t\tif (!end) {\n', '\t\tif ((end - input) >= sizeof (arg)) {\n', '\t\tif (end == input) {\n', '\t\tmemcpy (arg, input, end - input);\n', '\t\targ[end - input] = 0;\n', '\t\tRCoreAutocomplete* a = r_core_autocomplete_find (b, arg, true);\n', '\t\tinput = r_str_trim_ro (end);\n', '\t\tif (input && *input && !a) {\n', '\t\t\tif (b->type == R_CORE_AUTOCMPLT_DFLT && !(b = r_core_autocomplete_add (b, arg, R_CORE_AUTOCMPLT_DFLT, false))) {\n', 'else\n', '\t\t\t} else if (b->type != R_CORE_AUTOCMPLT_DFLT) {\n', 'else\n', '\t\t} else if ((!input || !*input) && !a) {\n', ""\t\t\tif (arg[0] == '$') {\n"", '\t\t\t\tint type = autocomplete_type (arg);\n', 'else\n', '\t\t} else if ((!input || !*input) && a) {\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2){
STRUCT2 *Var3=Var1->memberVar1; 
Var2=FUNC2(Var2); 
char  Var4[256]; 
if (!*Var2){
if (*Var2 == ){
if (*Var2 == -){
const char *Var4=Var2+1; 
if (!*Var2){
FUNC3(Var3,Var4); 
while (Var3){
const char *Var5=FUNC4(Var2); 
if (!Var5){
if ((Var5-Var2) >= sizeof (Var4)){
if (Var5 ==  Var2){
memcpy(Var4,Var2,Var5-Var2); 
Var4[Var5-Var2]=0; 
STRUCT2 *Var6=FUNC5(Var3,Var4,true ); 
Var2=FUNC2(Var5); 
if (Var2&&*Var2&&!Var6){
if (Var3->memberVar1 ==  Var7&&!(Var3=FUNC6(Var3,Var4,Var7,false ))){
else 
}else if (Var3->memberVar1 !=  Var7){
else 
}else if ((!Var2||!*Var2)&&!Var6){
if (Var4[0]== ){
int  memberVar1=FUNC7(Var4); 
else 
}else if ((!Var2||!*Var2)&&Var6){
",413,0
before_cmd.c,cmd_system,False,False,131,CWE-,CallExpression,free,2032,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\t(void)r_core_cmdf (core, ""\\""#!pipe %s\\"""", cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
if (Var2[1]== !){//!!!&!!!-
else 
}else if (Var2[1]== ){
else 
}else if (Var2[1]== *){
char *Var4=FUNC2(Var2+1); 
(void ) FUNC3(Var3,STRING!Var5%STRUCT2 STRING,Var4); 
free(Var4); 
char *Var4=FUNC4(Var3,Var2); 
char *Var4=FUNC2(Var2+1); 
const char *Var4=FUNC5(Var6); 
else 
char *Var4=FUNC4(Var3,Var2); 
",227,0
before_cmd.c,cmd_system,False,False,132,CWE-,CallExpression,free,2048,-3,"['\tswitch (*input) {\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', 'else\n', '\t\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tif (input[1]) {\n', '\t\t\t\tint olen;\n', '\t\t\t\tchar *out = NULL;\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\t\tif (cmd) {\n', '\t\t\t\t\tr_cons_memcat (out, olen);\n', '\t\t\t\t\tfree (out);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","switch (*Var1){
if (Var1[1]== !){//!!!&!!!-
else 
}else if (Var1[1]== ){
else 
}else if (Var1[1]== *){
char *Var2=FUNC1(Var1+1); 
else 
if (FUNC2(0)){
if (Var1[1]){
int  Var3; 
char *Var4=NULL ; 
char *Var2=FUNC3(Var5,Var1); 
if (Var2){
FUNC4(Var4,Var3); 
free(Var4); 
char *Var2=FUNC1(Var1+1); 
const char *Var2=FUNC5(Var6); 
else 
char *Var2=FUNC3(Var5,Var1); 
",219,0
before_cmd.c,cmd_system,False,False,133,CWE-,CallExpression,free,2049,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tint ret = 0;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', 'else\n', '\t\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tif (input[1]) {\n', '\t\t\t\tchar *out = NULL;\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\t\tif (cmd) {\n', '\t\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n', '\t\t\t\t\tfree (cmd);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=0; 
switch (*Var2){
if (Var2[1]== !){//!!!&!!!-
else 
}else if (Var2[1]== ){
else 
}else if (Var2[1]== *){
char *Var5=FUNC2(Var2+1); 
else 
if (FUNC3(0)){
if (Var2[1]){
char *Var6=NULL ; 
char *Var5=FUNC4(Var3,Var2); 
if (Var5){
Var4=FUNC5(Var5+1,NULL ,&Var6,&Var7,NULL ); 
free(Var5); 
char *Var5=FUNC2(Var2+1); 
const char *Var5=FUNC6(Var8); 
else 
char *Var5=FUNC4(Var3,Var2); 
",278,0
before_cmd.c,cmd_system,False,False,134,CWE-,CallExpression,free,2071,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tint ret = 0;\n', '\tswitch (*input) {\n', '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\tcmd = r_str_replace (cmd, "" "", ""\\\\ "", true);\n', '\t\tcmd = r_str_replace (cmd, ""\\\\ "", "" "", false);\n', '\t\tcmd = r_str_replace (cmd, ""\\"""", ""\'"", false);\n', '\t\tret = r_core_cmdf (core, ""\\""#!pipe %s\\"""", cmd);\n', '\t\tfree (cmd);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=0; 
switch (*Var2){
char *Var5=FUNC2(Var2+1); 
char *Var5=FUNC3(Var3,Var2); 
char *Var5=FUNC2(Var2+1); 
Var5=FUNC4(Var5,STRING,STRING,true ); 
Var5=FUNC4(Var5,STRING,STRING,false ); 
Var5=FUNC4(Var5,STRINGSTRING,false ); 
Var4=FUNC5(Var3,STRING!Var6%STRUCT2 STRING,Var5); 
free(Var5); 
const char *Var5=FUNC6(Var7); 
else 
char *Var5=FUNC3(Var3,Var2); 
",225,0
before_cmd.c,cmd_system,False,False,135,CWE-,CallExpression,atoi,2075,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tut64 n;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '?') {\n"", 'else\n', '\t\t\tif (!r_sandbox_enable (0)) {\n', '\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', 'else\n', '\t\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tif (input[1]) {\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\t\tif (cmd) {\n', '\t\t\t\t\tr_core_sysenv_end (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\tn = atoi (input);\n', ""\t\tif (*input == '0' || n > 0) {\n"", '\t\t\tconst char *cmd = r_line_hist_get (n);\n', '\t\t\tif (cmd) {\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\tif (cmd) {\n', '\t\t\t\tr_core_sysenv_end (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2  Var4; 
switch (*Var2){
if (Var2[1]== ){
else 
if (!FUNC2(0)){
Var3->memberVar1=Var2[1]10; 
if (Var2[1]== !){//!!!&!!!-
else 
}else if (Var2[1]== ){
else 
}else if (Var2[1]== *){
char *Var5=FUNC3(Var2+1); 
else 
if (FUNC2(0)){
if (Var2[1]){
char *Var5=FUNC4(Var3,Var2); 
if (Var5){
FUNC5(Var3,Var2); 
char *Var5=FUNC3(Var2+1); 
Var4=FUNC6(Var2); 
if (*Var2 == 0||Var4>0){
const char *Var5=FUNC7(Var4); 
if (Var5){
FUNC8(Var3,Var5); 
else 
char *Var5=FUNC4(Var3,Var2); 
if (Var5){
FUNC5(Var3,Var2); 
",352,0
before_cmd.c,cmd_system,False,False,136,CWE-,CallExpression,free,2089,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tut64 n;\n', '\tint ret = 0;\n', '\tswitch (*input) {\n', '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', ""\t\tif (*input == '0' || n > 0) {\n"", '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\tif (cmd) {\n', '\t\t\t\tret = r_sys_cmd (cmd);\n', '\t\t\t\tfree (cmd);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2  Var4; 
int  Var5=0; 
switch (*Var2){
char *Var6=FUNC2(Var2+1); 
char *Var6=FUNC3(Var3,Var2); 
char *Var6=FUNC2(Var2+1); 
if (*Var2 == 0||Var4>0){
const char *Var6=FUNC4(Var4); 
else 
char *Var6=FUNC3(Var3,Var2); 
if (Var6){
Var5=FUNC5(Var6); 
free(Var6); 
",192,0
before_cmd.c,r_w32_cmd_pipe,False,False,137,CWE-,CallExpression,free,2138,-3,"['static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n', '\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\t_shell_cmd = tmp;\n', '\tfree (tmp);\n']","static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){
STRUCT2  Var4[2]={NULL ,NULL }; 
char *Var5=NULL ; 
if (!FUNC2(&Var4[0],&Var4[1],&Var6,0)){
if (!FUNC3(Var4[1],Var7,0)){
char *Var8=FUNC4(STRING%STRUCT3 STRING,Var3); 
if (!Var8){
Var5=Var8; 
free(Var8); 
",150,1
before_cmd.c,r_w32_cmd_pipe,False,False,138,CWE-,CallExpression,calloc,2142,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\t_tcscat_s (systemdir, MAX_PATH, TEXT(""\\\\cmd.exe""));\n', '\tfree (systemdir);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
char *Var2=NULL ; 
STRUCT2  Var3=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){
if (!FUNC2(Var1[1],Var5,0)){
char *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); 
if (!Var6){
if (!Var3){
STRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); 
if (!Var8){
int  Var10=FUNC4(Var8,Var9); 
if (!Var10){
FUNC5(Var8,Var9,FUNC6(STRING)); 
free(Var8); 
",206,0
before_cmd.c,r_w32_cmd_pipe,False,False,139,CWE-,CallExpression,close,2167,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tif (fd_out == -1) {\n', '\tclose (1);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
if (Var2 == -1){
close(1); 
",257,0
before_cmd.c,r_w32_cmd_pipe,False,False,140,CWE-,CallExpression,close,2168,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n', '\tif (fd_out == -1) {\n', '\tdup2 (fd_out, 1);\n', '\tclose (fd_out);\n', '\tif (fd_out != -1) {\n', '\t\tclose (fd_out);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
Var2=FUNC6((Var16) Var1[1],Var17|Var18); 
if (Var2 == -1){
FUNC7(Var2,1); 
close(Var2); 
if (Var2 != -1){
close(Var2); 
",313,0
before_cmd.c,r_w32_cmd_pipe,False,False,141,CWE-,CallExpression,close,2185,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n', '\tif (fd_out == -1) {\n', '\tdup2 (fd_out, 1);\n', '\tclose (fd_out);\n', '\tfd_out = -1;\n', '\tif (fd_out != -1) {\n', '\t\tclose (fd_out);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
Var2=FUNC6((Var16) Var1[1],Var17|Var18); 
if (Var2 == -1){
FUNC7(Var2,1); 
close(Var2); 
Var2=-1; 
if (Var2 != -1){
close(Var2); 
",320,0
before_cmd.c,r_w32_cmd_pipe,False,False,142,CWE-,CallExpression,close,2189,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tif (fd_out == -1) {\n', '\tcons_out = dup (1);\n', '\tif (cons_out != -1) {\n', '\t\tdup2 (cons_out, 1);\n', '\t\tclose (cons_out);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
if (Var2 == -1){
Var3=FUNC6(1); 
if (Var3 != -1){
FUNC7(Var3,1); 
close(Var3); 
",291,0
before_cmd.c,r_w32_cmd_pipe,False,False,143,CWE-,CallExpression,free,2191,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\t_tcscat_s (systemdir, MAX_PATH, TEXT(""\\\\cmd.exe""));\n', '\tfree (systemdir);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
char *Var2=NULL ; 
STRUCT2  Var3=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){
if (!FUNC2(Var1[1],Var5,0)){
char *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); 
if (!Var6){
if (!Var3){
STRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); 
if (!Var8){
int  Var10=FUNC4(Var8,Var9); 
if (!Var10){
FUNC5(Var8,Var9,FUNC6(STRING)); 
free(Var8); 
",206,0
before_cmd.c,r_w32_cmd_pipe,False,False,144,CWE-,CallExpression,free,2192,-3,"['static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n', '\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\t_shell_cmd = tmp;\n', '\t_shell_cmd_ = r_sys_conv_utf8_to_win (_shell_cmd);\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tfree (_shell_cmd_);\n']","static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){
STRUCT2  Var4[2]={NULL ,NULL }; 
char *Var5=NULL ; 
STRUCT3  Var6=NULL ; 
if (!FUNC2(&Var4[0],&Var4[1],&Var7,0)){
if (!FUNC3(Var4[1],Var8,0)){
char *Var9=FUNC4(STRING%STRUCT4 STRING,Var3); 
if (!Var9){
Var5=Var9; 
Var6=FUNC5(Var5); 
if (!Var6){
STRUCT5 *Var10=calloc(Var11,sizeof (STRUCT5)); 
if (!Var10){
int  Var12=FUNC6(Var10,Var11); 
if (!Var12){
free(Var6); 
",235,1
before_cmd.c,r_core_cmd_pipe,False,False,145,CWE-,CallExpression,free,2222,-3,"['R_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n', '\tchar *str, *out = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', ""\tif (*shell_cmd=='!') {\n"", '\t\tstr = r_core_cmd_str (core, radare_cmd);\n', '\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n', '\t\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
if (FUNC2(0)){
if (*Var4 == !){
Var5=FUNC3(Var2,Var3); 
FUNC4(Var4+1,Var5,&Var6,&Var7,NULL ); 
free(Var5); 
",111,0
before_cmd.c,r_core_cmd_pipe,False,False,146,CWE-,CallExpression,free,2224,-3,"['\tint si, olen, ret = -1, pipecolor = -1;\n', '\tchar *str, *out = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', ""\tif (*shell_cmd=='!') {\n"", '\t\tout = NULL;\n', '\t\tr_cons_memcat (out, olen);\n', '\t\tfree (out);\n']","int  Var1,Var2,Var3=-1,Var4=-1; 
char *Var5,*Var6=NULL ; 
if (FUNC1(0)){
if (*STRUCT1 == !){
Var6=NULL ; 
FUNC2(Var6,Var2); 
free(Var6); 
",83,0
before_cmd.c,r_core_cmd_pipe,False,False,147,CWE-,CallExpression,signal,2231,-3,"['\tif (r_sandbox_enable (0)) {\n', '\tsignal (SIGPIPE, SIG_IGN);\n']","if (FUNC1(0)){
signal(Var1,Var2); 
",20,0
before_cmd.c,r_core_cmd_pipe,False,False,148,CWE-,CallExpression,close,2238,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tstdout_fd = dup (1);\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (stdout_fd, 1);\n', '\t\t\t\tclose (stdout_fd);\n', '\t\t\t\tclose (stdout_fd);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
Var1=FUNC2(1); 
if (Var1 != -1){
if (FUNC3(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC4(Var1,1); 
close(Var1); 
close(Var1); 
",116,0
before_cmd.c,r_core_cmd_pipe,False,False,149,CWE-,CallExpression,close,2241,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (fds[1], 1);\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tclose (fds[0]);\n', 'else\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tdup2 (fds[0], 0);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC3(Var2[1],1); 
close(Var2[1]); 
close(Var2[0]); 
else 
close(Var2[1]); 
FUNC3(Var2[0],0); 
",140,0
before_cmd.c,r_core_cmd_pipe,False,False,150,CWE-,CallExpression,close,2242,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (fds[1], 1);\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tclose (fds[0]);\n', 'else\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tdup2 (fds[0], 0);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC3(Var2[1],1); 
close(Var2[1]); 
close(Var2[0]); 
else 
close(Var2[1]); 
FUNC3(Var2[0],0); 
",140,0
before_cmd.c,r_core_cmd_pipe,False,False,151,CWE-,CallExpression,close,2245,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tclose (1);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
close(1); 
",88,0
before_cmd.c,r_core_cmd_pipe,False,False,152,CWE-,CallExpression,close,2248,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tstdout_fd = dup (1);\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (stdout_fd, 1);\n', '\t\t\t\tclose (stdout_fd);\n', '\t\t\t\tclose (stdout_fd);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
Var1=FUNC2(1); 
if (Var1 != -1){
if (FUNC3(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC4(Var1,1); 
close(Var1); 
close(Var1); 
",116,0
before_cmd.c,r_core_cmd_pipe,False,False,153,CWE-,CallExpression,close,2250,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (fds[1], 1);\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tclose (fds[0]);\n', 'else\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tdup2 (fds[0], 0);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC3(Var2[1],1); 
close(Var2[1]); 
close(Var2[0]); 
else 
close(Var2[1]); 
FUNC3(Var2[0],0); 
",140,0
before_cmd.c,r_core_cmd_pipe,False,False,154,CWE-,CallExpression,close,2254,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tstdout_fd = dup (1);\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (stdout_fd, 1);\n', '\t\t\t\tclose (stdout_fd);\n', '\t\t\t\tclose (stdout_fd);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
Var1=FUNC2(1); 
if (Var1 != -1){
if (FUNC3(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC4(Var1,1); 
close(Var1); 
close(Var1); 
",116,0
before_cmd.c,parse_tmp_evals,False,False,155,CWE-,CallExpression,strdup,2278,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', ""\t\teq = strchr (kv, '=');\n"", '\t\tif (eq) {\n', '\t\t\t*eq = 0;\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tr_config_set (core->config, kv, eq + 1);\n', ""\t\t\t*eq = '=';\n"", 'else\n', '\t\t\teprintf (""Missing \'=\' in e: expression (%s)\\n"", kv);\n', '\tfree (s);\n', '\treturn res;\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
Var8=strchr(Var9,=); 
if (Var8){
*Var8=0; 
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var6); 
Var6=FUNC6(Var6,Var11); 
free(Var11); 
FUNC7(Var1->memberVar1,Var9,Var8+1); 
*Var8==; 
else 
FUNC8(STRING,Var9); 
free(Var3); 
return  Var6; 
",319,0
before_cmd.c,parse_tmp_evals,False,False,156,CWE-,CallExpression,strdup,2280,-3,"['\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (res);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\treturn res;\n']","char *Var1=strdup(Var2); 
int  Var3,Var4=FUNC1(Var1,,); 
char *Var5=strdup(STRING); 
if (!Var1||!Var5){
free(Var5); 
for (Var3=0; Var3<Var4; Var3  Var6){
char *Var7,*Var8=(char *) FUNC2(Var1,Var3); 
if (!Var8){
if (Var7){
const char *Var9=FUNC3(Var10->memberVar1,Var8); 
if (!Var9){
char *Var11=FUNC4(STRING,Var8,Var9); 
if (!Var11){
free(Var5); 
Var5=FUNC5(Var5,Var11); 
return  Var5; 
",217,0
before_cmd.c,parse_tmp_evals,False,False,157,CWE-,CallExpression,free,2282,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\tfree (s);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var3); 
",229,0
before_cmd.c,parse_tmp_evals,False,False,158,CWE-,CallExpression,free,2283,-3,"['\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (res);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\treturn res;\n']","char *Var1=strdup(Var2); 
int  Var3,Var4=FUNC1(Var1,,); 
char *Var5=strdup(STRING); 
if (!Var1||!Var5){
free(Var5); 
for (Var3=0; Var3<Var4; Var3  Var6){
char *Var7,*Var8=(char *) FUNC2(Var1,Var3); 
if (!Var8){
if (Var7){
const char *Var9=FUNC3(Var10->memberVar1,Var8); 
if (!Var9){
char *Var11=FUNC4(STRING,Var8,Var9); 
if (!Var11){
free(Var5); 
Var5=FUNC5(Var5,Var11); 
return  Var5; 
",217,0
before_cmd.c,parse_tmp_evals,False,False,159,CWE-,CallExpression,strchr,2291,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', ""\t\teq = strchr (kv, '=');\n"", '\t\tif (eq) {\n', '\t\t\t*eq = 0;\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\tr_config_set (core->config, kv, eq + 1);\n', ""\t\t\t*eq = '=';\n"", 'else\n', '\t\t\teprintf (""Missing \'=\' in e: expression (%s)\\n"", kv);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
Var8=strchr(Var9,=); 
if (Var8){
*Var8=0; 
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
FUNC6(Var1->memberVar1,Var9,Var8+1); 
*Var8==; 
else 
FUNC7(STRING,Var9); 
",264,0
before_cmd.c,parse_tmp_evals,False,False,160,CWE-,CallExpression,free,2300,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\tfree (s);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var3); 
",229,0
before_cmd.c,parse_tmp_evals,False,False,161,CWE-,CallExpression,free,2301,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (res);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\treturn res;\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var6); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var6); 
Var6=FUNC6(Var6,Var11); 
return  Var6; 
",242,0
before_cmd.c,parse_tmp_evals,False,False,162,CWE-,CallExpression,free,2305,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\t\t\tfree (cmd);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
Var6=FUNC6(Var6,Var11); 
free(Var11); 
",229,0
before_cmd.c,parse_tmp_evals,False,False,163,CWE-,CallExpression,free,2312,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\tfree (s);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var3); 
",229,0
before_cmd.c,r_core_cmd_subst,False,False,164,CWE-,CallExpression,memmove,2324,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\t\tchar *cr = strdup (cmdrep);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
char *Var4,*Var5=NULL ,*Var6=NULL ; 
bool  Var7=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var8=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var9=Var1->memberVar2; 
Var6=strdup(Var2); 
const char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
char *Var12=strdup(Var10); 
",218,0
before_cmd.c,r_core_cmd_subst,False,False,165,CWE-,CallExpression,strlen,2324,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\t\tchar *cr = strdup (cmdrep);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
char *Var4,*Var5=NULL ,*Var6=NULL ; 
bool  Var7=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var8=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var9=Var1->memberVar2; 
Var6=strdup(Var2); 
const char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
char *Var12=strdup(Var10); 
",218,0
before_cmd.c,r_core_cmd_subst,False,False,166,CWE-,CallExpression,strstr,2325,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\tif (http) {\n', '\t\t\t*http = 0;\n', '\t\t\thttp--;\n', ""\t\t\tif (*http == ' ') {\n"", '\t\t\t\t*http = 0;\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\t\tchar *cr = strdup (cmdrep);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
char *Var4,*Var5=NULL ,*Var6=NULL ; 
bool  Var7=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var8=strstr(Var2,STRING); 
if (Var8){
*Var8=0; 
Var8  Var9; 
if (*Var8 == ){
*Var8=0; 
return FUNC4(Var1,Var2); 
STRUCT2  Var10=Var1->memberVar2; 
Var6=strdup(Var2); 
const char *Var11=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var12=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
char *Var13=strdup(Var11); 
",259,0
before_cmd.c,r_core_cmd_subst,False,False,167,CWE-,CallExpression,strdup,2342,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tcmt = *icmd ? (char *)r_str_firstbut (icmd, \'#\', ""\\""""): NULL;\n', ""\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n"", '\t\t*cmt = 0;\n', '\tif (*cmd != \'""\') {\n', ""\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n"", ""\t\t\tif ((colon = strchr (cmd, ';'))) {\n"", '\t\t\t\t*colon = 0;\n', '\tif (rep > 0) {\n', '\t\twhile (IS_DIGIT (*cmd)) {\n', '\t\t\tcmd++;\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', '\t\teprintf (""Command repeat sugar disabled in sandbox mode (%s)\\n"", cmd);\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', '\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n', '\tif (colon && colon[1]) {\n', ""\t\tfor (++colon; *colon == ';'; colon++) {\n"", '\t\tr_core_cmd_subst (core, colon);\n', '\tfree (icmd);\n', '\treturn ret;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var10=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC5(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
Var6=*Var8(char *) FUNC6(Var8,,STRING) NULL ; 
if (Var6&&(Var6[1]== ||Var6[1]==  Var12)){
*Var6=0; 
if (*Var2 != ){
if (!strchr(Var2,)){//Var13|Var14{Var15; Var16}//Var17; if  Var18  Var19  Var20  STRUCT3  Var21
if ((Var7=strchr(Var2,; ))){
*Var7=0; 
if (Var3>0){
while (FUNC7(*Var2)){
Var2  Var22; 
if (!*Var2){
if (Var3>1&&FUNC8(0)){
FUNC9(STRING,Var2); 
else 
if (Var3>Var23){
if (FUNC10()){
const char *Var24=Var1->STRUCT4  Var1->STRUCT4 STRING; 
int  Var25=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var26&&*Var2){
if (FUNC11()){
char *Var27=strdup(Var24); 
Var4=FUNC12(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); 
if (Var4&&*Var2 ==  Var28){
if (Var1->memberVar4){
if (Var7&&Var7[1]){
for (Var22  Var7; *Var7 == ; ; Var7  Var22){
FUNC1(Var1,Var7); 
free(Var8); 
return  Var4; 
",687,0
before_cmd.c,r_core_cmd_subst,False,False,168,CWE-,CallExpression,strchr,2364,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (*cmd != \'""\') {\n', ""\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n"", '\tif (rep > 0) {\n', '\t\twhile (IS_DIGIT (*cmd)) {\n', '\t\t\tcmd++;\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', '\t\teprintf (""Command repeat sugar disabled in sandbox mode (%s)\\n"", cmd);\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', '\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var10=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC5(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (*Var2 != ){
if (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20
if (Var3>0){
while (FUNC6(*Var2)){
Var2  Var21; 
if (!*Var2){
if (Var3>1&&FUNC7(0)){
FUNC8(STRING,Var2); 
else 
if (Var3>Var22){
if (FUNC9()){
const char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; 
int  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var25&&*Var2){
if (FUNC10()){
char *Var26=strdup(Var23); 
Var4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); 
if (Var4&&*Var2 ==  Var27){
if (Var1->memberVar4){
",531,0
before_cmd.c,r_core_cmd_subst,False,False,169,CWE-,CallExpression,strchr,2365,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (*cmd != \'""\') {\n', ""\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n"", ""\t\t\tif ((colon = strchr (cmd, ';'))) {\n"", '\t\t\t\t*colon = 0;\n', '\tif (rep > 0) {\n', '\t\twhile (IS_DIGIT (*cmd)) {\n', '\t\t\tcmd++;\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', '\t\teprintf (""Command repeat sugar disabled in sandbox mode (%s)\\n"", cmd);\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', '\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n', '\tif (colon && colon[1]) {\n', ""\t\tfor (++colon; *colon == ';'; colon++) {\n"", '\t\tr_core_cmd_subst (core, colon);\n', '\treturn ret;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var10=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC5(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (*Var2 != ){
if (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20
if ((Var7=strchr(Var2,; ))){
*Var7=0; 
if (Var3>0){
while (FUNC6(*Var2)){
Var2  Var21; 
if (!*Var2){
if (Var3>1&&FUNC7(0)){
FUNC8(STRING,Var2); 
else 
if (Var3>Var22){
if (FUNC9()){
const char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; 
int  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var25&&*Var2){
if (FUNC10()){
char *Var26=strdup(Var23); 
Var4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); 
if (Var4&&*Var2 ==  Var27){
if (Var1->memberVar4){
if (Var7&&Var7[1]){
for (Var21  Var7; *Var7 == ; ; Var7  Var21){
FUNC1(Var1,Var7); 
return  Var4; 
",617,0
before_cmd.c,r_core_cmd_subst,False,False,170,CWE-,CallExpression,strdup,2416,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
before_cmd.c,r_core_cmd_subst,False,False,171,CWE-,CallExpression,free,2420,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
before_cmd.c,r_core_cmd_subst,False,False,172,CWE-,CallExpression,free,2424,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
before_cmd.c,r_core_cmd_subst,False,False,173,CWE-,CallExpression,free,2434,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
before_cmd.c,r_core_cmd_subst,False,False,174,CWE-,CallExpression,free,2457,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tcmt = *icmd ? (char *)r_str_firstbut (icmd, \'#\', ""\\""""): NULL;\n', '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n', '\tif (colon && colon[1]) {\n', '\tfree (icmd);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC4(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
Var6=*Var8(char *) FUNC5(Var8,,STRING) NULL ; 
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC6(0)){
else 
if (Var3>Var12){
if (FUNC7()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC8()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
if (Var1->memberVar4){
if (Var7&&Var7[1]){
free(Var8); 
",417,0
before_cmd.c,findSeparator,False,False,175,CWE-,CallExpression,strchr,2474,-3,"['static char* findSeparator(char *p) {\n', ""\tchar *q = strchr (p, '+');\n"", '\tif (q) {\n', '\t\treturn q;\n', ""\treturn strchr (p, '-');\n""]","static char *FUNC1(char *Var1){
char *Var2=strchr(Var1,+); 
if (Var2){
return  Var2; 
return strchr(Var1,-); 
",55,0
before_cmd.c,findSeparator,False,False,176,CWE-,CallExpression,strchr,2478,-3,"['static char* findSeparator(char *p) {\n', ""\tchar *q = strchr (p, '+');\n"", '\tif (q) {\n', ""\treturn strchr (p, '-');\n""]","static char *FUNC1(char *Var1){
char *Var2=strchr(Var1,+); 
if (Var2){
return strchr(Var1,-); 
",49,0
before_cmd.c,tmpenvs_free,False,False,177,CWE-,CallExpression,free,2483,-3,"['static void tmpenvs_free(void *item) {\n', '\tr_sys_setenv (item, NULL);\n', '\tfree (item);\n']","static void FUNC1(void *Var1){
FUNC2(Var1,NULL ); 
free(Var1); 
",32,1
before_cmd.c,set_tmp_arch,False,False,178,CWE-,CallExpression,strdup,2490,-3,"['static bool set_tmp_arch(RCore *core, char *arch, char **tmparch) {\n', '\t*tmparch = strdup (r_config_get (core->config, ""asm.arch""));\n', '\tr_config_set (core->config, ""asm.arch"", arch);\n', '\tcore->fixedarch = true;\n']","static bool FUNC1(STRUCT1 *Var1,char *Var2,char **Var3){
*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); 
FUNC3(Var1->memberVar1,STRING,Var2); 
Var1->memberVar2=true ; 
",74,1
before_cmd.c,set_tmp_bits,False,False,179,CWE-,CallExpression,strdup,2500,-3,"['static bool set_tmp_bits(RCore *core, int bits, char **tmpbits) {\n', '\t*tmpbits = strdup (r_config_get (core->config, ""asm.bits""));\n', '\tr_config_set_i (core->config, ""asm.bits"", bits);\n', '\tcore->fixedbits = true;\n']","static bool FUNC1(STRUCT1 *Var1,int  Var2,char **Var3){
*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); 
FUNC3(Var1->memberVar1,STRING,Var2); 
Var1->memberVar2=true ; 
",73,1
before_cmd.c,r_core_cmd_subst_i,False,False,180,CWE-,CallExpression,strstr,2533,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3074,0
before_cmd.c,r_core_cmd_subst_i,False,False,181,CWE-,CallExpression,strchr,2535,-3,"['\tif (!cmd) {\n', '\tif ($0) {\n', ""\t\tchar *$1 = strchr ($0 + 2, ')');\n"", 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", ""\t\t\t\tchar *p = strchr (range, ' ');\n""]","if (!Var1){
if (0){
char *1=strchr(0+2,)); 
else 
char *Var2=strchr(Var1,; ); 
char *Var3=strchr(Var4+1,); 
char *Var5=strchr(Var1,); 
char *Var6=FUNC1(Var7,Var1); 
const char *Var8=strstr(Var1,STRING); 
char *Var9,*Var5=strchr(Var10+1,!); 
char *Var11=strchr(Var12,=); 
char *Var1=FUNC2(Var7,Var10+2); 
char *Var3=strchr(Var10+2,); 
char *Var4=strchr(Var13,); 
",197,0
before_cmd.c,r_core_cmd_subst_i,False,False,182,CWE-,CallExpression,memmove,2539,-3,"['\tif (!cmd) {\n', '\tif ($0) {\n', '\t\tif ($1) {\n', '\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n']","if (!Var1){
if (0){
if (1){
memmove(0+1,0+2,strlen(0+2)+1); 
else 
char *Var2=strchr(Var1,; ); 
char *Var3=strchr(Var1,); 
char *Var4=FUNC1(Var5,Var1); 
const char *Var6=strstr(Var1,STRING); 
char *Var1=FUNC2(Var5,Var7+2); 
",128,0
before_cmd.c,r_core_cmd_subst_i,False,False,183,CWE-,CallExpression,strlen,2539,-3,"['\tif (!cmd) {\n', '\tif ($0) {\n', '\t\tif ($1) {\n', '\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n']","if (!Var1){
if (0){
if (1){
memmove(0+1,0+2,strlen(0+2)+1); 
else 
char *Var2=strchr(Var1,; ); 
char *Var3=strchr(Var1,); 
char *Var4=FUNC1(Var5,Var1); 
const char *Var6=strstr(Var1,STRING); 
char *Var1=FUNC2(Var5,Var7+2); 
",128,0
before_cmd.c,r_core_cmd_subst_i,False,False,184,CWE-,CallExpression,strchr,2572,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (sc) {\n', '\t\t\t\t\t*sc = 0;\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q = 0;\n', '\t\t\t\t\thaveQuote = q != NULL;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\tif (p && *p && p[1] == '>') {\n"", '\t\t\t\t\tstr = p + 2;\n', ""\t\t\t\t\twhile (*str == '>') {\n"", '\t\t\t\t\t\tstr++;\n', '\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n', '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tstr = p + 2;\n', '\t\t\t\twhile (IS_WHITESPACE (*str)) {\n', '\t\t\t\t\tstr++;\n', '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
*Var25  Var26=0; 
else 
char *Var28=strchr(Var2,; ); 
if (Var28){
*Var28=0; 
FUNC7(Var1,Var2); 
if (!Var28){
Var2=Var28+1; 
if (*Var25){
if (Var25[0]== ){
Var25  Var29; 
while (Var25[1]== ; ||FUNC8(Var25[1])){
Var25  Var26; 
if (Var25[1]== ||(Var25[1]&&Var25[2]== )){
char *Var30=strchr(Var25+1,); 
if (Var30){
*Var30=0; 
Var19=Var30 != NULL ; 
FUNC9(Var1,FUNC10(Var1->memberVar6,Var25+2),1); 
if (Var30){
*Var25=; 
Var25=Var30; 
else 
Var25=strchr(Var25+1,; ); 
if (Var25&&*Var25&&Var25[1]== >){
Var9=Var25+2; 
while (*Var9 == >){
Var9  Var26; 
Var9=(char *) FUNC11(Var9); 
const bool  Var31=Var25[2]== >; 
Var16=FUNC12(Var9,1,Var31); 
Var24=strdup(Var2); 
Var24=FUNC13(Var24,STRINGSTRINGSTRING,true ); 
if (Var25&&*Var25&&Var25[1]== |){
Var9=Var25+2; 
while (FUNC8(*Var9)){
Var9  Var26; 
FUNC14(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var24); 
free(Var24); 
if (Var16 != -1){
FUNC15(Var16); 
if (!Var25){
if (Var18){
if (Var19){
if (*Var25 == ; ){
Var2=Var25+1; 
else 
if (*Var25 == ){
Var2=Var25+1; 
else 
*Var25=; 
Var2=Var25; 
else 
Var2=Var25+1; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC16(Var2,,STRING); //Var32  Var33  Var5  Var34
if (*Var2 != ){
Var7=(char *) FUNC17(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC17(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC18(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC19(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC20(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC14(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC21(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC17(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC22(Var1,Var38,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC23()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC16(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
int  Var39=1; 
int  Var40=FUNC24(Var1->memberVar8,STRING); 
int  Var41=false ; 
int  Var42=FUNC24(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC25(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
if (*Var9 == ){
char *Var45=FUNC26(Var1,Var2); 
char *Var46=FUNC27(Var1->memberVar5,Var9,1); 
char *Var47=FUNC28(STRING,Var46,Var45); 
else 
char *Var48=FUNC28(STRING,Var45); 
else 
char *Var48=FUNC28(STRING,Var45); 
else 
}else if (Var39>0){
if (Var16 != -1){
Var15=FUNC29(Var1,Var2); 
const char *Var49=FUNC30(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var42=FUNC24(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC31(strdup(Var2),Var9); 
Var15=FUNC29(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC32(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var63=strdup(Var7+2); 
char *Var64=strchr(Var63,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC33(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var65=(int ) FUNC10(Var1->memberVar6,Var7+2); 
STRUCT5 *Var66=FUNC34(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var67=FUNC35(Var1->memberVar1,Var68,Var69,0); 
char *Var70=strdup(Var7+2); 
char  Var35=*Var71; 
STRUCT3  Var54=FUNC10(Var1->memberVar6,Var7+2); 
char *Var2=FUNC36(Var1,Var7+2); 
STRUCT2 *Var67=FUNC35(Var1->memberVar1,Var68,Var69,0); 
char *Var72=FUNC37(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var30=strchr(Var7+2,); 
int  Var73=FUNC10(Var1->memberVar6,Var30); 
const STRUCT6 *Var74=(const STRUCT6 *) FUNC11(Var7+2); 
STRUCT2 *Var67=FUNC35(Var1->memberVar1,Var68,Var69,0); 
char *Var75=Var7-2; 
while (Var75>Var2){
if (!FUNC8(*Var75)){
Var2=FUNC18(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC38((STRUCT6) Var7[1])&&!Var54){
if (!FUNC39(Var1->memberVar12,Var7+1)){
else 
char  Var35=*Var57; 
STRUCT2 *Var67=Var12; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
Var15=FUNC40(Var1,Var2,Var76); 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC10(Var1->memberVar6,Var79); 
STRUCT3  Var81=FUNC10(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC42(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC42(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC42(Var2)) false ; 
",3558,0
before_cmd.c,r_core_cmd_subst_i,False,False,185,CWE-,CallExpression,strchr,2592,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (sc) {\n', '\t\t\t\t\t*sc = 0;\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q = 0;\n', '\t\t\t\t\thaveQuote = q != NULL;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\tif (p && *p && p[1] == '>') {\n"", '\t\t\t\t\tstr = p + 2;\n', ""\t\t\t\t\twhile (*str == '>') {\n"", '\t\t\t\t\t\tstr++;\n', '\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n', '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tstr = p + 2;\n', '\t\t\t\twhile (IS_WHITESPACE (*str)) {\n', '\t\t\t\t\tstr++;\n', '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
bool  Var17=false ; 
bool  Var18=Var1->memberVar2; 
bool  Var19=Var1->memberVar3; 
STRUCT3  Var20=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
for (; *Var2; ){
int  Var15=-1; 
char *Var21,*Var22; 
Var17=*Var2 == ; 
if (Var17){
Var2  Var23; 
Var22=*Var2 FUNC3(Var2) NULL ; 
if (!Var22||!*Var22){
FUNC4(STRINGFUNC5(%Var24).,Var2); 
*Var22  Var23=0; 
else 
char *Var25=strchr(Var2,; ); 
if (Var25){
*Var25=0; 
FUNC6(Var1,Var2); 
if (!Var25){
Var2=Var25+1; 
if (*Var22){
if (Var22[0]== ){
Var22  Var26; 
while (Var22[1]== ; ||FUNC7(Var22[1])){
Var22  Var23; 
if (Var22[1]== ||(Var22[1]&&Var22[2]== )){
char *Var27=strchr(Var22+1,); 
if (Var27){
*Var27=0; 
Var17=Var27 != NULL ; 
FUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); 
if (Var27){
*Var22=; 
Var22=Var27; 
else 
Var22=strchr(Var22+1,; ); 
if (Var22&&*Var22&&Var22[1]== >){
Var8=Var22+2; 
while (*Var8 == >){
Var8  Var23; 
Var8=(char *) FUNC10(Var8); 
const bool  Var28=Var22[2]== >; 
Var15=FUNC11(Var8,1,Var28); 
Var21=strdup(Var2); 
Var21=FUNC12(Var21,STRINGSTRINGSTRING,true ); 
if (Var22&&*Var22&&Var22[1]== |){
Var8=Var22+2; 
while (FUNC7(*Var8)){
Var8  Var23; 
FUNC13(Var1,Var2,Var8); 
else 
FUNC14(Var1->memberVar6,Var21); 
free(Var21); 
if (Var15 != -1){
FUNC15(Var15); 
if (!Var22){
if (Var16){
if (Var17){
if (*Var22 == ; ){
Var2=Var22+1; 
else 
if (*Var22 == ){
Var2=Var22+1; 
else 
*Var22=; 
Var2=Var22; 
else 
Var2=Var22+1; 
char *Var7=strchr(Var2,); 
int  Var29=Var1->memberVar5->memberVar1; 
else 
char *Var30=FUNC16(Var1->memberVar1,Var6+1); 
int  Var31=FUNC17(Var1->memberVar7,STRING); 
int  Var32=FUNC17(Var1->memberVar7,STRING); 
char *Var33=FUNC18(Var1,Var2); 
char *Var34=FUNC19(Var1->memberVar6,Var8,1); 
const char *Var35=FUNC20(Var1->memberVar7,STRING); 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var32=FUNC17(Var1->memberVar7,STRING); 
const char *Var24=strstr(Var2,STRING); 
char *Var36,*Var7=strchr(Var6+1,!); 
STRUCT3  Var37=Var1->memberVar8; 
char *Var38=NULL ; 
const char *Var39=NULL ; 
char *Var40=NULL ; 
char *Var41=NULL ; 
char *Var42=strdup(Var6+2); 
char *Var43=strchr(Var42,=); 
STRUCT3  Var37=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); 
int  Var44=(int ) FUNC9(Var1->memberVar5,Var6+2); 
STRUCT4 *Var45=FUNC22(Var1->memberVar9,Var1->memberVar8); 
STRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); 
char *Var49=strdup(Var6+2); 
STRUCT3  Var37=FUNC9(Var1->memberVar5,Var6+2); 
char *Var2=FUNC24(Var1,Var6+2); 
STRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); 
char *Var50=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); 
char *Var27=strchr(Var6+2,); 
int  Var51=FUNC9(Var1->memberVar5,Var27); 
const STRUCT5 *Var52=(const STRUCT5 *) FUNC10(Var6+2); 
STRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); 
STRUCT2 *Var46=Var11; 
const char *Var53[]={STRING,STRING,STRING,
const char *Var54[]={STRING,STRING,STRING,
char *Var22=strchr(Var55,); 
STRUCT3  Var56=FUNC9(Var1->memberVar5,Var55); 
STRUCT3  Var57=FUNC9(Var1->memberVar5,Var22+1); 
",1646,0
before_cmd.c,r_core_cmd_subst_i,False,False,186,CWE-,CallExpression,strchr,2603,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (sc) {\n', '\t\t\t\t\t*sc = 0;\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q = 0;\n', '\t\t\t\t\thaveQuote = q != NULL;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\tif (p && *p && p[1] == '>') {\n"", '\t\t\t\t\tstr = p + 2;\n', ""\t\t\t\t\twhile (*str == '>') {\n"", '\t\t\t\t\t\tstr++;\n', '\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n', '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tstr = p + 2;\n', '\t\t\t\twhile (IS_WHITESPACE (*str)) {\n', '\t\t\t\t\tstr++;\n', '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
bool  Var17=false ; 
bool  Var18=Var1->memberVar2; 
bool  Var19=Var1->memberVar3; 
STRUCT3  Var20=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
for (; *Var2; ){
int  Var15=-1; 
char *Var21,*Var22; 
Var17=*Var2 == ; 
if (Var17){
Var2  Var23; 
Var22=*Var2 FUNC3(Var2) NULL ; 
if (!Var22||!*Var22){
FUNC4(STRINGFUNC5(%Var24).,Var2); 
*Var22  Var23=0; 
else 
char *Var25=strchr(Var2,; ); 
if (Var25){
*Var25=0; 
FUNC6(Var1,Var2); 
if (!Var25){
Var2=Var25+1; 
if (*Var22){
if (Var22[0]== ){
Var22  Var26; 
while (Var22[1]== ; ||FUNC7(Var22[1])){
Var22  Var23; 
if (Var22[1]== ||(Var22[1]&&Var22[2]== )){
char *Var27=strchr(Var22+1,); 
if (Var27){
*Var27=0; 
Var17=Var27 != NULL ; 
FUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); 
if (Var27){
*Var22=; 
Var22=Var27; 
else 
Var22=strchr(Var22+1,; ); 
if (Var22&&*Var22&&Var22[1]== >){
Var8=Var22+2; 
while (*Var8 == >){
Var8  Var23; 
Var8=(char *) FUNC10(Var8); 
const bool  Var28=Var22[2]== >; 
Var15=FUNC11(Var8,1,Var28); 
Var21=strdup(Var2); 
Var21=FUNC12(Var21,STRINGSTRINGSTRING,true ); 
if (Var22&&*Var22&&Var22[1]== |){
Var8=Var22+2; 
while (FUNC7(*Var8)){
Var8  Var23; 
FUNC13(Var1,Var2,Var8); 
else 
FUNC14(Var1->memberVar6,Var21); 
free(Var21); 
if (Var15 != -1){
FUNC15(Var15); 
if (!Var22){
if (Var16){
if (Var17){
if (*Var22 == ; ){
Var2=Var22+1; 
else 
if (*Var22 == ){
Var2=Var22+1; 
else 
*Var22=; 
Var2=Var22; 
else 
Var2=Var22+1; 
char *Var7=strchr(Var2,); 
int  Var29=Var1->memberVar5->memberVar1; 
else 
char *Var30=FUNC16(Var1->memberVar1,Var6+1); 
int  Var31=FUNC17(Var1->memberVar7,STRING); 
int  Var32=FUNC17(Var1->memberVar7,STRING); 
char *Var33=FUNC18(Var1,Var2); 
char *Var34=FUNC19(Var1->memberVar6,Var8,1); 
const char *Var35=FUNC20(Var1->memberVar7,STRING); 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var32=FUNC17(Var1->memberVar7,STRING); 
const char *Var24=strstr(Var2,STRING); 
char *Var36,*Var7=strchr(Var6+1,!); 
STRUCT3  Var37=Var1->memberVar8; 
char *Var38=NULL ; 
const char *Var39=NULL ; 
char *Var40=NULL ; 
char *Var41=NULL ; 
char *Var42=strdup(Var6+2); 
char *Var43=strchr(Var42,=); 
STRUCT3  Var37=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); 
int  Var44=(int ) FUNC9(Var1->memberVar5,Var6+2); 
STRUCT4 *Var45=FUNC22(Var1->memberVar9,Var1->memberVar8); 
STRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); 
char *Var49=strdup(Var6+2); 
STRUCT3  Var37=FUNC9(Var1->memberVar5,Var6+2); 
char *Var2=FUNC24(Var1,Var6+2); 
STRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); 
char *Var50=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); 
char *Var27=strchr(Var6+2,); 
int  Var51=FUNC9(Var1->memberVar5,Var27); 
const STRUCT5 *Var52=(const STRUCT5 *) FUNC10(Var6+2); 
STRUCT2 *Var46=FUNC23(Var1->memberVar1,Var47,Var48,0); 
STRUCT2 *Var46=Var11; 
const char *Var53[]={STRING,STRING,STRING,
const char *Var54[]={STRING,STRING,STRING,
char *Var22=strchr(Var55,); 
STRUCT3  Var56=FUNC9(Var1->memberVar5,Var55); 
STRUCT3  Var57=FUNC9(Var1->memberVar5,Var22+1); 
",1646,0
before_cmd.c,r_core_cmd_subst_i,False,False,187,CWE-,CallExpression,strdup,2617,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p + 1;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
*Var25  Var26=0; 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
Var2=Var28+1; 
if (*Var25){
if (Var25[0]== ){
Var25  Var29; 
while (Var25[1]== ; ||FUNC8(Var25[1])){
Var25  Var26; 
if (Var25[1]== ||(Var25[1]&&Var25[2]== )){
char *Var30=strchr(Var25+1,); 
if (Var30){
Var25=Var30; 
else 
Var25=strchr(Var25+1,; ); 
const bool  Var31=Var25[2]== >; 
Var24=strdup(Var2); 
Var24=FUNC9(Var24,STRINGSTRINGSTRING,true ); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC10(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var24); 
free(Var24); 
if (!Var25){
if (Var18){
if (Var19){
if (*Var25 == ; ){
Var2=Var25+1; 
else 
if (*Var25 == ){
Var2=Var25+1; 
Var2=Var25; 
else 
Var2=Var25+1; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC11(Var2,,STRING); //Var32  Var33  Var5  Var34
if (*Var2 != ){
Var7=(char *) FUNC12(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC12(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC13(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC14(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC10(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC16(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC12(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC17(Var1,Var38,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC18()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC11(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
int  Var39=1; 
int  Var40=FUNC19(Var1->memberVar8,STRING); 
int  Var41=false ; 
int  Var42=FUNC19(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC20(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
if (*Var9 == ){
char *Var45=FUNC21(Var1,Var2); 
char *Var46=FUNC22(Var1->memberVar5,Var9,1); 
char *Var47=FUNC23(STRING,Var46,Var45); 
else 
char *Var48=FUNC23(STRING,Var45); 
else 
char *Var48=FUNC23(STRING,Var45); 
else 
}else if (Var39>0){
if (Var16 != -1){
Var15=FUNC24(Var1,Var2); 
const char *Var49=FUNC25(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var42=FUNC19(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC26(strdup(Var2),Var9); 
Var15=FUNC24(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC27(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var63=strdup(Var7+2); 
char *Var64=strchr(Var63,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC28(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var65=(int ) FUNC29(Var1->memberVar6,Var7+2); 
STRUCT5 *Var66=FUNC30(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); 
char *Var70=strdup(Var7+2); 
char  Var35=*Var71; 
STRUCT3  Var54=FUNC29(Var1->memberVar6,Var7+2); 
char *Var2=FUNC32(Var1,Var7+2); 
STRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); 
char *Var72=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var30=strchr(Var7+2,); 
int  Var73=FUNC29(Var1->memberVar6,Var30); 
const STRUCT6 *Var74=(const STRUCT6 *) FUNC34(Var7+2); 
STRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); 
char *Var75=Var7-2; 
while (Var75>Var2){
if (!FUNC8(*Var75)){
Var2=FUNC13(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC35((STRUCT6) Var7[1])&&!Var54){
if (!FUNC36(Var1->memberVar12,Var7+1)){
else 
char  Var35=*Var57; 
STRUCT2 *Var67=Var12; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
Var15=FUNC37(Var1,Var2,Var76); 
else 
Var15=FUNC38(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC29(Var1->memberVar6,Var79); 
STRUCT3  Var81=FUNC29(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; 
",3342,0
before_cmd.c,r_core_cmd_subst_i,False,False,188,CWE-,CallExpression,free,2628,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p + 1;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
STRUCT2 *Var8=NULL ; 
int  Var9=!Var1->memberVar1->memberVar1; 
bool  Var10=false ; 
bool  Var11=false ; 
bool  Var12=Var1->memberVar2; 
bool  Var13=Var1->memberVar3; 
STRUCT3  Var14=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
for (; *Var2; ){
char *Var15,*Var16; 
if (Var11){
Var2  Var17; 
Var16=*Var2 FUNC3(Var2) NULL ; 
if (!Var16||!*Var16){
*Var16  Var17=0; 
else 
char *Var18=strchr(Var2,; ); 
if (!Var18){
Var2=Var18+1; 
if (*Var16){
if (Var16[0]== ){
Var16  Var19; 
while (Var16[1]== ; ||FUNC4(Var16[1])){
Var16  Var17; 
if (Var16[1]== ||(Var16[1]&&Var16[2]== )){
char *Var20=strchr(Var16+1,); 
if (Var20){
Var16=Var20; 
else 
Var16=strchr(Var16+1,; ); 
const bool  Var21=Var16[2]== >; 
Var15=strdup(Var2); 
Var15=FUNC5(Var15,STRINGSTRINGSTRING,true ); 
if (Var16&&*Var16&&Var16[1]== |){
else 
FUNC6(Var1->memberVar5,Var15); 
free(Var15); 
if (!Var16){
if (Var10){
if (Var11){
if (*Var16 == ; ){
Var2=Var16+1; 
else 
if (*Var16 == ){
Var2=Var16+1; 
Var2=Var16; 
else 
Var2=Var16+1; 
char *Var22=strchr(Var2,); 
int  Var23=Var1->memberVar6->memberVar1; 
else 
char *Var24=FUNC7(Var1->memberVar1,Var25+1); 
int  Var26=FUNC8(Var1->memberVar7,STRING); 
int  Var27=FUNC8(Var1->memberVar7,STRING); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar5,Var30,1); 
const char *Var31=FUNC11(Var1->memberVar7,STRING); 
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var27=FUNC8(Var1->memberVar7,STRING); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var22=strchr(Var25+1,!); 
STRUCT3  Var34=Var1->memberVar8; 
char *Var35=NULL ; 
const char *Var36=NULL ; 
char *Var37=NULL ; 
char *Var38=NULL ; 
char *Var39=strdup(Var25+2); 
char *Var40=strchr(Var39,=); 
STRUCT3  Var34=FUNC12(Var1->memberVar6,Var1->memberVar8,Var25+4); 
int  Var41=(int ) FUNC13(Var1->memberVar6,Var25+2); 
STRUCT4 *Var42=FUNC14(Var1->memberVar9,Var1->memberVar8); 
STRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); 
char *Var46=strdup(Var25+2); 
STRUCT3  Var34=FUNC13(Var1->memberVar6,Var25+2); 
char *Var2=FUNC16(Var1,Var25+2); 
STRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); 
char *Var47=FUNC17(Var1->memberVar10,NULL ,0,Var25+((Var25[1]) 21)); 
char *Var20=strchr(Var25+2,); 
int  Var48=FUNC13(Var1->memberVar6,Var20); 
STRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); 
STRUCT2 *Var43=Var8; 
const char *Var49[]={STRING,STRING,STRING,
const char *Var50[]={STRING,STRING,STRING,
char *Var16=strchr(Var51,); 
STRUCT3  Var52=FUNC13(Var1->memberVar6,Var51); 
STRUCT3  Var53=FUNC13(Var1->memberVar6,Var16+1); 
",1310,0
before_cmd.c,r_core_cmd_subst_i,False,False,189,CWE-,CallExpression,strstr,2660,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3074,0
before_cmd.c,r_core_cmd_subst_i,False,False,190,CWE-,CallExpression,memmove,2711,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
before_cmd.c,r_core_cmd_subst_i,False,False,191,CWE-,CallExpression,strlen,2711,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
before_cmd.c,r_core_cmd_subst_i,False,False,192,CWE-,CallExpression,strchr,2715,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3074,0
before_cmd.c,r_core_cmd_subst_i,False,False,193,CWE-,CallExpression,strcmp,2720,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
before_cmd.c,r_core_cmd_subst_i,False,False,194,CWE-,CallExpression,strcmp,2727,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
before_cmd.c,r_core_cmd_subst_i,False,False,195,CWE-,CallExpression,strcmp,2731,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
before_cmd.c,r_core_cmd_subst_i,False,False,196,CWE-,CallExpression,free,2743,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\t\tif (res) {\n', '\t\t\t\t\t\t\tr_cons_printf (""%s\\n"", res);\n', '\t\t\t\t\t\t\tfree (res);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
else 
char *Var17=FUNC5(Var1->memberVar1,Var7+1); 
if (Var17){
FUNC6(STRING,Var17); 
free(Var17); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1227,0
before_cmd.c,r_core_cmd_subst_i,False,False,197,CWE-,CallExpression,strchr,2781,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\t\t\treturn ret;\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\teprintf (""==> Reading from stdin until \'%s\'\\n"", str);\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\teprintf (""Slurping file \'%s\'\\n"", str);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\t\t\t*fdnum = 0;\n', 'else\n', '\t\t\t\tif (IS_DIGIT (*fdnum)) {\n', ""\t\t\t\t\tfdn = *fdnum - '0';\n"", '\t\t\t\t*fdnum = 0;\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\tfree (n);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\t\tr_file_rm (str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tfree (str);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\t\treturn ret;\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\t*ptr2 = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (cmd == s) {\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""The current basic block has %d instructions\\n"", bb->ninstr);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tr_cons_grep_process (grep);\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\tif (tmpseek) {\n', '\t\t*tmpseek = cmd_tmpseek;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
int  Var28=-1; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var29,*Var30; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var31; 
Var30=*Var2 FUNC5(Var2) NULL ; 
if (!Var30||!*Var30){
FUNC6(STRINGFUNC7(%Var32).,Var2); 
else 
char *Var33=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var33){
char *Var34=strchr(Var30+1,); 
const bool  Var35=Var30[2]== >; 
Var29=strdup(Var2); 
if (Var30&&*Var30&&Var30[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var30){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38
if (Var9&&(Var9[1]== ||Var9[1]==  Var39)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var41=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var42=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
return  Var17; 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var43=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var43,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var31){
FUNC6(STRING,Var11); 
char  Var44[1024]; 
int  Var17; 
if (FUNC20(stdin)){
if (Var1->memberVar7){
if (!strcmp(Var44,Var11)){
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var31){
if (!*Var11){
FUNC6(STRING,Var11); 
Var1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); 
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
return FUNC22(Var1,(const char *) Var1->memberVar7); 
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var45=1; 
int  Var46=FUNC23(Var1->memberVar9,STRING); 
int  Var47=false ; 
int  Var48=FUNC23(Var1->memberVar9,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC24(Var9[-2])){
char *Var49=Var9-1; 
if (*Var49 ==  Var50){//STRING
Var20=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,true ); 
*Var49=0; 
else 
if (FUNC26(*Var49)){
Var45=*Var49-0; 
*Var49=0; 
if (!strcmp(Var11,STRING)){
FUNC25(Var1->memberVar9,STRING,Var51); 
const bool  Var52=(Var9[1]== >); 
if (*Var11 == ){
char *Var53=FUNC27(Var1,Var2); 
if (Var52){
char *Var54=FUNC28(Var1->memberVar5,Var11,1); 
if (Var54){
char *Var55=FUNC29(STRING,Var54,Var53); 
if (Var55){
FUNC30(Var1->memberVar5,Var11,Var55,1); 
free(Var55); 
else 
char *Var56=FUNC29(STRING,Var53); 
FUNC30(Var1->memberVar5,Var11,Var56,1); 
free(Var56); 
else 
char *Var56=FUNC29(STRING,Var53); 
FUNC30(Var1->memberVar5,Var11,Var56,1); 
free(Var56); 
else 
}else if (Var45>0){
Var18=FUNC31(Var11,Var45,Var52); 
if (Var18 != -1){
if (!Var46){
FUNC25(Var1->memberVar9,STRING,Var51); 
Var17=FUNC12(Var1,Var2); 
FUNC32(Var18); 
if (!Var46){
FUNC25(Var1->memberVar9,STRING,Var48); 
if (Var47){
const char *Var57=FUNC33(Var1->memberVar9,STRING); 
if (Var57&&*Var57){
FUNC34(STRING,Var57,Var11); 
FUNC35(Var11); 
FUNC25(Var1->memberVar9,STRING,Var48); 
free(Var11); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
Var1->memberVar10->memberVar1=false ; 
return  Var17; 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
bool  Var58=false ; 
int  Var59=1; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var58){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
*Var10=0; 
if (Var9[1]== !){
Var11=FUNC36(Var1,Var9+1); 
else 
int  Var48=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,0); 
Var11=FUNC27(Var1,Var9+1); 
FUNC25(Var1->memberVar9,STRING,Var48); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
free(Var11); 
if (Var59&&Var11){
for (Var16=0; Var11[Var16]; Var16  Var31){
if (Var11[Var16]==  Var56){
Var11[Var16]=; 
Var11=FUNC37(Var11,Var10+1); 
Var2=FUNC37(strdup(Var2),Var11); 
Var1->memberVar6->memberVar1=memberVar1; 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
free(Var11); 
return  Var17; 
if (*Var2 != &&*Var2){
const char *Var32=strstr(Var2,STRING); 
if (Var32){
bool  Var60=false ; 
if (Var2 ==  Var32){
if (Var60){
if (*Var2 != .){
Var13=FUNC38(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar11=Var9 true false ; 
int  Var61=0; 
if (Var9){
char *Var62,*Var10=strchr(Var9+1,!); 
STRUCT4  Var63=Var1->memberVar12; 
bool  Var64=false ; 
char *Var65=NULL ; 
const char *Var66=NULL ; 
bool  Var67=false ; 
bool  Var68=false ; 
char *Var69=NULL ; 
char *Var70=NULL ; 
bool  Var71=false ; 
int  Var72=-1; 
int  Var73,Var74; 
STRUCT6 *Var44; 
*Var9  Var31=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var31){
if (*Var9&&Var9[1]== ){
else 
Var9  Var75; 
Var9=FUNC39(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var76=strdup(Var9+2); 
char *Var77=strchr(Var76,=); 
if (Var77){
*Var77  Var31=0; 
FUNC40(Var76,Var77); 
FUNC41(Var5,Var76); 
else 
free(Var76); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+4); 
FUNC43(Var1,FUNC44((Var78) Var63-(Var78) Var1->memberVar12)); 
else 
Var63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+3); 
FUNC45(Var1,Var63,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var71=FUNC46(Var1->memberVar13,Var9+2); 
int  Var79=(int ) FUNC47(Var1->memberVar6,Var9+2); 
STRUCT7 *Var80=FUNC48(Var1->memberVar14,Var1->memberVar12); 
if (Var80){
if (Var79<0){
Var79=Var80->memberVar1+Var79; 
if (Var79 >= 0&&Var79<Var80->memberVar1){
STRUCT8  Var81=FUNC49(Var80,Var79); 
FUNC45(Var1,Var80->memberVar2+Var81,1); 
else 
FUNC6(STRING,Var80->memberVar1); 
Var62=FUNC21(Var9+2,&Var73); 
if (Var62){
STRUCT9 *Var82=FUNC50((const STRUCT6 *) Var62,Var73); 
STRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); 
if (Var83){
if (Var14){
FUNC52(Var14); 
Var14=Var83; 
if (Var15){
FUNC25(Var1->memberVar9,STRING,1); 
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); 
if (Var44){
free(Var1->memberVar15); 
memcpy(Var1->memberVar15,Var62,Var73); 
free(Var62); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var85; 
char *Var86=strdup(Var9+2); 
char *Var87=FUNC55(Var86); 
if (Var87){
char  Var40=*Var87; 
*Var87=0; 
Var85=FUNC56(Var1->memberVar16,Var86); 
*Var87=Var40; 
Var85=FUNC47(Var1->memberVar6,Var88); 
else 
Var85=FUNC56(Var1->memberVar16,Var9+2); 
FUNC45(Var1,Var85,1); 
free(Var86); 
Var67=FUNC57(Var1,FUNC47(Var1->memberVar6,Var9+2),&Var65); 
Var28=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,1); 
STRUCT4  memberVar2=FUNC47(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC58(Var1,Var9+2); 
if (!Var69){
Var69=Var2; 
else 
Var69=FUNC59(Var69,Var2); 
free(Var2); 
if (Var9[1]== ){
Var44=malloc(strlen(Var9+2)+1); 
if (Var44){
Var74=FUNC60(Var9+2,Var44); 
FUNC43(Var1,FUNC44(Var74)); 
if (Var74>0){
STRUCT9 *Var82=FUNC50(Var44,Var74); 
STRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); 
if (Var83){
if (Var14){
FUNC52(Var14); 
Var14=Var83; 
if (Var15){
FUNC25(Var1->memberVar9,STRING,1); 
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); 
FUNC43(Var1,Var74); 
free(Var44); 
char *Var89=FUNC61(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var89){
FUNC45(Var1,FUNC47(Var1->memberVar6,Var89),1); 
free(Var89); 
if (Var9[1]== ){
Var72=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC62(Var1->memberVar1,FUNC63(Var9+2)); 
if (Var9[1]== ){
char *Var34=strchr(Var9+2,); 
if (Var34){
*Var34  Var31=0; 
int  Var90=FUNC47(Var1->memberVar6,Var34); 
Var67=FUNC57(Var1,Var90,&Var65); 
Var68=FUNC64(Var1,Var9+2,&Var70); 
Var74=strlen(Var9+2); 
FUNC43(Var1,Var74); 
const STRUCT6 *Var44=(const STRUCT6 *) FUNC65(Var9+2); 
if (Var74>0){
STRUCT9 *Var82=FUNC50(Var44,Var74); 
STRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); 
if (!Var1->memberVar1->memberVar1){
FUNC25(Var1->memberVar9,STRING,1); 
if (Var83){
if (Var14){
FUNC52(Var14); 
Var14=Var83; 
if (Var15){
FUNC25(Var1->memberVar9,STRING,1); 
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); 
FUNC43(Var1,Var74); 
*Var9=; 
char *Var91=Var9-2; 
while (Var91>Var2){
if (!FUNC66(*Var91)){
*Var91=0; 
Var91  Var75; 
Var9=FUNC67(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
else 
*Var10=0; 
if (!Var10[1]){
FUNC43(
Var1,FUNC47(Var1->memberVar6,Var10+1)); 
Var66=FUNC67(Var9+1); 
memberVar2=FUNC47(Var1->memberVar6,Var66); 
if (FUNC68((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC69(Var1->memberVar13,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var40=*Var66; 
if (Var40 == -||Var40 == +){
memberVar2=Var1->memberVar12+memberVar2; 
if (memberVar2){
STRUCT3 *Var83=Var14; 
if (Var83){
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,memberVar2,FUNC70(Var83)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar18=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var92=Var9+3; 
while (*Var92&&*Var92 == ){
Var92  Var31; 
Var17=FUNC71(Var1,Var2,Var92); 
else 
Var17=FUNC72(Var1,Var2,Var9+2); 
else 
bool  memberVar11=false ; 
const char *Var93[]={STRING,STRING,STRING,
const char *Var94[]={STRING,STRING,STRING,
STRUCT4  Var95[FUNC73(Var93)-1],Var96[FUNC73(Var94)-1]; 
if (Var9[1]== (){
char *Var97=Var9+3; 
char *Var30=strchr(Var97,); 
if (!Var30){
free(Var69); 
*Var30=Var98; 
STRUCT4  Var99=FUNC47(Var1->memberVar6,Var97); 
STRUCT4  Var100=FUNC47(Var1->memberVar6,Var30+1); 
for (Var16=0; Var93[Var16]; Var16  Var31){
Var95[Var16]=FUNC23(Var1->memberVar9,Var93[Var16]); 
for (Var16=0; Var94[Var16]; Var16  Var31){
Var96[Var16]=FUNC23(Var1->memberVar9,Var94[Var16]); 
for (Var16=0; Var93[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var93[Var16],Var99); 
for (Var16=0; Var94[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var94[Var16],Var100); 
if (Var19){
if (Var64){
Var1->memberVar12=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC67(Var2)); 
else 
if (Var64){
if (Var9[1]){
FUNC45(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC67(Var2)); 
if (memberVar11){
for (Var16=0; Var93[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var93[Var16],Var95[Var16]); 
for (Var16=0; Var94[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var94[Var16],Var96[Var16]); 
if (Var10){
*Var10=!; 
if (Var72 != -1){
FUNC62(Var1->memberVar1,Var72); 
if (Var14){
if (Var15){
FUNC25(Var1->memberVar9,STRING,0); 
FUNC52(Var14); 
if (Var67){
FUNC74(Var1->memberVar9,STRING,Var65); 
if (Var69){
FUNC8(Var1,Var69); 
FUNC75(Var69); 
if (Var71){
FUNC76(Var1->memberVar13); 
*Var9=; 
Var61=Var17; 
Var61=Var2 FUNC4(Var1->memberVar5,FUNC67(Var2)) false ; 
FUNC77(Var13); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
if (Var14){
FUNC52(Var14); 
if (memberVar11){
*memberVar11=Var26; 
if (Var28 != -1){
FUNC25(Var1->memberVar9,STRING,Var28); 
return  Var61; 
",6674,0
before_cmd.c,r_core_cmd_subst_i,False,False,198,CWE-,CallExpression,strstr,2787,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var28,*Var29; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var30; 
Var29=*Var2 FUNC5(Var2) NULL ; 
if (!Var29||!*Var29){
FUNC6(STRINGFUNC7(%Var31).,Var2); 
else 
char *Var32=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var32){
char *Var33=strchr(Var29+1,); 
const bool  Var34=Var29[2]== >; 
Var28=strdup(Var2); 
if (Var29&&*Var29&&Var29[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var29){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37
if (Var9&&(Var9[1]== ||Var9[1]==  Var38)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var40=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var41=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var42=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var42,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var30){
char  Var43[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var30){
if (!*Var11){
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var44=1; 
int  Var45=FUNC20(Var1->memberVar8,STRING); 
int  Var46=false ; 
int  Var47=FUNC20(Var1->memberVar8,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC21(Var9[-2])){
char *Var48=Var9-1; 
const bool  Var49=(Var9[1]== >); 
if (*Var11 == ){
char *Var50=FUNC22(Var1,Var2); 
char *Var51=FUNC23(Var1->memberVar5,Var11,1); 
char *Var52=FUNC24(STRING,Var51,Var50); 
else 
char *Var53=FUNC24(STRING,Var50); 
else 
char *Var53=FUNC24(STRING,Var50); 
else 
}else if (Var44>0){
if (Var18 != -1){
Var17=FUNC12(Var1,Var2); 
const char *Var54=FUNC25(Var1->memberVar8,STRING); 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
bool  Var55=false ; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var55){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
if (Var9[1]== !){
Var11=FUNC26(Var1,Var9+1); 
else 
int  Var47=FUNC20(Var1->memberVar8,STRING); 
Var11=FUNC22(Var1,Var9+1); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
Var2=FUNC27(strdup(Var2),Var11); 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var31=strstr(Var2,STRING); 
if (Var31){
bool  Var56=false ; 
if (Var56){
if (*Var2 != .){
Var13=FUNC28(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar9=Var9 true false ; 
int  Var57=0; 
if (Var9){
char *Var58,*Var10=strchr(Var9+1,!); 
STRUCT4  Var59=Var1->memberVar10; 
bool  Var60=false ; 
char *Var61=NULL ; 
const char *Var62=NULL ; 
bool  Var63=false ; 
bool  Var64=false ; 
char *Var65=NULL ; 
char *Var66=NULL ; 
bool  Var67=false ; 
int  Var68=-1; 
int  Var69,Var70; 
STRUCT6 *Var43; 
*Var9  Var30=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var30){
if (*Var9&&Var9[1]== ){
else 
Var9  Var71; 
Var9=FUNC29(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var72=strdup(Var9+2); 
char *Var73=strchr(Var72,=); 
if (Var73){
*Var73  Var30=0; 
FUNC30(Var72,Var73); 
FUNC31(Var5,Var72); 
else 
free(Var72); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); 
FUNC33(Var1,FUNC34((Var74) Var59-(Var74) Var1->memberVar10)); 
else 
Var59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); 
FUNC35(Var1,Var59,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var67=FUNC36(Var1->memberVar11,Var9+2); 
int  Var75=(int ) FUNC37(Var1->memberVar6,Var9+2); 
STRUCT7 *Var76=FUNC38(Var1->memberVar12,Var1->memberVar10); 
if (Var76){
if (Var75<0){
Var75=Var76->memberVar1+Var75; 
if (Var75 >= 0&&Var75<Var76->memberVar1){
STRUCT8  Var77=FUNC39(Var76,Var75); 
FUNC35(Var1,Var76->memberVar2+Var77,1); 
Var58=FUNC40(Var9+2,&Var69); 
if (Var58){
STRUCT9 *Var78=FUNC41((const STRUCT6 *) Var58,Var69); 
STRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var14){
FUNC43(Var14); 
Var14=Var79; 
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); 
if (Var43){
memcpy(Var1->memberVar13,Var58,Var69); 
free(Var58); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var81; 
char *Var82=strdup(Var9+2); 
char *Var83=FUNC46(Var82); 
if (Var83){
char  Var39=*Var83; 
*Var83=0; 
Var81=FUNC47(Var1->memberVar14,Var82); 
*Var83=Var39; 
else 
Var81=FUNC47(Var1->memberVar14,Var9+2); 
FUNC35(Var1,Var81,1); 
free(Var82); 
Var63=FUNC48(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var61); 
STRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC49(Var1,Var9+2); 
if (!Var65){
Var65=Var2; 
else 
Var65=FUNC50(Var65,Var2); 
free(Var2); 
if (Var9[1]== ){
Var43=malloc(strlen(Var9+2)+1); 
if (Var43){
Var70=FUNC51(Var9+2,Var43); 
FUNC33(Var1,FUNC34(Var70)); 
if (Var70>0){
STRUCT9 *Var78=FUNC41(Var43,Var70); 
STRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var14){
FUNC43(Var14); 
Var14=Var79; 
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); 
FUNC33(Var1,Var70); 
free(Var43); 
char *Var84=FUNC52(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var84){
FUNC35(Var1,FUNC37(Var1->memberVar6,Var84),1); 
free(Var84); 
if (Var9[1]== ){
FUNC53(Var1->memberVar1,FUNC54(Var9+2)); 
if (Var9[1]== ){
char *Var33=strchr(Var9+2,); 
if (Var33){
*Var33  Var30=0; 
int  Var85=FUNC37(Var1->memberVar6,Var33); 
Var63=FUNC48(Var1,Var85,&Var61); 
Var64=FUNC55(Var1,Var9+2,&Var66); 
Var70=strlen(Var9+2); 
FUNC33(Var1,Var70); 
const STRUCT6 *Var43=(const STRUCT6 *) FUNC56(Var9+2); 
if (Var70>0){
STRUCT9 *Var78=FUNC41(Var43,Var70); 
STRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var14){
FUNC43(Var14); 
Var14=Var79; 
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); 
FUNC33(Var1,Var70); 
*Var9=; 
char *Var86=Var9-2; 
while (Var86>Var2){
if (!FUNC57(*Var86)){
*Var86=0; 
Var86  Var71; 
Var9=FUNC58(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var62=FUNC58(Var9+1); 
memberVar2=FUNC37(Var1->memberVar6,Var62); 
if (FUNC59((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC60(Var1->memberVar11,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var39=*Var62; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar10+memberVar2; 
if (memberVar2){
STRUCT3 *Var79=Var14; 
if (Var79){
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC61(Var79)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar16=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var87=Var9+3; 
while (*Var87&&*Var87 == ){
Var87  Var30; 
Var17=FUNC62(Var1,Var2,Var87); 
else 
Var17=FUNC63(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var88[]={STRING,STRING,STRING,
const char *Var89[]={STRING,STRING,STRING,
STRUCT4  Var90[FUNC64(Var88)-1],Var91[FUNC64(Var89)-1]; 
if (Var9[1]== (){
char *Var92=Var9+3; 
char *Var29=strchr(Var92,); 
if (!Var29){
free(Var65); 
*Var29=Var93; 
STRUCT4  Var94=FUNC37(Var1->memberVar6,Var92); 
STRUCT4  Var95=FUNC37(Var1->memberVar6,Var29+1); 
for (Var16=0; Var88[Var16]; Var16  Var30){
Var90[Var16]=FUNC20(Var1->memberVar8,Var88[Var16]); 
for (Var16=0; Var89[Var16]; Var16  Var30){
Var91[Var16]=FUNC20(Var1->memberVar8,Var89[Var16]); 
for (Var16=0; Var88[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var88[Var16],Var94); 
for (Var16=0; Var89[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var89[Var16],Var95); 
if (Var19){
if (Var60){
Var1->memberVar10=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC58(Var2)); 
else 
if (Var60){
if (Var9[1]){
FUNC35(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC58(Var2)); 
if (memberVar9){
for (Var16=0; Var88[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var88[Var16],Var90[Var16]); 
for (Var16=0; Var89[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var89[Var16],Var91[Var16]); 
if (Var68 != -1){
FUNC53(Var1->memberVar1,Var68); 
if (Var14){
if (Var15){
FUNC65(Var1->memberVar8,STRING,0); 
FUNC43(Var14); 
if (Var63){
FUNC66(Var1->memberVar8,STRING,Var61); 
if (Var65){
FUNC8(Var1,Var65); 
FUNC67(Var65); 
if (Var67){
FUNC68(Var1->memberVar11); 
*Var9=; 
Var57=Var17; 
Var57=Var2 FUNC4(Var1->memberVar5,FUNC58(Var2)) false ; 
if (Var20 != -1){
FUNC65(Var1->memberVar8,STRING,Var20); 
if (Var21 != -1){
FUNC65(Var1->memberVar8,STRING,Var21); 
if (Var14){
FUNC43(Var14); 
return  Var57; 
",5614,0
before_cmd.c,r_core_cmd_subst_i,False,False,199,CWE-,CallExpression,strchr,2814,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\teprintf (""==> Reading from stdin until \'%s\'\\n"", str);\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\teprintf (""Slurping file \'%s\'\\n"", str);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var28,*Var29; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var30; 
Var29=*Var2 FUNC5(Var2) NULL ; 
if (!Var29||!*Var29){
FUNC6(STRINGFUNC7(%Var31).,Var2); 
else 
char *Var32=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var32){
char *Var33=strchr(Var29+1,); 
const bool  Var34=Var29[2]== >; 
Var28=strdup(Var2); 
if (Var29&&*Var29&&Var29[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var29){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37
if (Var9&&(Var9[1]== ||Var9[1]==  Var38)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var40=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var41=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var42=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var42,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var30){
FUNC6(STRING,Var11); 
char  Var43[1024]; 
int  Var17; 
if (FUNC20(stdin)){
if (Var1->memberVar7){
if (!strcmp(Var43,Var11)){
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var30){
if (!*Var11){
FUNC6(STRING,Var11); 
Var1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); 
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
return FUNC22(Var1,(const char *) Var1->memberVar7); 
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var44=1; 
int  Var45=FUNC23(Var1->memberVar9,STRING); 
int  Var46=false ; 
int  Var47=FUNC23(Var1->memberVar9,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC24(Var9[-2])){
char *Var48=Var9-1; 
if (*Var48 ==  Var49){//STRING
Var20=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,true ); 
if (!strcmp(Var11,STRING)){
FUNC25(Var1->memberVar9,STRING,Var50); 
const bool  Var51=(Var9[1]== >); 
if (*Var11 == ){
char *Var52=FUNC26(Var1,Var2); 
if (Var51){
char *Var53=FUNC27(Var1->memberVar5,Var11,1); 
if (Var53){
char *Var54=FUNC28(STRING,Var53,Var52); 
if (Var54){
FUNC29(Var1->memberVar5,Var11,Var54,1); 
free(Var54); 
else 
char *Var55=FUNC28(STRING,Var52); 
FUNC29(Var1->memberVar5,Var11,Var55,1); 
else 
char *Var55=FUNC28(STRING,Var52); 
FUNC29(Var1->memberVar5,Var11,Var55,1); 
else 
}else if (Var44>0){
if (Var18 != -1){
if (!Var45){
FUNC25(Var1->memberVar9,STRING,Var50); 
Var17=FUNC12(Var1,Var2); 
if (!Var45){
FUNC25(Var1->memberVar9,STRING,Var47); 
if (Var46){
const char *Var56=FUNC30(Var1->memberVar9,STRING); 
if (Var56&&*Var56){
FUNC31(STRING,Var56,Var11); 
FUNC25(Var1->memberVar9,STRING,Var47); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
Var1->memberVar10->memberVar1=false ; 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
bool  Var57=false ; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var57){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
if (Var9[1]== !){
Var11=FUNC32(Var1,Var9+1); 
else 
int  Var47=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,0); 
Var11=FUNC26(Var1,Var9+1); 
FUNC25(Var1->memberVar9,STRING,Var47); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
Var2=FUNC33(strdup(Var2),Var11); 
Var1->memberVar6->memberVar1=memberVar1; 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (*Var2 != &&*Var2){
const char *Var31=strstr(Var2,STRING); 
if (Var31){
bool  Var58=false ; 
if (Var58){
if (*Var2 != .){
Var13=FUNC34(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar11=Var9 true false ; 
int  Var59=0; 
if (Var9){
char *Var60,*Var10=strchr(Var9+1,!); 
STRUCT4  Var61=Var1->memberVar12; 
bool  Var62=false ; 
char *Var63=NULL ; 
const char *Var64=NULL ; 
bool  Var65=false ; 
bool  Var66=false ; 
char *Var67=NULL ; 
char *Var68=NULL ; 
bool  Var69=false ; 
int  Var70=-1; 
int  Var71,Var72; 
STRUCT6 *Var43; 
*Var9  Var30=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var30){
if (*Var9&&Var9[1]== ){
else 
Var9  Var73; 
Var9=FUNC35(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var74=strdup(Var9+2); 
char *Var75=strchr(Var74,=); 
if (Var75){
*Var75  Var30=0; 
FUNC36(Var74,Var75); 
FUNC37(Var5,Var74); 
else 
free(Var74); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+4); 
FUNC39(Var1,FUNC40((Var76) Var61-(Var76) Var1->memberVar12)); 
else 
Var61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+3); 
FUNC41(Var1,Var61,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var69=FUNC42(Var1->memberVar13,Var9+2); 
int  Var77=(int ) FUNC43(Var1->memberVar6,Var9+2); 
STRUCT7 *Var78=FUNC44(Var1->memberVar14,Var1->memberVar12); 
if (Var78){
if (Var77<0){
Var77=Var78->memberVar1+Var77; 
if (Var77 >= 0&&Var77<Var78->memberVar1){
STRUCT8  Var79=FUNC45(Var78,Var77); 
FUNC41(Var1,Var78->memberVar2+Var79,1); 
Var60=FUNC21(Var9+2,&Var71); 
if (Var60){
STRUCT9 *Var80=FUNC46((const STRUCT6 *) Var60,Var71); 
STRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); 
if (Var81){
if (Var14){
FUNC48(Var14); 
Var14=Var81; 
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); 
if (Var43){
memcpy(Var1->memberVar15,Var60,Var71); 
free(Var60); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var83; 
char *Var84=strdup(Var9+2); 
char *Var85=FUNC51(Var84); 
if (Var85){
char  Var39=*Var85; 
*Var85=0; 
Var83=FUNC52(Var1->memberVar16,Var84); 
*Var85=Var39; 
else 
Var83=FUNC52(Var1->memberVar16,Var9+2); 
FUNC41(Var1,Var83,1); 
free(Var84); 
Var65=FUNC53(Var1,FUNC43(Var1->memberVar6,Var9+2),&Var63); 
STRUCT4  memberVar2=FUNC43(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC54(Var1,Var9+2); 
if (!Var67){
Var67=Var2; 
else 
Var67=FUNC55(Var67,Var2); 
free(Var2); 
if (Var9[1]== ){
Var43=malloc(strlen(Var9+2)+1); 
if (Var43){
Var72=FUNC56(Var9+2,Var43); 
FUNC39(Var1,FUNC40(Var72)); 
if (Var72>0){
STRUCT9 *Var80=FUNC46(Var43,Var72); 
STRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); 
if (Var81){
if (Var14){
FUNC48(Var14); 
Var14=Var81; 
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); 
FUNC39(Var1,Var72); 
free(Var43); 
char *Var86=FUNC57(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var86){
FUNC41(Var1,FUNC43(Var1->memberVar6,Var86),1); 
free(Var86); 
if (Var9[1]== ){
FUNC58(Var1->memberVar1,FUNC59(Var9+2)); 
if (Var9[1]== ){
char *Var33=strchr(Var9+2,); 
if (Var33){
*Var33  Var30=0; 
int  Var87=FUNC43(Var1->memberVar6,Var33); 
Var65=FUNC53(Var1,Var87,&Var63); 
Var66=FUNC60(Var1,Var9+2,&Var68); 
Var72=strlen(Var9+2); 
FUNC39(Var1,Var72); 
const STRUCT6 *Var43=(const STRUCT6 *) FUNC61(Var9+2); 
if (Var72>0){
STRUCT9 *Var80=FUNC46(Var43,Var72); 
STRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); 
if (Var81){
if (Var14){
FUNC48(Var14); 
Var14=Var81; 
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); 
FUNC39(Var1,Var72); 
*Var9=; 
char *Var88=Var9-2; 
while (Var88>Var2){
if (!FUNC62(*Var88)){
*Var88=0; 
Var88  Var73; 
Var9=FUNC63(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var64=FUNC63(Var9+1); 
memberVar2=FUNC43(Var1->memberVar6,Var64); 
if (FUNC64((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC65(Var1->memberVar13,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var39=*Var64; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar12+memberVar2; 
if (memberVar2){
STRUCT3 *Var81=Var14; 
if (Var81){
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,memberVar2,FUNC66(Var81)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar18=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var89=Var9+3; 
while (*Var89&&*Var89 == ){
Var89  Var30; 
Var17=FUNC67(Var1,Var2,Var89); 
else 
Var17=FUNC68(Var1,Var2,Var9+2); 
else 
bool  memberVar11=false ; 
const char *Var90[]={STRING,STRING,STRING,
const char *Var91[]={STRING,STRING,STRING,
STRUCT4  Var92[FUNC69(Var90)-1],Var93[FUNC69(Var91)-1]; 
if (Var9[1]== (){
char *Var94=Var9+3; 
char *Var29=strchr(Var94,); 
if (!Var29){
free(Var67); 
*Var29=Var95; 
STRUCT4  Var96=FUNC43(Var1->memberVar6,Var94); 
STRUCT4  Var97=FUNC43(Var1->memberVar6,Var29+1); 
for (Var16=0; Var90[Var16]; Var16  Var30){
Var92[Var16]=FUNC23(Var1->memberVar9,Var90[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var30){
Var93[Var16]=FUNC23(Var1->memberVar9,Var91[Var16]); 
for (Var16=0; Var90[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var90[Var16],Var96); 
for (Var16=0; Var91[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var91[Var16],Var97); 
if (Var19){
if (Var62){
Var1->memberVar12=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC63(Var2)); 
else 
if (Var62){
if (Var9[1]){
FUNC41(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC63(Var2)); 
if (memberVar11){
for (Var16=0; Var90[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var90[Var16],Var92[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var91[Var16],Var93[Var16]); 
if (Var70 != -1){
FUNC58(Var1->memberVar1,Var70); 
if (Var14){
if (Var15){
FUNC25(Var1->memberVar9,STRING,0); 
FUNC48(Var14); 
if (Var65){
FUNC70(Var1->memberVar9,STRING,Var63); 
if (Var67){
FUNC8(Var1,Var67); 
FUNC71(Var67); 
if (Var69){
FUNC72(Var1->memberVar13); 
*Var9=; 
Var59=Var17; 
Var59=Var2 FUNC4(Var1->memberVar5,FUNC63(Var2)) false ; 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
if (Var14){
FUNC48(Var14); 
return  Var59; 
",6134,0
before_cmd.c,r_core_cmd_subst_i,False,False,200,CWE-,CallExpression,free,2826,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC26(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC30(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC32(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC37(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC38(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC38(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC40(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC28(Var1,FUNC29(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
FUNC41(Var1); 
char *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC43(Var1->memberVar1,FUNC44(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC39(Var1,Var83,&Var60); 
Var63=FUNC45(Var1,Var6+2,&Var65); 
FUNC28(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC28(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC47((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC48(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC41(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC50(Var1,Var2,Var85); 
else 
Var14=FUNC51(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC41(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC28(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC54(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC43(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC54(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC28(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC55(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5719,0
before_cmd.c,r_core_cmd_subst_i,False,False,201,CWE-,CallExpression,malloc,2827,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
free(Var50); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
if (Var52&&*Var52){
FUNC26(STRING,Var52,Var8); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC27(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC31(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC33(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC38(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC39(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC39(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC41(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC29(Var1,FUNC30(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
FUNC42(Var1); 
char *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC44(Var1->memberVar1,FUNC45(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC40(Var1,Var83,&Var60); 
Var63=FUNC46(Var1,Var6+2,&Var65); 
FUNC29(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC29(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC48((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC49(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC42(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC51(Var1,Var2,Var85); 
else 
Var14=FUNC52(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC42(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC29(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC55(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC44(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC55(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC29(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC56(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5752,0
before_cmd.c,r_core_cmd_subst_i,False,False,202,CWE-,CallExpression,write,2835,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\twrite (1, ""> "", 2);\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=Var6->memberVar2; 
bool  Var11=Var6->memberVar3; 
STRUCT1  Var12=Var6->memberVar4; 
if (!Var13){
switch (*Var13){
if (Var13[1]== ){/*STRUCT2 */
else 
char *Var14=strchr(Var13,; ); 
if (Var13[1]!= *&&!strstr(Var13,STRING)){
if (Var13[1]== >){
if (*Var13 != ){
if (Var15&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var13){
char *Var16=Var2-1; 
if (*Var16 == ){
char *Var3=strchr(Var13,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var17=Var6->memberVar5->memberVar1; 
else 
char *Var18=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var13||Var2[-1]!= )){
if (*Var13 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var19[1024]; 
int  Var8; 
write(1,STRING,2); 
if (FUNC4(stdin)){
if (Var6->memberVar6){
if (!strcmp(Var19,Var4)){
char *Var16=Var2-1; 
int  Var20=FUNC5(Var6->memberVar7,STRING); 
int  Var21=FUNC5(Var6->memberVar7,STRING); 
char *Var22=Var2-1; 
const bool  Var23=(Var2[1]== >); 
char *Var24=FUNC6(Var6,Var13); 
char *Var25=FUNC7(Var6->memberVar8,Var4,1); 
const char *Var26=FUNC8(Var6->memberVar7,STRING); 
char *Var16=Var2-1; 
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
else 
int  Var21=FUNC5(Var6->memberVar7,STRING); 
const char *Var27=strstr(Var13,STRING); 
char *Var28,*Var3=strchr(Var2+1,!); 
STRUCT1  Var29=Var6->memberVar9; 
STRUCT3 *Var19; 
char *Var30=strdup(Var2+2); 
STRUCT1  Var29=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); 
int  Var31=(int ) FUNC10(Var6->memberVar5,Var2+2); 
STRUCT4 *Var32=FUNC11(Var6->memberVar10,Var6->memberVar9); 
STRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); 
char *Var36=strdup(Var2+2); 
char  Var16=*Var37; 
STRUCT1  Var29=FUNC10(Var6->memberVar5,Var2+2); 
char *Var13=FUNC13(Var6,Var2+2); 
STRUCT6 *Var34=FUNC14(Var19,Var38); 
STRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); 
char *Var39=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var40=strchr(Var2+2,); 
int  Var41=FUNC10(Var6->memberVar5,Var40); 
const STRUCT3 *Var19=(const STRUCT3 *) FUNC16(Var2+2); 
STRUCT6 *Var34=FUNC14(Var19,Var38); 
STRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); 
char *Var42=Var2-2; 
else 
char  Var16=*Var43; 
char *Var44=Var2+3; 
char *Var45=Var2+3; 
STRUCT1  Var46=FUNC10(Var6->memberVar5,Var45); 
STRUCT1  Var47=FUNC10(Var6->memberVar5,Var48+1); 
",1353,0
before_cmd.c,r_core_cmd_subst_i,False,False,203,CWE-,CallExpression,fgets,2836,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=Var6->memberVar2; 
bool  Var11=Var6->memberVar3; 
STRUCT1  Var12=Var6->memberVar4; 
if (!Var13){
switch (*Var13){
if (Var13[1]== ){/*STRUCT2 */
else 
char *Var14=strchr(Var13,; ); 
if (Var13[1]!= *&&!strstr(Var13,STRING)){
if (Var13[1]== >){
if (*Var13 != ){
if (Var15&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var13){
char *Var16=Var2-1; 
if (*Var16 == ){
char *Var3=strchr(Var13,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var17=Var6->memberVar5->memberVar1; 
else 
char *Var18=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var13||Var2[-1]!= )){
if (*Var13 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var19[1024]; 
int  Var8; 
fgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21
if (FUNC4(stdin)){
if (*Var19) Var19[strlen(Var19)-1]=0; 
Var8=strlen(Var19); 
if (Var6->memberVar6){
if (!strcmp(Var19,Var4)){
strcat((char *) Var6->memberVar6,Var19); 
char *Var16=Var2-1; 
int  Var22=FUNC5(Var6->memberVar7,STRING); 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
char *Var24=Var2-1; 
const bool  Var25=(Var2[1]== >); 
char *Var26=FUNC6(Var6,Var13); 
char *Var27=FUNC7(Var6->memberVar8,Var4,1); 
const char *Var28=FUNC8(Var6->memberVar7,STRING); 
char *Var16=Var2-1; 
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
else 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
const char *Var29=strstr(Var13,STRING); 
char *Var30,*Var3=strchr(Var2+1,!); 
STRUCT1  Var31=Var6->memberVar9; 
STRUCT4 *Var19; 
char *Var32=strdup(Var2+2); 
STRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); 
int  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); 
STRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var38=strdup(Var2+2); 
char  Var16=*Var39; 
STRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); 
char *Var13=FUNC13(Var6,Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var42=strchr(Var2+2,); 
int  Var43=FUNC10(Var6->memberVar5,Var42); 
const STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var44=Var2-2; 
else 
char  Var16=*Var45; 
char *Var46=Var2+3; 
char *Var47=Var2+3; 
STRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); 
STRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); 
",1424,0
before_cmd.c,r_core_cmd_subst_i,False,False,204,CWE-,CallExpression,strlen,2840,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=Var6->memberVar2; 
bool  Var11=Var6->memberVar3; 
STRUCT1  Var12=Var6->memberVar4; 
if (!Var13){
switch (*Var13){
if (Var13[1]== ){/*STRUCT2 */
else 
char *Var14=strchr(Var13,; ); 
if (Var13[1]!= *&&!strstr(Var13,STRING)){
if (Var13[1]== >){
if (*Var13 != ){
if (Var15&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var13){
char *Var16=Var2-1; 
if (*Var16 == ){
char *Var3=strchr(Var13,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var17=Var6->memberVar5->memberVar1; 
else 
char *Var18=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var13||Var2[-1]!= )){
if (*Var13 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var19[1024]; 
int  Var8; 
fgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21
if (FUNC4(stdin)){
if (*Var19) Var19[strlen(Var19)-1]=0; 
Var8=strlen(Var19); 
if (Var6->memberVar6){
if (!strcmp(Var19,Var4)){
strcat((char *) Var6->memberVar6,Var19); 
char *Var16=Var2-1; 
int  Var22=FUNC5(Var6->memberVar7,STRING); 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
char *Var24=Var2-1; 
const bool  Var25=(Var2[1]== >); 
char *Var26=FUNC6(Var6,Var13); 
char *Var27=FUNC7(Var6->memberVar8,Var4,1); 
const char *Var28=FUNC8(Var6->memberVar7,STRING); 
char *Var16=Var2-1; 
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
else 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
const char *Var29=strstr(Var13,STRING); 
char *Var30,*Var3=strchr(Var2+1,!); 
STRUCT1  Var31=Var6->memberVar9; 
STRUCT4 *Var19; 
char *Var32=strdup(Var2+2); 
STRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); 
int  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); 
STRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var38=strdup(Var2+2); 
char  Var16=*Var39; 
STRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); 
char *Var13=FUNC13(Var6,Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var42=strchr(Var2+2,); 
int  Var43=FUNC10(Var6->memberVar5,Var42); 
const STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var44=Var2-2; 
else 
char  Var16=*Var45; 
char *Var46=Var2+3; 
char *Var47=Var2+3; 
STRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); 
STRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); 
",1424,0
before_cmd.c,r_core_cmd_subst_i,False,False,205,CWE-,CallExpression,strlen,2841,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tint pipefd = -1;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\t\treturn ret;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tbool flgspc_changed = false;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=false ; 
int  Var11=-1; 
int  Var12=-1; 
bool  Var13=false ; 
bool  Var14=false ; 
bool  Var15=Var6->memberVar2; 
bool  Var16=Var6->memberVar3; 
bool  Var17=false ; 
STRUCT1  Var18=Var6->memberVar4; 
if (!Var19){
switch (*Var19){
if (Var19[1]== ){/*STRUCT2 */
int  Var9=-1; 
else 
char *Var20=strchr(Var19,; ); 
if (Var19[1]!= *&&!strstr(Var19,STRING)){
if (Var19[1]== >){
if (*Var19 != ){
if (Var21&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var19){
char *Var22=Var2-1; 
if (*Var22 == ){
char *Var3=strchr(Var19,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var23=Var6->memberVar5->memberVar1; 
else 
char *Var24=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var19||Var2[-1]!= )){
if (*Var19 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var25[1024]; 
int  Var8; 
fgets(Var25,sizeof (Var25)-1,stdin); //Var26  STRUCT3  Var27
if (FUNC4(stdin)){
if (*Var25) Var25[strlen(Var25)-1]=0; 
Var8=strlen(Var25); 
Var6->memberVar6  STRUCT4  Var8; 
Var6->memberVar7=realloc(Var6->memberVar7,Var6->memberVar6+1); 
if (Var6->memberVar7){
if (!strcmp(Var25,Var4)){
strcat((char *) Var6->memberVar7,Var25); 
if (!*Var4){
if (!Var6->memberVar7){
else 
}else if (Var2 ==  Var19){
if (Var2){
if (Var2>Var19){
char *Var22=Var2-1; 
if (*Var22 == ){
if (Var2[0]&&Var2[1]== ){
int  Var28=1; 
int  Var29=FUNC5(Var6->memberVar8,STRING); 
int  Var30=false ; 
int  Var31=FUNC5(Var6->memberVar8,STRING); 
if (!*Var4){
if (Var2>(Var19+1)&&FUNC6(Var2[-2])){
char *Var32=Var2-1; 
if (*Var32 ==  Var33){//STRING
Var11=FUNC5(Var6->memberVar8,STRING); 
FUNC7(Var6->memberVar8,STRING,true ); 
if (!strcmp(Var4,STRING)){
FUNC7(Var6->memberVar8,STRING,Var34); 
const bool  Var35=(Var2[1]== >); 
if (*Var4 == ){
char *Var36=FUNC8(Var6,Var19); 
if (Var35){
char *Var37=FUNC9(Var6->memberVar9,Var4,1); 
if (Var37){
char *Var38=FUNC10(STRING,Var37,Var36); 
if (Var38){
FUNC11(Var6->memberVar9,Var4,Var38,1); 
free(Var38); 
else 
char *Var39=FUNC10(STRING,Var36); 
FUNC11(Var6->memberVar9,Var4,Var39,1); 
else 
char *Var39=FUNC10(STRING,Var36); 
FUNC11(Var6->memberVar9,Var4,Var39,1); 
else 
}else if (Var28>0){
if (Var9 != -1){
if (!Var29){
FUNC7(Var6->memberVar8,STRING,Var34); 
if (!Var29){
FUNC7(Var6->memberVar8,STRING,Var31); 
if (Var30){
const char *Var40=FUNC12(Var6->memberVar8,STRING); 
if (Var40&&*Var40){
FUNC13(STRING,Var40,Var4); 
FUNC7(Var6->memberVar8,STRING,Var31); 
if (Var11 != -1){
FUNC7(Var6->memberVar8,STRING,Var11); 
if (Var12 != -1){
FUNC7(Var6->memberVar8,STRING,Var12); 
Var6->memberVar10->memberVar1=false ; 
return  Var8; 
if (Var2){
if (Var2>Var19){
char *Var22=Var2-1; 
if (*Var22 == ){
bool  Var41=false ; 
if (Var41){
else 
}else if (!Var3){
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
if (Var2[1]== !){
else 
int  Var31=FUNC5(Var6->memberVar8,STRING); 
FUNC7(Var6->memberVar8,STRING,0); 
FUNC7(Var6->memberVar8,STRING,Var31); 
if (!Var4){
if (*Var4 == |||*Var4 == *){
Var6->memberVar5->memberVar1=memberVar1; 
if (Var11 != -1){
FUNC7(Var6->memberVar8,STRING,Var11); 
if (*Var19 != &&*Var19){
const char *Var42=strstr(Var19,STRING); 
if (Var42){
bool  Var43=false ; 
if (Var43){
char *Var44,*Var3=strchr(Var2+1,!); 
STRUCT1  Var45=Var6->memberVar11; 
bool  Var46=false ; 
bool  Var47=false ; 
bool  Var48=false ; 
bool  Var49=false ; 
STRUCT5 *Var25; 
char *Var50=strdup(Var2+2); 
STRUCT1  Var45=FUNC14(Var6->memberVar5,Var6->memberVar11,Var2+4); 
int  Var51=(int ) FUNC15(Var6->memberVar5,Var2+2); 
STRUCT6 *Var52=FUNC16(Var6->memberVar12,Var6->memberVar11); 
STRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); 
char *Var56=strdup(Var2+2); 
char  Var22=*Var57; 
STRUCT1  Var45=FUNC15(Var6->memberVar5,Var2+2); 
char *Var19=FUNC18(Var6,Var2+2); 
STRUCT8 *Var54=FUNC19(Var25,Var58); 
STRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); 
char *Var59=FUNC20(Var6->memberVar13,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var60=strchr(Var2+2,); 
int  Var61=FUNC15(Var6->memberVar5,Var60); 
const STRUCT5 *Var25=(const STRUCT5 *) FUNC21(Var2+2); 
STRUCT8 *Var54=FUNC19(Var25,Var58); 
STRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); 
char *Var62=Var2-2; 
else 
char  Var22=*Var63; 
char *Var64=Var2+3; 
else 
bool  Var65=false ; 
char *Var66=Var2+3; 
STRUCT1  Var67=FUNC15(Var6->memberVar5,Var66); 
STRUCT1  Var68=FUNC15(Var6->memberVar5,Var69+1); 
if (Var11 != -1){
FUNC7(Var6->memberVar8,STRING,Var11); 
if (Var12 != -1){
FUNC7(Var6->memberVar8,STRING,Var12); 
",2435,0
before_cmd.c,r_core_cmd_subst_i,False,False,206,CWE-,CallExpression,realloc,2843,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var14=strlen(Var40); 
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
free(Var50); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
if (Var52&&*Var52){
FUNC26(STRING,Var52,Var8); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC27(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC31(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC33(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC38(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC39(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC39(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC41(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC29(Var1,FUNC30(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
FUNC42(Var1); 
char *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC44(Var1->memberVar1,FUNC45(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC40(Var1,Var83,&Var60); 
Var63=FUNC46(Var1,Var6+2,&Var65); 
FUNC29(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC29(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC48((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC49(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC42(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC51(Var1,Var2,Var85); 
else 
Var14=FUNC52(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC42(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC29(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC55(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC44(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC55(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC29(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC56(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5762,0
before_cmd.c,r_core_cmd_subst_i,False,False,207,CWE-,CallExpression,strcmp,2845,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\teprintf (""==> Reading from stdin until \'%s\'\\n"", str);\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var23){
FUNC8(STRING,Var9); 
char  Var24[1024]; 
int  Var12; 
fgets(Var24,sizeof (Var24)-1,stdin); //Var25  STRUCT4  Var26
if (FUNC9(stdin)){
if (*Var24) Var24[strlen(Var24)-1]=0; 
Var12=strlen(Var24); 
if (Var1->memberVar6){
if (!strcmp(Var24,Var9)){
strcat((char *) Var1->memberVar6,Var24); 
char *Var20=Var7-1; 
int  Var27=FUNC10(Var1->memberVar7,STRING); 
int  Var28=FUNC10(Var1->memberVar7,STRING); 
char *Var29=Var7-1; 
const bool  Var30=(Var7[1]== >); 
char *Var31=FUNC11(Var1,Var2); 
char *Var32=FUNC12(Var1->memberVar8,Var9,1); 
const char *Var33=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var28=FUNC10(Var1->memberVar7,STRING); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar9; 
STRUCT5 *Var24; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT8 *Var42=FUNC19(Var24,Var46); 
STRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var47=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC15(Var1->memberVar5,Var18); 
const STRUCT5 *Var24=(const STRUCT5 *) FUNC21(Var7+2); 
STRUCT8 *Var42=FUNC19(Var24,Var46); 
STRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); 
",1653,0
before_cmd.c,r_core_cmd_subst_i,False,False,208,CWE-,CallExpression,strcat,2848,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
fgets(Var40,sizeof (Var40)-1,stdin); //Var41  STRUCT5  Var42
if (FUNC17(stdin)){
if (*Var40) Var40[strlen(Var40)-1]=0; 
Var14=strlen(Var40); 
Var1->memberVar10  STRUCT6  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT7 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var43=1; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
int  Var45=false ; 
int  Var46=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var47=Var6-1; 
if (*Var47 ==  Var48){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var49=(Var6[1]== >); 
if (*Var8 == ){
char *Var50=FUNC21(Var1,Var2); 
if (Var49){
char *Var51=FUNC22(Var1->memberVar5,Var8,1); 
if (Var51){
char *Var52=FUNC23(STRING,Var51,Var50); 
if (Var52){
FUNC24(Var1->memberVar5,Var8,Var52,1); 
else 
char *Var53=FUNC23(STRING,Var50); 
FUNC24(Var1->memberVar5,Var8,Var53,1); 
else 
char *Var53=FUNC23(STRING,Var50); 
FUNC24(Var1->memberVar5,Var8,Var53,1); 
else 
}else if (Var43>0){
if (Var15 != -1){
if (!Var44){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var44){
FUNC11(Var1->memberVar8,STRING,Var46); 
if (Var45){
const char *Var54=FUNC25(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var46); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var55=false ; 
if (Var55){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC26(Var1,Var6+1); 
else 
int  Var46=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var46); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var56=strstr(Var2,STRING); 
if (Var56){
bool  Var57=false ; 
if (Var57){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var58=0; 
if (Var6){
char *Var59,*Var7=strchr(Var6+1,!); 
STRUCT3  Var60=Var1->memberVar6; 
bool  Var61=false ; 
char *Var62=NULL ; 
const char *Var63=NULL ; 
bool  Var64=false ; 
bool  Var65=false ; 
char *Var66=NULL ; 
char *Var67=NULL ; 
bool  Var68=false ; 
int  Var69=-1; 
int  Var70,Var71; 
STRUCT7 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var72=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC28(Var1,FUNC29((Var73) Var60-(Var73) Var1->memberVar6)); 
else 
Var60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var60,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var68=FUNC30(Var1->memberVar14,Var6+2); 
int  Var74=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT8 *Var75=FUNC31(Var1->memberVar15,Var1->memberVar6); 
if (Var75){
if (Var74 >= 0&&Var74<Var75->memberVar1){
STRUCT9  Var76=FUNC32(Var75,Var74); 
FUNC4(Var1,Var75->memberVar2+Var76,1); 
Var23=Var1->memberVar13=true ; 
if (Var59){
STRUCT10 *Var77=FUNC33((const STRUCT7 *) Var59,Var70); 
STRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); 
if (Var78){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var70; 
memcpy(Var1->memberVar16,Var59,Var70); 
if (Var6[1]== ){
STRUCT3  Var80; 
char *Var81=strdup(Var6+2); 
char *Var82=FUNC37(Var81); 
if (Var82){
char  Var34=*Var82; 
Var80=FUNC38(Var1->memberVar17,Var81); 
Var80=FUNC5(Var1->memberVar7,Var83); 
else 
Var80=FUNC38(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var80,1); 
Var23=Var1->memberVar13=true ; 
Var64=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var62); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC40(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC28(Var1,FUNC29(Var71)); 
if (Var71>0){
STRUCT10 *Var77=FUNC33(Var40,Var71); 
STRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); 
if (Var78){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); 
FUNC28(Var1,Var71); 
FUNC41(Var1); 
char *Var84=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var84){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var84),1); 
if (Var6[1]== ){
Var69=Var1->memberVar1->STRUCT11  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC43(Var1->memberVar1,FUNC44(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var85=FUNC5(Var1->memberVar7,Var31); 
Var64=FUNC39(Var1,Var85,&Var62); 
Var65=FUNC45(Var1,Var6+2,&Var67); 
FUNC28(Var1,Var71); 
const STRUCT7 *Var40=(const STRUCT7 *) FUNC46(Var6+2); 
if (Var71>0){
STRUCT10 *Var77=FUNC33(Var40,Var71); 
STRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var78){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); 
FUNC28(Var1,Var71); 
char *Var86=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC28(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var63); 
if (FUNC47((STRUCT7) Var6[1])&&!memberVar2){
if (!FUNC48(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var63; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var78=Var11; 
if (Var78){
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,memberVar2,FUNC49(Var78)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC41(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var87=Var6+3; 
Var14=FUNC50(Var1,Var2,Var87); 
else 
Var14=FUNC51(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var88[]={STRING,STRING,STRING,
const char *Var89[]={STRING,STRING,STRING,
STRUCT3  Var90[FUNC52(Var88)-1],Var91[FUNC52(Var89)-1]; 
if (Var6[1]== (){
char *Var92=Var6+3; 
char *Var29=strchr(Var92,); 
if (!Var29){
STRUCT3  Var93=FUNC5(Var1->memberVar7,Var92); 
STRUCT3  Var94=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var88[Var13]; Var13  Var95){
Var90[Var13]=FUNC10(Var1->memberVar8,Var88[Var13]); 
for (Var13=0; Var89[Var13]; Var13  Var95){
Var91[Var13]=FUNC10(Var1->memberVar8,Var89[Var13]); 
for (Var13=0; Var88[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var88[Var13],Var93); 
for (Var13=0; Var89[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var89[Var13],Var94); 
if (Var16){
if (Var61){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
else 
if (Var61){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC41(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
if (memberVar13){
for (Var13=0; Var88[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var88[Var13],Var90[Var13]); 
for (Var13=0; Var89[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var89[Var13],Var91[Var13]); 
if (Var7){
FUNC28(Var1,Var24); 
if (Var65){
Var1->memberVar2=Var21; 
FUNC54(Var1->memberVar8,STRING,Var67); 
if (Var69 != -1){
FUNC43(Var1->memberVar1,Var69); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var64){
FUNC54(Var1->memberVar8,STRING,Var62); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC28(Var1,Var24); 
if (Var66){
FUNC3(Var1,Var66); 
if (Var68){
FUNC55(Var1->memberVar14); 
Var58=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5781,0
before_cmd.c,r_core_cmd_subst_i,False,False,209,CWE-,CallExpression,free,2860,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC26(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC30(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC32(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC37(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC38(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC38(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC40(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC28(Var1,FUNC29(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
FUNC41(Var1); 
char *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC43(Var1->memberVar1,FUNC44(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC39(Var1,Var83,&Var60); 
Var63=FUNC45(Var1,Var6+2,&Var65); 
FUNC28(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC28(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC47((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC48(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC41(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC50(Var1,Var2,Var85); 
else 
Var14=FUNC51(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC41(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC28(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC54(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC43(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC54(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC28(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC55(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5719,0
before_cmd.c,r_core_cmd_subst_i,False,False,210,CWE-,CallExpression,memmove,2883,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC9(Var1->memberVar7,STRING); 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC10(Var7[-2])){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC11(Var1,Var2); 
char *Var29=FUNC12(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
const char *Var31=strstr(Var2,STRING); 
char *Var32,*Var8=strchr(Var7+1,!); 
STRUCT2  Var33=Var1->memberVar9; 
char *Var34=strdup(Var7+2); 
char *Var35=strchr(Var34,=); 
STRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var41=strdup(Var7+2); 
char  Var20=*Var42; 
STRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var44=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var46=Var7-2; 
else 
char  Var20=*Var47; 
char *Var48=Var7+3; 
char *Var49=Var7+3; 
char *Var19=strchr(Var49,); 
STRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); 
STRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); 
",1636,0
before_cmd.c,r_core_cmd_subst_i,False,False,211,CWE-,CallExpression,strlen,2883,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC9(Var1->memberVar7,STRING); 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC10(Var7[-2])){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC11(Var1,Var2); 
char *Var29=FUNC12(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
const char *Var31=strstr(Var2,STRING); 
char *Var32,*Var8=strchr(Var7+1,!); 
STRUCT2  Var33=Var1->memberVar9; 
char *Var34=strdup(Var7+2); 
char *Var35=strchr(Var34,=); 
STRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var41=strdup(Var7+2); 
char  Var20=*Var42; 
STRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var44=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var46=Var7-2; 
else 
char  Var20=*Var47; 
char *Var48=Var7+3; 
char *Var49=Var7+3; 
char *Var19=strchr(Var49,); 
STRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); 
STRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); 
",1636,0
before_cmd.c,r_core_cmd_subst_i,False,False,212,CWE-,CallExpression,strcmp,2920,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tint pipefd = -1;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\t\tr_file_rm (str);\n', '\t\t\tfree (str);\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
int  Var13=-1; 
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=1; 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
int  Var26=false ; 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
char *Var28=Var7-1; 
const bool  Var29=(Var7[1]== >); 
if (*Var9 == ){
char *Var30=FUNC10(Var1,Var2); 
if (Var29){
char *Var31=FUNC11(Var1->memberVar8,Var9,1); 
if (Var31){
char *Var32=FUNC12(STRING,Var31,Var30); 
if (Var32){
FUNC13(Var1->memberVar8,Var9,Var32,1); 
else 
char *Var33=FUNC12(STRING,Var30); 
FUNC13(Var1->memberVar8,Var9,Var33,1); 
else 
char *Var33=FUNC12(STRING,Var30); 
FUNC13(Var1->memberVar8,Var9,Var33,1); 
else 
}else if (Var24>0){
Var13=FUNC14(Var9,Var24,Var29); 
if (Var26){
const char *Var34=FUNC15(Var1->memberVar7,STRING); 
if (Var34&&*Var34){
FUNC16(STRING,Var34,Var9); 
FUNC17(Var9); 
free(Var9); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
const char *Var35=strstr(Var2,STRING); 
char *Var36,*Var8=strchr(Var7+1,!); 
STRUCT2  Var37=Var1->memberVar9; 
char *Var38=strdup(Var7+2); 
char *Var39=strchr(Var38,=); 
STRUCT2  Var37=FUNC18(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var40=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT4 *Var41=FUNC20(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); 
char *Var45=strdup(Var7+2); 
char  Var20=*Var46; 
STRUCT2  Var37=FUNC19(Var1->memberVar5,Var7+2); 
char *Var2=FUNC22(Var1,Var7+2); 
STRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); 
char *Var47=FUNC23(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC19(Var1->memberVar5,Var18); 
const STRUCT6 *Var49=(const STRUCT6 *) FUNC24(Var7+2); 
STRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); 
char *Var50=Var7-2; 
else 
char  Var20=*Var51; 
char *Var52=Var7+3; 
char *Var53=Var7+3; 
char *Var19=strchr(Var53,); 
STRUCT2  Var54=FUNC19(Var1->memberVar5,Var53); 
STRUCT2  Var55=FUNC19(Var1->memberVar5,Var19+1); 
",1839,0
before_cmd.c,r_core_cmd_subst_i,False,False,213,CWE-,CallExpression,free,2936,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tstr = r_file_temp (""dumpedit"");\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
Var1->memberVar6=malloc(1); 
Var1->memberVar7=0; 
char  Var24[1024]; 
int  Var12; 
if (FUNC8(stdin)){
Var12=strlen(Var24); 
Var1->memberVar7  STRUCT4  Var12; 
Var1->memberVar6=realloc(Var1->memberVar6,Var1->memberVar7+1); 
if (Var1->memberVar6){
if (!strcmp(Var24,Var9)){
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var23){
if (!*Var9){
Var1->memberVar6=(STRUCT5 *) FUNC9(Var9,&Var1->memberVar7); 
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC10(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var25=FUNC11(Var1->memberVar8,STRING); 
int  Var26=FUNC11(Var1->memberVar8,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
char *Var27=Var7-1; 
if (!strcmp(Var9,STRING)){
Var9=FUNC12(STRING); 
const bool  Var28=(Var7[1]== >); 
if (*Var9 == ){
char *Var29=FUNC13(Var1,Var2); 
if (Var28){
char *Var30=FUNC14(Var1->memberVar9,Var9,1); 
if (Var30){
char *Var31=FUNC15(STRING,Var30,Var29); 
if (Var31){
FUNC16(Var1->memberVar9,Var9,Var31,1); 
free(Var31); 
else 
char *Var32=FUNC15(STRING,Var29); 
else 
char *Var32=FUNC15(STRING,Var29); 
const char *Var33=FUNC17(Var1->memberVar8,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var26=FUNC11(Var1->memberVar8,STRING); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar10; 
STRUCT5 *Var24; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC18(Var1->memberVar5,Var1->memberVar10,Var7+4); 
int  Var39=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var40=FUNC20(Var1->memberVar11,Var1->memberVar10); 
STRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC19(Var1->memberVar5,Var7+2); 
char *Var2=FUNC22(Var1,Var7+2); 
STRUCT8 *Var42=FUNC23(Var24,Var46); 
STRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); 
char *Var47=FUNC24(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC19(Var1->memberVar5,Var18); 
const STRUCT5 *Var24=(const STRUCT5 *) FUNC25(Var7+2); 
STRUCT8 *Var42=FUNC23(Var24,Var46); 
STRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC19(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC19(Var1->memberVar5,Var19+1); 
",1953,0
before_cmd.c,r_core_cmd_subst_i,False,False,214,CWE-,CallExpression,free,2941,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
if (*Var9 == ){
char *Var28=FUNC9(Var1,Var2); 
if (Var27){
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
if (Var29){
char *Var30=FUNC11(STRING,Var29,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
FUNC12(Var1->memberVar8,Var9,Var31,1); 
free(Var31); 
else 
char *Var31=FUNC11(STRING,Var28); 
const char *Var32=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
const char *Var33=strstr(Var2,STRING); 
char *Var34,*Var8=strchr(Var7+1,!); 
STRUCT2  Var35=Var1->memberVar9; 
char *Var36=strdup(Var7+2); 
char *Var37=strchr(Var36,=); 
STRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var43=strdup(Var7+2); 
char  Var20=*Var44; 
STRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var46=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var48=Var7-2; 
else 
char  Var20=*Var49; 
char *Var50=Var7+3; 
char *Var51=Var7+3; 
char *Var19=strchr(Var51,); 
STRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); 
",1641,0
before_cmd.c,r_core_cmd_subst_i,False,False,215,CWE-,CallExpression,free,2946,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\tfree (n);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
if (*Var9 == ){
char *Var28=FUNC9(Var1,Var2); 
if (Var27){
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
char *Var30=FUNC11(STRING,Var29,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
FUNC12(Var1->memberVar8,Var9,Var31,1); 
free(Var31); 
const char *Var32=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
const char *Var33=strstr(Var2,STRING); 
char *Var34,*Var8=strchr(Var7+1,!); 
STRUCT2  Var35=Var1->memberVar9; 
char *Var36=strdup(Var7+2); 
char *Var37=strchr(Var36,=); 
STRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var43=strdup(Var7+2); 
char  Var20=*Var44; 
STRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var46=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var48=Var7-2; 
else 
char  Var20=*Var49; 
char *Var50=Var7+3; 
char *Var51=Var7+3; 
char *Var19=strchr(Var51,); 
STRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); 
",1633,0
before_cmd.c,r_core_cmd_subst_i,False,False,216,CWE-,CallExpression,free,2949,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
if (*Var9 == ){
char *Var28=FUNC9(Var1,Var2); 
if (Var27){
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
if (Var29){
char *Var30=FUNC11(STRING,Var29,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
else 
const char *Var32=FUNC12(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
const char *Var33=strstr(Var2,STRING); 
char *Var34,*Var8=strchr(Var7+1,!); 
STRUCT2  Var35=Var1->memberVar9; 
char *Var36=strdup(Var7+2); 
char *Var37=strchr(Var36,=); 
STRUCT2  Var35=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var38=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var39=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); 
char *Var43=strdup(Var7+2); 
char  Var20=*Var44; 
STRUCT2  Var35=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); 
char *Var45=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var46=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var47=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); 
char *Var48=Var7-2; 
else 
char  Var20=*Var49; 
char *Var50=Var7+3; 
char *Var51=Var7+3; 
char *Var19=strchr(Var51,); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var51); 
STRUCT2  Var53=FUNC14(Var1->memberVar5,Var19+1); 
",1617,0
before_cmd.c,r_core_cmd_subst_i,False,False,217,CWE-,CallExpression,free,2975,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tint pipefd = -1;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tstr = r_file_temp (""dumpedit"");\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\t\tr_file_rm (str);\n', '\t\t\tfree (str);\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
int  Var13=-1; 
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=1; 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
int  Var26=false ; 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
char *Var28=Var7-1; 
if (!strcmp(Var9,STRING)){
Var9=FUNC10(STRING); 
const bool  Var29=(Var7[1]== >); 
if (*Var9 == ){
char *Var30=FUNC11(Var1,Var2); 
if (Var29){
char *Var31=FUNC12(Var1->memberVar8,Var9,1); 
if (Var31){
char *Var32=FUNC13(STRING,Var31,Var30); 
if (Var32){
FUNC14(Var1->memberVar8,Var9,Var32,1); 
else 
char *Var33=FUNC13(STRING,Var30); 
FUNC14(Var1->memberVar8,Var9,Var33,1); 
else 
char *Var33=FUNC13(STRING,Var30); 
FUNC14(Var1->memberVar8,Var9,Var33,1); 
else 
}else if (Var24>0){
Var13=FUNC15(Var9,Var24,Var29); 
if (Var26){
const char *Var34=FUNC16(Var1->memberVar7,STRING); 
if (Var34&&*Var34){
FUNC17(STRING,Var34,Var9); 
FUNC18(Var9); 
free(Var9); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
const char *Var35=strstr(Var2,STRING); 
char *Var36,*Var8=strchr(Var7+1,!); 
STRUCT2  Var37=Var1->memberVar9; 
char *Var38=strdup(Var7+2); 
char *Var39=strchr(Var38,=); 
STRUCT2  Var37=FUNC19(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var40=(int ) FUNC20(Var1->memberVar5,Var7+2); 
STRUCT4 *Var41=FUNC21(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); 
char *Var45=strdup(Var7+2); 
char  Var20=*Var46; 
STRUCT2  Var37=FUNC20(Var1->memberVar5,Var7+2); 
char *Var2=FUNC23(Var1,Var7+2); 
STRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); 
char *Var47=FUNC24(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC20(Var1->memberVar5,Var18); 
const STRUCT6 *Var49=(const STRUCT6 *) FUNC25(Var7+2); 
STRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); 
char *Var50=Var7-2; 
else 
char  Var20=*Var51; 
char *Var52=Var7+3; 
char *Var53=Var7+3; 
char *Var19=strchr(Var53,); 
STRUCT2  Var54=FUNC20(Var1->memberVar5,Var53); 
STRUCT2  Var55=FUNC20(Var1->memberVar5,Var19+1); 
",1863,0
before_cmd.c,r_core_cmd_subst_i,False,False,218,CWE-,CallExpression,strchr,2990,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\t*ptr2 = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', ""\t\t*ptr = '@';\n"", '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
*Var7=0; 
if (FUNC11(Var1,Var2) == -1){
Var2=Var7+1; 
Var15=FUNC11(Var1,Var2); 
*Var7=; ; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC12(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC13(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC14(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC15(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC16(Var1,Var38,Var2); 
FUNC17(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC18()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var26){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var26){
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=1; 
int  Var41=FUNC19(Var1->memberVar8,STRING); 
int  Var42=false ; 
int  Var43=FUNC19(Var1->memberVar8,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC20(Var7[-2])){
char *Var44=Var7-1; 
const bool  Var45=(Var7[1]== >); 
if (*Var9 == ){
char *Var46=FUNC21(Var1,Var2); 
char *Var47=FUNC22(Var1->memberVar5,Var9,1); 
char *Var48=FUNC23(STRING,Var47,Var46); 
else 
char *Var49=FUNC23(STRING,Var46); 
else 
char *Var49=FUNC23(STRING,Var46); 
else 
}else if (Var40>0){
if (Var16 != -1){
Var15=FUNC11(Var1,Var2); 
const char *Var50=FUNC24(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
bool  Var51=false ; 
int  Var52=1; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var51){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var7=0; 
*Var8=0; 
if (Var7[1]== !){
Var9=FUNC25(Var1,Var7+1); 
else 
int  Var43=FUNC19(Var1->memberVar8,STRING); 
Var9=FUNC21(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var52&&Var9){
for (Var14=0; Var9[Var14]; Var14  Var26){
if (Var9[Var14]==  Var49){
Var9[Var14]=; 
Var9=FUNC26(Var9,Var8+1); 
Var2=FUNC26(strdup(Var2),Var9); 
Var15=FUNC11(Var1,Var2); 
free(Var2); 
free(Var9); 
return  Var15; 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var53=false ; 
if (Var53){
if (*Var2 != .){
Var11=FUNC27(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
Var22=Var1->memberVar9=Var7 true false ; 
int  Var54=0; 
if (Var7){
char *Var55,*Var8=strchr(Var7+1,!); 
STRUCT3  Var56=Var1->memberVar10; 
bool  Var57=false ; 
char *Var58=NULL ; 
const char *Var59=NULL ; 
bool  Var60=false ; 
bool  Var61=false ; 
char *Var62=NULL ; 
char *Var63=NULL ; 
bool  Var64=false ; 
int  Var65,Var66; 
STRUCT5 *Var39; 
*Var7  Var26=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var26){
if (*Var7&&Var7[1]== ){
else 
Var7  Var67; 
Var7=FUNC28(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var68=strdup(Var7+2); 
char *Var69=strchr(Var68,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+4); 
else 
Var56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var64=FUNC30(Var1->memberVar11,Var7+2); 
int  Var70=(int ) FUNC31(Var1->memberVar6,Var7+2); 
STRUCT6 *Var71=FUNC32(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var72=FUNC33(Var71,Var70); 
Var55=FUNC34(Var7+2,&Var65); 
if (Var55){
STRUCT8 *Var73=FUNC35((const STRUCT5 *) Var55,Var65); 
STRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); 
else 
FUNC5(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var76; 
char *Var77=strdup(Var7+2); 
char *Var78=FUNC37(Var77); 
if (Var78){
char  Var35=*Var78; 
else 
Var76=FUNC38(Var1->memberVar13,Var7+2); 
Var60=FUNC39(Var1,FUNC31(Var1->memberVar6,Var7+2),&Var58); 
STRUCT3  Var56=FUNC31(Var1->memberVar6,Var7+2); 
if (Var56){
FUNC14(Var1,STRING,Var7+2); 
char *Var2=FUNC40(Var1,Var7+2); 
if (!Var62){
Var62=Var2; 
else 
Var62=FUNC41(Var62,Var2); 
free(Var2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var66=FUNC42(Var7+2,Var39); 
STRUCT8 *Var73=FUNC35(Var39,Var66); 
STRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); 
char *Var79=FUNC43(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC44(Var1->memberVar1,FUNC45(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var80=FUNC31(Var1->memberVar6,Var29); 
Var61=FUNC46(Var1,Var7+2,&Var63); 
Var66=strlen(Var7+2); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC47(Var7+2); 
STRUCT8 *Var73=FUNC35(Var39,Var66); 
STRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); 
*Var7=; 
char *Var81=Var7-2; 
while (Var81>Var2){
if (!FUNC48(*Var81)){
Var7=FUNC49(Var7+1)-1; 
Var2=FUNC12(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var59=FUNC49(Var7+1); 
if (FUNC50((STRUCT5) Var7[1])&&!Var56){
if (!FUNC51(Var1->memberVar11,Var7+1)){
FUNC5(STRING,Var7+1); 
else 
char  Var35=*Var59; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var82=Var7+3; 
Var15=FUNC52(Var1,Var2,Var82); 
else 
Var15=FUNC53(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var83[]={STRING,STRING,STRING,
const char *Var84[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var25=strchr(Var85,); 
if (!Var25){
STRUCT3  Var86=FUNC31(Var1->memberVar6,Var85); 
STRUCT3  Var87=FUNC31(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC49(Var2)); 
else 
if (Var57){
Var15=FUNC3(Var1->memberVar5,FUNC49(Var2)); 
*Var7=; 
Var54=Var2 FUNC3(Var1->memberVar5,FUNC49(Var2)) false ; 
",4280,0
before_cmd.c,r_core_cmd_subst_i,False,False,219,CWE-,CallExpression,memmove,2995,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
before_cmd.c,r_core_cmd_subst_i,False,False,220,CWE-,CallExpression,strlen,2995,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
before_cmd.c,r_core_cmd_subst_i,False,False,221,CWE-,CallExpression,memmove,3002,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
before_cmd.c,r_core_cmd_subst_i,False,False,222,CWE-,CallExpression,strlen,3002,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
before_cmd.c,r_core_cmd_subst_i,False,False,223,CWE-,CallExpression,strchr,3006,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\t*ptr2 = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
*Var8=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var9=FUNC13(Var9,Var8+1); 
Var2=FUNC13(strdup(Var2),Var9); 
Var12=FUNC14(Var1,Var2); 
free(Var2); 
free(Var9); 
return  Var12; 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC15(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC16(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC17(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC16(Var1->memberVar5,Var7+2); 
char *Var2=FUNC19(Var1,Var7+2); 
STRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC16(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC21(Var7+2); 
STRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC16(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC16(Var1->memberVar5,Var19+1); 
",1832,0
before_cmd.c,r_core_cmd_subst_i,False,False,224,CWE-,CallExpression,free,3033,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tfree (str);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
bool  Var31=false ; 
int  Var32=1; 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var32&&Var9){
for (Var11=0; Var9[Var11]; Var11  Var23){
if (Var9[Var11]==  Var33){
Var9[Var11]=; 
Var9=FUNC13(Var9,Var8+1); 
Var2=FUNC13(strdup(Var2),Var9); 
free(Var9); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar9; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var47=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); 
",1799,0
before_cmd.c,r_core_cmd_subst_i,False,False,225,CWE-,CallExpression,strdup,3044,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
int  Var50=1; 
Var8=strchr(Var7+1,); 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
if (Var7[1]== !){
Var9=FUNC24(Var1,Var7+1); 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
Var9=FUNC19(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var50&&Var9){
for (Var14=0; Var9[Var14]; Var14  Var26){
if (Var9[Var14]==  Var47){
Var9[Var14]=; 
Var9=FUNC25(Var9,Var8+1); 
Var2=FUNC25(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
free(Var9); 
return  Var15; 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC26(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var63=strdup(Var7+2); 
char *Var64=strchr(Var63,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var65=(int ) FUNC28(Var1->memberVar6,Var7+2); 
STRUCT5 *Var66=FUNC29(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); 
char *Var70=strdup(Var7+2); 
char  Var34=*Var71; 
STRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
STRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); 
char *Var72=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var73=FUNC28(Var1->memberVar6,Var29); 
const STRUCT6 *Var74=(const STRUCT6 *) FUNC33(Var7+2); 
STRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); 
char *Var75=Var7-2; 
while (Var75>Var2){
if (!FUNC34(*Var75)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC35((STRUCT6) Var7[1])&&!Var54){
if (!FUNC36(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var57; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
Var15=FUNC37(Var1,Var2,Var76); 
else 
Var15=FUNC38(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC28(Var1->memberVar6,Var79); 
STRUCT3  Var81=FUNC28(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; 
",3283,0
before_cmd.c,r_core_cmd_subst_i,False,False,226,CWE-,CallExpression,free,3047,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
Var8=strchr(Var7+1,); 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
if (Var7[1]== !){
Var9=FUNC24(Var1,Var7+1); 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
Var9=FUNC19(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var9=FUNC25(Var9,Var8+1); 
Var2=FUNC25(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC26(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC28(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC29(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC28(Var1->memberVar6,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
STRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC28(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC33(Var7+2); 
STRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC34(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC35((STRUCT6) Var7[1])&&!Var53){
if (!FUNC36(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC37(Var1,Var2,Var75); 
else 
Var15=FUNC38(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC28(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC28(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; 
",3193,0
before_cmd.c,r_core_cmd_subst_i,False,False,227,CWE-,CallExpression,free,3051,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tfree (str);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
bool  Var31=false ; 
int  Var32=1; 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var32&&Var9){
for (Var11=0; Var9[Var11]; Var11  Var23){
if (Var9[Var11]==  Var33){
Var9[Var11]=; 
Var9=FUNC13(Var9,Var8+1); 
Var2=FUNC13(strdup(Var2),Var9); 
free(Var9); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar9; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var47=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); 
",1812,0
before_cmd.c,r_core_cmd_subst_i,False,False,228,CWE-,CallExpression,strstr,3059,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (cmd == s) {\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var2 ==  Var27){
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3131,0
before_cmd.c,r_core_cmd_subst_i,False,False,229,CWE-,CallExpression,strcmp,3069,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tif (cmd == s) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
bool  Var31=false ; 
if (Var31){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var32=strstr(Var2,STRING); 
if (Var32){
if (Var2 ==  Var32){
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC12(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC13(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC14(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var7+2); 
char *Var2=FUNC16(Var1,Var7+2); 
STRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC17(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC13(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC18(Var7+2); 
STRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC13(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC13(Var1->memberVar5,Var19+1); 
",1618,0
before_cmd.c,r_core_cmd_subst_i,False,False,230,CWE-,CallExpression,strchr,3087,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""The current basic block has %d instructions\\n"", bb->ninstr);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\tif (tmpseek) {\n', '\t\t*tmpseek = cmd_tmpseek;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
int  Var28=-1; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var29,*Var30; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var31; 
Var30=*Var2 FUNC5(Var2) NULL ; 
if (!Var30||!*Var30){
FUNC6(STRINGFUNC7(%Var32).,Var2); 
else 
char *Var33=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var33){
char *Var34=strchr(Var30+1,); 
const bool  Var35=Var30[2]== >; 
Var29=strdup(Var2); 
if (Var30&&*Var30&&Var30[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var30){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38
if (Var9&&(Var9[1]== ||Var9[1]==  Var39)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var41=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var42=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var43=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var43,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var31){
char  Var44[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var31){
if (!*Var11){
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var45=1; 
int  Var46=FUNC20(Var1->memberVar8,STRING); 
int  Var47=false ; 
int  Var48=FUNC20(Var1->memberVar8,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC21(Var9[-2])){
char *Var49=Var9-1; 
const bool  Var50=(Var9[1]== >); 
if (*Var11 == ){
char *Var51=FUNC22(Var1,Var2); 
char *Var52=FUNC23(Var1->memberVar5,Var11,1); 
char *Var53=FUNC24(STRING,Var52,Var51); 
else 
char *Var54=FUNC24(STRING,Var51); 
else 
char *Var54=FUNC24(STRING,Var51); 
else 
}else if (Var45>0){
if (Var18 != -1){
Var17=FUNC12(Var1,Var2); 
const char *Var55=FUNC25(Var1->memberVar8,STRING); 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
bool  Var56=false ; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var56){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
if (Var9[1]== !){
Var11=FUNC26(Var1,Var9+1); 
else 
int  Var48=FUNC20(Var1->memberVar8,STRING); 
Var11=FUNC22(Var1,Var9+1); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
Var2=FUNC27(strdup(Var2),Var11); 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var32=strstr(Var2,STRING); 
if (Var32){
bool  Var57=false ; 
if (Var57){
if (*Var2 != .){
Var13=FUNC28(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar9=Var9 true false ; 
int  Var58=0; 
if (Var9){
char *Var59,*Var10=strchr(Var9+1,!); 
STRUCT4  Var60=Var1->memberVar10; 
bool  Var61=false ; 
char *Var62=NULL ; 
const char *Var63=NULL ; 
bool  Var64=false ; 
bool  Var65=false ; 
char *Var66=NULL ; 
char *Var67=NULL ; 
bool  Var68=false ; 
int  Var69=-1; 
int  Var70,Var71; 
STRUCT6 *Var44; 
*Var9  Var31=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var31){
if (*Var9&&Var9[1]== ){
else 
Var9  Var72; 
Var9=FUNC29(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var73=strdup(Var9+2); 
char *Var74=strchr(Var73,=); 
if (Var74){
*Var74  Var31=0; 
FUNC30(Var73,Var74); 
FUNC31(Var5,Var73); 
else 
free(Var73); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); 
FUNC33(Var1,FUNC34((Var75) Var60-(Var75) Var1->memberVar10)); 
else 
Var60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); 
FUNC35(Var1,Var60,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var68=FUNC36(Var1->memberVar11,Var9+2); 
int  Var76=(int ) FUNC37(Var1->memberVar6,Var9+2); 
STRUCT7 *Var77=FUNC38(Var1->memberVar12,Var1->memberVar10); 
if (Var77){
if (Var76<0){
Var76=Var77->memberVar1+Var76; 
if (Var76 >= 0&&Var76<Var77->memberVar1){
STRUCT8  Var78=FUNC39(Var77,Var76); 
FUNC35(Var1,Var77->memberVar2+Var78,1); 
else 
FUNC6(STRING,Var77->memberVar1); 
Var59=FUNC40(Var9+2,&Var70); 
if (Var59){
STRUCT9 *Var79=FUNC41((const STRUCT6 *) Var59,Var70); 
STRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); 
if (Var80){
if (Var14){
FUNC43(Var14); 
Var14=Var80; 
if (Var15){
FUNC44(Var1->memberVar8,STRING,1); 
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); 
if (Var44){
free(Var1->memberVar13); 
memcpy(Var1->memberVar13,Var59,Var70); 
free(Var59); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var82; 
char *Var83=strdup(Var9+2); 
char *Var84=FUNC47(Var83); 
if (Var84){
char  Var40=*Var84; 
*Var84=0; 
Var82=FUNC48(Var1->memberVar14,Var83); 
*Var84=Var40; 
Var82=FUNC37(Var1->memberVar6,Var85); 
else 
Var82=FUNC48(Var1->memberVar14,Var9+2); 
FUNC35(Var1,Var82,1); 
free(Var83); 
Var64=FUNC49(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var62); 
Var28=FUNC20(Var1->memberVar8,STRING); 
FUNC44(Var1->memberVar8,STRING,1); 
STRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC50(Var1,Var9+2); 
if (!Var66){
Var66=Var2; 
else 
Var66=FUNC51(Var66,Var2); 
free(Var2); 
if (Var9[1]== ){
Var44=malloc(strlen(Var9+2)+1); 
if (Var44){
Var71=FUNC52(Var9+2,Var44); 
FUNC33(Var1,FUNC34(Var71)); 
if (Var71>0){
STRUCT9 *Var79=FUNC41(Var44,Var71); 
STRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); 
if (Var80){
if (Var14){
FUNC43(Var14); 
Var14=Var80; 
if (Var15){
FUNC44(Var1->memberVar8,STRING,1); 
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); 
FUNC33(Var1,Var71); 
free(Var44); 
char *Var86=FUNC53(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var86){
FUNC35(Var1,FUNC37(Var1->memberVar6,Var86),1); 
free(Var86); 
if (Var9[1]== ){
Var69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC54(Var1->memberVar1,FUNC55(Var9+2)); 
if (Var9[1]== ){
char *Var34=strchr(Var9+2,); 
if (Var34){
*Var34  Var31=0; 
int  Var87=FUNC37(Var1->memberVar6,Var34); 
Var64=FUNC49(Var1,Var87,&Var62); 
Var65=FUNC56(Var1,Var9+2,&Var67); 
Var71=strlen(Var9+2); 
FUNC33(Var1,Var71); 
const STRUCT6 *Var44=(const STRUCT6 *) FUNC57(Var9+2); 
if (Var71>0){
STRUCT9 *Var79=FUNC41(Var44,Var71); 
STRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); 
if (!Var1->memberVar1->memberVar1){
FUNC44(Var1->memberVar8,STRING,1); 
if (Var80){
if (Var14){
FUNC43(Var14); 
Var14=Var80; 
if (Var15){
FUNC44(Var1->memberVar8,STRING,1); 
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); 
FUNC33(Var1,Var71); 
*Var9=; 
char *Var88=Var9-2; 
while (Var88>Var2){
if (!FUNC58(*Var88)){
*Var88=0; 
Var88  Var72; 
Var9=FUNC59(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
else 
*Var10=0; 
if (!Var10[1]){
FUNC33(
Var1,FUNC37(Var1->memberVar6,Var10+1)); 
Var63=FUNC59(Var9+1); 
memberVar2=FUNC37(Var1->memberVar6,Var63); 
if (FUNC60((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC61(Var1->memberVar11,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var40=*Var63; 
if (Var40 == -||Var40 == +){
memberVar2=Var1->memberVar10+memberVar2; 
if (memberVar2){
STRUCT3 *Var80=Var14; 
if (Var80){
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,memberVar2,FUNC62(Var80)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar16=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var89=Var9+3; 
while (*Var89&&*Var89 == ){
Var89  Var31; 
Var17=FUNC63(Var1,Var2,Var89); 
else 
Var17=FUNC64(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var90[]={STRING,STRING,STRING,
const char *Var91[]={STRING,STRING,STRING,
STRUCT4  Var92[FUNC65(Var90)-1],Var93[FUNC65(Var91)-1]; 
if (Var9[1]== (){
char *Var94=Var9+3; 
char *Var30=strchr(Var94,); 
if (!Var30){
free(Var66); 
*Var30=Var95; 
STRUCT4  Var96=FUNC37(Var1->memberVar6,Var94); 
STRUCT4  Var97=FUNC37(Var1->memberVar6,Var30+1); 
for (Var16=0; Var90[Var16]; Var16  Var31){
Var92[Var16]=FUNC20(Var1->memberVar8,Var90[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var31){
Var93[Var16]=FUNC20(Var1->memberVar8,Var91[Var16]); 
for (Var16=0; Var90[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var90[Var16],Var96); 
for (Var16=0; Var91[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var91[Var16],Var97); 
if (Var19){
if (Var61){
Var1->memberVar10=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC59(Var2)); 
else 
if (Var61){
if (Var9[1]){
FUNC35(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC59(Var2)); 
if (memberVar9){
for (Var16=0; Var90[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var90[Var16],Var92[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var91[Var16],Var93[Var16]); 
if (Var10){
*Var10=!; 
if (Var69 != -1){
FUNC54(Var1->memberVar1,Var69); 
if (Var14){
if (Var15){
FUNC44(Var1->memberVar8,STRING,0); 
FUNC43(Var14); 
if (Var64){
FUNC66(Var1->memberVar8,STRING,Var62); 
if (Var66){
FUNC8(Var1,Var66); 
FUNC67(Var66); 
if (Var68){
FUNC68(Var1->memberVar11); 
*Var9=; 
Var58=Var17; 
Var58=Var2 FUNC4(Var1->memberVar5,FUNC59(Var2)) false ; 
if (Var20 != -1){
FUNC44(Var1->memberVar8,STRING,Var20); 
if (Var21 != -1){
FUNC44(Var1->memberVar8,STRING,Var21); 
if (Var14){
FUNC43(Var14); 
if (memberVar9){
*memberVar9=Var26; 
if (Var28 != -1){
FUNC44(Var1->memberVar8,STRING,Var28); 
return  Var58; 
",5915,0
before_cmd.c,r_core_cmd_subst_i,False,False,231,CWE-,CallExpression,strchr,3098,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
char  Var33[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
if (Var7[0]&&Var7[1]== ){
int  Var34=FUNC8(Var1->memberVar7,STRING); 
int  Var35=false ; 
int  Var36=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var37=Var7-1; 
const bool  Var38=(Var7[1]== >); 
char *Var39=FUNC9(Var1,Var2); 
char *Var40=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var41=FUNC11(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
bool  Var42=false ; 
if (Var42){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var36=FUNC8(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var43=strstr(Var2,STRING); 
if (Var43){
bool  Var44=false ; 
if (Var44){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var45,*Var8=strchr(Var7+1,!); 
STRUCT3  Var46=Var1->memberVar10; 
bool  Var47=false ; 
char *Var48=NULL ; 
const char *Var49=NULL ; 
bool  Var50=false ; 
bool  Var51=false ; 
char *Var52=NULL ; 
char *Var53=NULL ; 
bool  Var54=false ; 
int  Var55,Var56; 
STRUCT5 *Var33; 
*Var7  Var32=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var32){
if (*Var7&&Var7[1]== ){
else 
Var7  Var57; 
Var7=FUNC12(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var58=strdup(Var7+2); 
char *Var59=strchr(Var58,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var54=FUNC14(Var1->memberVar11,Var7+2); 
int  Var60=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var61=FUNC16(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var62=FUNC17(Var61,Var60); 
Var45=FUNC18(Var7+2,&Var55); 
if (Var45){
STRUCT8 *Var63=FUNC19((const STRUCT5 *) Var45,Var55); 
STRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); 
else 
FUNC21(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var66; 
char *Var67=strdup(Var7+2); 
char *Var68=FUNC22(Var67); 
if (Var68){
char  Var29=*Var68; 
else 
Var66=FUNC23(Var1->memberVar13,Var7+2); 
Var50=FUNC24(Var1,FUNC15(Var1->memberVar5,Var7+2),&Var48); 
STRUCT3  Var46=FUNC15(Var1->memberVar5,Var7+2); 
if (Var46){
FUNC25(Var1,STRING,Var7+2); 
char *Var2=FUNC26(Var1,Var7+2); 
if (Var7[1]== ){
Var33=malloc(strlen(Var7+2)+1); 
if (Var33){
Var56=FUNC27(Var7+2,Var33); 
STRUCT8 *Var63=FUNC19(Var33,Var56); 
STRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); 
char *Var69=FUNC28(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC29(Var1->memberVar1,FUNC30(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var70=FUNC15(Var1->memberVar5,Var27); 
Var51=FUNC31(Var1,Var7+2,&Var53); 
Var56=strlen(Var7+2); 
const STRUCT5 *Var33=(const STRUCT5 *) FUNC32(Var7+2); 
STRUCT8 *Var63=FUNC19(Var33,Var56); 
STRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); 
*Var7=; 
char *Var71=Var7-2; 
Var7=FUNC33(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC34(
Var1,FUNC15(Var1->memberVar5,Var8+1)); 
Var49=FUNC33(Var7+1); 
if (FUNC35((STRUCT5) Var7[1])&&!Var46){
if (!FUNC36(Var1->memberVar11,Var7+1)){
FUNC21(STRING,Var7+1); 
else 
char  Var29=*Var49; 
STRUCT2 *Var64=Var12; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var72=Var7+3; 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var73[]={STRING,STRING,STRING,
const char *Var74[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var75=Var7+3; 
char *Var25=strchr(Var75,); 
if (!Var25){
STRUCT3  Var76=FUNC15(Var1->memberVar5,Var75); 
STRUCT3  Var77=FUNC15(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var47){
if (Var8){
*Var8=!; 
*Var7=; 
",2977,0
before_cmd.c,r_core_cmd_subst_i,False,False,232,CWE-,CallExpression,strchr,3114,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\thaveQuote = q != NULL;\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_break_push (NULL, NULL);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\t\tarroba = NULL;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\ttmpdesc = NULL;\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\t\ttmpdesc = NULL;\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
for (; *Var2; ){
char *Var28,*Var29; 
if (Var23){
Var29=*Var2 FUNC4(Var2) NULL ; 
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var23=Var31 != NULL ; 
const bool  Var32=Var29[2]== >; 
if (!Var29){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC5(Var2,,STRING); //Var33  Var34  Var7  Var35
if (Var9&&(Var9[1]== ||Var9[1]==  Var36)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC6(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var37=Var9-1; 
if (*Var37 == ){
memmove(Var37,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC7(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC8(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var38=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var39=FUNC10(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC6(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var40){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
if (Var2<Var9&&Var9[-1]== ){
FUNC11(NULL ,NULL ); 
FUNC12(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC13()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var40){
char  Var41[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var40){
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC5(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var37=Var9-1; 
if (*Var37 == ){
memmove(Var37,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var42=FUNC14(Var1->memberVar7,STRING); 
int  Var43=false ; 
int  Var44=FUNC14(Var1->memberVar7,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC15(Var9[-2])){
char *Var45=Var9-1; 
const bool  Var46=(Var9[1]== >); 
char *Var47=FUNC16(Var1,Var2); 
char *Var48=FUNC17(Var1->memberVar8,Var11,1); 
const char *Var49=FUNC18(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var37=Var9-1; 
if (*Var37 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var44=FUNC14(Var1->memberVar7,STRING); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
if (*Var2 != &&*Var2){
const char *Var51=strstr(Var2,STRING); 
if (Var51){
bool  Var52=false ; 
if (Var52){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
Var26=Var1->memberVar9=Var9 true false ; 
int  Var53=0; 
if (Var9){
char *Var54,*Var10=strchr(Var9+1,!); 
STRUCT4  Var55=Var1->memberVar10; 
bool  Var56=false ; 
char *Var57=NULL ; 
const char *Var58=NULL ; 
bool  Var59=false ; 
bool  Var60=false ; 
char *Var61=NULL ; 
char *Var62=NULL ; 
bool  Var63=false ; 
int  Var64=-1; 
int  Var65,Var66; 
STRUCT6 *Var41; 
*Var9  Var40=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var40){
if (*Var9&&Var9[1]== ){
else 
Var9  Var67; 
Var9=FUNC19(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var68=strdup(Var9+2); 
char *Var69=strchr(Var68,=); 
if (Var69){
*Var69  Var40=0; 
FUNC20(Var68,Var69); 
FUNC21(Var5,Var68); 
else 
free(Var68); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+4); 
FUNC23(Var1,FUNC24((Var70) Var55-(Var70) Var1->memberVar10)); 
else 
Var55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+3); 
FUNC25(Var1,Var55,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var63=FUNC26(Var1->memberVar11,Var9+2); 
int  Var71=(int ) FUNC27(Var1->memberVar5,Var9+2); 
STRUCT7 *Var72=FUNC28(Var1->memberVar12,Var1->memberVar10); 
if (Var72){
if (Var71<0){
Var71=Var72->memberVar1+Var71; 
if (Var71 >= 0&&Var71<Var72->memberVar1){
STRUCT8  Var73=FUNC29(Var72,Var71); 
FUNC25(Var1,Var72->memberVar2+Var73,1); 
Var54=FUNC30(Var9+2,&Var65); 
if (Var54){
STRUCT9 *Var74=FUNC31((const STRUCT6 *) Var54,Var65); 
STRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); 
if (Var75){
if (Var14){
FUNC33(Var14); 
Var14=Var75; 
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); 
if (Var41){
memcpy(Var1->memberVar13,Var54,Var65); 
free(Var54); 
else 
FUNC36(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var77; 
char *Var78=strdup(Var9+2); 
char *Var79=FUNC37(Var78); 
if (Var79){
char  Var37=*Var79; 
*Var79=0; 
Var77=FUNC38(Var1->memberVar14,Var78); 
*Var79=Var37; 
else 
Var77=FUNC38(Var1->memberVar14,Var9+2); 
FUNC25(Var1,Var77,1); 
free(Var78); 
Var59=FUNC39(Var1,FUNC27(Var1->memberVar5,Var9+2),&Var57); 
STRUCT4  memberVar2=FUNC27(Var1->memberVar5,Var9+2); 
if (memberVar2){
FUNC40(Var1,STRING,Var9+2); 
char *Var2=FUNC41(Var1,Var9+2); 
if (!Var61){
Var61=Var2; 
else 
Var61=FUNC42(Var61,Var2); 
free(Var2); 
if (Var9[1]== ){
Var41=malloc(strlen(Var9+2)+1); 
if (Var41){
Var66=FUNC43(Var9+2,Var41); 
FUNC23(Var1,FUNC24(Var66)); 
if (Var66>0){
STRUCT9 *Var74=FUNC31(Var41,Var66); 
STRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); 
if (Var75){
if (Var14){
FUNC33(Var14); 
Var14=Var75; 
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); 
FUNC23(Var1,Var66); 
free(Var41); 
char *Var80=FUNC44(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var80){
FUNC25(Var1,FUNC27(Var1->memberVar5,Var80),1); 
free(Var80); 
if (Var9[1]== ){
FUNC45(Var1->memberVar1,FUNC46(Var9+2)); 
if (Var9[1]== ){
char *Var31=strchr(Var9+2,); 
if (Var31){
*Var31  Var40=0; 
int  Var81=FUNC27(Var1->memberVar5,Var31); 
Var59=FUNC39(Var1,Var81,&Var57); 
Var60=FUNC47(Var1,Var9+2,&Var62); 
Var66=strlen(Var9+2); 
FUNC23(Var1,Var66); 
const STRUCT6 *Var41=(const STRUCT6 *) FUNC48(Var9+2); 
if (Var66>0){
STRUCT9 *Var74=FUNC31(Var41,Var66); 
STRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); 
if (Var75){
if (Var14){
FUNC33(Var14); 
Var14=Var75; 
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); 
FUNC23(Var1,Var66); 
*Var9=; 
char *Var82=Var9-2; 
while (Var82>Var2){
if (!FUNC49(*Var82)){
*Var82=0; 
Var82  Var67; 
Var9=FUNC50(Var9+1)-1; 
Var2=FUNC7(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var58=FUNC50(Var9+1); 
memberVar2=FUNC27(Var1->memberVar5,Var58); 
if (FUNC51((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC52(Var1->memberVar11,Var9+1)){
FUNC36(STRING,Var9+1); 
else 
char  Var37=*Var58; 
if (Var37 == -||Var37 == +){
memberVar2=Var1->memberVar10+memberVar2; 
if (memberVar2){
STRUCT3 *Var75=Var14; 
if (Var75){
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,memberVar2,FUNC53(Var75)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var12=NULL ; 
Var1->memberVar16=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var83=Var9+3; 
while (*Var83&&*Var83 == ){
Var83  Var40; 
Var17=FUNC54(Var1,Var2,Var83); 
else 
Var17=FUNC55(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var84[]={STRING,STRING,STRING,
const char *Var85[]={STRING,STRING,STRING,
STRUCT4  Var86[FUNC56(Var84)-1],Var87[FUNC56(Var85)-1]; 
if (Var9[1]== (){
char *Var88=Var9+3; 
char *Var29=strchr(Var88,); 
if (!Var29){
free(Var61); 
*Var29=Var89; 
STRUCT4  Var90=FUNC27(Var1->memberVar5,Var88); 
STRUCT4  Var91=FUNC27(Var1->memberVar5,Var29+1); 
for (Var16=0; Var84[Var16]; Var16  Var40){
Var86[Var16]=FUNC14(Var1->memberVar7,Var84[Var16]); 
for (Var16=0; Var85[Var16]; Var16  Var40){
Var87[Var16]=FUNC14(Var1->memberVar7,Var85[Var16]); 
for (Var16=0; Var84[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var84[Var16],Var90); 
for (Var16=0; Var85[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var85[Var16],Var91); 
if (Var19){
if (Var56){
Var1->memberVar10=memberVar2; 
Var17=FUNC58(Var1->memberVar8,FUNC50(Var2)); 
else 
if (Var56){
if (Var9[1]){
FUNC25(Var1,memberVar2,1); 
Var17=FUNC58(Var1->memberVar8,FUNC50(Var2)); 
if (memberVar9){
for (Var16=0; Var84[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var84[Var16],Var86[Var16]); 
for (Var16=0; Var85[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var85[Var16],Var87[Var16]); 
if (Var64 != -1){
FUNC45(Var1->memberVar1,Var64); 
if (Var14){
if (Var15){
FUNC57(Var1->memberVar7,STRING,0); 
FUNC33(Var14); 
Var14=NULL ; 
if (Var59){
FUNC59(Var1->memberVar7,STRING,Var57); 
if (Var61){
FUNC60(Var1,Var61); 
FUNC61(Var61); 
if (Var63){
FUNC62(Var1->memberVar11); 
*Var9=; 
Var53=Var17; 
Var53=Var2 FUNC58(Var1->memberVar8,FUNC50(Var2)) false ; 
if (Var20 != -1){
FUNC57(Var1->memberVar7,STRING,Var20); 
if (Var21 != -1){
FUNC57(Var1->memberVar7,STRING,Var21); 
if (Var14){
FUNC33(Var14); 
Var14=NULL ; 
return  Var53; 
",5129,0
before_cmd.c,r_core_cmd_subst_i,False,False,233,CWE-,CallExpression,strdup,3134,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT4  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC4(Var2,,STRING); //Var31  Var32  Var7  Var33
if (Var9&&(Var9[1]== ||Var9[1]==  Var34)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC5(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var35=Var9-1; 
if (*Var35 == ){
memmove(Var35,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC6(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC7(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var9+1); 
else 
char *Var37=FUNC9(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC5(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var38){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
if (Var2<Var9&&Var9[-1]== ){
FUNC10(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC11()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var38){
char  Var39[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var38){
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC4(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var35=Var9-1; 
if (*Var35 == ){
memmove(Var35,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var40=FUNC12(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC12(Var1->memberVar7,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC13(Var9[-2])){
char *Var43=Var9-1; 
const bool  Var44=(Var9[1]== >); 
char *Var45=FUNC14(Var1,Var2); 
char *Var46=FUNC15(Var1->memberVar8,Var11,1); 
const char *Var47=FUNC16(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var35=Var9-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC12(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
Var24=Var1->memberVar9=Var9 true false ; 
if (Var9){
char *Var51,*Var10=strchr(Var9+1,!); 
STRUCT4  Var52=Var1->memberVar10; 
bool  Var53=false ; 
char *Var54=NULL ; 
const char *Var55=NULL ; 
bool  Var56=false ; 
bool  Var57=false ; 
char *Var58=NULL ; 
char *Var59=NULL ; 
bool  Var60=false ; 
int  Var61,Var62; 
STRUCT6 *Var39; 
*Var9  Var38=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
for (; *Var9 == ; Var9  Var38){
if (*Var9&&Var9[1]== ){
else 
Var9  Var63; 
Var9=FUNC17(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var64=strdup(Var9+2); 
char *Var65=strchr(Var64,=); 
if (Var65){
*Var65  Var38=0; 
FUNC18(Var64,Var65); 
FUNC19(Var5,Var64); 
else 
free(Var64); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+4); 
else 
Var52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+3); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var60=FUNC21(Var1->memberVar11,Var9+2); 
int  Var66=(int ) FUNC22(Var1->memberVar5,Var9+2); 
STRUCT7 *Var67=FUNC23(Var1->memberVar12,Var1->memberVar10); 
STRUCT8  Var68=FUNC24(Var67,Var66); 
Var51=FUNC25(Var9+2,&Var61); 
if (Var51){
STRUCT9 *Var69=FUNC26((const STRUCT6 *) Var51,Var61); 
STRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); 
else 
FUNC28(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var72; 
char *Var73=strdup(Var9+2); 
char *Var74=FUNC29(Var73); 
if (Var74){
char  Var35=*Var74; 
else 
Var72=FUNC30(Var1->memberVar13,Var9+2); 
Var56=FUNC31(Var1,FUNC22(Var1->memberVar5,Var9+2),&Var54); 
STRUCT4  Var52=FUNC22(Var1->memberVar5,Var9+2); 
if (Var52){
FUNC32(Var1,STRING,Var9+2); 
char *Var2=FUNC33(Var1,Var9+2); 
if (Var9[1]== ){
Var39=malloc(strlen(Var9+2)+1); 
if (Var39){
Var62=FUNC34(Var9+2,Var39); 
STRUCT9 *Var69=FUNC26(Var39,Var62); 
STRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); 
char *Var75=FUNC35(Var1->memberVar14,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var9[1]== ){
FUNC36(Var1->memberVar1,FUNC37(Var9+2)); 
if (Var9[1]== ){
char *Var29=strchr(Var9+2,); 
int  Var76=FUNC22(Var1->memberVar5,Var29); 
Var57=FUNC38(Var1,Var9+2,&Var59); 
Var62=strlen(Var9+2); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC39(Var9+2); 
STRUCT9 *Var69=FUNC26(Var39,Var62); 
STRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); 
*Var9=; 
char *Var77=Var9-2; 
Var9=FUNC40(Var9+1)-1; 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var55=FUNC40(Var9+1); 
if (FUNC41((STRUCT6) Var9[1])&&!Var52){
if (!FUNC42(Var1->memberVar11,Var9+1)){
FUNC28(STRING,Var9+1); 
else 
char  Var35=*Var55; 
STRUCT3 *Var70=Var14; 
if (Var12){
Var9=Var12+1; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var78=Var9+3; 
else 
Var17=FUNC43(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var79[]={STRING,STRING,STRING,
const char *Var80[]={STRING,STRING,STRING,
if (Var9[1]== (){
char *Var81=Var9+3; 
char *Var27=strchr(Var81,); 
if (!Var27){
STRUCT4  Var82=FUNC22(Var1->memberVar5,Var81); 
STRUCT4  Var83=FUNC22(Var1->memberVar5,Var27+1); 
if (Var19){
else 
if (Var53){
*Var9=; 
",3388,0
before_cmd.c,r_core_cmd_subst_i,False,False,234,CWE-,CallExpression,strchr,3135,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=Var1->memberVar2; 
bool  Var20=Var1->memberVar3; 
STRUCT4  Var21=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var24+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27
if (Var9&&(Var9[1]== ||Var9[1]==  Var28)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC5(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC6(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC7(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC8(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC5(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC9()->memberVar1){
if (Var9[1]== <){
int  Var17; 
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC4(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
if (Var9[0]&&Var9[1]== ){
int  Var33=FUNC10(Var1->memberVar7,STRING); 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
*Var9=0; 
if (!*Var11){
char *Var35=Var9-1; 
const bool  Var36=(Var9[1]== >); 
char *Var37=FUNC11(Var1,Var2); 
char *Var38=FUNC12(Var1->memberVar8,Var11,1); 
const char *Var39=FUNC13(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
if (Var9){
char *Var43,*Var10=strchr(Var9+1,!); 
STRUCT4  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var9  Var32=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
for (; *Var9 == ; Var9  Var32){
if (*Var9&&Var9[1]== ){
else 
Var9  Var49; 
Var9=FUNC14(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var50=strdup(Var9+2); 
char *Var51=strchr(Var50,=); 
if (Var51){
*Var51  Var32=0; 
FUNC15(Var50,Var51); 
FUNC16(Var5,Var50); 
else 
free(Var50); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
STRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
int  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); 
STRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var9+2); 
char  Var29=*Var58; 
STRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); 
char *Var2=FUNC21(Var1,Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); 
char *Var23=strchr(Var9+2,); 
int  Var60=FUNC18(Var1->memberVar5,Var23); 
const STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
*Var9=; 
char *Var62=Var9-2; 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
if (FUNC24((STRUCT7) Var9[1])&&!Var44){
if (!FUNC25(Var1->memberVar12,Var9+1)){
else 
char  Var29=*Var46; 
STRUCT3 *Var54=Var14; 
if (Var12){
Var9=Var12+1; 
char *Var63=Var9+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var9+3; 
char *Var24=strchr(Var66,); 
STRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); 
STRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); 
",2456,0
before_cmd.c,r_core_cmd_subst_i,False,False,235,CWE-,CallExpression,free,3141,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=Var1->memberVar2; 
bool  Var20=Var1->memberVar3; 
STRUCT4  Var21=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var24+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27
if (Var9&&(Var9[1]== ||Var9[1]==  Var28)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC5(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC6(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC7(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC8(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC5(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC9()->memberVar1){
if (Var9[1]== <){
int  Var17; 
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC4(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
if (Var9[0]&&Var9[1]== ){
int  Var33=FUNC10(Var1->memberVar7,STRING); 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
*Var9=0; 
if (!*Var11){
char *Var35=Var9-1; 
const bool  Var36=(Var9[1]== >); 
char *Var37=FUNC11(Var1,Var2); 
char *Var38=FUNC12(Var1->memberVar8,Var11,1); 
const char *Var39=FUNC13(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
if (Var9){
char *Var43,*Var10=strchr(Var9+1,!); 
STRUCT4  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var9  Var32=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
for (; *Var9 == ; Var9  Var32){
if (*Var9&&Var9[1]== ){
else 
Var9  Var49; 
Var9=FUNC14(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var50=strdup(Var9+2); 
char *Var51=strchr(Var50,=); 
if (Var51){
FUNC15(Var50,Var51); 
FUNC16(Var5,Var50); 
else 
free(Var50); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
STRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
int  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); 
STRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var9+2); 
char  Var29=*Var58; 
STRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); 
char *Var2=FUNC21(Var1,Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); 
char *Var23=strchr(Var9+2,); 
int  Var60=FUNC18(Var1->memberVar5,Var23); 
const STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
*Var9=; 
char *Var62=Var9-2; 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
if (FUNC24((STRUCT7) Var9[1])&&!Var44){
if (!FUNC25(Var1->memberVar12,Var9+1)){
else 
char  Var29=*Var46; 
STRUCT3 *Var54=Var14; 
if (Var12){
Var9=Var12+1; 
char *Var63=Var9+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var9+3; 
char *Var24=strchr(Var66,); 
STRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); 
STRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); 
",2446,0
before_cmd.c,r_core_cmd_subst_i,False,False,236,CWE-,CallExpression,malloc,3205,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tbuf = malloc (sz);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', 'else\n', '\t\t\t\t\t\teprintf (""cannot alloc %d"", sz);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
int  Var6=!Var7->memberVar1->memberVar1; 
int  Var8,Var9=0,Var10; 
bool  Var11=Var7->memberVar2; 
bool  Var12=Var7->memberVar3; 
STRUCT1  Var13=Var7->memberVar4; 
if (!Var14){
switch (*Var14){
if (Var14[1]== ){/*STRUCT2 */
else 
char *Var15=strchr(Var14,; ); 
if (Var14[1]!= *&&!strstr(Var14,STRING)){
if (Var14[1]== >){
if (*Var14 != ){
if (Var16&&Var2){
int  Var9; 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
char *Var3=strchr(Var14,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var18=Var7->memberVar5->memberVar1; 
else 
char *Var19=FUNC2(Var7->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var9 == -1){
if (Var2&&(Var2 ==  Var14||Var2[-1]!= )){
if (*Var14 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var20[1024]; 
int  Var9; 
if (!*Var4){
if (!Var7->memberVar6){
else 
}else if (Var2 ==  Var14){
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
if (Var2[0]&&Var2[1]== ){
int  Var21=FUNC4(Var7->memberVar7,STRING); 
int  Var22=FUNC4(Var7->memberVar7,STRING); 
if (!*Var4){
char *Var23=Var2-1; 
const bool  Var24=(Var2[1]== >); 
char *Var25=FUNC5(Var7,Var14); 
char *Var26=FUNC6(Var7->memberVar8,Var4,1); 
const char *Var27=FUNC7(Var7->memberVar7,STRING); 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
bool  Var28=false ; 
if (Var28){
else 
int  memberVar1=Var7->memberVar5->memberVar1; 
else 
int  Var22=FUNC4(Var7->memberVar7,STRING); 
if (*Var14 != &&*Var14){
const char *Var29=strstr(Var14,STRING); 
if (Var29){
bool  Var30=false ; 
if (Var30){
if (Var2){
char *Var31,*Var3=strchr(Var2+1,!); 
STRUCT1  Var32=Var7->memberVar9; 
int  Var33,Var34; 
STRUCT3 *Var20; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var35=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT1  Var32=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var36=(int ) FUNC9(Var7->memberVar5,Var2+2); 
STRUCT4 *Var37=FUNC10(Var7->memberVar10,Var7->memberVar9); 
if (Var31){
STRUCT5 *Var38=FUNC11((const STRUCT3 *) Var31,Var33); 
STRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); 
Var20=malloc(Var33); 
if (Var20){
free(Var7->memberVar11); 
Var7->memberVar11=Var20; 
Var7->memberVar4=Var33; 
memcpy(Var7->memberVar11,Var31,Var33); 
else 
FUNC13(STRING,Var33); 
char *Var41=strdup(Var2+2); 
char  Var17=*Var42; 
STRUCT1  Var32=FUNC9(Var7->memberVar5,Var2+2); 
char *Var14=FUNC14(Var7,Var2+2); 
STRUCT5 *Var38=FUNC11(Var20,Var34); 
STRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); 
char *Var43=FUNC15(Var7->memberVar12,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var44=strchr(Var2+2,); 
int  Var45=FUNC9(Var7->memberVar5,Var44); 
const STRUCT3 *Var20=(const STRUCT3 *) FUNC16(Var2+2); 
STRUCT5 *Var38=FUNC11(Var20,Var34); 
STRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); 
char *Var46=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC17((STRUCT3) Var2[1])&&!Var32){
if (!FUNC18(Var7->memberVar13,Var2+1)){
else 
char  Var17=*Var47; 
if (Var5){
char *Var48=Var2+3; 
char *Var49=Var2+3; 
STRUCT1  Var50=FUNC9(Var7->memberVar5,Var49); 
STRUCT1  Var51=FUNC9(Var7->memberVar5,Var52+1); 
",1917,0
before_cmd.c,r_core_cmd_subst_i,False,False,237,CWE-,CallExpression,free,3207,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tbuf = malloc (sz);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
int  Var26=-1; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
STRUCT3  Var27=Var28; 
char *Var29,*Var30; 
if (Var21){
if (!Var30||!*Var30){
else 
char *Var31=strchr(Var2,; ); 
FUNC4(Var1,Var2); 
if (!Var31){
if (*Var30){
if (Var30[1]== ||(Var30[1]&&Var30[2]== )){
char *Var32=strchr(Var30+1,); 
Var27=Var1->memberVar6; 
FUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); 
const bool  Var33=Var30[2]== >; 
if (Var30&&*Var30&&Var30[1]== |){
FUNC7(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var29); 
if (Var27 !=  Var28){
FUNC5(Var1,Var27,1); 
if (!Var30){
if (Var20){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC8(Var1,Var34); 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (FUNC9(Var1,Var2) == -1){
Var15=FUNC9(Var1,Var2); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC10(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
FUNC8(Var1,Var36); 
else 
}else if (!FUNC11(Var7+1,STRING,1)){//STRING
Var18=FUNC12(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var19=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,Var37); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC14(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var38=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var39=FUNC15(Var1->memberVar1,Var7+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var18=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,0); 
Var19=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,Var37); 
Var7=(char *) FUNC16(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var40){
Var7=strchr(Var2,&); 
FUNC17(Var1->memberVar9); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var41=0; 
FUNC18(Var1,Var41,Var2); 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
if (Var7){
if (FUNC19()->memberVar1){
if (Var7[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var42[1024]; 
int  Var15; 
if (FUNC20(stdin)){
Var1->memberVar10  STRUCT5  Var15; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var42,Var9)){
strcat((char *) Var1->memberVar9,Var42); 
if (!*Var9){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC21(Var9,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var7 ==  Var2){
return FUNC22(Var1,(const char *) Var1->memberVar9); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
FUNC8(Var1,Var34); 
int  Var43=1; 
int  Var44=FUNC12(Var1->memberVar8,STRING); 
int  Var45=false ; 
int  Var46=FUNC12(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC23(Var7[-2])){
char *Var47=Var7-1; 
if (*Var47 ==  Var48){//STRING
Var18=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var9,STRING)){
FUNC13(Var1->memberVar8,STRING,Var37); 
const bool  Var49=(Var7[1]== >); 
if (*Var9 == ){
char *Var50=FUNC24(Var1,Var2); 
if (Var49){
char *Var51=FUNC25(Var1->memberVar5,Var9,1); 
if (Var51){
char *Var52=FUNC26(STRING,Var51,Var50); 
if (Var52){
FUNC27(Var1->memberVar5,Var9,Var52,1); 
else 
char *Var53=FUNC26(STRING,Var50); 
FUNC27(Var1->memberVar5,Var9,Var53,1); 
else 
char *Var53=FUNC26(STRING,Var50); 
FUNC27(Var1->memberVar5,Var9,Var53,1); 
else 
}else if (Var43>0){
if (Var16 != -1){
if (!Var44){
FUNC13(Var1->memberVar8,STRING,Var37); 
Var15=FUNC9(Var1,Var2); 
if (!Var44){
FUNC13(Var1->memberVar8,STRING,Var46); 
if (Var45){
const char *Var54=FUNC28(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,Var46); 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
Var1->memberVar11->memberVar1=false ; 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var55=false ; 
if (Var55){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var7[1]== !){
Var9=FUNC29(Var1,Var7+1); 
else 
int  Var46=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var9=FUNC24(Var1,Var7+1); 
Var1->memberVar12=false ; 
FUNC13(Var1->memberVar8,STRING,Var46); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var15=FUNC9(Var1,Var2); 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (*Var2 != &&*Var2){
const char *Var56=strstr(Var2,STRING); 
if (Var56){
bool  Var57=false ; 
if (Var57){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar13=Var7 true false ; 
int  Var58=0; 
if (Var7){
char *Var59,*Var8=strchr(Var7+1,!); 
STRUCT3  Var60=Var1->memberVar6; 
bool  Var61=false ; 
char *Var62=NULL ; 
const char *Var63=NULL ; 
bool  Var64=false ; 
bool  Var65=false ; 
char *Var66=NULL ; 
char *Var67=NULL ; 
bool  Var68=false ; 
int  Var69=-1; 
int  Var70,Var71; 
STRUCT6 *Var42; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var72=strdup(Var7+2); 
char *Var73=strchr(Var72,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+4); 
FUNC31(Var1,FUNC32((Var74) Var60-(Var74) Var1->memberVar6)); 
else 
Var60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+3); 
FUNC5(Var1,Var60,1); 
Var24=Var1->memberVar13=true ; 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var68=FUNC33(Var1->memberVar14,Var7+2); 
int  Var75=(int ) FUNC6(Var1->memberVar7,Var7+2); 
STRUCT7 *Var76=FUNC34(Var1->memberVar15,Var1->memberVar6); 
if (Var76){
if (Var75 >= 0&&Var75<Var76->memberVar1){
STRUCT8  Var77=FUNC35(Var76,Var75); 
FUNC5(Var1,Var76->memberVar2+Var77,1); 
Var24=Var1->memberVar13=true ; 
if (Var59){
STRUCT9 *Var78=FUNC36((const STRUCT6 *) Var59,Var70); 
STRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var13){
FUNC13(Var1->memberVar8,STRING,1); 
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); 
Var42=malloc(Var70); 
if (Var42){
free(Var1->memberVar16); 
Var1->memberVar16=Var42; 
Var1->memberVar4=Var70; 
memcpy(Var1->memberVar16,Var59,Var70); 
if (Var7[1]== ){
STRUCT3  Var81; 
char *Var82=strdup(Var7+2); 
char *Var83=FUNC40(Var82); 
if (Var83){
char  Var35=*Var83; 
Var81=FUNC41(Var1->memberVar17,Var82); 
Var81=FUNC6(Var1->memberVar7,Var84); 
else 
Var81=FUNC41(Var1->memberVar17,Var7+2); 
FUNC5(Var1,Var81,1); 
Var24=Var1->memberVar13=true ; 
Var64=FUNC42(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var62); 
Var26=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); 
if (memberVar2){
FUNC14(Var1,STRING,Var7+2); 
Var24=Var1->memberVar13=true ; 
char *Var2=FUNC43(Var1,Var7+2); 
if (Var7[1]== ){
if (Var42){
FUNC31(Var1,FUNC32(Var71)); 
if (Var71>0){
STRUCT9 *Var78=FUNC36(Var42,Var71); 
STRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var13){
FUNC13(Var1->memberVar8,STRING,1); 
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); 
FUNC31(Var1,Var71); 
FUNC44(Var1); 
char *Var85=FUNC45(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var85){
FUNC5(Var1,FUNC6(Var1->memberVar7,Var85),1); 
if (Var7[1]== ){
Var69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC46(Var1->memberVar1,FUNC47(Var7+2)); 
if (Var7[1]== ){
char *Var32=strchr(Var7+2,); 
if (Var32){
int  Var86=FUNC6(Var1->memberVar7,Var32); 
Var64=FUNC42(Var1,Var86,&Var62); 
Var65=FUNC48(Var1,Var7+2,&Var67); 
FUNC31(Var1,Var71); 
const STRUCT6 *Var42=(const STRUCT6 *) FUNC49(Var7+2); 
if (Var71>0){
STRUCT9 *Var78=FUNC36(Var42,Var71); 
STRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); 
if (!Var1->memberVar1->memberVar1){
FUNC13(Var1->memberVar8,STRING,1); 
if (Var79){
if (Var13){
FUNC13(Var1->memberVar8,STRING,1); 
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); 
FUNC31(Var1,Var71); 
char *Var87=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
FUNC31(
Var1,FUNC6(Var1->memberVar7,Var8+1)); 
memberVar2=FUNC6(Var1->memberVar7,Var63); 
if (FUNC50((STRUCT6) Var7[1])&&!memberVar2){
if (!FUNC51(Var1->memberVar14,Var7+1)){
else 
char  Var35=*Var63; 
if (Var35 == -||Var35 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var79=Var12; 
if (Var79){
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC52(Var79)); 
if (Var10){
Var1->memberVar19=!!Var12; 
if (Var1->memberVar19){
FUNC44(Var1); 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var88=Var7+3; 
Var15=FUNC53(Var1,Var2,Var88); 
else 
Var15=FUNC54(Var1,Var2,Var7+2); 
else 
bool  memberVar13=false ; 
const char *Var89[]={STRING,STRING,STRING,
const char *Var90[]={STRING,STRING,STRING,
STRUCT3  Var91[FUNC55(Var89)-1],Var92[FUNC55(Var90)-1]; 
if (Var7[1]== (){
char *Var93=Var7+3; 
char *Var30=strchr(Var93,); 
if (!Var30){
STRUCT3  Var94=FUNC6(Var1->memberVar7,Var93); 
STRUCT3  Var95=FUNC6(Var1->memberVar7,Var30+1); 
for (Var14=0; Var89[Var14]; Var14  Var40){
Var91[Var14]=FUNC12(Var1->memberVar8,Var89[Var14]); 
for (Var14=0; Var90[Var14]; Var14  Var40){
Var92[Var14]=FUNC12(Var1->memberVar8,Var90[Var14]); 
for (Var14=0; Var89[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var89[Var14],Var94); 
for (Var14=0; Var90[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var90[Var14],Var95); 
if (Var17){
if (Var61){
Var1->memberVar6=memberVar2; 
Var15=FUNC3(Var1->memberVar5,FUNC56(Var2)); 
else 
if (Var61){
if (Var7[1]){
FUNC5(Var1,memberVar2,1); 
FUNC44(Var1); 
Var15=FUNC3(Var1->memberVar5,FUNC56(Var2)); 
if (memberVar13){
for (Var14=0; Var89[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var89[Var14],Var91[Var14]); 
for (Var14=0; Var90[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var90[Var14],Var92[Var14]); 
if (Var8){
FUNC31(Var1,Var25); 
if (Var65){
Var1->memberVar2=Var22; 
FUNC57(Var1->memberVar8,STRING,Var67); 
if (Var69 != -1){
FUNC46(Var1->memberVar1,Var69); 
if (Var12){
if (Var13){
FUNC13(Var1->memberVar8,STRING,0); 
if (Var64){
FUNC57(Var1->memberVar8,STRING,Var62); 
Var1->memberVar3=Var23; 
if (Var25 !=  Var1->memberVar4){
FUNC31(Var1,Var25); 
if (Var66){
FUNC4(Var1,Var66); 
if (Var68){
FUNC58(Var1->memberVar14); 
Var58=Var2 FUNC3(Var1->memberVar5,FUNC56(Var2)) false ; 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
Var1->memberVar2=Var22; 
Var1->memberVar3=Var23; 
if (Var26 != -1){
FUNC13(Var1->memberVar8,STRING,Var26); 
",5905,0
before_cmd.c,r_core_cmd_subst_i,False,False,238,CWE-,CallExpression,memcpy,3210,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tR_FREE (core->oobi);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tbuf = malloc (sz);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', 'else\n', '\t\t\t\t\t\teprintf (""cannot alloc %d"", sz);\n', '\t\t\t\t\tfree (f);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
int  Var26=-1; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
STRUCT3  Var27=Var28; 
char *Var29,*Var30; 
if (Var21){
if (!Var30||!*Var30){
else 
char *Var31=strchr(Var2,; ); 
FUNC4(Var1,Var2); 
if (!Var31){
if (*Var30){
if (Var30[1]== ||(Var30[1]&&Var30[2]== )){
char *Var32=strchr(Var30+1,); 
Var27=Var1->memberVar6; 
FUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); 
const bool  Var33=Var30[2]== >; 
if (Var30&&*Var30&&Var30[1]== |){
FUNC7(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var29); 
if (Var27 !=  Var28){
FUNC5(Var1,Var27,1); 
if (!Var30){
if (Var20){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC8(Var1,Var34); 
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37
if (Var7&&(Var7[1]== ||Var7[1]==  Var38)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (FUNC10(Var1,Var2) == -1){
Var15=FUNC10(Var1,Var2); 
Var7=(char *) FUNC11(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC12(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
FUNC8(Var1,Var40); 
else 
}else if (!FUNC13(Var7+1,STRING,1)){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC16(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var42=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var43=FUNC17(Var1->memberVar1,Var7+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
Var7=(char *) FUNC11(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){
Var7=strchr(Var2,&); 
FUNC18(Var1->memberVar9); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var45=0; 
FUNC19(Var1,Var45,Var2); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC20()->memberVar1){
if (Var7[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var46[1024]; 
int  Var15; 
if (FUNC21(stdin)){
Var1->memberVar10  STRUCT5  Var15; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var46,Var9)){
strcat((char *) Var1->memberVar9,Var46); 
if (!*Var9){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC22(Var9,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var7 ==  Var2){
return FUNC23(Var1,(const char *) Var1->memberVar9); 
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
if (Var7[0]&&Var7[1]== ){
FUNC8(Var1,Var34); 
int  Var47=1; 
int  Var48=FUNC14(Var1->memberVar8,STRING); 
int  Var49=false ; 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
*Var7=0; 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC24(Var7[-2])){
char *Var51=Var7-1; 
if (*Var51 ==  Var52){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var9,STRING)){
FUNC15(Var1->memberVar8,STRING,Var41); 
const bool  Var53=(Var7[1]== >); 
if (*Var9 == ){
char *Var54=FUNC25(Var1,Var2); 
if (Var53){
char *Var55=FUNC26(Var1->memberVar5,Var9,1); 
if (Var55){
char *Var56=FUNC27(STRING,Var55,Var54); 
if (Var56){
FUNC28(Var1->memberVar5,Var9,Var56,1); 
else 
char *Var57=FUNC27(STRING,Var54); 
FUNC28(Var1->memberVar5,Var9,Var57,1); 
else 
char *Var57=FUNC27(STRING,Var54); 
FUNC28(Var1->memberVar5,Var9,Var57,1); 
else 
}else if (Var47>0){
if (Var16 != -1){
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var41); 
Var15=FUNC10(Var1,Var2); 
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var49){
const char *Var58=FUNC29(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar11->memberVar1=false ; 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
bool  Var59=false ; 
if (Var59){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var7[1]== !){
Var9=FUNC30(Var1,Var7+1); 
else 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var9=FUNC25(Var1,Var7+1); 
Var1->memberVar12=false ; 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var15=FUNC10(Var1,Var2); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (*Var2 != &&*Var2){
const char *Var60=strstr(Var2,STRING); 
if (Var60){
bool  Var61=false ; 
if (Var61){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar13=Var7 true false ; 
int  Var62=0; 
if (Var7){
char *Var63,*Var8=strchr(Var7+1,!); 
STRUCT3  Var64=Var1->memberVar6; 
bool  Var65=false ; 
char *Var66=NULL ; 
const char *Var67=NULL ; 
bool  Var68=false ; 
bool  Var69=false ; 
char *Var70=NULL ; 
char *Var71=NULL ; 
bool  Var72=false ; 
int  Var73=-1; 
int  Var74,Var75; 
STRUCT6 *Var46; 
*Var7  Var44=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var44){
if (*Var7&&Var7[1]== ){
else 
Var7  Var76; 
Var7=FUNC31(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var77=strdup(Var7+2); 
char *Var78=strchr(Var77,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+4); 
FUNC33(Var1,FUNC34((Var79) Var64-(Var79) Var1->memberVar6)); 
else 
Var64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+3); 
FUNC5(Var1,Var64,1); 
Var24=Var1->memberVar13=true ; 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var72=FUNC35(Var1->memberVar14,Var7+2); 
int  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); 
STRUCT7 *Var81=FUNC36(Var1->memberVar15,Var1->memberVar6); 
if (Var81){
if (Var80 >= 0&&Var80<Var81->memberVar1){
STRUCT8  Var82=FUNC37(Var81,Var80); 
FUNC5(Var1,Var81->memberVar2+Var82,1); 
Var24=Var1->memberVar13=true ; 
Var63=FUNC22(Var7+2,&Var74); 
if (Var63){
STRUCT9 *Var83=FUNC38((const STRUCT6 *) Var63,Var74); 
STRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); 
Var46=malloc(Var74); 
if (Var46){
free(Var1->memberVar16); 
Var1->memberVar16=Var46; 
Var1->memberVar4=Var74; 
memcpy(Var1->memberVar16,Var63,Var74); 
else 
FUNC42(STRING,Var74); 
free(Var63); 
if (Var7[1]== ){
STRUCT3  Var86; 
char *Var87=strdup(Var7+2); 
char *Var88=FUNC43(Var87); 
if (Var88){
char  Var39=*Var88; 
Var86=FUNC44(Var1->memberVar17,Var87); 
Var86=FUNC6(Var1->memberVar7,Var89); 
else 
Var86=FUNC44(Var1->memberVar17,Var7+2); 
FUNC5(Var1,Var86,1); 
Var24=Var1->memberVar13=true ; 
Var68=FUNC45(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); 
Var26=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); 
if (memberVar2){
FUNC16(Var1,STRING,Var7+2); 
Var24=Var1->memberVar13=true ; 
char *Var2=FUNC46(Var1,Var7+2); 
if (Var7[1]== ){
if (Var46){
FUNC33(Var1,FUNC34(Var75)); 
if (Var75>0){
STRUCT9 *Var83=FUNC38(Var46,Var75); 
STRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); 
FUNC33(Var1,Var75); 
FUNC47(Var1); 
char *Var90=FUNC48(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var90){
FUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); 
if (Var7[1]== ){
Var73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC49(Var1->memberVar1,FUNC50(Var7+2)); 
if (Var7[1]== ){
char *Var32=strchr(Var7+2,); 
if (Var32){
int  Var91=FUNC6(Var1->memberVar7,Var32); 
Var68=FUNC45(Var1,Var91,&Var66); 
Var69=FUNC51(Var1,Var7+2,&Var71); 
FUNC33(Var1,Var75); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC52(Var7+2); 
if (Var75>0){
STRUCT9 *Var83=FUNC38(Var46,Var75); 
STRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); 
if (!Var1->memberVar1->memberVar1){
FUNC15(Var1->memberVar8,STRING,1); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); 
FUNC33(Var1,Var75); 
*Var7=; 
char *Var92=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
FUNC33(
Var1,FUNC6(Var1->memberVar7,Var8+1)); 
memberVar2=FUNC6(Var1->memberVar7,Var67); 
if (FUNC53((STRUCT6) Var7[1])&&!memberVar2){
if (!FUNC54(Var1->memberVar14,Var7+1)){
else 
char  Var39=*Var67; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var84=Var12; 
if (Var84){
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC55(Var84)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar19=!!Var12; 
if (Var1->memberVar19){
FUNC47(Var1); 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var93=Var7+3; 
Var15=FUNC56(Var1,Var2,Var93); 
else 
Var15=FUNC57(Var1,Var2,Var7+2); 
else 
bool  memberVar13=false ; 
const char *Var94[]={STRING,STRING,STRING,
const char *Var95[]={STRING,STRING,STRING,
STRUCT3  Var96[FUNC58(Var94)-1],Var97[FUNC58(Var95)-1]; 
if (Var7[1]== (){
char *Var98=Var7+3; 
char *Var30=strchr(Var98,); 
if (!Var30){
STRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); 
STRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); 
for (Var14=0; Var94[Var14]; Var14  Var44){
Var96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
Var97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); 
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var99); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var100); 
if (Var17){
if (Var65){
Var1->memberVar6=memberVar2; 
Var15=FUNC3(Var1->memberVar5,FUNC59(Var2)); 
else 
if (Var65){
if (Var7[1]){
FUNC5(Var1,memberVar2,1); 
FUNC47(Var1); 
Var15=FUNC3(Var1->memberVar5,FUNC59(Var2)); 
if (memberVar13){
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); 
if (Var8){
FUNC33(Var1,Var25); 
if (Var69){
Var1->memberVar2=Var22; 
FUNC60(Var1->memberVar8,STRING,Var71); 
if (Var73 != -1){
FUNC49(Var1->memberVar1,Var73); 
if (Var12){
if (Var13){
FUNC15(Var1->memberVar8,STRING,0); 
if (Var68){
FUNC60(Var1->memberVar8,STRING,Var66); 
Var1->memberVar3=Var23; 
if (Var25 !=  Var1->memberVar4){
FUNC33(Var1,Var25); 
if (Var70){
FUNC4(Var1,Var70); 
if (Var72){
FUNC61(Var1->memberVar14); 
Var62=Var2 FUNC3(Var1->memberVar5,FUNC59(Var2)) false ; 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar2=Var22; 
Var1->memberVar3=Var23; 
if (Var26 != -1){
FUNC15(Var1->memberVar8,STRING,Var26); 
",6239,0
before_cmd.c,r_core_cmd_subst_i,False,False,239,CWE-,CallExpression,free,3215,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var20=strchr(Var2,; ); 
char *Var21=strchr(Var22+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25
if (Var7&&(Var7[1]== ||Var7[1]==  Var26)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var28=Var1->memberVar5->memberVar1; 
else 
char *Var29=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
char  Var31[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
if (Var7[0]&&Var7[1]== ){
int  Var32=FUNC9(Var1->memberVar7,STRING); 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var34=Var7-1; 
const bool  Var35=(Var7[1]== >); 
char *Var36=FUNC10(Var1,Var2); 
char *Var37=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var38=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
bool  Var39=false ; 
if (Var39){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var40=strstr(Var2,STRING); 
if (Var40){
bool  Var41=false ; 
if (Var41){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var42,*Var8=strchr(Var7+1,!); 
STRUCT3  Var43=Var1->memberVar9; 
char *Var44=NULL ; 
const char *Var45=NULL ; 
char *Var46=NULL ; 
char *Var47=NULL ; 
int  Var48,Var49; 
STRUCT5 *Var31; 
*Var7  Var30=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var30){
if (*Var7&&Var7[1]== ){
else 
Var7  Var50; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var51=strdup(Var7+2); 
char *Var52=strchr(Var51,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); 
Var42=FUNC17(Var7+2,&Var48); 
if (Var42){
STRUCT7 *Var55=FUNC18((const STRUCT5 *) Var42,Var48); 
STRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); 
if (Var31){
memcpy(Var1->memberVar11,Var42,Var48); 
free(Var42); 
char *Var58=strdup(Var7+2); 
char  Var27=*Var59; 
STRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC20(Var1,Var7+2); 
STRUCT7 *Var55=FUNC18(Var31,Var49); 
STRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); 
char *Var60=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var21=strchr(Var7+2,); 
int  Var61=FUNC15(Var1->memberVar5,Var21); 
const STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); 
STRUCT7 *Var55=FUNC18(Var31,Var49); 
STRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); 
*Var7=; 
char *Var62=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC23((STRUCT5) Var7[1])&&!Var43){
if (!FUNC24(Var1->memberVar13,Var7+1)){
else 
char  Var27=*Var45; 
STRUCT2 *Var56=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var7+3; 
char *Var22=strchr(Var66,); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); 
STRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); 
",2537,0
before_cmd.c,r_core_cmd_subst_i,False,False,240,CWE-,CallExpression,strdup,3224,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
*Var72=0; 
Var70=FUNC27(Var1->memberVar13,Var71); 
*Var72=Var33; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
free(Var71); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var53=FUNC37(Var7+1); 
if (FUNC38((STRUCT5) Var7[1])&&!Var50){
if (!FUNC39(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC40(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
*Var7=; 
",3363,0
before_cmd.c,r_core_cmd_subst_i,False,False,241,CWE-,CallExpression,free,3233,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tfree (numexpr);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
int  Var6=!Var7->memberVar1->memberVar1; 
int  Var8,Var9=0,Var10; 
bool  Var11=Var7->memberVar2; 
bool  Var12=Var7->memberVar3; 
STRUCT1  Var13=Var7->memberVar4; 
if (!Var14){
switch (*Var14){
if (Var14[1]== ){/*STRUCT2 */
else 
char *Var15=strchr(Var14,; ); 
if (Var14[1]!= *&&!strstr(Var14,STRING)){
if (Var14[1]== >){
if (*Var14 != ){
if (Var16&&Var2){
int  Var9; 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
char *Var3=strchr(Var14,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var18=Var7->memberVar5->memberVar1; 
else 
char *Var19=FUNC2(Var7->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var9 == -1){
if (Var2&&(Var2 ==  Var14||Var2[-1]!= )){
if (*Var14 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
int  Var9; 
if (!*Var4){
if (!Var7->memberVar6){
else 
}else if (Var2 ==  Var14){
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
if (Var2[0]&&Var2[1]== ){
int  Var20=FUNC4(Var7->memberVar7,STRING); 
int  Var21=FUNC4(Var7->memberVar7,STRING); 
if (!*Var4){
char *Var22=Var2-1; 
const bool  Var23=(Var2[1]== >); 
char *Var24=FUNC5(Var7,Var14); 
char *Var25=FUNC6(Var7->memberVar8,Var4,1); 
const char *Var26=FUNC7(Var7->memberVar7,STRING); 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
bool  Var27=false ; 
if (Var27){
else 
int  memberVar1=Var7->memberVar5->memberVar1; 
else 
int  Var21=FUNC4(Var7->memberVar7,STRING); 
if (*Var14 != &&*Var14){
const char *Var28=strstr(Var14,STRING); 
if (Var28){
bool  Var29=false ; 
if (Var29){
if (Var2){
char *Var30,*Var3=strchr(Var2+1,!); 
STRUCT1  Var31=Var7->memberVar9; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var32=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT1  Var31=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var33=(int ) FUNC9(Var7->memberVar5,Var2+2); 
STRUCT3 *Var34=FUNC10(Var7->memberVar10,Var7->memberVar9); 
STRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); 
if (Var2[1]== ){
char *Var38=strdup(Var2+2); 
char *Var39=FUNC12(Var38); 
if (Var39){
char  Var17=*Var39; 
free(Var40); 
STRUCT1  Var31=FUNC9(Var7->memberVar5,Var2+2); 
char *Var14=FUNC13(Var7,Var2+2); 
STRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); 
char *Var41=FUNC14(Var7->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var42=strchr(Var2+2,); 
int  Var43=FUNC9(Var7->memberVar5,Var42); 
const STRUCT5 *Var44=(const STRUCT5 *) FUNC15(Var2+2); 
STRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); 
char *Var45=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC16((STRUCT5) Var2[1])&&!Var31){
if (!FUNC17(Var7->memberVar12,Var2+1)){
else 
char  Var17=*Var46; 
if (Var5){
char *Var47=Var2+3; 
char *Var48=Var2+3; 
STRUCT1  Var49=FUNC9(Var7->memberVar5,Var48); 
STRUCT1  Var50=FUNC9(Var7->memberVar5,Var51+1); 
",1786,0
before_cmd.c,r_core_cmd_subst_i,False,False,242,CWE-,CallExpression,free,3239,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var20=strchr(Var2,; ); 
char *Var21=strchr(Var22+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25
if (Var7&&(Var7[1]== ||Var7[1]==  Var26)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var28=Var1->memberVar5->memberVar1; 
else 
char *Var29=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
if (Var7[0]&&Var7[1]== ){
int  Var31=FUNC9(Var1->memberVar7,STRING); 
int  Var32=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var33=Var7-1; 
const bool  Var34=(Var7[1]== >); 
char *Var35=FUNC10(Var1,Var2); 
char *Var36=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var37=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
bool  Var38=false ; 
if (Var38){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var32=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var39=strstr(Var2,STRING); 
if (Var39){
bool  Var40=false ; 
if (Var40){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var41,*Var8=strchr(Var7+1,!); 
STRUCT3  Var42=Var1->memberVar9; 
char *Var43=NULL ; 
const char *Var44=NULL ; 
char *Var45=NULL ; 
char *Var46=NULL ; 
*Var7  Var30=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var30){
if (*Var7&&Var7[1]== ){
else 
Var7  Var47; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var48=strdup(Var7+2); 
char *Var49=strchr(Var48,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var42=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var50=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT5 *Var51=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); 
if (Var7[1]== ){
STRUCT3  Var55; 
char *Var56=strdup(Var7+2); 
char *Var57=FUNC18(Var56); 
if (Var57){
char  Var27=*Var57; 
Var55=FUNC19(Var1->memberVar11,Var56); 
free(Var56); 
STRUCT3  Var42=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC20(Var1,Var7+2); 
STRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); 
char *Var58=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var21=strchr(Var7+2,); 
int  Var59=FUNC15(Var1->memberVar5,Var21); 
const STRUCT6 *Var60=(const STRUCT6 *) FUNC22(Var7+2); 
STRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); 
*Var7=; 
char *Var61=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC23((STRUCT6) Var7[1])&&!Var42){
if (!FUNC24(Var1->memberVar13,Var7+1)){
else 
char  Var27=*Var44; 
STRUCT2 *Var52=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var62=Var7+3; 
const char *Var63[]={STRING,STRING,STRING,
const char *Var64[]={STRING,STRING,STRING,
char *Var65=Var7+3; 
char *Var22=strchr(Var65,); 
STRUCT3  Var66=FUNC15(Var1->memberVar5,Var65); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var22+1); 
",2458,0
before_cmd.c,r_core_cmd_subst_i,False,False,243,CWE-,CallExpression,free,3264,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var38,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
int  Var39=1; 
int  Var40=FUNC17(Var1->memberVar8,STRING); 
int  Var41=false ; 
int  Var42=FUNC17(Var1->memberVar8,STRING); 
*Var7=0; 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
if (*Var9 == ){
char *Var45=FUNC19(Var1,Var2); 
char *Var46=FUNC20(Var1->memberVar5,Var9,1); 
char *Var47=FUNC21(STRING,Var46,Var45); 
else 
char *Var48=FUNC21(STRING,Var45); 
else 
char *Var48=FUNC21(STRING,Var45); 
else 
}else if (Var39>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var49=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var42=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
*Var7  Var26=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var26){
if (*Var7&&Var7[1]== ){
else 
Var7  Var63; 
Var7=FUNC26(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var64=strdup(Var7+2); 
char *Var65=strchr(Var64,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var66=(int ) FUNC28(Var1->memberVar6,Var7+2); 
STRUCT5 *Var67=FUNC29(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); 
char *Var71=strdup(Var7+2); 
char  Var35=*Var72; 
STRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (!Var60){
Var60=Var2; 
else 
Var60=FUNC32(Var60,Var2); 
free(Var2); 
STRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); 
char *Var73=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var74=FUNC28(Var1->memberVar6,Var29); 
const STRUCT6 *Var75=(const STRUCT6 *) FUNC34(Var7+2); 
STRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); 
*Var7=; 
char *Var76=Var7-2; 
while (Var76>Var2){
if (!FUNC35(*Var76)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC36((STRUCT6) Var7[1])&&!Var54){
if (!FUNC37(Var1->memberVar12,Var7+1)){
else 
char  Var35=*Var57; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var77=Var7+3; 
Var15=FUNC38(Var1,Var2,Var77); 
else 
Var15=FUNC39(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var78[]={STRING,STRING,STRING,
const char *Var79[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var80=Var7+3; 
char *Var25=strchr(Var80,); 
if (!Var25){
STRUCT3  Var81=FUNC28(Var1->memberVar6,Var80); 
STRUCT3  Var82=FUNC28(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC40(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC40(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC40(Var2)) false ; 
",3392,0
before_cmd.c,r_core_cmd_subst_i,False,False,244,CWE-,CallExpression,malloc,3270,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var38){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var38){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=FUNC11(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
char *Var45=FUNC13(Var1,Var2); 
char *Var46=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var47=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar9=Var7 true false ; 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar10; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
int  Var62=-1; 
int  Var63,Var64; 
STRUCT5 *Var39; 
*Var7  Var38=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var38){
if (*Var7&&Var7[1]== ){
else 
Var7  Var65; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var66=strdup(Var7+2); 
char *Var67=strchr(Var66,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var61=FUNC18(Var1->memberVar11,Var7+2); 
int  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var70=FUNC21(Var69,Var68); 
Var52=FUNC22(Var7+2,&Var63); 
if (Var52){
STRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
else 
FUNC26(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var74; 
char *Var75=strdup(Var7+2); 
char *Var76=FUNC27(Var75); 
if (Var76){
char  Var35=*Var76; 
else 
Var74=FUNC28(Var1->memberVar13,Var7+2); 
Var57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); 
STRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); 
if (Var53){
FUNC30(Var1,STRING,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var64=FUNC32(Var7+2,Var39); 
FUNC33(Var1,FUNC34(Var64)); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
Var12=Var72; 
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); 
FUNC33(Var1,Var64); 
free(Var39); 
char *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC38(Var1->memberVar1,FUNC39(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var78=FUNC19(Var1->memberVar5,Var29); 
Var58=FUNC40(Var1,Var7+2,&Var60); 
Var64=strlen(Var7+2); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
*Var7=; 
char *Var79=Var7-2; 
Var7=FUNC42(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var56=FUNC42(Var7+1); 
if (FUNC43((STRUCT5) Var7[1])&&!Var53){
if (!FUNC44(Var1->memberVar11,Var7+1)){
FUNC26(STRING,Var7+1); 
else 
char  Var35=*Var56; 
if (Var53){
STRUCT2 *Var72=Var12; 
if (Var72){
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar15=!!Var12; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var80=Var7+3; 
else 
Var15=FUNC46(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var81[]={STRING,STRING,STRING,
const char *Var82[]={STRING,STRING,STRING,
STRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; 
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var27=strchr(Var85,); 
if (!Var27){
STRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); 
STRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); 
for (Var14=0; Var81[Var14]; Var14  Var38){
Var83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
Var84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); 
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var86); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var87); 
if (Var17){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
else 
if (Var54){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
if (memberVar9){
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); 
if (Var62 != -1){
FUNC38(Var1->memberVar1,Var62); 
if (Var12){
if (Var13){
FUNC48(Var1->memberVar7,STRING,0); 
FUNC25(Var12); 
if (Var57){
FUNC50(Var1->memberVar7,STRING,Var55); 
if (Var61){
FUNC51(Var1->memberVar11); 
*Var7=; 
Var51=Var15; 
if (Var18 != -1){
FUNC48(Var1->memberVar7,STRING,Var18); 
if (Var19 != -1){
FUNC48(Var1->memberVar7,STRING,Var19); 
if (Var12){
FUNC25(Var12); 
return  Var51; 
",4205,0
before_cmd.c,r_core_cmd_subst_i,False,False,245,CWE-,CallExpression,strlen,3270,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var38){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var38){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=FUNC11(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
char *Var45=FUNC13(Var1,Var2); 
char *Var46=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var47=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar9=Var7 true false ; 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar10; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
int  Var62=-1; 
int  Var63,Var64; 
STRUCT5 *Var39; 
*Var7  Var38=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var38){
if (*Var7&&Var7[1]== ){
else 
Var7  Var65; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var66=strdup(Var7+2); 
char *Var67=strchr(Var66,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var61=FUNC18(Var1->memberVar11,Var7+2); 
int  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var70=FUNC21(Var69,Var68); 
Var52=FUNC22(Var7+2,&Var63); 
if (Var52){
STRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
else 
FUNC26(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var74; 
char *Var75=strdup(Var7+2); 
char *Var76=FUNC27(Var75); 
if (Var76){
char  Var35=*Var76; 
else 
Var74=FUNC28(Var1->memberVar13,Var7+2); 
Var57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); 
STRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); 
if (Var53){
FUNC30(Var1,STRING,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var64=FUNC32(Var7+2,Var39); 
FUNC33(Var1,FUNC34(Var64)); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
Var12=Var72; 
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); 
FUNC33(Var1,Var64); 
free(Var39); 
char *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC38(Var1->memberVar1,FUNC39(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var78=FUNC19(Var1->memberVar5,Var29); 
Var58=FUNC40(Var1,Var7+2,&Var60); 
Var64=strlen(Var7+2); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
*Var7=; 
char *Var79=Var7-2; 
Var7=FUNC42(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var56=FUNC42(Var7+1); 
if (FUNC43((STRUCT5) Var7[1])&&!Var53){
if (!FUNC44(Var1->memberVar11,Var7+1)){
FUNC26(STRING,Var7+1); 
else 
char  Var35=*Var56; 
if (Var53){
STRUCT2 *Var72=Var12; 
if (Var72){
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar15=!!Var12; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var80=Var7+3; 
else 
Var15=FUNC46(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var81[]={STRING,STRING,STRING,
const char *Var82[]={STRING,STRING,STRING,
STRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; 
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var27=strchr(Var85,); 
if (!Var27){
STRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); 
STRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); 
for (Var14=0; Var81[Var14]; Var14  Var38){
Var83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
Var84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); 
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var86); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var87); 
if (Var17){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
else 
if (Var54){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
if (memberVar9){
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); 
if (Var62 != -1){
FUNC38(Var1->memberVar1,Var62); 
if (Var12){
if (Var13){
FUNC48(Var1->memberVar7,STRING,0); 
FUNC25(Var12); 
if (Var57){
FUNC50(Var1->memberVar7,STRING,Var55); 
if (Var61){
FUNC51(Var1->memberVar11); 
*Var7=; 
Var51=Var15; 
if (Var18 != -1){
FUNC48(Var1->memberVar7,STRING,Var18); 
if (Var19 != -1){
FUNC48(Var1->memberVar7,STRING,Var19); 
if (Var12){
FUNC25(Var12); 
return  Var51; 
",4205,0
before_cmd.c,r_core_cmd_subst_i,False,False,246,CWE-,CallExpression,free,3292,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var20=strchr(Var2,; ); 
char *Var21=strchr(Var22+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25
if (Var7&&(Var7[1]== ||Var7[1]==  Var26)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var28=Var1->memberVar5->memberVar1; 
else 
char *Var29=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
char  Var31[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
if (Var7[0]&&Var7[1]== ){
int  Var32=FUNC9(Var1->memberVar7,STRING); 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var34=Var7-1; 
const bool  Var35=(Var7[1]== >); 
char *Var36=FUNC10(Var1,Var2); 
char *Var37=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var38=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
bool  Var39=false ; 
if (Var39){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var40=strstr(Var2,STRING); 
if (Var40){
bool  Var41=false ; 
if (Var41){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var42,*Var8=strchr(Var7+1,!); 
STRUCT3  Var43=Var1->memberVar9; 
char *Var44=NULL ; 
const char *Var45=NULL ; 
char *Var46=NULL ; 
char *Var47=NULL ; 
int  Var48,Var49; 
STRUCT5 *Var31; 
*Var7  Var30=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var30){
if (*Var7&&Var7[1]== ){
else 
Var7  Var50; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var51=strdup(Var7+2); 
char *Var52=strchr(Var51,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT7 *Var55=FUNC17((const STRUCT5 *) Var42,Var48); 
STRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); 
char *Var58=strdup(Var7+2); 
char  Var27=*Var59; 
STRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC19(Var1,Var7+2); 
if (Var7[1]== ){
Var31=malloc(strlen(Var7+2)+1); 
if (Var31){
Var49=FUNC20(Var7+2,Var31); 
if (Var49>0){
STRUCT7 *Var55=FUNC17(Var31,Var49); 
STRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); 
free(Var31); 
char *Var60=FUNC21(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var21=strchr(Var7+2,); 
int  Var61=FUNC15(Var1->memberVar5,Var21); 
const STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); 
STRUCT7 *Var55=FUNC17(Var31,Var49); 
STRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); 
*Var7=; 
char *Var62=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC23((STRUCT5) Var7[1])&&!Var43){
if (!FUNC24(Var1->memberVar12,Var7+1)){
else 
char  Var27=*Var45; 
STRUCT2 *Var56=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var7+3; 
char *Var22=strchr(Var66,); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); 
STRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); 
",2552,0
before_cmd.c,r_core_cmd_subst_i,False,False,247,CWE-,CallExpression,free,3305,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var24=strchr(Var2,; ); 
char *Var25=strchr(Var26+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var27  Var28  Var5  Var29
if (Var7&&(Var7[1]== ||Var7[1]==  Var30)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var31=Var7-1; 
if (*Var31 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var32=Var1->memberVar5->memberVar1; 
else 
char *Var33=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var34){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
char  Var35[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var31=Var7-1; 
if (*Var31 == ){
if (Var7[0]&&Var7[1]== ){
int  Var36=FUNC9(Var1->memberVar7,STRING); 
int  Var37=false ; 
int  Var38=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var39=Var7-1; 
const bool  Var40=(Var7[1]== >); 
char *Var41=FUNC10(Var1,Var2); 
char *Var42=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var43=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var31=Var7-1; 
if (*Var31 == ){
bool  Var44=false ; 
if (Var44){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var38=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var45=strstr(Var2,STRING); 
if (Var45){
bool  Var46=false ; 
if (Var46){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var47,*Var8=strchr(Var7+1,!); 
STRUCT3  Var48=Var1->memberVar10; 
bool  Var49=false ; 
char *Var50=NULL ; 
const char *Var51=NULL ; 
bool  Var52=false ; 
bool  Var53=false ; 
char *Var54=NULL ; 
char *Var55=NULL ; 
bool  Var56=false ; 
int  Var57,Var58; 
STRUCT5 *Var35; 
*Var7  Var34=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var34){
if (*Var7&&Var7[1]== ){
else 
Var7  Var59; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var60=strdup(Var7+2); 
char *Var61=strchr(Var60,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var48=FUNC14(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var62=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var63=FUNC16(Var1->memberVar11,Var1->memberVar10); 
if (Var63){
if (Var62 >= 0&&Var62<Var63->memberVar1){
STRUCT7  Var64=FUNC17(Var63,Var62); 
Var22=Var1->memberVar9=true ; 
if (Var47){
STRUCT8 *Var65=FUNC18((const STRUCT5 *) Var47,Var57); 
STRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); 
if (Var35){
Var1->memberVar4=Var57; 
if (Var7[1]== ){
char *Var68=strdup(Var7+2); 
char  Var31=*Var69; 
Var22=Var1->memberVar9=true ; 
STRUCT3  Var48=FUNC15(Var1->memberVar5,Var7+2); 
if (Var48){
Var22=Var1->memberVar9=true ; 
char *Var2=FUNC20(Var1,Var7+2); 
STRUCT8 *Var65=FUNC18(Var35,Var58); 
STRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); 
char *Var70=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var70){
FUNC22(Var1,FUNC15(Var1->memberVar5,Var70),1); 
free(Var70); 
char *Var25=strchr(Var7+2,); 
int  Var71=FUNC15(Var1->memberVar5,Var25); 
const STRUCT5 *Var35=(const STRUCT5 *) FUNC23(Var7+2); 
STRUCT8 *Var65=FUNC18(Var35,Var58); 
STRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); 
*Var7=; 
char *Var72=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC24((STRUCT5) Var7[1])&&!Var48){
if (!FUNC25(Var1->memberVar13,Var7+1)){
else 
char  Var31=*Var51; 
STRUCT2 *Var66=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var73=Var7+3; 
else 
bool  memberVar9=false ; 
const char *Var74[]={STRING,STRING,STRING,
const char *Var75[]={STRING,STRING,STRING,
char *Var76=Var7+3; 
char *Var26=strchr(Var76,); 
STRUCT3  Var77=FUNC15(Var1->memberVar5,Var76); 
STRUCT3  Var78=FUNC15(Var1->memberVar5,Var26+1); 
",2761,0
before_cmd.c,r_core_cmd_subst_i,False,False,248,CWE-,CallExpression,atoi,3313,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tR_FREE (core->oobi);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
int  Var26=-1; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
STRUCT3  Var27=Var28; 
char *Var29,*Var30; 
if (Var21){
if (!Var30||!*Var30){
else 
char *Var31=strchr(Var2,; ); 
FUNC4(Var1,Var2); 
if (!Var31){
if (*Var30){
if (Var30[1]== ||(Var30[1]&&Var30[2]== )){
char *Var32=strchr(Var30+1,); 
Var27=Var1->memberVar6; 
FUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); 
const bool  Var33=Var30[2]== >; 
if (Var30&&*Var30&&Var30[1]== |){
FUNC7(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var29); 
if (Var27 !=  Var28){
FUNC5(Var1,Var27,1); 
if (!Var30){
if (Var20){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC8(Var1,Var34); 
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37
if (Var7&&(Var7[1]== ||Var7[1]==  Var38)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (FUNC10(Var1,Var2) == -1){
Var15=FUNC10(Var1,Var2); 
Var7=(char *) FUNC11(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
memmove(Var39,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC12(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
FUNC8(Var1,Var40); 
else 
}else if (!FUNC13(Var7+1,STRING,1)){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC16(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var42=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var43=FUNC17(Var1->memberVar1,Var7+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
Var7=(char *) FUNC11(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){
Var7=strchr(Var2,&); 
FUNC18(Var1->memberVar9); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var45=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC19(Var1,Var45,Var2); 
FUNC20(Var7+2,STRING); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC21()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var44){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var46[1024]; 
int  Var15; 
if (FUNC22(stdin)){
Var1->memberVar10  STRUCT5  Var15; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var46,Var9)){
strcat((char *) Var1->memberVar9,Var46); 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var44){
if (!*Var9){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC23(Var9,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var7 ==  Var2){
return FUNC24(Var1,(const char *) Var1->memberVar9); 
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
memmove(Var39,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
FUNC8(Var1,Var34); 
int  Var47=1; 
int  Var48=FUNC14(Var1->memberVar8,STRING); 
int  Var49=false ; 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC25(Var7[-2])){
char *Var51=Var7-1; 
if (*Var51 ==  Var52){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var9,STRING)){
FUNC15(Var1->memberVar8,STRING,Var41); 
const bool  Var53=(Var7[1]== >); 
if (*Var9 == ){
char *Var54=FUNC26(Var1,Var2); 
if (Var53){
char *Var55=FUNC27(Var1->memberVar5,Var9,1); 
if (Var55){
char *Var56=FUNC28(STRING,Var55,Var54); 
if (Var56){
FUNC29(Var1->memberVar5,Var9,Var56,1); 
else 
char *Var57=FUNC28(STRING,Var54); 
FUNC29(Var1->memberVar5,Var9,Var57,1); 
else 
char *Var57=FUNC28(STRING,Var54); 
FUNC29(Var1->memberVar5,Var9,Var57,1); 
else 
}else if (Var47>0){
if (Var16 != -1){
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var41); 
Var15=FUNC10(Var1,Var2); 
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var49){
const char *Var58=FUNC30(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar11->memberVar1=false ; 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
bool  Var59=false ; 
if (Var59){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var7[1]== !){
Var9=FUNC31(Var1,Var7+1); 
else 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var9=FUNC26(Var1,Var7+1); 
Var1->memberVar12=false ; 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var15=FUNC10(Var1,Var2); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (*Var2 != &&*Var2){
const char *Var60=strstr(Var2,STRING); 
if (Var60){
bool  Var61=false ; 
if (Var61){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar13=Var7 true false ; 
int  Var62=0; 
if (Var7){
char *Var63,*Var8=strchr(Var7+1,!); 
STRUCT3  Var64=Var1->memberVar6; 
bool  Var65=false ; 
char *Var66=NULL ; 
const char *Var67=NULL ; 
bool  Var68=false ; 
bool  Var69=false ; 
char *Var70=NULL ; 
char *Var71=NULL ; 
bool  Var72=false ; 
int  Var73=-1; 
int  Var74,Var75; 
STRUCT6 *Var46; 
*Var7  Var44=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var44){
if (*Var7&&Var7[1]== ){
else 
Var7  Var76; 
Var7=FUNC32(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var77=strdup(Var7+2); 
char *Var78=strchr(Var77,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+4); 
FUNC34(Var1,FUNC35((Var79) Var64-(Var79) Var1->memberVar6)); 
else 
Var64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+3); 
FUNC5(Var1,Var64,1); 
Var24=Var1->memberVar13=true ; 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var72=FUNC36(Var1->memberVar14,Var7+2); 
int  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); 
STRUCT7 *Var81=FUNC37(Var1->memberVar15,Var1->memberVar6); 
if (Var81){
if (Var80 >= 0&&Var80<Var81->memberVar1){
STRUCT8  Var82=FUNC38(Var81,Var80); 
FUNC5(Var1,Var81->memberVar2+Var82,1); 
Var24=Var1->memberVar13=true ; 
Var63=FUNC23(Var7+2,&Var74); 
if (Var63){
STRUCT9 *Var83=FUNC39((const STRUCT6 *) Var63,Var74); 
STRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); 
if (Var46){
free(Var1->memberVar16); 
Var1->memberVar16=Var46; 
Var1->memberVar4=Var74; 
memcpy(Var1->memberVar16,Var63,Var74); 
else 
FUNC43(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var86; 
char *Var87=strdup(Var7+2); 
char *Var88=FUNC44(Var87); 
if (Var88){
char  Var39=*Var88; 
Var86=FUNC45(Var1->memberVar17,Var87); 
Var86=FUNC6(Var1->memberVar7,Var89); 
else 
Var86=FUNC45(Var1->memberVar17,Var7+2); 
FUNC5(Var1,Var86,1); 
Var24=Var1->memberVar13=true ; 
Var68=FUNC46(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); 
Var26=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); 
if (memberVar2){
FUNC16(Var1,STRING,Var7+2); 
Var24=Var1->memberVar13=true ; 
char *Var2=FUNC47(Var1,Var7+2); 
if (Var7[1]== ){
Var46=malloc(strlen(Var7+2)+1); 
if (Var46){
Var75=FUNC48(Var7+2,Var46); 
FUNC34(Var1,FUNC35(Var75)); 
if (Var75>0){
STRUCT9 *Var83=FUNC39(Var46,Var75); 
STRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); 
FUNC34(Var1,Var75); 
FUNC49(Var1); 
char *Var90=FUNC50(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var90){
FUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); 
if (Var7[1]== ){
Var73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC51(Var1->memberVar1,FUNC52(Var7+2)); 
if (Var7[1]== ){
char *Var32=strchr(Var7+2,); 
if (Var32){
int  Var91=FUNC6(Var1->memberVar7,Var32); 
Var68=FUNC46(Var1,Var91,&Var66); 
Var69=FUNC53(Var1,Var7+2,&Var71); 
Var75=strlen(Var7+2); 
FUNC34(Var1,Var75); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC54(Var7+2); 
if (Var75>0){
STRUCT9 *Var83=FUNC39(Var46,Var75); 
STRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); 
if (!Var1->memberVar1->memberVar1){
FUNC15(Var1->memberVar8,STRING,1); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); 
FUNC34(Var1,Var75); 
*Var7=; 
char *Var92=Var7-2; 
Var7=FUNC55(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
FUNC34(
Var1,FUNC6(Var1->memberVar7,Var8+1)); 
Var67=FUNC55(Var7+1); 
memberVar2=FUNC6(Var1->memberVar7,Var67); 
if (FUNC56((STRUCT6) Var7[1])&&!memberVar2){
if (!FUNC57(Var1->memberVar14,Var7+1)){
FUNC43(STRING,Var7+1); 
else 
char  Var39=*Var67; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var84=Var12; 
if (Var84){
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC58(Var84)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar19=!!Var12; 
if (Var1->memberVar19){
FUNC49(Var1); 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var93=Var7+3; 
Var15=FUNC59(Var1,Var2,Var93); 
else 
Var15=FUNC60(Var1,Var2,Var7+2); 
else 
bool  memberVar13=false ; 
const char *Var94[]={STRING,STRING,STRING,
const char *Var95[]={STRING,STRING,STRING,
STRUCT3  Var96[FUNC61(Var94)-1],Var97[FUNC61(Var95)-1]; 
if (Var7[1]== (){
char *Var98=Var7+3; 
char *Var30=strchr(Var98,); 
if (!Var30){
STRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); 
STRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); 
for (Var14=0; Var94[Var14]; Var14  Var44){
Var96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
Var97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); 
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var99); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var100); 
if (Var17){
if (Var65){
Var1->memberVar6=memberVar2; 
Var15=FUNC3(Var1->memberVar5,FUNC55(Var2)); 
else 
if (Var65){
if (Var7[1]){
FUNC5(Var1,memberVar2,1); 
FUNC49(Var1); 
Var15=FUNC3(Var1->memberVar5,FUNC55(Var2)); 
if (memberVar13){
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); 
if (Var8){
FUNC34(Var1,Var25); 
if (Var69){
Var1->memberVar2=Var22; 
FUNC62(Var1->memberVar8,STRING,Var71); 
if (Var73 != -1){
FUNC51(Var1->memberVar1,Var73); 
if (Var12){
if (Var13){
FUNC15(Var1->memberVar8,STRING,0); 
if (Var68){
FUNC62(Var1->memberVar8,STRING,Var66); 
Var1->memberVar3=Var23; 
if (Var25 !=  Var1->memberVar4){
FUNC34(Var1,Var25); 
if (Var70){
FUNC4(Var1,Var70); 
if (Var72){
FUNC63(Var1->memberVar14); 
*Var7=; 
Var62=Var2 FUNC3(Var1->memberVar5,FUNC55(Var2)) false ; 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar2=Var22; 
Var1->memberVar3=Var23; 
if (Var26 != -1){
FUNC15(Var1->memberVar8,STRING,Var26); 
",6467,0
before_cmd.c,r_core_cmd_subst_i,False,False,249,CWE-,CallExpression,strchr,3318,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
if (Var27){
*Var27  Var36=0; 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var54=FUNC28(Var1,Var74,&Var52); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var53=FUNC37(Var7+1); 
if (FUNC38((STRUCT5) Var7[1])&&!Var50){
if (!FUNC39(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC40(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
*Var7=; 
",3360,0
before_cmd.c,r_core_cmd_subst_i,False,False,250,CWE-,CallExpression,strlen,3331,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var38){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var38){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=FUNC11(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
char *Var45=FUNC13(Var1,Var2); 
char *Var46=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var47=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar9=Var7 true false ; 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar10; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
int  Var62=-1; 
int  Var63,Var64; 
STRUCT5 *Var39; 
*Var7  Var38=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var38){
if (*Var7&&Var7[1]== ){
else 
Var7  Var65; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var66=strdup(Var7+2); 
char *Var67=strchr(Var66,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var61=FUNC18(Var1->memberVar11,Var7+2); 
int  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var70=FUNC21(Var69,Var68); 
Var52=FUNC22(Var7+2,&Var63); 
if (Var52){
STRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
else 
FUNC26(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var74; 
char *Var75=strdup(Var7+2); 
char *Var76=FUNC27(Var75); 
if (Var76){
char  Var35=*Var76; 
else 
Var74=FUNC28(Var1->memberVar13,Var7+2); 
Var57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); 
STRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); 
if (Var53){
FUNC30(Var1,STRING,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var64=FUNC32(Var7+2,Var39); 
FUNC33(Var1,FUNC34(Var64)); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
FUNC33(Var1,Var64); 
char *Var77=FUNC35(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC36(Var1->memberVar1,FUNC37(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var78=FUNC19(Var1->memberVar5,Var29); 
Var58=FUNC38(Var1,Var7+2,&Var60); 
Var64=strlen(Var7+2); 
FUNC33(Var1,Var64); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC39(Var7+2); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
Var12=Var72; 
FUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC41(Var71)); 
FUNC33(Var1,Var64); 
*Var7=; 
char *Var79=Var7-2; 
Var7=FUNC42(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var56=FUNC42(Var7+1); 
if (FUNC43((STRUCT5) Var7[1])&&!Var53){
if (!FUNC44(Var1->memberVar11,Var7+1)){
FUNC26(STRING,Var7+1); 
else 
char  Var35=*Var56; 
if (Var53){
STRUCT2 *Var72=Var12; 
if (Var72){
FUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar15=!!Var12; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var80=Var7+3; 
else 
Var15=FUNC46(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var81[]={STRING,STRING,STRING,
const char *Var82[]={STRING,STRING,STRING,
STRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; 
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var27=strchr(Var85,); 
if (!Var27){
STRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); 
STRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); 
for (Var14=0; Var81[Var14]; Var14  Var38){
Var83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
Var84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); 
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var86); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var87); 
if (Var17){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
else 
if (Var54){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
if (memberVar9){
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); 
if (Var62 != -1){
FUNC36(Var1->memberVar1,Var62); 
if (Var12){
if (Var13){
FUNC48(Var1->memberVar7,STRING,0); 
FUNC25(Var12); 
if (Var57){
FUNC50(Var1->memberVar7,STRING,Var55); 
if (Var61){
FUNC51(Var1->memberVar11); 
*Var7=; 
Var51=Var15; 
if (Var18 != -1){
FUNC48(Var1->memberVar7,STRING,Var18); 
if (Var19 != -1){
FUNC48(Var1->memberVar7,STRING,Var19); 
if (Var12){
FUNC25(Var12); 
return  Var51; 
",4220,0
before_cmd.c,r_core_cmd_subst_i,False,False,251,CWE-,CallExpression,strlen,3376,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
before_cmd.c,r_core_cmd_subst_i,False,False,252,CWE-,CallExpression,strlen,3376,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
before_cmd.c,r_core_cmd_subst_i,False,False,253,CWE-,CallExpression,memcmp,3376,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
before_cmd.c,r_core_cmd_subst_i,False,False,254,CWE-,CallExpression,memcmp,3376,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
before_cmd.c,r_core_cmd_subst_i,False,False,255,CWE-,CallExpression,strlen,3380,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
before_cmd.c,r_core_cmd_subst_i,False,False,256,CWE-,CallExpression,strlen,3380,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
before_cmd.c,r_core_cmd_subst_i,False,False,257,CWE-,CallExpression,strchr,3447,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var20,*Var21; 
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var21+1,); 
const bool  Var24=Var21[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27
if (Var7&&(Var7[1]== ||Var7[1]==  Var28)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
if (Var7[0]&&Var7[1]== ){
int  Var33=FUNC9(Var1->memberVar7,STRING); 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var35=Var7-1; 
const bool  Var36=(Var7[1]== >); 
char *Var37=FUNC10(Var1,Var2); 
char *Var38=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var39=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var43,*Var8=strchr(Var7+1,!); 
STRUCT3  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var7  Var32=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var32){
if (*Var7&&Var7[1]== ){
else 
Var7  Var49; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var50=strdup(Var7+2); 
char *Var51=strchr(Var50,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var7+2); 
char  Var29=*Var58; 
STRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var23=strchr(Var7+2,); 
int  Var60=FUNC15(Var1->memberVar5,Var23); 
const STRUCT6 *Var61=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
*Var7=; 
char *Var62=Var7-2; 
Var7=FUNC21(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC22((STRUCT6) Var7[1])&&!Var44){
if (!FUNC23(Var1->memberVar12,Var7+1)){
else 
char  Var29=*Var46; 
STRUCT2 *Var54=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
STRUCT3  Var66[FUNC24(Var64)-1],Var67[FUNC24(Var65)-1]; 
if (Var7[1]== (){
char *Var68=Var7+3; 
char *Var21=strchr(Var68,); 
if (!Var21){
*Var21=Var69; 
STRUCT3  Var70=FUNC15(Var1->memberVar5,Var68); 
STRUCT3  Var71=FUNC15(Var1->memberVar5,Var21+1); 
for (Var14=0; Var65[Var14]; Var14  Var32){
FUNC25(Var1->memberVar7,Var65[Var14],Var71); 
",2555,0
before_cmd.c,r_core_cmd_subst_i,False,False,258,CWE-,CallExpression,free,3450,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var20,*Var21; 
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var21+1,); 
const bool  Var24=Var21[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27
if (Var7&&(Var7[1]== ||Var7[1]==  Var28)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
if (Var7[0]&&Var7[1]== ){
int  Var33=FUNC9(Var1->memberVar7,STRING); 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var35=Var7-1; 
const bool  Var36=(Var7[1]== >); 
char *Var37=FUNC10(Var1,Var2); 
char *Var38=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var39=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var43,*Var8=strchr(Var7+1,!); 
STRUCT3  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var7  Var32=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var32){
if (*Var7&&Var7[1]== ){
else 
Var7  Var49; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var50=strdup(Var7+2); 
char *Var51=strchr(Var50,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var7+2); 
char  Var29=*Var58; 
STRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
if (!Var47){
Var47=Var2; 
else 
Var47=FUNC19(Var47,Var2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var23=strchr(Var7+2,); 
int  Var60=FUNC15(Var1->memberVar5,Var23); 
const STRUCT6 *Var61=(const STRUCT6 *) FUNC21(Var7+2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
*Var7=; 
char *Var62=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC22((STRUCT6) Var7[1])&&!Var44){
if (!FUNC23(Var1->memberVar12,Var7+1)){
else 
char  Var29=*Var46; 
STRUCT2 *Var54=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var66=Var7+3; 
char *Var21=strchr(Var66,); 
if (!Var21){
free(Var47); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); 
STRUCT3  Var68=FUNC15(Var1->memberVar5,Var21+1); 
if (Var47){
FUNC24(Var1,Var47); 
FUNC25(Var47); 
",2522,0
before_cmd.c,r_core_cmd_subst_i,False,False,259,CWE-,CallExpression,free,3451,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpasm);\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\tif (is_arch_set) {\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\t\tR_FREE (tmpasm);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
char *Var6=NULL ; 
STRUCT1 *Var7=NULL ; 
int  Var8=!Var9->memberVar1->memberVar1; 
int  Var10,Var11=0,Var12; 
bool  Var13=Var9->memberVar2; 
bool  Var14=Var9->memberVar3; 
STRUCT2  Var15=Var9->memberVar4; 
if (!Var16){
switch (*Var16){
if (Var16[1]== ){/*STRUCT3 */
char *Var17,*Var18; 
else 
char *Var19=strchr(Var16,; ); 
char *Var20=strchr(Var18+1,); 
const bool  Var21=Var18[2]== >; 
if (Var16[1]!= *&&!strstr(Var16,STRING)){
if (Var16[1]== >){
if (*Var16 != ){
if (Var22&&Var2){
int  Var11; 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
char *Var3=strchr(Var16,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var24=Var9->memberVar5->memberVar1; 
else 
char *Var25=FUNC2(Var9->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var11 == -1){
if (Var2&&(Var2 ==  Var16||Var2[-1]!= )){
if (*Var16 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
int  Var11; 
if (!*Var4){
if (!Var9->memberVar6){
else 
}else if (Var2 ==  Var16){
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
if (Var2[0]&&Var2[1]== ){
int  Var26=FUNC4(Var9->memberVar7,STRING); 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (!*Var4){
char *Var28=Var2-1; 
const bool  Var29=(Var2[1]== >); 
char *Var30=FUNC5(Var9,Var16); 
char *Var31=FUNC6(Var9->memberVar8,Var4,1); 
const char *Var32=FUNC7(Var9->memberVar7,STRING); 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
bool  Var33=false ; 
if (Var33){
else 
int  memberVar1=Var9->memberVar5->memberVar1; 
else 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (*Var16 != &&*Var16){
const char *Var34=strstr(Var16,STRING); 
if (Var34){
bool  Var35=false ; 
if (Var35){
if (Var2){
char *Var36,*Var3=strchr(Var2+1,!); 
STRUCT2  Var37=Var9->memberVar9; 
char *Var38=NULL ; 
const char *Var39=NULL ; 
bool  Var40=false ; 
char *Var41=NULL ; 
char *Var42=NULL ; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var43=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); 
STRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var49=strdup(Var2+2); 
char  Var23=*Var50; 
STRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); 
char *Var16=FUNC12(Var9,Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var20=strchr(Var2+2,); 
int  Var52=FUNC9(Var9->memberVar5,Var20); 
const STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var54=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC15((STRUCT5) Var2[1])&&!Var37){
if (!FUNC16(Var9->memberVar12,Var2+1)){
else 
char  Var23=*Var39; 
STRUCT1 *Var46=Var7; 
if (Var5){
if (Var2[1]== ){
char *Var55=Var2+3; 
const char *Var56[]={STRING,STRING,STRING,
const char *Var57[]={STRING,STRING,STRING,
if (Var2[1]== (){
char *Var58=Var2+3; 
char *Var18=strchr(Var58,); 
if (!Var18){
free(Var42); 
STRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); 
STRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); 
if (Var40){
FUNC17(Var9->memberVar7,STRING,Var42); 
FUNC18(Var42); 
",1996,0
before_cmd.c,r_core_cmd_subst_i,False,False,260,CWE-,CallExpression,free,3452,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpbits);\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
char *Var6=NULL ; 
STRUCT1 *Var7=NULL ; 
int  Var8=!Var9->memberVar1->memberVar1; 
int  Var10,Var11=0,Var12; 
bool  Var13=Var9->memberVar2; 
bool  Var14=Var9->memberVar3; 
STRUCT2  Var15=Var9->memberVar4; 
if (!Var16){
switch (*Var16){
if (Var16[1]== ){/*STRUCT3 */
char *Var17,*Var18; 
else 
char *Var19=strchr(Var16,; ); 
char *Var20=strchr(Var18+1,); 
const bool  Var21=Var18[2]== >; 
if (Var16[1]!= *&&!strstr(Var16,STRING)){
if (Var16[1]== >){
if (*Var16 != ){
if (Var22&&Var2){
int  Var11; 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
char *Var3=strchr(Var16,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var24=Var9->memberVar5->memberVar1; 
else 
char *Var25=FUNC2(Var9->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var11 == -1){
if (Var2&&(Var2 ==  Var16||Var2[-1]!= )){
if (*Var16 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
int  Var11; 
if (!*Var4){
if (!Var9->memberVar6){
else 
}else if (Var2 ==  Var16){
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
if (Var2[0]&&Var2[1]== ){
int  Var26=FUNC4(Var9->memberVar7,STRING); 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (!*Var4){
char *Var28=Var2-1; 
const bool  Var29=(Var2[1]== >); 
char *Var30=FUNC5(Var9,Var16); 
char *Var31=FUNC6(Var9->memberVar8,Var4,1); 
const char *Var32=FUNC7(Var9->memberVar7,STRING); 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
bool  Var33=false ; 
if (Var33){
else 
int  memberVar1=Var9->memberVar5->memberVar1; 
else 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (*Var16 != &&*Var16){
const char *Var34=strstr(Var16,STRING); 
if (Var34){
bool  Var35=false ; 
if (Var35){
if (Var2){
char *Var36,*Var3=strchr(Var2+1,!); 
STRUCT2  Var37=Var9->memberVar9; 
char *Var38=NULL ; 
const char *Var39=NULL ; 
bool  Var40=false ; 
char *Var41=NULL ; 
char *Var42=NULL ; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var43=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); 
STRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var49=strdup(Var2+2); 
char  Var23=*Var50; 
STRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); 
char *Var16=FUNC12(Var9,Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var20=strchr(Var2+2,); 
int  Var52=FUNC9(Var9->memberVar5,Var20); 
const STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var54=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC15((STRUCT5) Var2[1])&&!Var37){
if (!FUNC16(Var9->memberVar12,Var2+1)){
else 
char  Var23=*Var39; 
STRUCT1 *Var46=Var7; 
if (Var5){
if (Var2[1]== ){
char *Var55=Var2+3; 
const char *Var56[]={STRING,STRING,STRING,
const char *Var57[]={STRING,STRING,STRING,
if (Var2[1]== (){
char *Var58=Var2+3; 
char *Var18=strchr(Var58,); 
if (!Var18){
free(Var38); 
STRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); 
STRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); 
if (Var40){
FUNC17(Var9->memberVar7,STRING,Var38); 
",1988,0
before_cmd.c,foreach_comment,False,False,261,CWE-,CallExpression,free,3576,-3,"['static int foreach_comment(void *user, const char *k, const char *v) {\n', '\tif (!strncmp (k, ""meta.C."", 7)) {\n', '\t\tchar *cmt = (char *)sdb_decode (v, 0);\n', '\t\tif (cmt) {\n', '\t\t\tfree (cmt);\n']","static int FUNC1(void *Var1,const char *Var2,const char *Var3){
if (!FUNC2(Var2,STRING,7)){
char *Var4=(char *) FUNC3(Var3,0); 
if (Var4){
free(Var4); 
",84,0
before_cmd.c,foreach_pairs,False,False,262,CWE-,CallExpression,strchr,3599,-3,"['static void foreach_pairs(RCore *core, const char *cmd, const char *each) {\n', '\tconst char *arg;\n', '\tint pair = 0;\n', '\tfor (arg = each ; ; ) {\n', ""\t\tchar *next = strchr (arg, ' ');\n"", '\t\tif (next) {\n', '\t\t\t*next = 0;\n', '\t\tif (arg && *arg) {\n', '\t\t\tut64 n = r_num_get (NULL, arg);\n', '\t\t\tif (pair%2) {\n', '\t\t\t\tr_core_block_size (core, n);\n', 'else\n', '\t\t\t\tr_core_seek (core, n, 1);\n', '\t\tif (!next) {\n', '\t\targ = next + 1;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
const char *Var4; 
int  Var5=0; 
for (Var4=Var3; ; ){
char *Var6=strchr(Var4,); 
if (Var6){
*Var6=0; 
if (Var4&&*Var4){
STRUCT2  Var7=FUNC2(NULL ,Var4); 
if (Var5%2){
FUNC3(Var1,Var7); 
else 
FUNC4(Var1,Var7,1); 
if (!Var6){
Var4=Var6+1; 
",176,1
before_cmd.c,r_core_cmd_foreach3,False,False,263,CWE-,CallExpression,free,3642,-3,"['R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // ""@@@""\n', '\tRDebug *dbg = core->dbg;\n', '\tconst char *filter = NULL;\n', ""\tif (each[1] == ':') {\n"", '\t\tfilter = each + 2;\n', '\tswitch (each[0]) {\n', '\t\tif (filter) {\n', '\t\t\tchar *arg = r_core_cmd_str (core, filter);\n', '\t\t\tforeach_pairs (core, cmd, arg);\n', '\t\t\tfree (arg);\n', '\t\t\tint fd = r_io_fd_get_current (core->io);\n', '\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 bszorig = core->blocksize;\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\tint cbsz = core->blocksize;\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n', '\t\t\tut64 off = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING
STRUCT2 *Var5=Var2->memberVar1; 
const char *Var6=NULL ; 
if (Var4[1]== ){
Var6=Var4+2; 
switch (Var4[0]){
if (Var6){
char *Var7=FUNC2(Var2,Var6); 
FUNC3(Var2,Var3,Var7); 
free(Var7); 
int  Var8=FUNC4(Var2->memberVar2); 
STRUCT3 *Var9=FUNC5(Var2->memberVar2,Var8); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var11=FUNC6(Var2->memberVar4,Var12); 
STRUCT5 *Var13=FUNC7(Var2->memberVar5); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var14=Var2->memberVar6; 
STRUCT5 *Var13=FUNC7(Var2->memberVar5); 
int  Var15=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
char *Var17=Var6 FUNC8(Var6) NULL ; 
STRUCT4  Var18=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT6 *Var19=FUNC9(Var2->memberVar7,Var2->memberVar3,0); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
",471,0
before_cmd.c,r_core_cmd_foreach3,False,False,264,CWE-,CallExpression,free,3728,-3,"['\tRDebug *dbg = core->dbg;\n', '\tswitch (each[0]) {\n', '\t\t\tchar *arg = r_core_cmd_str (core, filter);\n', '\t\t\tint fd = r_io_fd_get_current (core->io);\n', '\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRBinImport *imp;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tchar *impflag = r_str_newf (""sym.imp.%s"", imp->name);\n', '\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n', '\t\t\t\tfree (impflag);\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 bszorig = core->blocksize;\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\tint cbsz = core->blocksize;\n', '\t\t\t\tut64 addr = sec->vaddr;\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 off = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n']","STRUCT1 *Var1=Var2->memberVar1; 
switch (Var3[0]){
char *Var4=FUNC1(Var2,Var5); 
int  Var6=FUNC2(Var2->memberVar2); 
STRUCT2 *Var7=FUNC3(Var2->memberVar2,Var6); 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT4 *Var9; 
STRUCT3  Var8=Var2->memberVar3; 
char *Var10=FUNC4(STRING,Var9->memberVar1); 
STRUCT3  Var11=FUNC5(Var2->memberVar4,Var10); 
free(Var10); 
STRUCT5 *Var12=FUNC6(Var2->memberVar5); 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var13=Var2->memberVar6; 
STRUCT5 *Var12=FUNC6(Var2->memberVar5); 
int  Var14=Var2->memberVar6; 
STRUCT3  Var11=Var15->memberVar1; 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var17=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT6 *Var18=FUNC7(Var2->memberVar7,Var2->memberVar3,0); 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
",401,0
before_cmd.c,r_core_cmd_foreach3,False,False,265,CWE-,CallExpression,free,3819,-3,"['R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // ""@@@""\n', '\tRDebug *dbg = core->dbg;\n', '\tconst char *filter = NULL;\n', ""\tif (each[1] == ':') {\n"", '\t\tfilter = each + 2;\n', '\tswitch (each[0]) {\n', '\t\t\tchar *arg = r_core_cmd_str (core, filter);\n', '\t\t\tint fd = r_io_fd_get_current (core->io);\n', '\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 bszorig = core->blocksize;\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\tint cbsz = core->blocksize;\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n', '\t\t\tut64 off = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tr_flag_foreach_glob (core->flags, glob, exec_command_on_flag, &u);\n', '\t\t\tfree (glob);\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING
STRUCT2 *Var5=Var2->memberVar1; 
const char *Var6=NULL ; 
if (Var4[1]== ){
Var6=Var4+2; 
switch (Var4[0]){
char *Var7=FUNC2(Var2,Var6); 
int  Var8=FUNC3(Var2->memberVar2); 
STRUCT3 *Var9=FUNC4(Var2->memberVar2,Var8); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var11=FUNC5(Var2->memberVar4,Var12); 
STRUCT5 *Var13=FUNC6(Var2->memberVar5); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var14=Var2->memberVar6; 
STRUCT5 *Var13=FUNC6(Var2->memberVar5); 
int  Var15=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
char *Var17=Var6 FUNC7(Var6) NULL ; 
STRUCT4  Var18=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
FUNC8(Var2->memberVar7,Var17,Var19,&Var20); 
free(Var17); 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT6 *Var21=FUNC9(Var2->memberVar8,Var2->memberVar3,0); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
",470,0
before_cmd.c,foreachOffset,False,False,266,CWE-,CallExpression,strdup,3867,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *cmd = strdup (_cmd);\n', '\twhile (each) {\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\twhile (each && *each) {\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\tr_core_cmd (core, cmd, 0);\n', '\tfree (cmd);\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=strdup(Var2); 
while (Var3){
if (!*Var3){
char *Var5=strchr(Var3,Var6); 
while (Var3&&*Var3){
char *Var7=strchr(Var3,); 
if (Var7){
else 
if (!*Var3){
FUNC2(Var1,Var4,0); 
free(Var4); 
",145,1
before_cmd.c,foreachOffset,False,False,267,CWE-,CallExpression,strchr,3881,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *nextLine = NULL;\n', '\tut64 addr;\n', '\twhile (each) {\n', ""\t\twhile (*each == ' ') {\n"", '\t\t\teach++;\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\t\tnextLine = nl + 1;\n', 'else\n', '\t\t\tnextLine = NULL;\n', ""\t\tnl = strchr (each, '#');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\twhile (each && *each) {\n', ""\t\t\twhile (*each == ' ') {\n"", '\t\t\t\teach++;\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', ""\t\t\t\t*str = '\\0';\n"", '\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t*str = ' ';\n"", '\t\t\t\teach = str + 1;\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\tr_core_seek (core, addr, 1);\n', '\t\teach = nextLine;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=NULL ; 
STRUCT2  Var5; 
while (Var3){
while (*Var3 == ){
Var3  Var6; 
if (!*Var3){
char *Var7=strchr(Var3,Var8); 
if (Var7){
*Var7=0; 
Var4=Var7+1; 
else 
Var4=NULL ; 
Var7=strchr(Var3,); 
if (Var7){
*Var7=0; 
while (Var3&&*Var3){
while (*Var3 == ){
Var3  Var6; 
char *Var9=strchr(Var3,); 
if (Var9){
*Var9=0; 
Var5=FUNC2(Var1->memberVar1,Var3); 
*Var9=; 
Var3=Var9+1; 
else 
if (!*Var3){
Var5=FUNC2(Var1->memberVar1,Var3); 
FUNC3(Var1,Var5,1); 
Var3=Var4; 
",302,1
before_cmd.c,foreachOffset,False,False,268,CWE-,CallExpression,strchr,3889,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *nextLine = NULL;\n', '\tut64 addr;\n', '\twhile (each) {\n', ""\t\twhile (*each == ' ') {\n"", '\t\t\teach++;\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\t\tnextLine = nl + 1;\n', 'else\n', '\t\t\tnextLine = NULL;\n', ""\t\tnl = strchr (each, '#');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\twhile (each && *each) {\n', ""\t\t\twhile (*each == ' ') {\n"", '\t\t\t\teach++;\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\teach = nextLine;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=NULL ; 
STRUCT2  Var5; 
while (Var3){
while (*Var3 == ){
Var3  Var6; 
if (!*Var3){
char *Var7=strchr(Var3,Var8); 
if (Var7){
*Var7=0; 
Var4=Var7+1; 
else 
Var4=NULL ; 
Var7=strchr(Var3,); 
if (Var7){
*Var7=0; 
while (Var3&&*Var3){
while (*Var3 == ){
Var3  Var6; 
char *Var9=strchr(Var3,); 
if (Var9){
Var5=FUNC2(Var1->memberVar1,Var3); 
else 
if (!*Var3){
Var5=FUNC2(Var1->memberVar1,Var3); 
Var3=Var4; 
",267,1
before_cmd.c,foreachOffset,False,False,269,CWE-,CallExpression,strchr,3899,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *nextLine = NULL;\n', '\tut64 addr;\n', '\twhile (each) {\n', ""\t\twhile (*each == ' ') {\n"", '\t\t\teach++;\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\tif (nl) {\n', '\t\t\tnextLine = nl + 1;\n', 'else\n', '\t\t\tnextLine = NULL;\n', ""\t\tnl = strchr (each, '#');\n"", '\t\twhile (each && *each) {\n', ""\t\t\twhile (*each == ' ') {\n"", '\t\t\t\teach++;\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', ""\t\t\t\t*str = '\\0';\n"", '\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t*str = ' ';\n"", '\t\t\t\teach = str + 1;\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\teach = NULL;\n', '\t\t\tr_core_seek (core, addr, 1);\n', '\t\teach = nextLine;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=NULL ; 
STRUCT2  Var5; 
while (Var3){
while (*Var3 == ){
Var3  Var6; 
if (!*Var3){
char *Var7=strchr(Var3,Var8); 
if (Var7){
Var4=Var7+1; 
else 
Var4=NULL ; 
Var7=strchr(Var3,); 
while (Var3&&*Var3){
while (*Var3 == ){
Var3  Var6; 
char *Var9=strchr(Var3,); 
if (Var9){
*Var9=0; 
Var5=FUNC2(Var1->memberVar1,Var3); 
*Var9=; 
Var3=Var9+1; 
else 
if (!*Var3){
Var5=FUNC2(Var1->memberVar1,Var3); 
Var3=NULL ; 
FUNC3(Var1,Var5,1); 
Var3=Var4; 
",287,1
before_cmd.c,foreachOffset,False,False,270,CWE-,CallExpression,free,3918,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *cmd = strdup (_cmd);\n', '\twhile (each) {\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\twhile (each && *each) {\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\tr_core_cmd (core, cmd, 0);\n', '\tfree (cmd);\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=strdup(Var2); 
while (Var3){
if (!*Var3){
char *Var5=strchr(Var3,Var6); 
while (Var3&&*Var3){
char *Var7=strchr(Var3,); 
if (Var7){
else 
if (!*Var3){
FUNC2(Var1,Var4,0); 
free(Var4); 
",145,1
before_cmd.c,r_core_cmd_foreach,False,False,271,CWE-,CallExpression,strdup,3953,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar ch;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tut64 oseek, addr;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_core_cmd0 (core, each);\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tif (*str == ':' || *str == ' ') {\n"", '\t\t\t\tstr++;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\tif (count == 3) {\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\teach = out;\n', ""\t\t\t\twhile (*each == ' ') {\n"", '\t\t\t\t\teach++;\n', '\t\t\t\tif (!*each) {\n', ""\t\t\t\tstr = strchr (each, ' ');\n"", '\t\t\t\tif (str) {\n', ""\t\t\t\t\t*str = '\\0';\n"", '\t\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t\t*str = ' ';\n"", 'else\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\teach = str + 1;\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t} while (str != NULL);\n', '\t\t\tfree (out);\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', 'else\n', '\t\t\t\teprintf (""cannot open file \'%s\' to read offsets\\n"", each + 1);\n', ""\t\tfor (; *each == ' '; each++) {\n"", '\t\twhile (str[i]) {\n', '\t\t\tch = str[i];\n', ""\t\t\tstr[i] = '\\0';\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\tstr[i] = ch;\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\tR_FREE (word);\n', '\tfree (word);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char  Var7; 
char *Var8=NULL ; 
char *Var9,*Var10=NULL ; 
STRUCT2  Var11,Var12; 
Var10=Var9=strdup(Var4); 
switch (Var4[0]){
char *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2,Var4); 
free(Var10); 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var15=Var2->memberVar4; 
if (Var14){
if (FUNC5()){
char *Var9=Var4+1; 
if (*Var9 == ||*Var9 == ){
Var9  Var16; 
int  Var17=FUNC6(Var9,); 
if (Var17 == 3){
STRUCT2  Var18=FUNC7(Var2->memberVar5,FUNC8(Var9,0)); 
STRUCT2  Var19=FUNC7(Var2->memberVar5,FUNC8(Var9,1)); 
STRUCT2  Var20=FUNC7(Var2->memberVar5,FUNC8(Var9,2)); 
int  Var5; 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT3 *Var14; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var14->memberVar1,Var4+2)){
if (FUNC5()){
else 
STRUCT3 *Var14; 
if (Var2->memberVar2){
STRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC5()){
int  Var23=Var2->memberVar7->memberVar1; 
STRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); 
if (Var4[1]== ){
char *Var25=FUNC11(Var2,Var4+2); 
FUNC12(Var2,Var3,Var9+1); 
if (Var4[1]==  Var26&&Var4[2]==  Var27){
STRUCT2  Var11=Var2->memberVar3; 
char *Var28=FUNC13(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var28){
Var4=Var28; 
while (*Var4 == ){
Var4  Var16; 
if (!*Var4){
Var9=strchr(Var4,); 
if (Var9){
*Var9=0; 
memberVar1=FUNC7(Var2->memberVar5,Var4); 
*Var9=; 
else 
memberVar1=FUNC7(Var2->memberVar5,Var4); 
Var4=Var9+1; 
FUNC14(Var2,memberVar1,1); 
}while (Var9 != NULL ); 
free(Var28); 
if (Var4[1]== (){
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){
if (FUNC5()){
FUNC15(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
STRUCT6 *Var29=FUNC16(Var4+1,STRING); 
if (Var29){
else 
FUNC17(STRING,Var4+1); 
for (; *Var4 == ; Var4  Var16){
while (Var9[Var5]){
Var7=Var9[Var5]; 
Var9[Var5]=0; 
Var8=strdup(Var9+Var6); 
if (!Var8){
Var9[Var5]=Var7; 
const STRUCT7 *Var30=FUNC18(Var2->memberVar10); 
STRUCT5 *Var31=FUNC19((Var32) Var33); 
if (!Var31){
if (FUNC5()){
char *Var34=NULL ; 
const char *Var35=NULL ; 
FUNC20(Var8); 
free(Var8); 
free(Var10); 
free(Var10); 
",1184,0
before_cmd.c,r_core_cmd_foreach,False,False,272,CWE-,CallExpression,strdup,3958,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tRFlagItem *flag;\n', '\tut64 oseek, addr;\n', '\toseek = core->offset;\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_config_set (core->config, ""cmd.hit"", cmd);\n', '\t\tr_core_cmd0 (core, each);\n', '\t\tr_config_set (core->config, ""cmd.hit"", cmdhit);\n', '\t\tfree (cmdhit);\n', '\t\tr_core_cmd_help (core, help_msg_at_at);\n', '\t\t\tRAnalBlock *bb;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tr_core_block_size (core, bb->size);\n', '\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tr_core_block_size (core, bs);\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\tif (count == 3) {\n', '\t\t\t\tut64 cur;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\t\tfor (cur = from; cur < to; cur += step) {\n', '\t\t\t\t\t(void)r_core_seek (core, cur, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tRAnalBlock *bb;\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n', '\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tcore->cons->context->grep = grep;\n', '\t\t\tRDebugPid *p;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\tr_debug_select (core->dbg, pid, pid);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tif (arg) {\n', '\t\t\t\tforeachOffset (core, cmd, arg);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\t\tRDebugFrame *frame;\n', '\t\t\tRList *list;\n', '\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n', '\t\t\t\tswitch (each[3]) {\n', '\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n', '\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n', '\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n', '\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\tr_core_seek (core, oseek, 0);\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\tif (str) {\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', 'else\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t} while (str != NULL);\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tchar cmd2[1024];\n', '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\t\taddr = core->rcmd->macro._brk_value;\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tr_core_cmd (core, cmd2, 0);\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tchar cmd2[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', '\t\t\t\tcore->rcmd->macro.counter = 0;\n', '\t\t\t\twhile (!feof (fd)) {\n', '\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n', '\t\t\t\t\taddr = r_num_math (core->num, buf);\n', '\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n', '\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n', '\t\t\t\t\tcore->rcmd->macro.counter++;\n', '\t\tcore->rcmd->macro.counter = 0;\n', '\t\twhile (str[i]) {\n', '\t\t\tif (!word) {\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\tr_flag_foreach_space (core->flags, flagspace, duplicate_flag, &u);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\tcore->rcmd->macro.counter++ ;\n', '\tcore->offset = oseek;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char *Var7=NULL ; 
char *Var8,*Var9=NULL ; 
STRUCT2 *Var10; 
STRUCT3  Var11,Var12; 
Var11=Var2->memberVar1; 
switch (Var4[0]){
char *Var13=strdup(FUNC2(Var2->memberVar2,STRING)); 
FUNC3(Var2->memberVar2,STRING,Var3); 
FUNC4(Var2,Var4); 
FUNC3(Var2->memberVar2,STRING,Var13); 
free(Var13); 
FUNC5(Var2,Var14); 
STRUCT4 *Var15; 
STRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); 
int  Var17=Var2->memberVar4; 
if (Var16){
FUNC7(Var2,Var15->size ); 
FUNC8(Var2,Var15->memberVar1,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
FUNC7(Var2,Var17); 
char *Var8=Var4+1; 
int  Var18=FUNC11(Var8,); 
if (Var18 == 3){
STRUCT3  Var19; 
STRUCT3  Var20=FUNC12(Var2->memberVar5,FUNC13(Var8,0)); 
STRUCT3  Var21=FUNC12(Var2->memberVar5,FUNC13(Var8,1)); 
STRUCT3  Var22=FUNC12(Var2->memberVar5,FUNC13(Var8,2)); 
for (Var19=Var20; Var19<Var21; Var19  STRUCT6  Var22){
(void ) FUNC8(Var2,Var19,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
STRUCT4 *Var15; 
int  Var5; 
STRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); 
if (Var16){
for (Var5=0; Var5<Var15->memberVar2; Var5  Var23){
STRUCT3  memberVar1=Var15->memberVar1+Var15->memberVar3[Var5]; 
FUNC8(Var2,memberVar1,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
if (Var4[1]== ){
STRUCT5 *Var16; 
if (Var2->memberVar3){
if (Var4[2]&&strstr(Var16->memberVar1,Var4+2)){
FUNC8(Var2,Var16->memberVar2,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
else 
STRUCT5 *Var16; 
if (Var2->memberVar3){
STRUCT7  Var24=Var2->memberVar6->memberVar1->memberVar1; 
char *Var25; 
FUNC8(Var2,Var16->memberVar2,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
Var2->memberVar6->memberVar1->memberVar1=memberVar1; 
STRUCT8 *Var26; 
int  Var27=Var2->memberVar7->memberVar1; 
if (Var2->memberVar7->memberVar2&&Var2->memberVar7->memberVar2->memberVar1){
STRUCT9 *Var28=Var2->memberVar7->memberVar2->memberVar1(Var2->memberVar7,FUNC14(0,memberVar1)); 
FUNC15(Var2->memberVar7,Var26->memberVar1,Var26->memberVar1); 
FUNC9(Var2,Var3,0); 
FUNC15(Var2->memberVar7,memberVar1,memberVar1); 
if (Var4[1]== ){
char *Var29=FUNC16(Var2,Var4+2); 
if (Var29){
FUNC17(Var2,Var3,Var29); 
FUNC17(Var2,Var3,Var8+1); 
if (Var4[1]==  Var30&&Var4[2]==  Var31){
STRUCT3  Var11=Var2->memberVar1; 
STRUCT10 *Var32; 
STRUCT9 *Var28; 
Var28=FUNC18(Var2->memberVar7,Var33); 
switch (Var4[3]){
FUNC8(Var2,Var32->memberVar1,1); 
FUNC8(Var2,Var32->memberVar2,1); 
FUNC8(Var2,Var32->memberVar3,1); 
FUNC9(Var2,Var3,0); 
FUNC8(Var2,Var11,0); 
char *Var34=FUNC19(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
if (Var34){
if (!*Var4){
if (Var8){
memberVar3=FUNC12(Var2->memberVar5,Var4); 
else 
memberVar3=FUNC12(Var2->memberVar5,Var4); 
FUNC8(Var2,memberVar3,1); 
FUNC9(Var2,Var3,0); 
}while (Var8 != NULL ); 
if (Var4[1]== (){
char  Var35[1024]; 
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var23){
if (FUNC10()){
FUNC20(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
memberVar3=Var2->memberVar9->memberVar1.memberVar3; 
FUNC8(Var2,memberVar3,1); 
FUNC9(Var2,Var35,0); 
else 
char  Var25[1024]; 
char  Var35[1024]; 
STRUCT11 *Var36=FUNC21(Var4+1,STRING); 
if (Var36){
Var2->memberVar9->memberVar1.memberVar1=0; 
while (!FUNC22(Var36)){
if (!fgets(Var25,sizeof (Var25),Var36)){
memberVar3=FUNC12(Var2->memberVar5,Var25); 
FUNC8(Var2,memberVar3,1); //Var37
FUNC9(Var2,Var35,0); 
Var2->memberVar9->memberVar1.memberVar1  Var23; 
Var2->memberVar9->memberVar1.memberVar1=0; 
while (Var8[Var5]){
if (!Var7){
const STRUCT12 *Var38=FUNC23(Var2->memberVar10); 
STRUCT9 *Var39=FUNC24((Var40) Var41); 
if (!Var39){
FUNC25(Var2->memberVar10,Var38,Var42,&Var43); 
if (FUNC10()){
char *Var25=NULL ; 
const char *Var44=NULL ; 
FUNC8(Var2,Var10->memberVar1,1); 
FUNC9(Var2,Var3,0); 
Var2->memberVar9->memberVar1.memberVar1  Var23; 
Var2->memberVar1=Var11; 
",1839,0
before_cmd.c,r_core_cmd_foreach,False,False,273,CWE-,CallExpression,free,3962,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_config_set (core->config, ""cmd.hit"", cmdhit);\n', '\t\tfree (cmdhit);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
switch (Var4[0]){
char *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2->memberVar1,STRING,Var5); 
free(Var5); 
STRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var7=Var2->memberVar4; 
char *Var8=Var4+1; 
STRUCT3  Var9=FUNC5(Var2->memberVar5,FUNC6(Var8,0)); 
STRUCT3  Var10=FUNC5(Var2->memberVar5,FUNC6(Var8,1)); 
STRUCT3  Var11=FUNC5(Var2->memberVar5,FUNC6(Var8,2)); 
STRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; 
int  Var13=Var2->memberVar7->memberVar1; 
STRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); 
char *Var15=FUNC9(Var2,Var4+2); 
STRUCT3  Var16=Var2->memberVar3; 
char *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
STRUCT6 *Var18=FUNC11(Var4+1,STRING); 
const STRUCT7 *Var19=FUNC12(Var2->memberVar9); 
",417,0
before_cmd.c,r_core_cmd_foreach,False,False,274,CWE-,CallExpression,free,3964,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
Var6=Var5=strdup(Var4); 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
free(Var6); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
if (Var8){
if (FUNC4()){
char *Var5=Var4+1; 
int  Var10=FUNC5(Var5,); 
STRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); 
STRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
if (Var4[1]== ){
STRUCT2 *Var8; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var8; 
if (Var2->memberVar2){
STRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var15=Var2->memberVar7->memberVar1; 
STRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var17=FUNC10(Var2,Var4+2); 
STRUCT3  Var18=Var2->memberVar3; 
char *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); 
STRUCT6 *Var20=FUNC12(Var4+1,STRING); 
const STRUCT7 *Var21=FUNC13(Var2->memberVar9); 
free(Var6); 
free(Var6); 
",573,0
before_cmd.c,r_core_cmd_foreach,False,False,275,CWE-,CallExpression,strstr,4043,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_core_cmd0 (core, each);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', 'else\n', '\t\t\t\teprintf (""cannot open file \'%s\' to read offsets\\n"", each + 1);\n', ""\t\tfor (; *each == ' '; each++) {\n"", '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char *Var7,*Var8=NULL ; 
Var8=Var7=strdup(Var4); 
switch (Var4[0]){
char *Var9=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2,Var4); 
STRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var11=Var2->memberVar4; 
char *Var7=Var4+1; 
int  Var12=FUNC5(Var7,); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var7,0)); 
STRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var7,1)); 
STRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var7,2)); 
int  Var5; 
STRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT2 *Var10; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var10->memberVar1,Var4+2)){
FUNC8(Var2,Var10->memberVar2,1); 
else 
STRUCT2 *Var10; 
STRUCT4  Var18=Var2->memberVar6->memberVar1->memberVar1; 
int  Var19=Var2->memberVar7->memberVar1; 
STRUCT5 *Var20=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); 
if (Var4[1]== ){
char *Var21=FUNC11(Var2,Var4+2); 
if (Var4[1]==  Var22&&Var4[2]==  Var23){
STRUCT3  Var24=Var2->memberVar3; 
char *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var4[1]== (){
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var26){
if (FUNC13()){
FUNC14(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
STRUCT6 *Var27=FUNC15(Var4+1,STRING); 
if (Var27){
else 
FUNC16(STRING,Var4+1); 
for (; *Var4 == ; Var4  Var26){
const STRUCT7 *Var28=FUNC17(Var2->memberVar10); 
",753,0
before_cmd.c,r_core_cmd_foreach,False,False,276,CWE-,CallExpression,strdup,4065,-3,"['\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tbuf = strdup (buf);\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n']","switch (Var1[0]){
char *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
int  Var5=Var3->memberVar4; 
char *Var6=Var1+1; 
STRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); 
STRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); 
STRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
if (Var1[1]== ){
if (Var3->memberVar2){
STRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; 
char *Var11; 
Var11=(char *) FUNC5(); 
if (Var11){
Var11=strdup(Var11); 
FUNC6(Var11); 
free(Var11); 
int  Var12=Var3->memberVar7->memberVar1; 
STRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); 
char *Var14=FUNC9(Var3,Var1+2); 
STRUCT2  Var15=Var3->memberVar3; 
char *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); 
else 
char  Var11[1024]; 
STRUCT5 *Var17=FUNC11(Var1+1,STRING); 
const STRUCT6 *Var18=FUNC12(Var3->memberVar9); 
char *Var11=NULL ; 
",463,0
before_cmd.c,r_core_cmd_foreach,False,False,277,CWE-,CallExpression,free,4069,-3,"['\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tbuf = strdup (buf);\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n']","switch (Var1[0]){
char *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
int  Var5=Var3->memberVar4; 
char *Var6=Var1+1; 
STRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); 
STRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); 
STRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
if (Var1[1]== ){
if (Var3->memberVar2){
STRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; 
char *Var11; 
Var11=(char *) FUNC5(); 
if (Var11){
Var11=strdup(Var11); 
FUNC6(Var11); 
free(Var11); 
int  Var12=Var3->memberVar7->memberVar1; 
STRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); 
char *Var14=FUNC9(Var3,Var1+2); 
STRUCT2  Var15=Var3->memberVar3; 
char *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); 
else 
char  Var11[1024]; 
STRUCT5 *Var17=FUNC11(Var1+1,STRING); 
const STRUCT6 *Var18=FUNC12(Var3->memberVar9); 
char *Var11=NULL ; 
",463,0
before_cmd.c,r_core_cmd_foreach,False,False,278,CWE-,CallExpression,free,4102,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tif (arg) {\n', '\t\t\t\tforeachOffset (core, cmd, arg);\n', '\t\t\t\tfree (arg);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
switch (Var4[0]){
char *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var7=Var2->memberVar4; 
char *Var8=Var4+1; 
STRUCT3  Var9=FUNC4(Var2->memberVar5,FUNC5(Var8,0)); 
STRUCT3  Var10=FUNC4(Var2->memberVar5,FUNC5(Var8,1)); 
STRUCT3  Var11=FUNC4(Var2->memberVar5,FUNC5(Var8,2)); 
STRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; 
int  Var13=Var2->memberVar7->memberVar1; 
STRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); 
if (Var4[1]== ){
char *Var15=FUNC8(Var2,Var4+2); 
if (Var15){
FUNC9(Var2,Var3,Var15); 
free(Var15); 
STRUCT3  Var16=Var2->memberVar3; 
char *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
STRUCT6 *Var18=FUNC11(Var4+1,STRING); 
const STRUCT7 *Var19=FUNC12(Var2->memberVar9); 
",436,0
before_cmd.c,r_core_cmd_foreach,False,False,279,CWE-,CallExpression,strchr,4153,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar ch;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tut64 oseek, addr;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_core_cmd0 (core, each);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tif (*str == ':' || *str == ' ') {\n"", '\t\t\t\tstr++;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\tif (count == 3) {\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\teach = out;\n', ""\t\t\t\twhile (*each == ' ') {\n"", '\t\t\t\t\teach++;\n', '\t\t\t\tif (!*each) {\n', ""\t\t\t\tstr = strchr (each, ' ');\n"", '\t\t\t\tif (str) {\n', ""\t\t\t\t\t*str = '\\0';\n"", '\t\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t\t*str = ' ';\n"", 'else\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\teach = str + 1;\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t} while (str != NULL);\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', 'else\n', '\t\t\t\teprintf (""cannot open file \'%s\' to read offsets\\n"", each + 1);\n', ""\t\tfor (; *each == ' '; each++) {\n"", '\t\twhile (str[i]) {\n', '\t\t\tch = str[i];\n', ""\t\t\tstr[i] = '\\0';\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\tstr[i] = ch;\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char  Var7; 
char *Var8=NULL ; 
char *Var9,*Var10=NULL ; 
STRUCT2  Var11,Var12; 
Var10=Var9=strdup(Var4); 
switch (Var4[0]){
char *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2,Var4); 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var15=Var2->memberVar4; 
char *Var9=Var4+1; 
if (*Var9 == ||*Var9 == ){
Var9  Var16; 
int  Var17=FUNC5(Var9,); 
if (Var17 == 3){
STRUCT2  Var18=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); 
STRUCT2  Var19=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); 
STRUCT2  Var20=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); 
int  Var5; 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT3 *Var14; 
if (Var2->memberVar2){
else 
STRUCT3 *Var14; 
STRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; 
int  Var23=Var2->memberVar7->memberVar1; 
STRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
if (Var4[1]== ){
char *Var25=FUNC10(Var2,Var4+2); 
FUNC11(Var2,Var3,Var9+1); 
if (Var4[1]==  Var26&&Var4[2]==  Var27){
STRUCT2  Var11=Var2->memberVar3; 
char *Var28=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var28){
Var4=Var28; 
while (*Var4 == ){
Var4  Var16; 
if (!*Var4){
Var9=strchr(Var4,); 
if (Var9){
*Var9=0; 
memberVar1=FUNC6(Var2->memberVar5,Var4); 
*Var9=; 
else 
memberVar1=FUNC6(Var2->memberVar5,Var4); 
Var4=Var9+1; 
FUNC13(Var2,memberVar1,1); 
}while (Var9 != NULL ); 
if (Var4[1]== (){
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){
if (FUNC14()){
FUNC15(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
STRUCT6 *Var29=FUNC16(Var4+1,STRING); 
if (Var29){
else 
FUNC17(STRING,Var4+1); 
for (; *Var4 == ; Var4  Var16){
while (Var9[Var5]){
Var7=Var9[Var5]; 
Var9[Var5]=0; 
Var8=strdup(Var9+Var6); 
if (!Var8){
Var9[Var5]=Var7; 
const STRUCT7 *Var30=FUNC18(Var2->memberVar10); 
STRUCT5 *Var31=FUNC19((Var32) Var33); 
if (!Var31){
if (FUNC14()){
char *Var34=NULL ; 
const char *Var35=NULL ; 
",1066,0
before_cmd.c,r_core_cmd_foreach,False,False,280,CWE-,CallExpression,free,4167,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\teach = out;\n', '\t\t\tfree (out);\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5=NULL ; 
char *Var6,*Var7=NULL ; 
Var7=Var6=strdup(Var4); 
switch (Var4[0]){
char *Var8=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var10=Var2->memberVar4; 
char *Var6=Var4+1; 
int  Var11=FUNC4(Var6,); 
STRUCT3  Var12=FUNC5(Var2->memberVar5,FUNC6(Var6,0)); 
STRUCT3  Var13=FUNC5(Var2->memberVar5,FUNC6(Var6,1)); 
STRUCT3  Var14=FUNC5(Var2->memberVar5,FUNC6(Var6,2)); 
STRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT4  Var15=Var2->memberVar6->memberVar1->memberVar1; 
int  Var16=Var2->memberVar7->memberVar1; 
STRUCT5 *Var17=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); 
char *Var18=FUNC9(Var2,Var4+2); 
STRUCT3  Var19=Var2->memberVar3; 
char *Var20=FUNC10(Var2->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var20){
Var4=Var20; 
free(Var20); 
STRUCT6 *Var21=FUNC11(Var4+1,STRING); 
const STRUCT7 *Var22=FUNC12(Var2->memberVar9); 
char *Var23=NULL ; 
const char *Var24=NULL ; 
",489,0
before_cmd.c,r_core_cmd_foreach,False,False,281,CWE-,CallExpression,fgets,4199,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tut64 oseek, addr;\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', ""\t\tif (each[1] == '(') {\n"", 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', '\t\t\t\twhile (!feof (fd)) {\n', ""\t\t\t\t\tbuf[0] = '\\0';\n"", '\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n', '\t\t\t\t\taddr = r_num_math (core->num, buf);\n', '\t\t\t\tfclose (fd);\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
STRUCT2  Var5,Var6; 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
char *Var10=Var4+1; 
STRUCT2  Var11=FUNC4(Var2->memberVar5,FUNC5(Var10,0)); 
STRUCT2  Var12=FUNC4(Var2->memberVar5,FUNC5(Var10,1)); 
STRUCT2  Var13=FUNC4(Var2->memberVar5,FUNC5(Var10,2)); 
STRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT2  Var6=Var14->memberVar1+Var14->memberVar2[Var15]; 
STRUCT4  Var16=Var2->memberVar6->memberVar1->memberVar1; 
char *Var17; 
int  Var18=Var2->memberVar7->memberVar1; 
STRUCT5 *Var19=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); 
char *Var20=FUNC8(Var2,Var4+2); 
STRUCT2  Var5=Var2->memberVar3; 
char *Var21=FUNC9(Var2->memberVar8,NULL ,0,Var10+((Var10[1]) 21)); 
if (Var4[1]== (){
else 
char  Var17[1024]; 
STRUCT6 *Var22=FUNC10(Var4+1,STRING); 
if (Var22){
while (!FUNC11(Var22)){
Var17[0]=0; 
if (!fgets(Var17,sizeof (Var17),Var22)){
memberVar1=FUNC4(Var2->memberVar5,Var17); 
fclose(Var22); 
const STRUCT7 *Var23=FUNC12(Var2->memberVar9); 
char *Var17=NULL ; 
",545,0
before_cmd.c,r_core_cmd_foreach,False,False,282,CWE-,CallExpression,fclose,4209,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tswitch (each[0]) {\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', ""\t\tif (each[1] == '(') {\n"", 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', '\t\t\t\twhile (!feof (fd)) {\n', '\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n', '\t\t\t\tfclose (fd);\n', '\t\t\t\t\tchar *buf = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
switch (Var4[0]){
char *Var5=Var4+1; 
char *Var6; 
char *Var7=FUNC2(Var2,Var4+2); 
if (Var4[1]== (){
else 
char  Var6[1024]; 
STRUCT2 *Var8=FUNC3(Var4+1,STRING); 
if (Var8){
while (!FUNC4(Var8)){
if (!fgets(Var6,sizeof (Var6),Var8)){
fclose(Var8); 
char *Var6=NULL ; 
",183,0
before_cmd.c,r_core_cmd_foreach,False,False,283,CWE-,CallExpression,strdup,4231,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar ch;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\ti = 0;\n', '\t\twhile (str[i]) {\n', '\t\t\tj = i;\n', ""\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n"", ""\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n"", '\t\t\tch = str[i];\n', ""\t\t\tstr[i] = '\\0';\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\tstr[i] = ch;\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\tR_FREE (word);\n', '\tfree (word);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char  Var7; 
char *Var8=NULL ; 
char *Var9,*Var10=NULL ; 
Var10=Var9=strdup(Var4); 
switch (Var4[0]){
char *Var11=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var13=Var2->memberVar4; 
if (Var12){
if (FUNC4()){
char *Var9=Var4+1; 
int  Var14=FUNC5(Var9,); 
STRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); 
STRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); 
STRUCT3  Var17=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); 
int  Var5; 
STRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT3  Var18=Var19->memberVar1+Var19->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT2 *Var12; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var12->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var12; 
if (Var2->memberVar2){
STRUCT4  Var20=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var21=Var2->memberVar7->memberVar1; 
STRUCT5 *Var22=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var23=FUNC10(Var2,Var4+2); 
FUNC11(Var2,Var3,Var9+1); 
STRUCT3  Var24=Var2->memberVar3; 
char *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); 
STRUCT6 *Var26=FUNC13(Var4+1,STRING); 
Var5=0; 
while (Var9[Var5]){
Var6=Var5; 
for (; Var9[Var6]&&Var9[Var6]== ; Var6  Var27){
for (Var5=Var6; Var9[Var5]&&Var9[Var5]!= ; Var5  Var27){
Var7=Var9[Var5]; 
Var9[Var5]=0; 
Var8=strdup(Var9+Var6); 
if (!Var8){
Var9[Var5]=Var7; 
const STRUCT7 *Var28=FUNC14(Var2->memberVar9); 
STRUCT5 *Var29=FUNC15((Var30) Var31); 
if (!Var29){
if (FUNC4()){
char *Var32=NULL ; 
const char *Var33=NULL ; 
FUNC16(Var8); 
free(Var8); 
",844,0
before_cmd.c,r_core_cmd_foreach,False,False,284,CWE-,CallExpression,strdup,4265,-3,"['\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tr_cons_break_push (NULL, NULL); //pop on return\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\t\tif (!*each) {\n', '\t\t\t} while (str != NULL);\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\twhile (str[i]) {\n', '\t\t\tif (!word) {\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\t\ttmp = r_cons_get_buffer ();\n', '\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4,*Var5=NULL ; 
FUNC1(NULL ,NULL ); //Var6  STRUCT1 return 
switch (Var7[0]){
char *Var8=strdup(FUNC2(Var9->memberVar1,STRING)); 
STRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); 
int  Var11=Var9->memberVar4; 
char *Var4=Var7+1; 
int  Var12=FUNC4(Var4,); 
STRUCT3  Var13=FUNC5(Var9->memberVar5,FUNC6(Var4,0)); 
STRUCT3  Var14=FUNC5(Var9->memberVar5,FUNC6(Var4,1)); 
STRUCT3  Var15=FUNC5(Var9->memberVar5,FUNC6(Var4,2)); 
int  Var1; 
STRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); 
STRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var1]; 
STRUCT4  Var18=Var9->memberVar6->memberVar1->memberVar1; 
char *Var19; 
int  Var20=Var9->memberVar7->memberVar1; 
STRUCT5 *Var21=Var9->memberVar7->memberVar2->FUNC7(Var9->memberVar7,FUNC8(0,memberVar1)); 
char *Var22=FUNC9(Var9,Var7+2); 
STRUCT3  Var23=Var9->memberVar3; 
char *Var24=FUNC10(Var9->memberVar8,NULL ,0,Var4+((Var4[1]) 21)); 
if (Var24){
if (!*Var7){
}while (Var4 != NULL ); 
else 
char  Var19[1024]; 
STRUCT6 *Var25=FUNC11(Var7+1,STRING); 
while (Var4[Var1]){
if (!Var3){
const STRUCT7 *Var26=FUNC12(Var9->memberVar9); 
STRUCT5 *Var27=FUNC13((Var28) Var29); 
if (!Var27){
if (FUNC14()){
char *Var19=NULL ; 
const char *Var30=NULL ; 
Var30=FUNC15(); 
Var19=Var30 strdup(Var30) NULL ; 
FUNC16(Var19); 
free(Var19); 
",632,0
before_cmd.c,r_core_cmd_foreach,False,False,285,CWE-,CallExpression,free,4268,-3,"['\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\twhile (str[i]) {\n', '\t\t\tif (!word) {\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\t\ttmp = r_cons_get_buffer ();\n', '\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4,*Var5=NULL ; 
switch (Var6[0]){
char *Var7=strdup(FUNC1(Var8->memberVar1,STRING)); 
char *Var4=Var6+1; 
int  Var9=FUNC2(Var4,); 
STRUCT1  Var10=FUNC3(Var8->memberVar2,FUNC4(Var4,0)); 
STRUCT1  Var11=FUNC3(Var8->memberVar2,FUNC4(Var4,1)); 
STRUCT1  Var12=FUNC3(Var8->memberVar2,FUNC4(Var4,2)); 
int  Var1; 
STRUCT1  Var13=Var14->memberVar1+Var14->memberVar2[Var1]; 
char *Var15; 
char *Var16=FUNC5(Var8,Var6+2); 
char *Var17=FUNC6(Var8->memberVar3,NULL ,0,Var4+((Var4[1]) 21)); 
else 
char  Var15[1024]; 
STRUCT2 *Var18=FUNC7(Var6+1,STRING); 
while (Var4[Var1]){
if (!Var3){
STRUCT3 *Var19=FUNC8((Var20) Var21); 
if (!Var19){
if (FUNC9()){
char *Var15=NULL ; 
const char *Var22=NULL ; 
Var22=FUNC10(); 
Var15=Var22 strdup(Var22) NULL ; 
FUNC11(Var15); 
free(Var15); 
",412,0
before_cmd.c,r_core_cmd_foreach,False,False,286,CWE-,CallExpression,free,4281,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\ti = 0;\n', '\t\twhile (str[i]) {\n', '\t\t\tj = i;\n', ""\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n"", ""\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\tR_FREE (word);\n', '\tfree (word);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char *Var7=NULL ; 
char *Var8,*Var9=NULL ; 
Var9=Var8=strdup(Var4); 
switch (Var4[0]){
char *Var10=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var12=Var2->memberVar4; 
if (Var11){
if (FUNC4()){
char *Var8=Var4+1; 
int  Var13=FUNC5(Var8,); 
STRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var8,0)); 
STRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var8,1)); 
STRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var8,2)); 
int  Var5; 
STRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT3  Var17=Var18->memberVar1+Var18->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT2 *Var11; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var11->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var11; 
if (Var2->memberVar2){
STRUCT4  Var19=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var20=Var2->memberVar7->memberVar1; 
STRUCT5 *Var21=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var22=FUNC10(Var2,Var4+2); 
STRUCT3  Var23=Var2->memberVar3; 
char *Var24=FUNC11(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
STRUCT6 *Var25=FUNC12(Var4+1,STRING); 
Var5=0; 
while (Var8[Var5]){
Var6=Var5; 
for (; Var8[Var6]&&Var8[Var6]== ; Var6  Var26){
for (Var5=Var6; Var8[Var5]&&Var8[Var5]!= ; Var5  Var26){
Var7=strdup(Var8+Var6); 
if (!Var7){
const STRUCT7 *Var27=FUNC13(Var2->memberVar9); 
STRUCT5 *Var28=FUNC14((Var29) Var30); 
if (!Var28){
if (FUNC4()){
char *Var31=NULL ; 
const char *Var32=NULL ; 
FUNC15(Var7); 
free(Var7); 
",790,0
before_cmd.c,r_core_cmd_foreach,False,False,287,CWE-,CallExpression,free,4282,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
Var6=Var5=strdup(Var4); 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
free(Var6); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
if (Var8){
if (FUNC4()){
char *Var5=Var4+1; 
int  Var10=FUNC5(Var5,); 
STRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); 
STRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
if (Var4[1]== ){
STRUCT2 *Var8; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var8; 
if (Var2->memberVar2){
STRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var15=Var2->memberVar7->memberVar1; 
STRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var17=FUNC10(Var2,Var4+2); 
STRUCT3  Var18=Var2->memberVar3; 
char *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); 
STRUCT6 *Var20=FUNC12(Var4+1,STRING); 
const STRUCT7 *Var21=FUNC13(Var2->memberVar9); 
free(Var6); 
free(Var6); 
",573,0
before_cmd.c,r_core_cmd_foreach,False,False,288,CWE-,CallExpression,free,4285,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
Var6=Var5=strdup(Var4); 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
free(Var6); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
if (Var8){
if (FUNC4()){
char *Var5=Var4+1; 
int  Var10=FUNC5(Var5,); 
STRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); 
STRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
if (Var4[1]== ){
STRUCT2 *Var8; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var8; 
if (Var2->memberVar2){
STRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var15=Var2->memberVar7->memberVar1; 
STRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var17=FUNC10(Var2,Var4+2); 
STRUCT3  Var18=Var2->memberVar3; 
char *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); 
STRUCT6 *Var20=FUNC12(Var4+1,STRING); 
const STRUCT7 *Var21=FUNC13(Var2->memberVar9); 
free(Var6); 
free(Var6); 
",573,0
before_cmd.c,run_pending_anal,False,False,289,CWE-,CallExpression,free,4297,-3,"['R_API void run_pending_anal(RCore *core) {\n', '\tcore->ev->incall = false;\n', '\tif (core && core->anal && core->anal->cmdtail) {\n', '\t\tchar *res = core->anal->cmdtail;\n', '\t\tr_core_cmd_lines (core, res);\n', '\t\tfree (res);\n']","Var1 void FUNC1(STRUCT1 *Var2){
Var2->memberVar1->memberVar1=false ; 
if (Var2&&Var2->memberVar2&&Var2->memberVar2->memberVar1){
char *Var3=Var2->memberVar2->memberVar1; 
FUNC2(Var2,Var3); 
free(Var3); 
",88,1
before_cmd.c,r_core_cmd,False,False,290,CWE-,CallExpression,strchr,4308,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
",415,0
before_cmd.c,r_core_cmd,False,False,291,CWE-,CallExpression,strlen,4313,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\t\tcore->incomment = false;\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tfree (core->lastcmd);\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tR_FREE (core->oobi);\n', '\t\tcore->oobi_len = 0;\n', '\tcore->cons->context->cmd_depth--;\n', '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\tif (!ptr) {\n', '\trun_pending_anal (core);\n', '\tcore->cons->context->cmd_depth++;\n', '\tR_FREE (core->oobi);\n', '\tcore->oobi_len = 0;\n', '\tif (r_list_empty (core->tasks)) {\n', '\t\tr_th_lock_leave (core->lock);\n', '\trun_pending_anal (core);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
Var2->memberVar4=false ; 
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
free(Var2->memberVar5); 
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
Var2->memberVar6->memberVar1->memberVar1  Var15; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
if (!Var7){
FUNC9(Var2); 
Var2->memberVar6->memberVar1->memberVar1  Var12; 
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
if (FUNC10(Var2->memberVar9)){
FUNC11(Var2->memberVar10); 
FUNC9(Var2); 
",604,0
before_cmd.c,r_core_cmd,False,False,292,CWE-,CallExpression,free,4323,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_printf (""%s\\n"", res);\n', '\t\t\t\tfree (res);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
int  Var5=false ,Var6; 
if (Var2->memberVar1){
const char *Var7=STRING; 
for (Var6=0; Var7[Var6]; Var6  Var8){
if (strchr(Var3,Var7[Var6])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var9&&FUNC2(Var3,STRING,2)){
char *Var10=FUNC3(Var2->memberVar3,Var3); 
if (Var10){
FUNC4(STRING,Var10); 
free(Var10); 
",224,0
before_cmd.c,r_core_cmd,False,False,293,CWE-,CallExpression,free,4347,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\t\tcore->incomment = false;\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tfree (core->lastcmd);\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tR_FREE (core->oobi);\n', '\t\tcore->oobi_len = 0;\n', '\tcore->cons->context->cmd_depth--;\n', '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\tif (!ptr) {\n', '\trun_pending_anal (core);\n', '\tcore->cons->context->cmd_depth++;\n', '\tR_FREE (core->oobi);\n', '\tcore->oobi_len = 0;\n', '\tif (r_list_empty (core->tasks)) {\n', '\t\tr_th_lock_leave (core->lock);\n', '\trun_pending_anal (core);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
Var2->memberVar4=false ; 
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
free(Var2->memberVar5); 
Var2->memberVar5=strdup(Var3); 
if (!Var6){
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC5(Var2->memberVar7); 
Var2->memberVar8=0; 
Var2->memberVar6->memberVar1->memberVar1  Var15; 
Var9=FUNC6(Var2,Var8); 
if (Var9 == -1){
if (!Var7){
FUNC7(Var2); 
Var2->memberVar6->memberVar1->memberVar1  Var12; 
FUNC5(Var2->memberVar7); 
Var2->memberVar8=0; 
if (FUNC8(Var2->memberVar9)){
FUNC9(Var2->memberVar10); 
FUNC7(Var2); 
",558,0
before_cmd.c,r_core_cmd,False,False,294,CWE-,CallExpression,strdup,4348,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\t\tcore->incomment = false;\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tfree (core->lastcmd);\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tR_FREE (core->oobi);\n', '\t\tcore->oobi_len = 0;\n', '\tcore->cons->context->cmd_depth--;\n', '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\tif (!ptr) {\n', '\trun_pending_anal (core);\n', '\tcore->cons->context->cmd_depth++;\n', '\tR_FREE (core->oobi);\n', '\tcore->oobi_len = 0;\n', '\tif (r_list_empty (core->tasks)) {\n', '\t\tr_th_lock_leave (core->lock);\n', '\trun_pending_anal (core);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
Var2->memberVar4=false ; 
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
free(Var2->memberVar5); 
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
Var2->memberVar6->memberVar1->memberVar1  Var15; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
if (!Var7){
FUNC9(Var2); 
Var2->memberVar6->memberVar1->memberVar1  Var12; 
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
if (FUNC10(Var2->memberVar9)){
FUNC11(Var2->memberVar10); 
FUNC9(Var2); 
",604,0
before_cmd.c,r_core_cmd,False,False,295,CWE-,CallExpression,malloc,4351,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\teprintf (""r_core_cmd: That was too deep (%s)...\\n"", cmd);\n', '\t\tfree (ocmd);\n', '\tfor (rcmd = cmd;;) {\n', ""\t\tptr = strchr (rcmd, '\\n');\n"", '\t\tif (ptr) {\n', ""\t\t\t*ptr = '\\0';\n"", '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""|ERROR| Invalid command \'%s\' (0x%02x)\\n"", rcmd, *rcmd);\n', '\t\tif (!ptr) {\n', '\t\trcmd = ptr + 1;\n', '\tfree (ocmd);\n', '\treturn ret;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(STRING,Var5); 
free(Var6); 
for (Var8=Var5; ; ){
Var7=strchr(Var8,Var15); 
if (Var7){
*Var7=0; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
FUNC7(STRING,Var8,*Var8); 
if (!Var7){
Var8=Var7+1; 
free(Var6); 
return  Var9; 
",566,0
before_cmd.c,r_core_cmd,False,False,296,CWE-,CallExpression,strlen,4351,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\teprintf (""r_core_cmd: That was too deep (%s)...\\n"", cmd);\n', '\t\tfree (ocmd);\n', '\tfor (rcmd = cmd;;) {\n', ""\t\tptr = strchr (rcmd, '\\n');\n"", '\t\tif (ptr) {\n', ""\t\t\t*ptr = '\\0';\n"", '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""|ERROR| Invalid command \'%s\' (0x%02x)\\n"", rcmd, *rcmd);\n', '\t\tif (!ptr) {\n', '\t\trcmd = ptr + 1;\n', '\tfree (ocmd);\n', '\treturn ret;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(STRING,Var5); 
free(Var6); 
for (Var8=Var5; ; ){
Var7=strchr(Var8,Var15); 
if (Var7){
*Var7=0; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
FUNC7(STRING,Var8,*Var8); 
if (!Var7){
Var8=Var7+1; 
free(Var6); 
return  Var9; 
",566,0
before_cmd.c,r_core_cmd,False,False,297,CWE-,CallExpression,free,4362,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tfree (ocmd);\n', '\tfree (ocmd);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
if (Var2->memberVar5->memberVar1->memberVar1<1){
free(Var6); 
free(Var6); 
",369,0
before_cmd.c,r_core_cmd,False,False,298,CWE-,CallExpression,strchr,4369,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\tfor (rcmd = cmd;;) {\n', ""\t\tptr = strchr (rcmd, '\\n');\n"", '\t\tif (ptr) {\n', ""\t\t\t*ptr = '\\0';\n"", '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""|ERROR| Invalid command \'%s\' (0x%02x)\\n"", rcmd, *rcmd);\n', '\t\tif (!ptr) {\n', '\t\trcmd = ptr + 1;\n', '\treturn ret;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
if (Var2->memberVar5->memberVar1->memberVar1<1){
for (Var8=Var5; ; ){
Var7=strchr(Var8,Var15); 
if (Var7){
*Var7=0; 
Var9=FUNC5(Var2,Var8); 
if (Var9 == -1){
FUNC6(STRING,Var8,*Var8); 
if (!Var7){
Var8=Var7+1; 
return  Var9; 
",463,0
before_cmd.c,r_core_cmd,False,False,299,CWE-,CallExpression,free,4386,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tfree (ocmd);\n', '\tfree (ocmd);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
if (Var2->memberVar5->memberVar1->memberVar1<1){
free(Var6); 
free(Var6); 
",369,0
before_cmd.c,r_core_cmd_lines,False,False,300,CWE-,CallExpression,strdup,4412,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', ""\t\t\t*nl = '\\0';\n"", '\t\t\tr = r_core_cmd (core, data, 0);\n', '\t\t\tif (r < 0) { //== -1) {\n', '\t\t\t\tdata = nl + 1;\n', ""\t\t\tif (data[0] == 'q') {\n"", '\t\t\t\tdata = nl + 1;\n', '\t\t\tdata = nl + 1;\n', ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tif (ret >= 0 && data && *data) {\n', '\t\tr_core_cmd (core, data, 0);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
*Var6=0; 
Var4=FUNC3(Var2,Var7,0); 
if (Var4<0){/Var10=-1){
Var7=Var6+1; 
if (Var7[0]==  Var11){
Var7=Var6+1; 
Var7=Var6+1; 
}while ((Var6=strchr(Var7,Var9))); 
if (Var5 >= 0&&Var7&&*Var7){
FUNC3(Var2,Var7,0); 
free(Var8); 
",269,0
before_cmd.c,r_core_cmd_lines,False,False,301,CWE-,CallExpression,strchr,4416,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', ""\t\t\t*nl = '\\0';\n"", '\t\t\tr = r_core_cmd (core, data, 0);\n', '\t\t\tif (r < 0) { //== -1) {\n', '\t\t\t\tdata = nl + 1;\n', ""\t\t\tif (data[0] == 'q') {\n"", '\t\t\t\tdata = nl + 1;\n', '\t\t\tdata = nl + 1;\n', ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tif (ret >= 0 && data && *data) {\n', '\t\tr_core_cmd (core, data, 0);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
*Var6=0; 
Var4=FUNC3(Var2,Var7,0); 
if (Var4<0){/Var10=-1){
Var7=Var6+1; 
if (Var7[0]==  Var11){
Var7=Var6+1; 
Var7=Var6+1; 
}while ((Var6=strchr(Var7,Var9))); 
if (Var5 >= 0&&Var7&&*Var7){
FUNC3(Var2,Var7,0); 
free(Var8); 
",269,0
before_cmd.c,r_core_cmd_lines,False,False,302,CWE-,CallExpression,free,4421,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', '\t\t\tif (r < 0) { //== -1) {\n', ""\t\t\tif (data[0] == 'q') {\n"", ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
if (Var4<0){/Var10=-1){
if (Var7[0]==  Var11){
}while ((Var6=strchr(Var7,Var9))); 
free(Var8); 
",186,0
before_cmd.c,r_core_cmd_lines,False,False,303,CWE-,CallExpression,strchr,4443,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t*nl = '\\0';\n"", '\t\t\tr = r_core_cmd (core, data, 0);\n', '\t\t\tif (r < 0) { //== -1) {\n', '\t\t\t\tdata = nl + 1;\n', ""\t\t\tif (data[0] == 'q') {\n"", '\t\t\t\tdata = nl + 1;\n', '\t\t\tdata = nl + 1;\n', ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tif (ret >= 0 && data && *data) {\n', '\t\tr_core_cmd (core, data, 0);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
*Var6=0; 
Var4=FUNC3(Var2,Var7,0); 
if (Var4<0){/Var10=-1){
Var7=Var6+1; 
if (Var7[0]==  Var11){
Var7=Var6+1; 
Var7=Var6+1; 
}while ((Var6=strchr(Var7,Var9))); 
if (Var5 >= 0&&Var7&&*Var7){
FUNC3(Var2,Var7,0); 
",255,0
before_cmd.c,r_core_cmd_lines,False,False,304,CWE-,CallExpression,free,4449,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', '\t\t\tif (r < 0) { //== -1) {\n', ""\t\t\tif (data[0] == 'q') {\n"", ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
if (Var4<0){/Var10=-1){
if (Var7[0]==  Var11){
}while ((Var6=strchr(Var7,Var9))); 
free(Var8); 
",186,0
before_cmd.c,r_core_cmd_file,False,False,305,CWE-,CallExpression,free,4459,-3,"['R_API int r_core_cmd_file(RCore *core, const char *file) {\n', '\tchar *data = r_file_abspath (file);\n', '\tif (!data) {\n', '\tchar *odata = r_file_slurp (data, NULL);\n', '\tfree (data);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4=FUNC2(Var3); 
if (!Var4){
char *Var5=FUNC3(Var4,NULL ); 
free(Var4); 
",71,0
before_cmd.c,r_core_cmd_file,False,False,306,CWE-,CallExpression,free,4465,-3,"['R_API int r_core_cmd_file(RCore *core, const char *file) {\n', '\tchar *data = r_file_abspath (file);\n', '\tif (!data) {\n', '\tchar *odata = r_file_slurp (data, NULL);\n', '\tif (!odata) {\n', '\tif (!r_core_cmd_lines (core, odata)) {\n', '\t\tfree (odata);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4=FUNC2(Var3); 
if (!Var4){
char *Var5=FUNC3(Var4,NULL ); 
if (!Var5){
if (!FUNC4(Var2,Var5)){
free(Var5); 
free(Var5); 
",103,0
before_cmd.c,r_core_cmd_file,False,False,307,CWE-,CallExpression,free,4468,-3,"['R_API int r_core_cmd_file(RCore *core, const char *file) {\n', '\tchar *data = r_file_abspath (file);\n', '\tif (!data) {\n', '\tchar *odata = r_file_slurp (data, NULL);\n', '\tif (!odata) {\n', '\tif (!r_core_cmd_lines (core, odata)) {\n', '\t\tfree (odata);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4=FUNC2(Var3); 
if (!Var4){
char *Var5=FUNC3(Var4,NULL ); 
if (!Var5){
if (!FUNC4(Var2,Var5)){
free(Var5); 
free(Var5); 
",103,0
before_cmd.c,r_core_cmd_command,False,False,308,CWE-,CallExpression,free,4478,-3,"['R_API int r_core_cmd_command(RCore *core, const char *command) {\n', '\tchar *buf, *rcmd, *ptr;\n', '\tchar *cmd = r_core_sysenv_begin (core, command);\n', '\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n', '\tif (!buf) {\n', '\t\tfree (cmd);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6; 
char *Var7=FUNC2(Var2,Var3); 
Var5=Var6=Var4=FUNC3(Var7,0,&Var8); 
if (!Var4){
free(Var7); 
",95,0
before_cmd.c,r_core_cmd_command,False,False,309,CWE-,CallExpression,free,4483,-3,"['R_API int r_core_cmd_command(RCore *core, const char *command) {\n', '\tchar *buf, *rcmd, *ptr;\n', '\tchar *cmd = r_core_sysenv_begin (core, command);\n', '\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n', '\tif (!buf) {\n', '\tfree (buf);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6; 
char *Var7=FUNC2(Var2,Var3); 
Var5=Var6=Var4=FUNC3(Var7,0,&Var8); 
if (!Var4){
free(Var4); 
",95,0
before_cmd.c,r_core_disassemble_instr,False,False,310,CWE-,CallExpression,free,4493,-3,"['\tchar *cmd, *ret = NULL;\n', '\tif (cmd) {\n', '\t\tret = r_core_cmd_str (core, cmd);\n', '\t\tfree (cmd);\n']","char *Var1,*Var2=NULL ; 
if (Var1){
Var2=FUNC1(Var3,Var1); 
free(Var1); 
",42,0
before_cmd.c,r_core_disassemble_bytes,False,False,311,CWE-,CallExpression,free,4503,-3,"['\tchar *cmd, *ret = NULL;\n', '\tif (cmd) {\n', '\t\tret = r_core_cmd_str (core, cmd);\n', '\t\tfree (cmd);\n']","char *Var1,*Var2=NULL ; 
if (Var1){
Var2=FUNC1(Var3,Var1); 
free(Var1); 
",42,0
before_cmd.c,r_core_cmd_buffer,False,False,312,CWE-,CallExpression,strdup,4509,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\t*ptr = '\\0';\n"", '\t\tr_core_cmd (core, optr, 0);\n', '\t\toptr = ptr + 1;\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tr_core_cmd (core, optr, 0);\n', '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
*Var4=0; 
FUNC2(Var2,Var5,0); 
Var5=Var4+1; 
Var4=strchr(Var6,Var7); 
FUNC2(Var2,Var5,0); 
free(Var6); 
",144,0
before_cmd.c,r_core_cmd_buffer,False,False,313,CWE-,CallExpression,strchr,4514,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\t*ptr = '\\0';\n"", '\t\tr_core_cmd (core, optr, 0);\n', '\t\toptr = ptr + 1;\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tr_core_cmd (core, optr, 0);\n', '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
*Var4=0; 
FUNC2(Var2,Var5,0); 
Var5=Var4+1; 
Var4=strchr(Var6,Var7); 
FUNC2(Var2,Var5,0); 
free(Var6); 
",144,0
before_cmd.c,r_core_cmd_buffer,False,False,314,CWE-,CallExpression,strchr,4519,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\t*ptr = '\\0';\n"", '\t\tr_core_cmd (core, optr, 0);\n', '\t\toptr = ptr + 1;\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tr_core_cmd (core, optr, 0);\n', '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
*Var4=0; 
FUNC2(Var2,Var5,0); 
Var5=Var4+1; 
Var4=strchr(Var6,Var7); 
FUNC2(Var2,Var5,0); 
free(Var6); 
",144,0
before_cmd.c,r_core_cmd_buffer,False,False,315,CWE-,CallExpression,free,4522,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
Var4=strchr(Var6,Var7); 
free(Var6); 
",102,0
before_cmd.c,r_core_cmdf,False,False,316,CWE-,CallExpression,vsnprintf,4531,-3,"['R_API int r_core_cmdf(RCore *core, const char *fmt, ...) {\n', '\tchar string[4096];\n', '\tint ret;\n', '\tva_list ap;\n', '\tva_start (ap, fmt);\n', '\tvsnprintf (string, sizeof (string), fmt, ap);\n', '\tret = r_core_cmd (core, string, 0);\n', '\tva_end (ap);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,...){
char  Var4[4096]; 
int  Var5; 
STRUCT2  Var6; 
FUNC2(Var6,Var3); 
vsnprintf(Var4,sizeof (Var4),Var3,Var6); 
Var5=FUNC3(Var2,Var4,0); 
FUNC4(Var6); 
",106,0
before_cmd.c,r_core_cmd_str_pipe,False,False,317,CWE-,CallExpression,strchr,4550,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\treturn r_core_cmd_str (core, cmd);\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\treturn NULL;\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
return FUNC3(Var1,Var2); 
if (FUNC6(STRING,&Var4) != -1){
int  Var11=FUNC7(Var4,1,0); 
if (Var11 == -1){
return FUNC3(Var1,Var2); 
char *Var12=strdup(Var2); 
Var3=FUNC8(Var4,NULL ); 
if (Var3){
return FUNC3(Var1,Var2); 
return NULL ; 
",328,0
before_cmd.c,r_core_cmd_str_pipe,False,False,318,CWE-,CallExpression,strdup,4555,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\t\t\t\tfree (res);\n', '\t\t\t\treturn hres;\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\treturn ret;\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\treturn r_core_cmd_str (core, cmd);\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tif (s) {\n', '\t\treturn r_core_cmd_str (core, cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
free(Var6); 
char *Var8=FUNC4(Var7,NULL ); 
free(Var7); 
return  Var8; 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
free(Var6); 
return  Var10; 
return FUNC3(Var1,Var2); 
if (FUNC6(STRING,&Var4) != -1){
int  Var11=FUNC7(Var4,1,0); 
if (Var11 == -1){
return FUNC3(Var1,Var2); 
char *Var12=strdup(Var2); 
if (Var3){
return FUNC3(Var1,Var2); 
",341,0
before_cmd.c,r_core_cmd_str_pipe,False,False,319,CWE-,CallExpression,strcmp,4557,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
char *Var9=FUNC3(Var1,Var6); 
int  Var10=FUNC5(Var4,1,0); 
char *Var11=strdup(Var2); 
",208,0
before_cmd.c,r_core_cmd_str_pipe,False,False,320,CWE-,CallExpression,free,4559,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
if (FUNC2(0)){
char *Var3=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var3){
char *Var4=strdup(Var2); 
Var4[Var3-Var2]=0; 
if (!strcmp(Var3+1,STRING)){
char *Var5=FUNC3(Var1,Var4); 
free(Var4); 
char *Var6=FUNC4(Var5,NULL ); 
else 
int  Var7=FUNC5(Var1->memberVar1,STRING); 
char *Var8=FUNC3(Var1,Var4); 
free(Var4); 
char *Var9=strdup(Var2); 
",211,0
before_cmd.c,r_core_cmd_str_pipe,False,False,321,CWE-,CallExpression,free,4561,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\t\t\t\tfree (res);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
free(Var7); 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
char *Var11=strdup(Var2); 
",205,0
before_cmd.c,r_core_cmd_str_pipe,False,False,322,CWE-,CallExpression,free,4568,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
if (FUNC2(0)){
char *Var3=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var3){
char *Var4=strdup(Var2); 
Var4[Var3-Var2]=0; 
if (!strcmp(Var3+1,STRING)){
char *Var5=FUNC3(Var1,Var4); 
free(Var4); 
char *Var6=FUNC4(Var5,NULL ); 
else 
int  Var7=FUNC5(Var1->memberVar1,STRING); 
char *Var8=FUNC3(Var1,Var4); 
free(Var4); 
char *Var9=strdup(Var2); 
",211,0
before_cmd.c,r_core_cmd_str_pipe,False,False,323,CWE-,CallExpression,free,4581,-3,"['\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\teprintf (""slurp %s fails\\n"", tmp);\n', '\t\tr_file_rm (tmp);\n', '\t\tfree (tmp);\n']","char *Var1,*Var2=NULL ; 
if (FUNC1(0)){
char *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; 
char *Var4=FUNC2(Var5,NULL ); 
if (FUNC3(STRING,&Var2) != -1){
int  Var6=FUNC4(Var2,1,0); 
if (Var6 == -1){
FUNC5(Var2); 
free(Var2); 
Var1=FUNC6(Var2,NULL ); 
if (Var1){
FUNC5(Var2); 
free(Var2); 
FUNC7(STRING,Var2); 
FUNC5(Var2); 
free(Var2); 
",195,0
before_cmd.c,r_core_cmd_str_pipe,False,False,324,CWE-,CallExpression,strdup,4584,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\treturn r_core_cmd_str (core, cmd);\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tr_core_cmd_subst (core, _cmd);\n', '\t\tif (s) {\n', '\t\t\tfree (_cmd);\n', '\t\tfree (_cmd);\n', '\t\treturn r_core_cmd_str (core, cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
return FUNC3(Var1,Var2); 
if (FUNC6(STRING,&Var4) != -1){
int  Var11=FUNC7(Var4,1,0); 
if (Var11 == -1){
return FUNC3(Var1,Var2); 
char *Var12=strdup(Var2); 
FUNC8(Var1,Var12); 
if (Var3){
free(Var12); 
free(Var12); 
return FUNC3(Var1,Var2); 
",317,0
before_cmd.c,r_core_cmd_str_pipe,False,False,325,CWE-,CallExpression,free,4592,-3,"['\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\teprintf (""slurp %s fails\\n"", tmp);\n', '\t\tr_file_rm (tmp);\n', '\t\tfree (tmp);\n']","char *Var1,*Var2=NULL ; 
if (FUNC1(0)){
char *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; 
char *Var4=FUNC2(Var5,NULL ); 
if (FUNC3(STRING,&Var2) != -1){
int  Var6=FUNC4(Var2,1,0); 
if (Var6 == -1){
FUNC5(Var2); 
free(Var2); 
Var1=FUNC6(Var2,NULL ); 
if (Var1){
FUNC5(Var2); 
free(Var2); 
FUNC7(STRING,Var2); 
FUNC5(Var2); 
free(Var2); 
",195,0
before_cmd.c,r_core_cmd_str_pipe,False,False,326,CWE-,CallExpression,free,4593,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tr_core_cmd_subst (core, _cmd);\n', '\t\tif (s) {\n', '\t\t\tfree (_cmd);\n', '\t\tfree (_cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
char *Var6=strdup(Var2); 
char *Var7=FUNC3(Var1,Var6); 
else 
int  Var8=FUNC4(Var1->memberVar1,STRING); 
char *Var9=FUNC3(Var1,Var6); 
if (FUNC5(STRING,&Var4) != -1){
int  Var10=FUNC6(Var4,1,0); 
if (Var10 == -1){
char *Var11=strdup(Var2); 
FUNC7(Var1,Var11); 
if (Var3){
free(Var11); 
free(Var11); 
",240,0
before_cmd.c,r_core_cmd_str_pipe,False,False,327,CWE-,CallExpression,free,4598,-3,"['\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\teprintf (""slurp %s fails\\n"", tmp);\n', '\t\tr_file_rm (tmp);\n', '\t\tfree (tmp);\n']","char *Var1,*Var2=NULL ; 
if (FUNC1(0)){
char *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; 
char *Var4=FUNC2(Var5,NULL ); 
if (FUNC3(STRING,&Var2) != -1){
int  Var6=FUNC4(Var2,1,0); 
if (Var6 == -1){
FUNC5(Var2); 
free(Var2); 
Var1=FUNC6(Var2,NULL ); 
if (Var1){
FUNC5(Var2); 
free(Var2); 
FUNC7(STRING,Var2); 
FUNC5(Var2); 
free(Var2); 
",195,0
before_cmd.c,r_core_cmd_str_pipe,False,False,328,CWE-,CallExpression,free,4599,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tr_core_cmd_subst (core, _cmd);\n', '\t\tif (s) {\n', '\t\t\tfree (_cmd);\n', '\t\tfree (_cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
char *Var6=strdup(Var2); 
char *Var7=FUNC3(Var1,Var6); 
else 
int  Var8=FUNC4(Var1->memberVar1,STRING); 
char *Var9=FUNC3(Var1,Var6); 
if (FUNC5(STRING,&Var4) != -1){
int  Var10=FUNC6(Var4,1,0); 
if (Var10 == -1){
char *Var11=strdup(Var2); 
FUNC7(Var1,Var11); 
if (Var3){
free(Var11); 
free(Var11); 
",240,0
before_cmd.c,r_core_cmd_strf,False,False,329,CWE-,CallExpression,vsnprintf,4612,-3,"['R_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n', '\tchar string[4096];\n', '\tchar *ret;\n', '\tva_list ap;\n', '\tva_start (ap, fmt);\n', '\tvsnprintf (string, sizeof (string), fmt, ap);\n', '\tret = r_core_cmd_str (core, string);\n', '\tva_end (ap);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2,...){
char  Var3[4096]; 
char *Var4; 
STRUCT3  Var5; 
FUNC2(Var5,Var2); 
vsnprintf(Var3,sizeof (Var3),Var2,Var5); 
Var4=FUNC3(Var1,Var3); 
FUNC4(Var5); 
",106,0
before_cmd.c,r_core_cmd_str,False,False,330,CWE-,CallExpression,strdup,4629,-3,"['\tconst char *static_str;\n', '\tchar *retstr = NULL;\n', '\tif (r_core_cmd (core, cmd, 0) == -1) {\n', '\tstatic_str = r_cons_get_buffer ();\n', '\tretstr = strdup (static_str? static_str: """");\n', '\treturn retstr;\n']","const char *Var1; 
char *Var2=NULL ; 
if (FUNC1(Var3,Var4,0) == -1){
Var1=FUNC2(); 
Var2=strdup(Var1  Var1 STRING); 
return  Var2; 
",70,0
before_cmd.c,r_core_cmd_task_sync,False,False,331,CWE-,CallExpression,strdup,4682,-3,"['R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n', '\tRCoreTask *task = core->main_task;\n', '\tchar *s = strdup (cmd);\n', '\tif (!s) {\n', '\ttask->cmd = s;\n', '\tint res = r_core_task_run_sync (core, task);\n', '\tfree (s);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){
STRUCT2 *Var5=Var2->memberVar1; 
char *Var6=strdup(Var3); 
if (!Var6){
Var5->memberVar1=Var6; 
int  Var7=FUNC2(Var2,Var5); 
free(Var6); 
",98,0
before_cmd.c,r_core_cmd_task_sync,False,False,332,CWE-,CallExpression,free,4690,-3,"['R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n', '\tRCoreTask *task = core->main_task;\n', '\tchar *s = strdup (cmd);\n', '\tif (!s) {\n', '\ttask->cmd = s;\n', '\tint res = r_core_task_run_sync (core, task);\n', '\tfree (s);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){
STRUCT2 *Var5=Var2->memberVar1; 
char *Var6=strdup(Var3); 
if (!Var6){
Var5->memberVar1=Var6; 
int  Var7=FUNC2(Var2,Var5); 
free(Var6); 
",98,0
before_cmd.c,compare_cmd_descriptor_name,False,False,333,CWE-,CallExpression,strcmp,4699,-3,"['static int compare_cmd_descriptor_name(const void *a, const void *b) {\n', '\treturn strcmp (((RCmdDescriptor *)a)->cmd, ((RCmdDescriptor *)b)->cmd);\n']","static int FUNC1(const void *Var1,const void *Var2){
return strcmp(((STRUCT1 *) Var1)->memberVar1,((STRUCT1 *) Var2)->memberVar1); 
",60,0
after_cmd.c,cmd_uniq,False,False,334,CWE-,CallExpression,strchr,361,-3,"['static int cmd_uniq(void *data, const char *input) { // ""uniq""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_uniq (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (FUNC3(Var3->memberVar1,Var4)){
FUNC4(Var3,STRING,Var4); 
else 
char *Var5=FUNC5(Var4); 
if (Var5){
FUNC6(Var5); 
free(Var5); 
",159,0
after_cmd.c,cmd_uniq,False,False,335,CWE-,CallExpression,free,379,-3,"['static int cmd_uniq(void *data, const char *input) { // ""uniq""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (!arg) {\n', '\t\t\targ = """";\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', 'else\n', '\t\t\tchar *res = r_syscmd_uniq (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (!Var4){
Var4=STRING; 
if (FUNC3(Var3->memberVar1,Var4)){
else 
char *Var5=FUNC4(Var4); 
if (Var5){
FUNC5(Var5); 
free(Var5); 
",161,0
after_cmd.c,cmd_head,False,False,336,CWE-,CallExpression,strdup,390,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\t*count = 0;\t// split the count and file name\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\tfree (input);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var12=FUNC6(Var6,Var4); 
if (Var12){
FUNC7(Var12); 
free(Var12); 
free(Var5); 
",294,0
after_cmd.c,cmd_head,False,False,337,CWE-,CallExpression,strchr,391,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\t*count = 0;\t// split the count and file name\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\tfree (input);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var12=FUNC6(Var6,Var4); 
if (Var12){
FUNC7(Var12); 
free(Var12); 
free(Var5); 
",294,0
after_cmd.c,cmd_head,False,False,338,CWE-,CallExpression,strchr,395,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\t*count = 0;\t// split the count and file name\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
*Var8=0; //Var9  Var10  Var8 and  STRUCT3  Var11
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var12=FUNC6(Var6,Var4); 
if (Var12){
FUNC7(Var12); 
free(Var12); 
",287,0
after_cmd.c,cmd_head,False,False,339,CWE-,CallExpression,atoi,399,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\tlines = atoi (arg);\n', '\tswitch (*input) {\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
Var4=FUNC3(Var6); 
switch (*Var5){
if (FUNC4(Var3->memberVar1,Var6)){
FUNC5(Var3,STRING,Var6); 
else 
char *Var9=FUNC6(Var6,Var4); 
if (Var9){
FUNC7(Var9); 
free(Var9); 
",235,0
after_cmd.c,cmd_head,False,False,340,CWE-,CallExpression,free,417,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tRCore *core = (RCore *)data;\n', '\tint lines = 5;\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", '\tchar *tmp, *count;\n', '\tif (arg) {\n', '\t\targ = (char *)r_str_trim_ro (arg + 1); \t// contains ""count filename""\n', ""\t\tcount = strchr (arg, ' ');\n"", '\t\tif (count) {\n', '\t\t\ttmp = (char *)r_str_trim_ro (count + 1);\n', '\t\t\tlines = atoi (arg);\n', '\t\t\targ = tmp;\n', '\tswitch (*input) {\n', '\t\tif (!arg) {\n', '\t\t\targ = """";\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=5; 
char *Var5=strdup(Var2); 
char *Var6=strchr(Var5,); 
char *Var7,*Var8; 
if (Var6){
Var6=(char *) FUNC2(Var6+1); //STRUCT2 STRING
Var8=strchr(Var6,); 
if (Var8){
Var7=(char *) FUNC2(Var8+1); 
Var4=FUNC3(Var6); 
Var6=Var7; 
switch (*Var5){
if (!Var6){
Var6=STRING; 
if (FUNC4(Var3->memberVar1,Var6)){
else 
char *Var9=FUNC5(Var6,Var4); 
if (Var9){
FUNC6(Var9); 
free(Var9); 
",263,0
after_cmd.c,cmd_head,False,False,341,CWE-,CallExpression,free,422,-3,"['static int cmd_head (void *data, const char *_input) { // ""head""\n', '\tchar *input = strdup (_input);\n', ""\tchar *arg = strchr (input, ' ');\n"", 'else\n', '\t\t\tchar *res = r_syscmd_head (arg, lines);\n', '\tfree (input);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
char *Var3=strdup(Var2); 
char *Var4=strchr(Var3,); 
else 
char *Var5=FUNC2(Var4,Var6); 
free(Var3); 
",78,1
after_cmd.c,cmd_uname,False,False,342,CWE-,CallExpression,strdup,435,-3,"['static int cmd_uname(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', '\t\t\tchar *cmd = strdup (input + 2);\n', ""\t\t\tchar *rcmd = strchr (cmd, ',');\n"", '\t\t\tif (rcmd) {\n', '\t\t\t\t*rcmd++ = 0;\n', '\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n', '\t\t\t\tr_core_undo_push (core, undo);\n', '\t\t\tfree (cmd);\n', '\t\tr_core_cmdf (data, ""s-%s"", input + 1);\n', '\t\tr_core_cmdf (data, ""wc%s"", input + 1);\n', ""\t\tif (input[1] == 'i' && input[2] == 'q') {\n"", '\t\t\tcmd_uniq (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
char *Var4=strdup(Var2+2); 
char *Var5=strchr(Var4,,); 
if (Var5){
*Var5  Var6=0; 
STRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); 
FUNC3(Var3,Var7); 
free(Var4); 
FUNC4(Var1,STRING,Var2+1); 
FUNC4(Var1,STRING,Var2+1); 
if (Var2[1]==  Var8&&Var2[2]==  Var9){
FUNC5(Var3,Var2); 
",219,0
after_cmd.c,cmd_uname,False,False,343,CWE-,CallExpression,strchr,436,-3,"['static int cmd_uname(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', '\t\t\tchar *cmd = strdup (input + 2);\n', ""\t\t\tchar *rcmd = strchr (cmd, ',');\n"", '\t\t\tif (rcmd) {\n', '\t\t\t\t*rcmd++ = 0;\n', '\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n', '\t\t\t\tr_core_undo_push (core, undo);\n', '\t\t\tfree (cmd);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
char *Var4=strdup(Var2+2); 
char *Var5=strchr(Var4,,); 
if (Var5){
*Var5  Var6=0; 
STRUCT2 *Var7=FUNC2(Var3->memberVar1,Var4,Var5); 
FUNC3(Var3,Var7); 
free(Var4); 
",152,1
after_cmd.c,cmd_uname,False,False,344,CWE-,CallExpression,free,444,-3,"['static int cmd_uname(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', '\t\t\tchar *cmd = strdup (input + 2);\n', ""\t\t\tchar *rcmd = strchr (cmd, ',');\n"", '\t\t\tif (rcmd) {\n', '\t\t\t\tRCoreUndo *undo = r_core_undo_new (core->offset, cmd, rcmd);\n', '\t\t\tfree (cmd);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
char *Var4=strdup(Var2+2); 
char *Var5=strchr(Var4,,); 
if (Var5){
STRUCT2 *Var6=FUNC2(Var3->memberVar1,Var4,Var5); 
free(Var4); 
",131,1
after_cmd.c,cmd_alias,False,False,345,CWE-,CallExpression,strlen,504,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', '\t\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\t*desc = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tr_cons_println (v);\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', 'else\n', '\t\tif (q) {\n', '\t\t\t*q = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", '\t\t\t\tr_cons_strcat (v + 1);\n', 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n', 'else\n', '\t\t\t\tr_core_cmd0 (core, v);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
*Var11  Var13=0; 
size_t  Var14=strlen(Var11); 
if (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){
Var11[Var14-1]=0; 
Var11  Var13; 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
char *Var16=FUNC3(NULL ,Var15); 
if (Var16){
FUNC4(Var3->memberVar1,Var5,Var16,0); 
free(Var16); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
*Var12=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
FUNC6(Var15); 
free(Var5); 
else 
FUNC7(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
for (Var4=0; Var4<Var17; Var4  Var13){
char *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); 
char *Var10=FUNC9(Var15,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
else 
if (Var10){
*Var10=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
if (*Var15 == ){
FUNC10(Var15+1); 
else 
}else if (Var10){
char *Var19=FUNC11(STRING,Var15,Var10+1); 
FUNC12(Var3,Var19); 
free(Var19); 
else 
FUNC12(Var3,Var15); 
else 
FUNC7(STRING,Var5); 
free(Var5); 
",840,0
after_cmd.c,cmd_alias,False,False,346,CWE-,CallExpression,malloc,505,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', '\t\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\t*desc = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tr_cons_println (v);\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', 'else\n', '\t\tif (q) {\n', '\t\t\t*q = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", '\t\t\t\tr_cons_strcat (v + 1);\n', 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n', 'else\n', '\t\t\t\tr_core_cmd0 (core, v);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
*Var11  Var13=0; 
size_t  Var14=strlen(Var11); 
if (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){
Var11[Var14-1]=0; 
Var11  Var13; 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
char *Var16=FUNC3(NULL ,Var15); 
if (Var16){
FUNC4(Var3->memberVar1,Var5,Var16,0); 
free(Var16); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
*Var12=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
FUNC6(Var15); 
free(Var5); 
else 
FUNC7(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
for (Var4=0; Var4<Var17; Var4  Var13){
char *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); 
char *Var10=FUNC9(Var15,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var17=0; 
char **Var18=FUNC8(Var3->memberVar1,&Var17); 
else 
if (Var10){
*Var10=0; 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
if (*Var15 == ){
FUNC10(Var15+1); 
else 
}else if (Var10){
char *Var19=FUNC11(STRING,Var15,Var10+1); 
FUNC12(Var3,Var19); 
free(Var19); 
else 
FUNC12(Var3,Var15); 
else 
FUNC7(STRING,Var5); 
free(Var5); 
",840,0
after_cmd.c,cmd_alias,False,False,347,CWE-,CallExpression,memcpy,510,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",671,0
after_cmd.c,cmd_alias,False,False,348,CWE-,CallExpression,strchr,511,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', 'else\n', '\t\tif (q) {\n', '\t\t\t*q = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
else 
if (Var10){
*Var10=0; 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
if (*Var14 == ){
else 
}else if (Var10){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
FUNC10(Var3,Var19); 
free(Var19); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",731,0
after_cmd.c,cmd_alias,False,False,349,CWE-,CallExpression,strchr,512,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
*Var11  Var13=0; 
size_t  Var14=strlen(Var11); 
if (Var14>0&&(Var11[0]== )&&(Var11[Var14-1]== )){
Var11[Var14-1]=0; 
Var11  Var13; 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
char *Var16=FUNC3(NULL ,Var15); 
if (Var16){
FUNC4(Var3->memberVar1,Var5,Var16,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var17=0; 
char **Var18=FUNC7(Var3->memberVar1,&Var17); 
for (Var4=0; Var4<Var17; Var4  Var13){
char *Var15=FUNC2(Var3->memberVar1,Var18[Var4],0); 
char *Var10=FUNC8(Var15,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var17=0; 
char **Var18=FUNC7(Var3->memberVar1,&Var17); 
char *Var15=FUNC2(Var3->memberVar1,Var5,0); 
if (Var15){
char *Var19=FUNC9(STRING,Var15,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",735,0
after_cmd.c,cmd_alias,False,False,350,CWE-,CallExpression,strchr,513,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\t*desc = 0;\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
*Var12=0; 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",678,0
after_cmd.c,cmd_alias,False,False,351,CWE-,CallExpression,strlen,518,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
*Var7  Var9=0; 
size_t  Var10=strlen(Var7); 
if (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){
Var7[Var10-1]=0; 
Var7  Var9; 
if (!Var6||(Var6&&Var6>Var7)){
if (*Var7){
if (!strcmp(Var7,STRING)){
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
else 
FUNC3(Var3->memberVar1,Var5,Var7,0); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var11,-1); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
char *Var14=FUNC6(STRING,Var11,Var6+1); 
",503,0
after_cmd.c,cmd_alias,False,False,352,CWE-,CallExpression,strcmp,526,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\t*def++ = 0;\n', '\t\tsize_t len = strlen (def);\n', ""\t\tif (len > 0 && (def[0] == '\\'') && (def[len - 1] == '\\'')) {\n"", '\t\t\tdef[len - 1] = 0x00;\n', '\t\t\tdef++;\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
*Var7  Var9=0; 
size_t  Var10=strlen(Var7); 
if (Var10>0&&(Var7[0]== )&&(Var7[Var10-1]== )){
Var7[Var10-1]=0; 
Var7  Var9; 
if (!Var6||(Var6&&Var6>Var7)){
if (*Var7){
if (!strcmp(Var7,STRING)){
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
else 
FUNC3(Var3->memberVar1,Var5,Var7,0); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var11,-1); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var11=FUNC2(Var3->memberVar1,Var5,0); 
char *Var14=FUNC6(STRING,Var11,Var6+1); 
",503,0
after_cmd.c,cmd_alias,False,False,353,CWE-,CallExpression,free,531,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', '\t\t\t\t\t\tfree (n);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
size_t  Var9=strlen(Var7); 
if (!Var6||(Var6&&Var6>Var7)){
if (*Var7){
if (!strcmp(Var7,STRING)){
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var11=FUNC3(NULL ,Var10); 
if (Var11){
FUNC4(Var3->memberVar1,Var5,Var11,0); 
free(Var11); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
int  Var4,Var12=0; 
char **Var13=FUNC5(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC6(Var10,-1); 
int  Var4,Var12=0; 
char **Var13=FUNC5(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var14=FUNC7(STRING,Var10,Var6+1); 
",469,0
after_cmd.c,cmd_alias,False,False,354,CWE-,CallExpression,free,546,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",671,0
after_cmd.c,cmd_alias,False,False,355,CWE-,CallExpression,free,563,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', ""\t\t\tif (buf[2] == '*') {\n"", 'else\n', '\t\t\t\tr_cons_printf (""%s=base64:%s\\n"", keys[i], q);\n', '\t\t\tfree (q);\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
size_t  Var9=strlen(Var7); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var11=FUNC3(NULL ,Var10); 
else 
}else if (Var8&&!Var6){
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
else 
}else if (Var5[1]== *){
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
for (Var4=0; Var4<Var12; Var4  Var14){
char *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var10,-1); 
if (Var5[2]== *){
else 
FUNC6(STRING,Var13[Var4],Var6); 
free(Var6); 
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC7(STRING,Var10,Var6+1); 
",491,0
after_cmd.c,cmd_alias,False,False,356,CWE-,CallExpression,free,584,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', ""\t\t\tif (*v == '$') {\n"", 'else\n', '\t\t\t} else if (q) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', '\t\t\t\tr_core_cmd0 (core, out);\n', '\t\t\t\tfree (out);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
char *Var6=strchr(Var5,); 
char *Var7=strchr(Var5,=); 
char *Var8=strchr(Var5,); 
if ((Var7&&Var6&&(Var7<Var6))||(Var7&&!Var6)){
size_t  Var9=strlen(Var7); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
char *Var11=FUNC3(NULL ,Var10); 
else 
}else if (Var8&&!Var6){
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
else 
}else if (Var5[1]== *){
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var13[Var4],0); 
char *Var6=FUNC5(Var10,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var12=0; 
char **Var13=FUNC4(Var3->memberVar1,&Var12); 
char *Var10=FUNC2(Var3->memberVar1,Var5,0); 
if (Var10){
if (*Var10 == ){
else 
}else if (Var6){
char *Var14=FUNC6(STRING,Var10,Var6+1); 
FUNC7(Var3,Var14); 
free(Var14); 
",495,0
after_cmd.c,cmd_alias,False,False,357,CWE-,CallExpression,free,592,-3,"['static int cmd_alias(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', ""\tif (*input == '?') {\n"", '\tint i = strlen (input);\n', '\tchar *buf = malloc (i + 2);\n', '\tif (!buf) {\n', ""\t*buf = '$'; // prefix aliases with a dollar\n"", '\tmemcpy (buf + 1, input, i + 1);\n', ""\tchar *q = strchr (buf, ' ');\n"", ""\tchar *def = strchr (buf, '=');\n"", ""\tchar *desc = strchr (buf, '?');\n"", '\tif ((def && q && (def < q)) || (def && !q)) {\n', '\t\tsize_t len = strlen (def);\n', '\t\tif (!q || (q && q > def)) {\n', '\t\t\tif (*def) {\n', '\t\t\t\tif (!strcmp (def, ""-"")) {\n', '\t\t\t\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\t\t\t\tchar *n = r_cons_editor (NULL, v);\n', '\t\t\t\t\tif (n) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, n, 0);\n', 'else\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, buf, def, 0);\n', 'else\n', '\t\t\t\tr_cmd_alias_del (core->rcmd, buf);\n', 'else\n', '\t} else if (desc && !q) {\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\tfree (buf);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', 'else\n', ""\t} else if (buf[1] == '*') {\n"", '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tfor (i = 0; i < count; i++) {\n', '\t\t\tchar *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n', '\t\t\tchar *q = r_base64_encode_dyn (v, -1);\n', 'else\n', '\t} else if (!buf[1]) {\n', '\t\tint i, count = 0;\n', '\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n', '\t\tchar *v = r_cmd_alias_get (core->rcmd, buf, 0);\n', '\t\tif (v) {\n', '\t\t\t\tchar *out = r_str_newf (""%s %s"", v, q + 1);\n', 'else\n', '\t\t\teprintf (""unknown key \'%s\'\\n"", buf);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
if (*Var2 == ){
int  Var4=strlen(Var2); 
char *Var5=malloc(Var4+2); 
if (!Var5){
*Var5=; //Var6  Var7  Var8  STRUCT2  Var9
memcpy(Var5+1,Var2,Var4+1); 
char *Var10=strchr(Var5,); 
char *Var11=strchr(Var5,=); 
char *Var12=strchr(Var5,); 
if ((Var11&&Var10&&(Var11<Var10))||(Var11&&!Var10)){
size_t  Var13=strlen(Var11); 
if (!Var10||(Var10&&Var10>Var11)){
if (*Var11){
if (!strcmp(Var11,STRING)){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
char *Var15=FUNC3(NULL ,Var14); 
if (Var15){
FUNC4(Var3->memberVar1,Var5,Var15,0); 
else 
FUNC4(Var3->memberVar1,Var5,Var11,0); 
else 
FUNC5(Var3->memberVar1,Var5); 
else 
}else if (Var12&&!Var10){
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
free(Var5); 
else 
FUNC6(STRING,Var5); 
else 
}else if (Var5[1]== *){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
for (Var4=0; Var4<Var16; Var4  Var18){
char *Var14=FUNC2(Var3->memberVar1,Var17[Var4],0); 
char *Var10=FUNC8(Var14,-1); 
else 
}else if (!Var5[1]){
int  Var4,Var16=0; 
char **Var17=FUNC7(Var3->memberVar1,&Var16); 
char *Var14=FUNC2(Var3->memberVar1,Var5,0); 
if (Var14){
char *Var19=FUNC9(STRING,Var14,Var10+1); 
else 
FUNC6(STRING,Var5); 
free(Var5); 
",671,0
after_cmd.c,cmd_rap,False,False,358,CWE-,CallExpression,free,648,-3,"['static int cmd_rap(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '=') {\n"", 'else\n', '\t\t\tchar *res = r_io_system (core->io, input + 1);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_printf (""%s\\n"", res);\n', '\t\t\t\tfree (res);\n', 'else\n', '\t\t\tconst char *arg = r_str_trim_ro (input + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
if (Var2[1]== =){
else 
char *Var4=FUNC2(Var3->memberVar1,Var2+1); 
if (Var4){
FUNC3(STRING,Var4); 
free(Var4); 
else 
const char *Var5=FUNC4(Var2+1); 
",132,0
after_cmd.c,cmd_rap_run,False,False,359,CWE-,CallExpression,atoi,705,-3,"['static int cmd_rap_run(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tchar *res = r_io_system (core->io, input);\n', '\tif (res) {\n', '\t\tint ret = atoi (res);\n', '\t\tfree (res);\n', '\t\treturn ret;\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
char *Var4=FUNC2(Var3->memberVar1,Var2); 
if (Var4){
int  Var5=FUNC3(Var4); 
free(Var4); 
return  Var5; 
",94,0
after_cmd.c,cmd_rap_run,False,False,360,CWE-,CallExpression,free,706,-3,"['static int cmd_rap_run(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tchar *res = r_io_system (core->io, input);\n', '\tif (res) {\n', '\t\tint ret = atoi (res);\n', '\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
char *Var4=FUNC2(Var3->memberVar1,Var2); 
if (Var4){
int  Var5=FUNC3(Var4); 
free(Var4); 
",88,0
after_cmd.c,cmd_yank,False,False,361,CWE-,CallExpression,strlen,738,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tut64 n;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n', '\t\tcore->num->value = r_buf_size (core->yank_buf);\n', ""\t\twhile (input[1] == ' ') {\n"", '\t\t\tinput++;\n', '\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n', '\t\tr_core_yank_paste (core, n, 0);\n', '\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n', ""\t\t\tif (input[2] == ' ') {\n"", '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\t\tif (len > 0) {\n', '\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n', '\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n', '\t\tif (input[1] == \'f\') { // ""wtf""\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', 'else\n', ""\t\t} else if (input[1] == ' ') {\n"", '\t\t\tr_core_yank_to (core, input + 1);\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_file_ex (core, input + 1);\n', '\t\t\tr_core_yank_hexpair (core, input + 2);\n', '\t\t\tr_core_yank_file_all (core, input + 2);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\tr_core_yank_dump (core, 0, input[0]);\n', '\t\tr_core_cmd_help (core, help_msg_y);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1  Var3; 
STRUCT2 *Var4=(STRUCT2 *) Var1; 
switch (Var2[0]){
FUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
Var4->memberVar2->memberVar1=FUNC4(Var4->memberVar3); 
while (Var2[1]== ){
Var2  Var5; 
Var3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; 
FUNC5(Var4,Var3,0); 
FUNC6(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC7(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
switch (Var2[1]){
FUNC8(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); 
if (Var2[2]== ){
char *Var6=strdup(Var2+3); 
int  Var7=FUNC9(Var2+3,(STRUCT3 *) Var6); 
if (Var7>0){
FUNC8(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); 
FUNC10(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC11(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
if (Var2[1]==  Var8){//STRING
const char *Var9=FUNC12(Var2+2); 
const STRUCT3 *Var10=FUNC13(Var4->memberVar3,&Var11); 
else 
}else if (Var2[1]== ){
FUNC14(Var4,Var2+1); 
switch (Var2[1]){
FUNC15(Var4,Var2+1); 
FUNC16(Var4,Var2+2); 
FUNC17(Var4,Var2+2); 
char *Var12=FUNC18(Var4,STRING); 
char *Var1=FUNC19(Var4,NULL ,Var12); 
FUNC20(Var4,STRING,Var1); 
FUNC21(Var4,0,Var2[0]); 
FUNC22(Var4,Var13); 
",620,0
after_cmd.c,cmd_yank,False,False,362,CWE-,CallExpression,strdup,742,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tut64 n;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n', ""\t\twhile (input[1] == ' ') {\n"", '\t\t\tinput++;\n', '\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n', '\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n', ""\t\t\tif (input[2] == ' ') {\n"", '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\t\tif (len > 0) {\n', '\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n', '\t\t\t\tfree (out);\n', '\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n', '\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n', '\t\tif (input[1] == \'f\') { // ""wtf""\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', 'else\n', ""\t\t} else if (input[1] == ' ') {\n"", '\t\t\tr_core_yank_to (core, input + 1);\n', '\t\tswitch (input[1]) {\n', '\t\t\tr_core_yank_file_ex (core, input + 1);\n', '\t\t\tr_core_yank_hexpair (core, input + 2);\n', '\t\t\tr_core_yank_file_all (core, input + 2);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\tr_core_yank_dump (core, 0, input[0]);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1  Var3; 
STRUCT2 *Var4=(STRUCT2 *) Var1; 
switch (Var2[0]){
FUNC2(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
while (Var2[1]== ){
Var2  Var5; 
Var3=Var2[1]FUNC3(Var4->memberVar2,Var2+1) Var4->memberVar1; 
FUNC4(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC5(Var4,Var4->memberVar1,FUNC3(Var4->memberVar2,Var2+1)); 
switch (Var2[1]){
FUNC6(Var4,0,(const STRUCT3 *) Var2+2,strlen(Var2+2)); 
if (Var2[2]== ){
char *Var6=strdup(Var2+3); 
int  Var7=FUNC7(Var2+3,(STRUCT3 *) Var6); 
if (Var7>0){
FUNC6(Var4,Var4->memberVar1,(const STRUCT3 *) Var6,Var7); 
free(Var6); 
FUNC8(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
FUNC9(Var4,FUNC3(Var4->memberVar2,Var2+1)); 
if (Var2[1]==  Var8){//STRING
const char *Var9=FUNC10(Var2+2); 
const STRUCT3 *Var10=FUNC11(Var4->memberVar3,&Var11); 
else 
}else if (Var2[1]== ){
FUNC12(Var4,Var2+1); 
switch (Var2[1]){
FUNC13(Var4,Var2+1); 
FUNC14(Var4,Var2+2); 
FUNC15(Var4,Var2+2); 
char *Var12=FUNC16(Var4,STRING); 
char *Var1=FUNC17(Var4,NULL ,Var12); 
FUNC18(Var4,0,Var2[0]); 
",570,0
after_cmd.c,cmd_yank,False,False,363,CWE-,CallExpression,free,749,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\tswitch (input[1]) {\n', ""\t\t\tif (input[2] == ' ') {\n"", '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\t\tif (len > 0) {\n', '\t\t\t\t\tr_core_yank_set (core, core->offset, (const ut8*)out, len);\n', '\t\t\t\tfree (out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
switch (Var2[1]){
if (Var2[2]== ){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
if (Var5>0){
FUNC3(Var3,Var3->memberVar1,(const STRUCT2 *) Var4,Var5); 
free(Var4); 
const char *Var6=FUNC4(Var2+2); 
const STRUCT2 *Var7=FUNC5(Var3->memberVar2,&Var8); 
char *Var9=FUNC6(Var3,STRING); 
char *Var1=FUNC7(Var3,NULL ,Var9); 
",239,0
after_cmd.c,cmd_yank,False,False,364,CWE-,CallExpression,free,803,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tfree (sig);\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\tfree (sig);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
free(Var9); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
free(Var9); 
",198,0
after_cmd.c,cmd_yank,False,False,365,CWE-,CallExpression,strdup,804,-3,"['\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\t(void) strtok (data, "";\\n"");\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\t\tfree (sig);\n', '\t\t\tfree (data);\n']","STRUCT1 *Var1=(STRUCT1 *) Var2; 
switch (Var3[0]){
char *Var4=strdup(Var3+3); 
int  Var5=FUNC1(Var3+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC2(Var3+2); 
const STRUCT2 *Var7=FUNC3(Var1->memberVar1,&Var8); 
char *Var9=FUNC4(Var1,STRING); 
if (!Var9||!*Var9){
Var9=strdup(STRING); 
char *Var2=FUNC5(Var1,NULL ,Var9); 
(void ) strtok(Var2,STRING); 
FUNC6(Var1,STRING,Var2); 
free(Var9); 
free(Var2); 
",211,0
after_cmd.c,cmd_yank,False,False,366,CWE-,CallExpression,strtok,807,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\t(void) strtok (data, "";\\n"");\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\t\tfree (data);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
Var9=strdup(STRING); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
(void ) strtok(Var1,STRING); 
FUNC7(Var3,STRING,Var1); 
free(Var1); 
",227,0
after_cmd.c,cmd_yank,False,False,367,CWE-,CallExpression,free,809,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tfree (sig);\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\tfree (sig);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
free(Var9); 
Var9=strdup(STRING); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
free(Var9); 
",207,0
after_cmd.c,cmd_yank,False,False,368,CWE-,CallExpression,free,810,-3,"['static int cmd_yank(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (input[0]) {\n', '\t\t\t\tchar *out = strdup (input + 3);\n', '\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\t\tconst ut8 *tmp = r_buf_data (core->yank_buf, &tmpsz);\n', '\t\t\tchar *sig = r_core_cmd_str (core, ""y*"");\n', '\t\t\tif (!sig || !*sig) {\n', '\t\t\t\tsig = strdup (""wx 10203040"");\n', '\t\t\tchar *data = r_core_editor (core, NULL, sig);\n', '\t\t\t(void) strtok (data, "";\\n"");\n', '\t\t\tr_core_cmdf (core, ""y%s"", data);\n', '\t\t\tfree (data);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (Var2[0]){
char *Var4=strdup(Var2+3); 
int  Var5=FUNC2(Var2+3,(STRUCT2 *) Var4); 
const char *Var6=FUNC3(Var2+2); 
const STRUCT2 *Var7=FUNC4(Var3->memberVar1,&Var8); 
char *Var9=FUNC5(Var3,STRING); 
if (!Var9||!*Var9){
Var9=strdup(STRING); 
char *Var1=FUNC6(Var3,NULL ,Var9); 
(void ) strtok(Var1,STRING); 
FUNC7(Var3,STRING,Var1); 
free(Var1); 
",227,0
after_cmd.c,langFromHashbang,False,False,369,CWE-,CallExpression,strchr,839,-3,"['\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n', '\tif (fd != -1) {\n', '\t\tchar firstLine[128] = {0};\n', '\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n', '\t\tfirstLine[len] = 0;\n', '\t\tif (!strncmp (firstLine, ""#!/"", 3)) {\n', ""\t\t\tchar *nl = strchr (firstLine, '\\n');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', ""\t\t\tnl = strchr (firstLine, ' ');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', '\t\t\treturn strdup (firstLine + 2);\n']","int  Var1=FUNC1(Var2,Var3,0); 
if (Var1 != -1){
char  Var4[128]={0}; 
int  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); 
Var4[Var5]=0; 
if (!FUNC3(Var4,STRING,3)){
char *Var6=strchr(Var4,Var7); 
if (Var6){
*Var6=0; 
Var6=strchr(Var4,); 
if (Var6){
*Var6=0; 
return strdup(Var4+2); 
",170,0
after_cmd.c,langFromHashbang,False,False,370,CWE-,CallExpression,strchr,843,-3,"['\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n', '\tif (fd != -1) {\n', '\t\tchar firstLine[128] = {0};\n', '\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n', '\t\tfirstLine[len] = 0;\n', '\t\tif (!strncmp (firstLine, ""#!/"", 3)) {\n', ""\t\t\tchar *nl = strchr (firstLine, '\\n');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', ""\t\t\tnl = strchr (firstLine, ' ');\n"", '\t\t\tif (nl) {\n', '\t\t\t\t*nl = 0;\n', '\t\t\treturn strdup (firstLine + 2);\n']","int  Var1=FUNC1(Var2,Var3,0); 
if (Var1 != -1){
char  Var4[128]={0}; 
int  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); 
Var4[Var5]=0; 
if (!FUNC3(Var4,STRING,3)){
char *Var6=strchr(Var4,Var7); 
if (Var6){
*Var6=0; 
Var6=strchr(Var4,); 
if (Var6){
*Var6=0; 
return strdup(Var4+2); 
",170,0
after_cmd.c,langFromHashbang,False,False,371,CWE-,CallExpression,strdup,847,-3,"['\tint fd = r_sandbox_open (file, O_RDONLY, 0);\n', '\tif (fd != -1) {\n', '\t\tchar firstLine[128] = {0};\n', '\t\tint len = r_sandbox_read (fd, (ut8*)firstLine, sizeof (firstLine) - 1);\n', '\t\tfirstLine[len] = 0;\n', '\t\tif (!strncmp (firstLine, ""#!/"", 3)) {\n', ""\t\t\tchar *nl = strchr (firstLine, '\\n');\n"", ""\t\t\tnl = strchr (firstLine, ' ');\n"", '\t\t\treturn strdup (firstLine + 2);\n']","int  Var1=FUNC1(Var2,Var3,0); 
if (Var1 != -1){
char  Var4[128]={0}; 
int  Var5=FUNC2(Var1,(STRUCT1 *) Var4,sizeof (Var4)-1); 
Var4[Var5]=0; 
if (!FUNC3(Var4,STRING,3)){
char *Var6=strchr(Var4,Var7); 
Var6=strchr(Var4,); 
return strdup(Var4+2); 
",140,0
after_cmd.c,r_core_run_script,False,False,372,CWE-,CallExpression,strcmp,861,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\t\t\teprintf (""WARNING: ignored nested source: %s\\n"", file);\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(STRING,Var3); 
FUNC3(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC4(Var2,NULL ,NULL ); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
char *Var10=FUNC8(Var3); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC9(Var2,STRING,Var3); 
else 
}else if (FUNC10(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); 
else 
Var5=FUNC12(Var2->memberVar4,Var3); 
if (Var5){
Var4=FUNC13(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC14(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC16(STRING,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC13(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC17(STRING); 
if (Var14){
char *Var13=FUNC16(STRING,Var14,Var3); 
char *Var13=FUNC15(STRING); 
char *Var13=FUNC15(STRING); 
else 
char *Var15=FUNC18(Var3); 
char *memberVar4=FUNC19(Var2,Var3); 
if (memberVar4){
char *Var13=FUNC16(STRING,memberVar4,Var3); 
if (!Var4){
Var4=FUNC20(Var2,Var3); 
",840,0
after_cmd.c,r_core_run_script,False,False,373,CWE-,CallExpression,strdup,866,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\t\t\teprintf (""WARNING: ignored nested source: %s\\n"", file);\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", 0);\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tr_core_cmdf (core, ""=H"");\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", httpSandbox);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tr_lang_use (core->lang, p->name);\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""vala"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n', '\tfree (r_list_pop (core->scriptstack));\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(STRING,Var3); 
FUNC3(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC4(Var2,NULL ,NULL ); 
if (Var7){
Var4=FUNC5(Var2,Var7); 
else 
}else if (FUNC6(Var3,STRING)){
const bool  Var8=FUNC7(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC8(Var2->memberVar2,STRING)); 
FUNC9(Var2->memberVar2,STRING,0); 
char *Var10=FUNC10(Var3); 
FUNC11(Var2->memberVar2,STRING,Var10); 
FUNC12(Var2,STRING); 
FUNC9(Var2->memberVar2,STRING,Var8); 
FUNC11(Var2->memberVar2,STRING,Var9); 
else 
}else if (FUNC6(Var3,STRING)){
FUNC13(Var2,STRING,Var3); 
else 
}else if (FUNC14(Var3)){
const char *Var11=FUNC8(Var2->memberVar2,STRING); 
char *Var7=FUNC15(Var2->memberVar3,Var3,Var11,NULL ); 
if (Var7){
FUNC16(Var2->memberVar3->memberVar1,Var7); 
else 
Var5=FUNC17(Var2->memberVar4,Var3); 
if (Var5){
FUNC18(Var2->memberVar4,Var5->memberVar1); 
Var4=FUNC19(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC20(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC22(STRING,Var3); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC23(STRING); 
if (Var14){
FUNC18(Var2->memberVar4,STRING); 
char *Var13=FUNC22(STRING,Var14,Var3); 
if (Var13){
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING); 
FUNC18(Var2->memberVar4,STRING); 
FUNC19(Var2,Var2->memberVar4,Var13); 
else 
char *Var15=FUNC24(Var3); 
char *memberVar4=FUNC25(Var2,Var3); 
if (memberVar4){
FUNC18(Var2->memberVar4,STRING); 
char *Var13=FUNC22(STRING,memberVar4,Var3); 
FUNC19(Var2,Var2->memberVar4,Var13); 
if (!Var4){
Var4=FUNC26(Var2,Var3); 
free(FUNC27(Var2->memberVar1)); 
",1410,0
after_cmd.c,r_core_run_script,False,False,374,CWE-,CallExpression,strcmp,868,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\t\t\teprintf (""WARNING: ignored nested source: %s\\n"", file);\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(STRING,Var3); 
FUNC3(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC4(Var2,NULL ,NULL ); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
char *Var10=FUNC8(Var3); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC9(Var2,STRING,Var3); 
else 
}else if (FUNC10(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC11(Var2->memberVar3,Var3,Var11,NULL ); 
else 
Var5=FUNC12(Var2->memberVar4,Var3); 
if (Var5){
Var4=FUNC13(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC14(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC16(STRING,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC15(STRING); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC13(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC17(STRING); 
if (Var14){
char *Var13=FUNC16(STRING,Var14,Var3); 
char *Var13=FUNC15(STRING); 
char *Var13=FUNC15(STRING); 
else 
char *Var15=FUNC18(Var3); 
char *memberVar4=FUNC19(Var2,Var3); 
if (memberVar4){
char *Var13=FUNC16(STRING,memberVar4,Var3); 
if (!Var4){
Var4=FUNC20(Var2,Var3); 
",840,0
after_cmd.c,r_core_run_script,False,False,375,CWE-,CallExpression,free,872,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', '\t\t\tfree (out);\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
if (Var6){
Var4=FUNC3(Var2,Var6); 
free(Var6); 
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC7(Var2->memberVar2,Var3,Var10,NULL ); 
const char *Var11=FUNC8(Var3,.); 
char *Var12=FUNC9(STRING,Var3); 
char *Var12=FUNC9(STRING,Var13,Var3); 
else 
char *Var14=FUNC10(Var3); 
char *Var15=FUNC11(Var2,Var3); 
char *Var12=FUNC9(STRING,Var15,Var3); 
",326,0
after_cmd.c,r_core_run_script,False,False,376,CWE-,CallExpression,strdup,876,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", 0);\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tr_core_cmdf (core, ""=H"");\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", httpSandbox);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', '\t\tfree (httpIndex);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tr_lang_use (core->lang, p->name);\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""vala"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n', '\tfree (r_list_pop (core->scriptstack));\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC3(Var2,NULL ,NULL ); 
if (Var7){
Var4=FUNC4(Var2,Var7); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
FUNC8(Var2->memberVar2,STRING,0); 
char *Var10=FUNC9(Var3); 
FUNC10(Var2->memberVar2,STRING,Var10); 
FUNC11(Var2,STRING); 
FUNC8(Var2->memberVar2,STRING,Var8); 
FUNC10(Var2->memberVar2,STRING,Var9); 
free(Var9); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC12(Var2,STRING,Var3); 
else 
}else if (FUNC13(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); 
if (Var7){
FUNC15(Var2->memberVar3->memberVar1,Var7); 
else 
Var5=FUNC16(Var2->memberVar4,Var3); 
if (Var5){
FUNC17(Var2->memberVar4,Var5->memberVar1); 
Var4=FUNC18(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC19(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING,Var3); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC22(STRING); 
if (Var14){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,Var14,Var3); 
if (Var13){
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
char *Var15=FUNC23(Var3); 
char *memberVar4=FUNC24(Var2,Var3); 
if (memberVar4){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,memberVar4,Var3); 
FUNC18(Var2,Var2->memberVar4,Var13); 
if (!Var4){
Var4=FUNC25(Var2,Var3); 
free(FUNC26(Var2->memberVar1)); 
",1407,0
after_cmd.c,r_core_run_script,False,False,377,CWE-,CallExpression,free,880,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tfree (absfile);\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4; 
if (!strcmp(Var3,Var4)){
if (!strcmp(Var3,STRING)){
char *Var5=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var6=FUNC4(Var2->memberVar1,STRING); 
char *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var8=FUNC6(Var3); 
FUNC7(Var2->memberVar1,STRING,Var8); 
free(Var8); 
const char *Var9=FUNC5(Var2->memberVar1,STRING); 
char *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); 
const char *Var10=FUNC9(Var3,.); 
char *Var11=FUNC10(STRING,Var3); 
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
char *Var13=FUNC11(Var3); 
char *Var14=FUNC12(Var2,Var3); 
char *Var11=FUNC10(STRING,Var14,Var3); 
",330,0
after_cmd.c,r_core_run_script,False,False,378,CWE-,CallExpression,free,884,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', '\t\tfree (httpIndex);\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4; 
if (!strcmp(Var3,Var4)){
if (!strcmp(Var3,STRING)){
char *Var5=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var6=FUNC4(Var2->memberVar1,STRING); 
char *Var7=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var8=FUNC6(Var3); 
FUNC7(Var2->memberVar1,STRING,Var7); 
free(Var7); 
const char *Var9=FUNC5(Var2->memberVar1,STRING); 
char *Var5=FUNC8(Var2->memberVar2,Var3,Var9,NULL ); 
const char *Var10=FUNC9(Var3,.); 
char *Var11=FUNC10(STRING,Var3); 
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
char *Var13=FUNC11(Var3); 
char *Var14=FUNC12(Var2,Var3); 
char *Var11=FUNC10(STRING,Var14,Var3); 
",330,0
after_cmd.c,r_core_run_script,False,False,379,CWE-,CallExpression,free,895,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tr_cons_strcat (out);\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', '\t\t\tfree (out);\n', '\t\tret = out? true: false;\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var6){
FUNC9(Var6); 
FUNC10(Var2->memberVar2->memberVar1,Var6); 
free(Var6); 
Var4=Var6 true false ; 
const char *Var11=FUNC11(Var3,.); 
char *Var12=FUNC12(STRING,Var3); 
char *Var12=FUNC12(STRING,Var13,Var3); 
else 
char *Var14=FUNC13(Var3); 
char *Var15=FUNC14(Var2,Var3); 
char *Var12=FUNC12(STRING,Var15,Var3); 
",404,0
after_cmd.c,r_core_run_script,False,False,380,CWE-,CallExpression,strcmp,914,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,381,CWE-,CallExpression,free,918,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC10(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC11(STRING,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC11(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC11(STRING,memberVar3,Var3); 
",511,0
after_cmd.c,r_core_run_script,False,False,382,CWE-,CallExpression,strcmp,920,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,383,CWE-,CallExpression,free,928,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC11(STRING,Var3); 
FUNC12(Var2,Var2->memberVar3,Var12); 
free(Var12); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var13,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC13(Var3); 
char *memberVar3=FUNC14(Var2,Var3); 
char *Var12=FUNC11(STRING,memberVar3,Var3); 
",555,0
after_cmd.c,r_core_run_script,False,False,384,CWE-,CallExpression,strcmp,930,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,385,CWE-,CallExpression,free,934,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",549,0
after_cmd.c,r_core_run_script,False,False,386,CWE-,CallExpression,strcmp,936,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,387,CWE-,CallExpression,free,940,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",568,0
after_cmd.c,r_core_run_script,False,False,388,CWE-,CallExpression,strcmp,942,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,389,CWE-,CallExpression,free,946,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",587,0
after_cmd.c,r_core_run_script,False,False,390,CWE-,CallExpression,strcmp,948,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,391,CWE-,CallExpression,free,952,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",606,0
after_cmd.c,r_core_run_script,False,False,392,CWE-,CallExpression,strcmp,954,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,393,CWE-,CallExpression,free,958,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",625,0
after_cmd.c,r_core_run_script,False,False,394,CWE-,CallExpression,strcmp,960,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,395,CWE-,CallExpression,free,964,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC10(STRING,Var12,Var3); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",644,0
after_cmd.c,r_core_run_script,False,False,396,CWE-,CallExpression,strcmp,966,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,397,CWE-,CallExpression,strcmp,970,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,398,CWE-,CallExpression,strdup,973,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (!shell) {\n', '\t\t\t\t\t\tshell = strdup (""sh"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\t\tfree (shell);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
else 
}else if (!strcmp(Var10,STRING)){
char *Var12=FUNC11(STRING); 
if (!Var12){
Var12=strdup(STRING); 
if (Var12){
char *Var11=FUNC10(STRING,Var12,Var3); 
if (Var11){
FUNC12(Var5,Var5->memberVar3,Var11); 
free(Var11); 
free(Var12); 
char *Var11=FUNC9(STRING); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC13(Var3); 
char *memberVar3=FUNC14(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",736,0
after_cmd.c,r_core_run_script,False,False,399,CWE-,CallExpression,free,980,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (!shell) {\n', '\t\t\t\t\t\tshell = strdup (""sh"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC11(STRING,Var3); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
char *Var12=FUNC10(STRING); 
else 
}else if (!strcmp(Var11,STRING)){
else 
}else if (!strcmp(Var11,STRING)){
char *Var13=FUNC12(STRING); 
if (!Var13){
Var13=strdup(STRING); 
if (Var13){
char *Var12=FUNC11(STRING,Var13,Var3); 
if (Var12){
FUNC13(Var2,Var2->memberVar3,Var12); 
free(Var12); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC14(Var3); 
char *memberVar3=FUNC15(Var2,Var3); 
char *Var12=FUNC11(STRING,memberVar3,Var3); 
",754,0
after_cmd.c,r_core_run_script,False,False,400,CWE-,CallExpression,free,982,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (!shell) {\n', '\t\t\t\t\t\tshell = strdup (""sh"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tfree (shell);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC1(Var3,STRING)){
char *Var4=strdup(FUNC2(Var5->memberVar1,STRING)); 
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC1(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var5->memberVar2,Var3,Var8,NULL ); 
if (Var1){
const char *Var1=FUNC6(Var3,.); 
if (Var1){
const char *Var9=Var1+1; 
if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC8(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var11=FUNC9(STRING); 
if (!Var11){
Var11=strdup(STRING); 
if (Var11){
char *Var10=FUNC8(STRING,Var11,Var3); 
free(Var11); 
char *Var10=FUNC7(STRING); 
char *Var10=FUNC7(STRING); 
else 
char *Var12=FUNC10(Var3); 
char *Var13=FUNC11(Var5,Var3); 
char *Var10=FUNC8(STRING,Var13,Var3); 
",643,0
after_cmd.c,r_core_run_script,False,False,401,CWE-,CallExpression,strcmp,985,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,402,CWE-,CallExpression,free,989,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
char *Var11=FUNC9(STRING); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",701,0
after_cmd.c,r_core_run_script,False,False,403,CWE-,CallExpression,strcmp,991,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
else 
}else if (!strcmp(Var9,STRING)){
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
}else if (!strcmp(Var9,STRING)){
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
",502,0
after_cmd.c,r_core_run_script,False,False,404,CWE-,CallExpression,free,995,-3,"['\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n']","STRUCT1 *Var1; 
char *Var2; 
if (!strcmp(Var3,Var2)){
if (!strcmp(Var3,STRING)){
char *Var4=FUNC1(Var5,NULL ,NULL ); 
else 
}else if (FUNC2(Var3,STRING)){
const bool  Var6=FUNC3(Var5->memberVar1,STRING); 
char *Var7=strdup(FUNC4(Var5->memberVar1,STRING)); 
char *Var8=FUNC5(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC6(Var3)){
const char *Var9=FUNC4(Var5->memberVar1,STRING); 
char *Var4=FUNC7(Var5->memberVar2,Var3,Var9,NULL ); 
if (Var1){
const char *Var1=FUNC8(Var3,.); 
if (Var1){
const char *Var10=Var1+1; 
if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC10(STRING,Var12,Var3); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
else 
}else if (!strcmp(Var10,STRING)){
char *Var11=FUNC9(STRING); 
FUNC11(Var5,Var5->memberVar3,Var11); 
free(Var11); 
else 
char *Var13=FUNC12(Var3); 
char *memberVar3=FUNC13(Var5,Var3); 
char *Var11=FUNC10(STRING,memberVar3,Var3); 
",720,0
after_cmd.c,r_core_run_script,False,False,405,CWE-,CallExpression,free,1005,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tfree (lang);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var13,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC12(Var3); 
char *Var15=FUNC13(Var2,Var3); 
if (Var15){
char *Var12=FUNC11(STRING,Var15,Var3); 
free(Var15); 
",513,0
after_cmd.c,r_core_run_script,False,False,406,CWE-,CallExpression,free,1006,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\t\t\tfree (cmd);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
char *Var6=FUNC2(Var2,NULL ,NULL ); 
else 
}else if (FUNC3(Var3,STRING)){
const bool  Var7=FUNC4(Var2->memberVar1,STRING); 
char *Var8=strdup(FUNC5(Var2->memberVar1,STRING)); 
char *Var9=FUNC6(Var3); 
else 
}else if (FUNC3(Var3,STRING)){
else 
}else if (FUNC7(Var3)){
const char *Var10=FUNC5(Var2->memberVar1,STRING); 
char *Var6=FUNC8(Var2->memberVar2,Var3,Var10,NULL ); 
if (Var4){
const char *Var4=FUNC9(Var3,.); 
if (Var4){
const char *Var11=Var4+1; 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC11(STRING,Var13,Var3); 
char *Var12=FUNC10(STRING); 
char *Var12=FUNC10(STRING); 
else 
char *Var14=FUNC12(Var3); 
char *Var15=FUNC13(Var2,Var3); 
if (Var15){
char *Var12=FUNC11(STRING,Var15,Var3); 
FUNC14(Var2,Var2->memberVar3,Var12); 
free(Var12); 
",530,0
after_cmd.c,r_core_run_script,False,False,407,CWE-,CallExpression,free,1009,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tif (!strcmp (file, ""-"")) {\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tchar *absfile = r_file_abspath (file);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (p) {\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\tfree (abspath);\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
STRUCT2 *Var4; 
char *Var5; 
if (!strcmp(Var3,Var5)){
if (!strcmp(Var3,STRING)){
else 
}else if (FUNC2(Var3,STRING)){
char *Var6=FUNC3(Var3); 
else 
}else if (FUNC2(Var3,STRING)){
else 
}else if (FUNC4(Var3)){
char *Var7=FUNC5(Var2->memberVar1,Var3,Var8,NULL ); 
if (Var4){
const char *Var4=FUNC6(Var3,.); 
if (Var4){
const char *Var9=Var4+1; 
char *Var10=FUNC7(STRING,Var3); 
char *Var10=FUNC7(STRING,Var11,Var3); 
else 
char *Var12=FUNC8(Var3); 
char *Var13=FUNC9(Var2,Var3); 
char *Var10=FUNC7(STRING,Var13,Var3); 
free(Var12); 
",305,0
after_cmd.c,r_core_run_script,False,False,408,CWE-,CallExpression,free,1016,-3,"['R_API bool r_core_run_script(RCore *core, const char *file) {\n', '\tbool ret = false;\n', '\tRLangPlugin *p;\n', '\tchar *name;\n', '\t\tif (!strcmp (file, name)) {\n', '\tr_list_push (core->scriptstack, strdup (file));\n', '\tif (!strcmp (file, ""-"")) {\n', '\t\tchar *out = r_core_editor (core, NULL, NULL);\n', '\t\tif (out) {\n', '\t\t\tret = r_core_cmd_lines (core, out);\n', 'else\n', '\t} else if (r_str_endswith (file, "".html"")) {\n', '\t\tconst bool httpSandbox = r_config_get_i (core->config, ""http.sandbox"");\n', '\t\tchar *httpIndex = strdup (r_config_get (core->config, ""http.index""));\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", 0);\n', '\t\tchar *absfile = r_file_abspath (file);\n', '\t\tr_config_set (core->config, ""http.index"", absfile);\n', '\t\tr_core_cmdf (core, ""=H"");\n', '\t\tr_config_set_i (core->config, ""http.sandbox"", httpSandbox);\n', '\t\tr_config_set (core->config, ""http.index"", httpIndex);\n', 'else\n', '\t} else if (r_str_endswith (file, "".c"")) {\n', '\t\tr_core_cmd_strf (core, ""#!c %s"", file);\n', 'else\n', '\t} else if (r_file_is_c (file)) {\n', '\t\tconst char *dir = r_config_get (core->config, ""dir.types"");\n', '\t\tchar *out = r_parse_c_file (core->anal, file, dir, NULL);\n', '\t\tif (out) {\n', '\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n', 'else\n', '\t\tp = r_lang_get_by_extension (core->lang, file);\n', '\t\tif (p) {\n', '\t\t\tr_lang_use (core->lang, p->name);\n', '\t\t\tret = lang_run_file (core, core->lang, file);\n', ""\t\t\tconst char *p = r_str_lchr (file, '.');\n"", '\t\t\tif (p) {\n', '\t\t\t\tconst char *ext = p + 1;\n', '\t\t\t\tif (!strcmp (ext, ""js"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""exe"")) {\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s"", file);\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""zig"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""zig run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""d"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""dmd -run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""lsp"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""newlisp -n"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""go"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""go run"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""es6"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""babel-node"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""rb"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""ruby"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""vala"")) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""vala"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, file);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""sh"")) {\n', '\t\t\t\t\tchar *shell = r_sys_getenv (""SHELL"");\n', '\t\t\t\t\tif (shell) {\n', '\t\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", shell, file);\n', '\t\t\t\t\t\tif (cmd) {\n', '\t\t\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""pl"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""perl"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ext, ""py"")) {\n', '\t\t\t\t\tchar *cmd = cmdstr (""python"");\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', 'else\n', '\t\t\t\tchar *abspath = r_file_path (file);\n', '\t\t\t\tchar *lang = langFromHashbang (core, file);\n', '\t\t\t\tif (lang) {\n', '\t\t\t\t\tr_lang_use (core->lang, ""pipe"");\n', '\t\t\t\t\tchar *cmd = r_str_newf (""%s \'%s\'"", lang, file);\n', '\t\t\t\t\tlang_run_file (core, core->lang, cmd);\n', '\t\t\tif (!ret) {\n', '\t\t\t\tret = r_core_cmd_file (core, file);\n', '\tfree (r_list_pop (core->scriptstack));\n']","Var1 bool FUNC1(STRUCT1 *Var2,const char *Var3){
bool  Var4=false ; 
STRUCT2 *Var5; 
char *Var6; 
if (!strcmp(Var3,Var6)){
FUNC2(Var2->memberVar1,strdup(Var3)); 
if (!strcmp(Var3,STRING)){
char *Var7=FUNC3(Var2,NULL ,NULL ); 
if (Var7){
Var4=FUNC4(Var2,Var7); 
else 
}else if (FUNC5(Var3,STRING)){
const bool  Var8=FUNC6(Var2->memberVar2,STRING); 
char *Var9=strdup(FUNC7(Var2->memberVar2,STRING)); 
FUNC8(Var2->memberVar2,STRING,0); 
char *Var10=FUNC9(Var3); 
FUNC10(Var2->memberVar2,STRING,Var10); 
FUNC11(Var2,STRING); 
FUNC8(Var2->memberVar2,STRING,Var8); 
FUNC10(Var2->memberVar2,STRING,Var9); 
else 
}else if (FUNC5(Var3,STRING)){
FUNC12(Var2,STRING,Var3); 
else 
}else if (FUNC13(Var3)){
const char *Var11=FUNC7(Var2->memberVar2,STRING); 
char *Var7=FUNC14(Var2->memberVar3,Var3,Var11,NULL ); 
if (Var7){
FUNC15(Var2->memberVar3->memberVar1,Var7); 
else 
Var5=FUNC16(Var2->memberVar4,Var3); 
if (Var5){
FUNC17(Var2->memberVar4,Var5->memberVar1); 
Var4=FUNC18(Var2,Var2->memberVar4,Var3); 
const char *Var5=FUNC19(Var3,.); 
if (Var5){
const char *Var12=Var5+1; 
if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC21(STRING,Var3); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var3); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var14=FUNC22(STRING); 
if (Var14){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,Var14,Var3); 
if (Var13){
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
}else if (!strcmp(Var12,STRING)){
char *Var13=FUNC20(STRING); 
FUNC17(Var2->memberVar4,STRING); 
FUNC18(Var2,Var2->memberVar4,Var13); 
else 
char *Var15=FUNC23(Var3); 
char *memberVar4=FUNC24(Var2,Var3); 
if (memberVar4){
FUNC17(Var2->memberVar4,STRING); 
char *Var13=FUNC21(STRING,memberVar4,Var3); 
FUNC18(Var2,Var2->memberVar4,Var13); 
if (!Var4){
Var4=FUNC25(Var2,Var3); 
free(FUNC26(Var2->memberVar1)); 
",1400,0
after_cmd.c,cmd_ls,False,False,409,CWE-,CallExpression,strchr,1022,-3,"['static int cmd_ls(void *data, const char *input) { // ""ls""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (arg) {\n', '\t\t\tr_core_cmdf (core, ""cat %s~.."", arg);\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', '\t\t\tr_core_cmdf (core, ""md %s"", arg);\n', 'else\n', '\t\t\tchar *res = r_syscmd_ls (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (Var4){
FUNC3(Var3,STRING,Var4); 
if (FUNC4(Var3->memberVar1,Var4)){
FUNC3(Var3,STRING,Var4); 
else 
char *Var5=FUNC5(Var4); 
if (Var5){
FUNC6(Var5); 
free(Var5); 
",180,0
after_cmd.c,cmd_ls,False,False,410,CWE-,CallExpression,free,1047,-3,"['static int cmd_ls(void *data, const char *input) { // ""ls""\n', '\tRCore *core = (RCore *)data;\n', ""\tconst char *arg = strchr (input, ' ');\n"", '\tif (arg) {\n', '\t\targ = r_str_trim_ro (arg + 1);\n', '\tswitch (*input) {\n', '\t\tif (!arg) {\n', '\t\t\targ = """";\n', '\t\tif (r_fs_check (core->fs, arg)) {\n', 'else\n', '\t\t\tchar *res = r_syscmd_ls (arg);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strchr(Var2,); 
if (Var4){
Var4=FUNC2(Var4+1); 
switch (*Var2){
if (!Var4){
Var4=STRING; 
if (FUNC3(Var3->memberVar1,Var4)){
else 
char *Var5=FUNC4(Var4); 
if (Var5){
FUNC5(Var5); 
free(Var5); 
",161,0
after_cmd.c,cmd_join,False,False,411,CWE-,CallExpression,strdup,1057,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', ""\t*end = '\\0';\n"", '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\t\t\tR_FREE (tmp);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
*Var6=0; 
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
FUNC6(Var4); 
",249,0
after_cmd.c,cmd_join,False,False,412,CWE-,CallExpression,strchr,1058,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', ""\t*end = '\\0';\n"", '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n', '\t\t\tR_FREE (tmp);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
*Var6=0; 
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
FUNC6(Var4); 
",249,0
after_cmd.c,cmd_join,False,False,413,CWE-,CallExpression,strchr,1063,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', ""\t*end = '\\0';\n"", '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
*Var6=0; 
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
",241,0
after_cmd.c,cmd_join,False,False,414,CWE-,CallExpression,free,1087,-3,"['static int cmd_join(void *data, const char *input) { // ""join""\n', '\tRCore *core = (RCore *)data;\n', '\tconst char *tmp = strdup (input);\n', ""\tconst char *arg1 = strchr (tmp, ' ');\n"", '\tif (!arg1) {\n', '\targ1 = r_str_trim_ro (arg1);\n', ""\tchar *end = strchr (arg1, ' ');\n"", '\tif (!end) {\n', '\tconst char *arg2 = end+1;\n', '\tif (!arg2) {\n', '\targ2 = r_str_trim_ro (arg2);\n', '\tswitch (*input) {\n', '\t\tif (!arg1) {\n', '\t\t\targ1 = """";\n', '\t\tif (!arg2) {\n', '\t\t\targ2 = """";\n', '\t\tif (!r_fs_check (core->fs, arg1) && !r_fs_check (core->fs, arg2)) {\n', '\t\t\tchar *res = r_syscmd_join (arg1, arg2);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_print (res);\n', '\t\t\t\tfree (res);\n']","static int FUNC1(void *Var1,const char *Var2){//STRING
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4=strdup(Var2); 
const char *Var5=strchr(Var4,); 
if (!Var5){
Var5=FUNC2(Var5); 
char *Var6=strchr(Var5,); 
if (!Var6){
const char *Var7=Var6+1; 
if (!Var7){
Var7=FUNC2(Var7); 
switch (*Var2){
if (!Var5){
Var5=STRING; 
if (!Var7){
Var7=STRING; 
if (!FUNC3(Var3->memberVar1,Var5)&&!FUNC3(Var3->memberVar1,Var7)){
char *Var8=FUNC4(Var5,Var7); 
if (Var8){
FUNC5(Var8); 
free(Var8); 
",264,0
after_cmd.c,cmd_interpret,False,False,415,CWE-,CallExpression,strchr,1118,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", '\t\t\tcmd = ptr + 1;\n', '\t\t\t*ptr = 0;\n', ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\thost = input + 1;\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", '\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n', '\t\t\tif (rbuf) {\n', '\t\t\t\tr_cons_print (rbuf);\n', '\t\t\t\tfree (rbuf);\n', 'else\n', '\t\t\tr_core_rtr_cmds (core, input + 1);\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tr_core_cmd_command (core, input + 1);\n', '\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var11=Var4+1; 
*Var4=0; 
Var5=strchr(Var2+1,); 
if (Var5){
Var9=Var2+1; 
Var10=Var2+((Var2[1]== ) 21); 
Var6=FUNC2(Var12,Var9,Var10,Var11); 
if (Var6){
FUNC3(Var6); 
free(Var6); 
else 
FUNC4(Var12,Var2+1); 
if (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16
else 
}else if (Var2[1]){
char *Var3=FUNC5(Var12,FUNC6(Var2)); 
const char *Var17=FUNC6(Var2+1); 
char *Var18=strdup(Var17); 
char *Var19=strchr(Var18,); 
const char *Var20=FUNC6(Var2+1); 
FUNC7(Var12,Var2+1); 
FUNC8(&Var12->memberVar1->memberVar1,Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
char *Var21=FUNC9(strdup(Var4),Var7); 
",451,0
after_cmd.c,cmd_interpret,False,False,416,CWE-,CallExpression,strchr,1123,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\t*eol = 0;\n', '\t\t\t\thost = input + 1;\n', '\t\t\t\tport = eol + 1;\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", '\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n', '\t\t\tif (rbuf) {\n', '\t\t\t\tr_cons_print (rbuf);\n', '\t\t\t\tfree (rbuf);\n', 'else\n', '\t\t\tr_core_rtr_cmds (core, input + 1);\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tr_core_cmd_command (core, input + 1);\n', '\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var5=strchr(Var2+1,); 
if (Var5){
*Var5=0; 
Var9=Var2+1; 
Var10=Var5+1; 
Var10=Var2+((Var2[1]== ) 21); 
Var6=FUNC2(Var12,Var9,Var10,Var11); 
if (Var6){
FUNC3(Var6); 
free(Var6); 
else 
FUNC4(Var12,Var2+1); 
if (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16
else 
}else if (Var2[1]){
char *Var3=FUNC5(Var12,FUNC6(Var2)); 
const char *Var17=FUNC6(Var2+1); 
char *Var18=strdup(Var17); 
char *Var19=strchr(Var18,); 
const char *Var20=FUNC6(Var2+1); 
FUNC7(Var12,Var2+1); 
FUNC8(&Var12->memberVar1->memberVar1,Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
char *Var21=FUNC9(strdup(Var4),Var7); 
",451,0
after_cmd.c,cmd_interpret,False,False,417,CWE-,CallExpression,free,1135,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", '\t\t\tcmd = ptr + 1;\n', ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\thost = input + 1;\n', '\t\t\t\tport = eol + 1;\n', 'else\n', '\t\t\t\thost = ""localhost"";\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", '\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n', '\t\t\tif (rbuf) {\n', '\t\t\t\tr_cons_print (rbuf);\n', '\t\t\t\tfree (rbuf);\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var11=Var4+1; 
Var5=strchr(Var2+1,); 
if (Var5){
Var9=Var2+1; 
Var10=Var5+1; 
else 
Var9=STRING; 
Var10=Var2+((Var2[1]== ) 21); 
Var6=FUNC2(Var12,Var9,Var10,Var11); 
if (Var6){
FUNC3(Var6); 
free(Var6); 
char *Var3=FUNC4(Var12,FUNC5(Var2)); 
const char *Var13=FUNC5(Var2+1); 
char *Var14=strchr(Var15,); 
const char *Var16=FUNC5(Var2+1); 
char *Var17=FUNC6(strdup(Var4),Var7); 
",322,0
after_cmd.c,cmd_interpret,False,False,418,CWE-,CallExpression,free,1149,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tif (str) {\n', '\t\t\t\tr_core_cmd (core, str, 0);\n', '\t\t\t\tfree (str);\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
if (Var2[1]== .){//STRING Var10  Var11  Var12  STRUCT2  Var13
else 
}else if (Var2[1]){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
if (Var3){
FUNC4(Var9,Var3,0); 
free(Var3); 
const char *Var14=FUNC3(Var2+1); 
const char *Var15=FUNC3(Var2+1); 
",209,0
after_cmd.c,cmd_interpret,False,False,419,CWE-,CallExpression,strdup,1158,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tif (sp) {\n', '\t\t\t\t*sp = 0;\n', '\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n', '\t\t\t\tr_core_run_script (core, s);\n', '\t\t\tfree (s);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var4=FUNC2(Var3,FUNC3(Var2)); 
const char *Var5=FUNC3(Var2+1); 
char *Var6=strdup(Var5); 
char *Var7=strchr(Var6,); 
if (Var7){
*Var7=0; 
if (FUNC4(Var6)){
FUNC5(Var3,Var6); 
free(Var6); 
const char *Var8=FUNC3(Var2+1); 
char *Var9=FUNC6(strdup(Var10),Var11); 
",198,1
after_cmd.c,cmd_interpret,False,False,420,CWE-,CallExpression,strchr,1159,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tif (sp) {\n', '\t\t\t\t*sp = 0;\n', '\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n', '\t\t\t\tr_core_run_script (core, s);\n', '\t\t\tfree (s);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var4=FUNC2(Var3,FUNC3(Var2)); 
const char *Var5=FUNC3(Var2+1); 
char *Var6=strdup(Var5); 
char *Var7=strchr(Var6,); 
if (Var7){
*Var7=0; 
if (FUNC4(Var6)){
FUNC5(Var3,Var6); 
free(Var6); 
const char *Var8=FUNC3(Var2+1); 
char *Var9=FUNC6(strdup(Var10),Var11); 
",198,1
after_cmd.c,cmd_interpret,False,False,421,CWE-,CallExpression,free,1166,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tif (R_STR_ISNOTEMPTY (s)) {\n', '\t\t\t\tr_core_run_script (core, s);\n', '\t\t\tfree (s);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var4=FUNC2(Var3,FUNC3(Var2)); 
const char *Var5=FUNC3(Var2+1); 
char *Var6=strdup(Var5); 
char *Var7=strchr(Var6,); 
if (FUNC4(Var6)){
FUNC5(Var3,Var6); 
free(Var6); 
const char *Var8=FUNC3(Var2+1); 
char *Var9=FUNC6(strdup(Var10),Var11); 
",183,1
after_cmd.c,cmd_interpret,False,False,422,CWE-,CallExpression,strdup,1206,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tconst char *host, *port, *cmd;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', ""\t\tif ((ptr = strchr (input + 1, ' '))) {\n"", ""\t\t\teol = strchr (input + 1, ':');\n"", '\t\t\tif (eol) {\n', '\t\t\t\thost = input + 1;\n', ""\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n"", 'else\n', '\t\t\tr_core_rtr_cmds (core, input + 1);\n', '\t\tif (input[1] == \'.\') { // ""..."" run the last command repeated\n', 'else\n', '\t\t} else if (input[1]) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tr_core_cmd_command (core, input + 1);\n', '\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tif (filter) {\n', '\t\t\t*filter = 0;\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (filter) {\n', ""\t\t\t*filter = '~';\n"", '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (eol) {\n', ""\t\t\t\t\t*eol = '\\0';\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n', '\t\tfree (str);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
const char *Var9,*Var10,*Var11; 
STRUCT1 *Var12=(STRUCT1 *) Var1; 
switch (*Var2){
if ((Var4=strchr(Var2+1,))){
Var5=strchr(Var2+1,); 
if (Var5){
Var9=Var2+1; 
Var10=Var2+((Var2[1]== ) 21); 
else 
FUNC2(Var12,Var2+1); 
if (Var2[1]== .){//STRING Var13  Var14  Var15  STRUCT2  Var16
else 
}else if (Var2[1]){
char *Var3=FUNC3(Var12,FUNC4(Var2)); 
const char *Var17=FUNC4(Var2+1); 
char *Var18=strdup(Var17); 
char *Var19=strchr(Var18,); 
const char *Var20=FUNC4(Var2+1); 
FUNC5(Var12,Var2+1); 
FUNC6(&Var12->memberVar1->memberVar1,Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
if (Var7){
*Var7=0; 
Var4=Var3=FUNC7(Var12,Var8); 
if (Var7){
*Var7=; 
if (Var4){
if (FUNC8()){
Var5=strchr(Var4,Var21); 
if (Var5){
*Var5=0; 
if (*Var4){
char *Var22=FUNC9(strdup(Var4),Var7); 
FUNC10(Var12,Var22); 
free(Var22); 
if (!Var5){
Var4=Var5+1; 
free(Var3); 
free(Var8); 
",554,0
after_cmd.c,cmd_interpret,False,False,423,CWE-,CallExpression,strchr,1207,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tif (filter) {\n', '\t\t\t*filter = 0;\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (filter) {\n', ""\t\t\t*filter = '~';\n"", '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
if (Var7){
*Var7=0; 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var7){
*Var7=; 
if (Var4){
if (FUNC5()){
if (*Var4){
char *Var14=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var14); 
free(Var14); 
if (!Var5){
free(Var8); 
",328,0
after_cmd.c,cmd_interpret,False,False,424,CWE-,CallExpression,strchr,1225,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (eol) {\n', ""\t\t\t\t\t*eol = '\\0';\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var4){
if (FUNC5()){
Var5=strchr(Var4,Var14); 
if (Var5){
*Var5=0; 
if (*Var4){
char *Var15=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var15); 
free(Var15); 
if (!Var5){
Var4=Var5+1; 
",318,0
after_cmd.c,cmd_interpret,False,False,425,CWE-,CallExpression,strdup,1230,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tif (filter) {\n', '\t\t\t*filter = 0;\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (filter) {\n', ""\t\t\t*filter = '~';\n"", '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
if (Var7){
*Var7=0; 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var7){
*Var7=; 
if (Var4){
if (FUNC5()){
Var5=strchr(Var4,Var14); 
if (*Var4){
char *Var15=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var15); 
free(Var15); 
if (!Var5){
Var4=Var5+1; 
",343,0
after_cmd.c,cmd_interpret,False,False,426,CWE-,CallExpression,free,1232,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\tif (ptr) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t\teol = strchr (ptr, '\\n');\n"", '\t\t\t\tif (*ptr) {\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\t\t\t\tr_core_cmd0 (core, p);\n', '\t\t\t\t\tfree (p);\n', '\t\t\t\tif (!eol) {\n', '\t\t\t\tptr = eol + 1;\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
Var4=Var3=FUNC4(Var9,Var8); 
if (Var4){
if (FUNC5()){
Var5=strchr(Var4,Var14); 
if (*Var4){
char *Var15=FUNC6(strdup(Var4),Var7); 
FUNC7(Var9,Var15); 
free(Var15); 
if (!Var5){
Var4=Var5+1; 
",314,0
after_cmd.c,cmd_interpret,False,False,427,CWE-,CallExpression,free,1241,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\tfree (str);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
const char *Var12=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var4=Var3=FUNC4(Var9,Var8); 
char *Var13=FUNC5(strdup(Var4),Var7); 
free(Var3); 
",220,0
after_cmd.c,cmd_interpret,False,False,428,CWE-,CallExpression,free,1242,-3,"['static int cmd_interpret(void *data, const char *input) {\n', '\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n', '\tRCore *core = (RCore *)data;\n', '\tswitch (*input) {\n', '\t\t\tchar *str = r_core_cmd_str_pipe (core, r_str_trim_ro (input));\n', '\t\t\tconst char *a = r_str_trim_ro (input + 1);\n', '\t\t\tchar *s = strdup (a);\n', ""\t\t\tchar *sp = strchr (s, ' ');\n"", '\t\t\tconst char *script_file = r_str_trim_ro (input + 1);\n', '\t\tif (*input >= 0 && *input <= 9) {\n', '\t\tinp = strdup (input);\n', ""\t\tfilter = strchr (inp, '~');\n"", '\t\tptr = str = r_core_cmd_str (core, inp);\n', '\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5,*Var6,*Var7,*Var8; 
STRUCT1 *Var9=(STRUCT1 *) Var1; 
switch (*Var2){
char *Var3=FUNC2(Var9,FUNC3(Var2)); 
const char *Var10=FUNC3(Var2+1); 
char *Var11=strdup(Var10); 
char *Var12=strchr(Var11,); 
const char *Var13=FUNC3(Var2+1); 
if (*Var2 >= 0&&*Var2 <= 9){
Var8=strdup(Var2); 
Var7=strchr(Var8,); 
Var4=Var3=FUNC4(Var9,Var8); 
char *Var14=FUNC5(strdup(Var4),Var7); 
free(Var8); 
",245,0
after_cmd.c,r_line_hist_sdb_up,False,False,429,CWE-,CallExpression,strncpy,1258,-3,"['R_API int r_line_hist_sdb_up(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
after_cmd.c,r_line_hist_sdb_up,False,False,430,CWE-,CallExpression,strlen,1259,-3,"['R_API int r_line_hist_sdb_up(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->n) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->n;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
after_cmd.c,r_line_hist_sdb_down,False,False,431,CWE-,CallExpression,strncpy,1268,-3,"['R_API int r_line_hist_sdb_down(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
after_cmd.c,r_line_hist_sdb_down,False,False,432,CWE-,CallExpression,strlen,1269,-3,"['R_API int r_line_hist_sdb_down(RLine *line) {\n', '\tif (!line->sdbshell_hist_iter || !line->sdbshell_hist_iter->p) {\n', '\tline->sdbshell_hist_iter = line->sdbshell_hist_iter->p;\n', '\tstrncpy (line->buffer.data, line->sdbshell_hist_iter->data, R_LINE_BUFSIZE - 1);\n', '\tline->buffer.index = line->buffer.length = strlen (line->buffer.data);\n']","Var1 int FUNC1(STRUCT1 *Var2){
if (!Var2->memberVar1||!Var2->memberVar1->memberVar1){
Var2->memberVar1=Var2->memberVar1->memberVar1; 
strncpy(Var2->memberVar2.memberVar1,Var2->memberVar1->memberVar2,Var3-1); 
Var2->memberVar2.memberVar2=Var2->memberVar2.memberVar3=strlen(Var2->memberVar2.memberVar1); 
",113,0
after_cmd.c,cmd_kuery,False,False,433,CWE-,CallExpression,strchr,1295,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tr_cons_printf (""\\n\\n\\""%s\\"" : ["", cur_cmd);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\twhile (*temp_storage) {\n', ""\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n"", '\t\t\t\tif (!temp_pos) {\n', '\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n', '\t\t\t\tr_cons_printf (""\\""%s\\"","", temp_cmd);\n', '\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (next_cmd);\n', '\t\tfree (temp_storage);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
FUNC4(STRING%Var6 STRING,Var8); 
Var9=FUNC5(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
while (*Var12){
Var10=strchr(Var12,Var13); 
if (!Var10){
Var11=FUNC3(Var12,Var10-Var12); 
FUNC4(STRING%Var6 STRING,Var11); 
Var12  STRUCT3  Var10-Var12+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var9); 
free(Var12); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC6(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",521,0
after_cmd.c,cmd_kuery,False,False,434,CWE-,CallExpression,strchr,1314,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\twhile (*temp_storage) {\n', ""\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n"", '\t\t\t\tif (!temp_pos) {\n', '\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n', '\t\t\t\tr_cons_printf (""\\""%s\\"","", temp_cmd);\n', '\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (temp_storage);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
Var9=FUNC4(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
while (*Var12){
Var10=strchr(Var12,Var13); 
if (!Var10){
Var11=FUNC3(Var12,Var10-Var12); 
FUNC5(STRING%Var6 STRING,Var11); 
Var12  STRUCT3  Var10-Var12+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var12); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC6(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC7(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",499,0
after_cmd.c,cmd_kuery,False,False,435,CWE-,CallExpression,free,1329,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (next_cmd);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
Var9=FUNC4(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var9); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC5(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",421,0
after_cmd.c,cmd_kuery,False,False,436,CWE-,CallExpression,free,1330,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, ""anal/**"");\n', '\t\tif (!out) {\n', '\t\twhile (*out) {\n', ""\t\t\tcur_pos = strchr (out, '\\n');\n"", '\t\t\tif (!cur_pos) {\n', '\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n', '\t\t\tnext_cmd = r_str_newf (""anal/%s/*"", cur_cmd);\n', '\t\t\ttemp_storage = sdb_querys (s, NULL, 0, next_cmd);\n', '\t\t\tif (!temp_storage) {\n', '\t\t\t\tout += cur_pos - out + 1;\n', '\t\t\twhile (*temp_storage) {\n', ""\t\t\t\ttemp_pos = strchr (temp_storage, '\\n');\n"", '\t\t\t\tif (!temp_pos) {\n', '\t\t\t\ttemp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);\n', '\t\t\t\ttemp_storage += temp_pos - temp_storage + 1;\n', '\t\t\tout += cur_pos - out + 1;\n', '\t\tfree (temp_storage);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,STRING); 
if (!Var4){
while (*Var4){
Var7=strchr(Var4,Var13); 
if (!Var7){
Var8=FUNC3(Var4,Var7-Var4); 
Var9=FUNC4(STRING,Var8); 
Var12=FUNC2(Var6,NULL ,0,Var9); 
if (!Var12){
Var4  STRUCT3  Var7-Var4+1; 
while (*Var12){
Var10=strchr(Var12,Var13); 
if (!Var10){
Var11=FUNC3(Var12,Var10-Var12); 
Var12  STRUCT3  Var10-Var12+1; 
Var4  STRUCT3  Var7-Var4+1; 
free(Var12); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT4 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var19=FUNC5(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
char *Var18=strchr(Var17,); 
STRUCT2 *Var20=FUNC6(Var5->memberVar1,Var18,0); 
char *Var21=strdup(Var2); 
",484,0
after_cmd.c,cmd_kuery,False,False,437,CWE-,CallExpression,free,1338,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\tfree (out);\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
STRUCT2 *Var6=Var5->memberVar1; 
char *Var7,*Var8,*Var9=NULL ; 
char *Var10,*Var11,*Var12=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var6,NULL ,0,Var2+1); 
if (Var4){
FUNC3(Var4); 
free(Var4); 
char *Var13,*Var14,*Var15=strdup(Var2+2); 
STRUCT3 *Var16=Var5->memberVar2->memberVar1; 
char *Var17=strdup(Var2+2); 
STRUCT2 *Var18=FUNC4(NULL ,Var17,0); 
char *Var17=strdup(Var2+2); 
STRUCT2 *Var19=FUNC5(Var5->memberVar1,Var20,0); 
char *Var21=strdup(Var2); 
",284,1
after_cmd.c,cmd_kuery,False,False,438,CWE-,CallExpression,strdup,1354,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tfor (n = o = p; n; o = n) {\n', ""\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n"", '\t\t\t\tif (n) {\n', '\t\t\t\t\t*n++ = 0;\n', '\t\t\t\ts = sdb_ns (s, o, 1);\n', '\t\t\tfree (p);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tr_line_set_prompt (p);\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tif (out) {\n', '\t\t\t\tr_cons_println (out);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
const int  Var8=sizeof (Var3)-1; 
STRUCT2 *Var9=Var5->memberVar1; 
char *Var10,*Var11,*Var12=NULL ; 
char *Var13,*Var14,*Var15=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var9,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var16,*Var17,*Var7=strdup(Var2+2); 
for (Var16=Var17=Var7; Var16; Var17=Var16){
Var16=strchr(Var17,/); //STRUCT3  Var18
if (Var16){
*Var16  Var19=0; 
Var9=FUNC4(Var9,Var17,1); 
free(Var7); 
STRUCT4 *Var20=Var5->memberVar3->memberVar1; 
FUNC5(Var7); 
if (FUNC6(Var3,Var8,0,NULL )<1){
if (!*Var3){
Var4=FUNC2(Var9,NULL ,0,Var3); 
if (Var4){
FUNC7(Var4); 
if (FUNC8(0)){
if (Var2[1]== ){
char *Var21=strdup(Var2+2); 
if (!Var21){
char *Var22=strchr(Var21,); 
STRUCT2 *Var23=FUNC9(NULL ,Var21,0); 
if (FUNC8(0)){
if (Var2[1]== ){
char *Var21=strdup(Var2+2); 
char *Var22=strchr(Var21,); 
STRUCT2 *Var24=FUNC10(Var5->memberVar1,Var22,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var25=strdup(Var2); 
Var25[(size_t )(Var6-Var2)]=0; 
",627,0
after_cmd.c,cmd_kuery,False,False,439,CWE-,CallExpression,strchr,1357,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tfor (n = o = p; n; o = n) {\n', ""\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n"", '\t\t\t\tif (n) {\n', '\t\t\t\t\t*n++ = 0;\n', '\t\t\t\ts = sdb_ns (s, o, 1);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tif (out) {\n', '\t\t\t\tr_cons_println (out);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
const int  Var8=sizeof (Var3)-1; 
STRUCT2 *Var9=Var5->memberVar1; 
char *Var10,*Var11,*Var12=NULL ; 
char *Var13,*Var14,*Var15=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
if (Var2[1]== ){
char *Var16,*Var17,*Var7=strdup(Var2+2); 
for (Var16=Var17=Var7; Var16; Var17=Var16){
Var16=strchr(Var17,/); //STRUCT3  Var18
if (Var16){
*Var16  Var19=0; 
Var9=FUNC3(Var9,Var17,1); 
STRUCT4 *Var20=Var5->memberVar3->memberVar1; 
if (FUNC4(Var3,Var8,0,NULL )<1){
if (!*Var3){
Var4=FUNC5(Var9,NULL ,0,Var3); 
if (Var4){
FUNC6(Var4); 
char *Var21=strdup(Var2+2); 
char *Var22=strchr(Var21,); 
STRUCT2 *Var23=FUNC7(NULL ,Var21,0); 
char *Var21=strdup(Var2+2); 
char *Var22=strchr(Var21,); 
STRUCT2 *Var24=FUNC8(Var5->memberVar1,Var22,0); 
char *Var25=strdup(Var2); 
",481,0
after_cmd.c,cmd_kuery,False,False,440,CWE-,CallExpression,free,1363,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tfor (n = o = p; n; o = n) {\n', '\t\t\tfree (p);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tr_line_set_prompt (p);\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
const int  Var8=sizeof (Var3)-1; 
STRUCT2 *Var9=Var5->memberVar1; 
char *Var10,*Var11,*Var12=NULL ; 
char *Var13,*Var14,*Var15=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
if (Var2[1]== ){
char *Var16,*Var17,*Var7=strdup(Var2+2); 
for (Var16=Var17=Var7; Var16; Var17=Var16){
free(Var7); 
STRUCT3 *Var18=Var5->memberVar3->memberVar1; 
FUNC3(Var7); 
if (FUNC4(Var3,Var8,0,NULL )<1){
if (!*Var3){
char *Var19=strdup(Var2+2); 
STRUCT2 *Var20=FUNC5(NULL ,Var19,0); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var21=FUNC6(Var5->memberVar1,Var22,0); 
char *Var23=strdup(Var2); 
",379,0
after_cmd.c,cmd_kuery,False,False,441,CWE-,CallExpression,strcmp,1384,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (!line->sdbshell_hist) {\n', '\t\t\tline->sdbshell_hist = r_list_newf (free);\n', '\t\tRList *sdb_hist = line->sdbshell_hist;\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tif (sdb_hist) {\n', '\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n', '\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n', '\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const int  Var6=sizeof (Var3)-1; 
STRUCT2 *Var7=Var5->memberVar1; 
char *Var8,*Var9,*Var10=NULL ; 
char *Var11,*Var12,*Var13=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
char *Var14,*Var15,*Var16=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (!memberVar1->memberVar1){
memberVar1->memberVar1=FUNC3(free); 
STRUCT4 *Var18=memberVar1->memberVar1; 
if (FUNC4(Var3,Var6,0,NULL )<1){
if (!*Var3){
if (Var18){
if ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){
FUNC7(Var18,1,strdup(Var3)); 
memberVar1->memberVar2=Var18->memberVar1; 
Var4=FUNC8(Var7,NULL ,0,Var3); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var20=FUNC9(NULL ,Var19,0); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); 
char *Var23=strdup(Var2); 
",451,0
after_cmd.c,cmd_kuery,False,False,442,CWE-,CallExpression,strdup,1385,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst int buflen = sizeof (buf) - 1;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (!line->sdbshell_hist) {\n', '\t\t\tline->sdbshell_hist = r_list_newf (free);\n', '\t\tRList *sdb_hist = line->sdbshell_hist;\n', '\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1) {\n', '\t\t\tif (!*buf) {\n', '\t\t\tif (sdb_hist) {\n', '\t\t\t\tif ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {\n', '\t\t\t\t\tr_list_insert (sdb_hist, 1, strdup (buf));\n', '\t\t\t\tline->sdbshell_hist_iter = sdb_hist->head;\n', '\t\t\tout = sdb_querys (s, NULL, 0, buf);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const int  Var6=sizeof (Var3)-1; 
STRUCT2 *Var7=Var5->memberVar1; 
char *Var8,*Var9,*Var10=NULL ; 
char *Var11,*Var12,*Var13=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
char *Var14,*Var15,*Var16=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (!memberVar1->memberVar1){
memberVar1->memberVar1=FUNC3(free); 
STRUCT4 *Var18=memberVar1->memberVar1; 
if (FUNC4(Var3,Var6,0,NULL )<1){
if (!*Var3){
if (Var18){
if ((FUNC5(Var18) == 1)||(FUNC5(Var18)>1&&strcmp(FUNC6(Var18,1),Var3))){
FUNC7(Var18,1,strdup(Var3)); 
memberVar1->memberVar2=Var18->memberVar1; 
Var4=FUNC8(Var7,NULL ,0,Var3); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var20=FUNC9(NULL ,Var19,0); 
char *Var19=strdup(Var2+2); 
STRUCT2 *Var21=FUNC10(Var5->memberVar1,Var22,0); 
char *Var23=strdup(Var2); 
",451,0
after_cmd.c,cmd_kuery,False,False,443,CWE-,CallExpression,strdup,1403,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', '\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', 'else\n', '\t\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\tfree (fn);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
if (Var19){
STRUCT2 *Var20; 
*Var19  Var21=0; 
if (FUNC5(Var18)){
Var20=FUNC6(Var5->memberVar1,Var19,1); 
if (Var20){
STRUCT2 *Var22=FUNC7(NULL ,Var18,0); 
if (Var22){
FUNC8(Var20,Var22); 
else 
FUNC9(STRING,Var18); 
else 
FUNC9(STRING,Var19); 
free(Var18); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
if (Var19){
STRUCT2 *Var20=FUNC6(Var5->memberVar1,Var19,0); 
if (Var20){
FUNC10(Var20,Var18); 
free(Var18); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var23=strdup(Var2); 
Var23[(size_t )(Var6-Var2)]=0; 
",598,0
after_cmd.c,cmd_kuery,False,False,444,CWE-,CallExpression,strchr,1408,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', '\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', 'else\n', '\t\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2 *Var4=Var3->memberVar1; 
char *Var5,*Var6,*Var7=NULL ; 
char *Var8,*Var9,*Var10=NULL ; 
switch (Var2[0]){
char *Var11,*Var12,*Var13=strdup(Var2+2); 
STRUCT3 *Var14=Var3->memberVar2->memberVar1; 
if (FUNC2(0)){
if (Var2[1]== ){
char *Var15=strdup(Var2+2); 
if (!Var15){
char *Var16=strchr(Var15,); 
if (Var16){
STRUCT2 *Var17; 
*Var16  Var18=0; 
if (FUNC3(Var15)){
Var17=FUNC4(Var3->memberVar1,Var16,1); 
if (Var17){
STRUCT2 *Var19=FUNC5(NULL ,Var15,0); 
if (Var19){
FUNC6(Var17,Var19); 
else 
FUNC7(STRING,Var15); 
else 
FUNC7(STRING,Var16); 
free(Var15); 
char *Var15=strdup(Var2+2); 
char *Var16=strchr(Var15,); 
STRUCT2 *Var17=FUNC4(Var3->memberVar1,Var16,0); 
char *Var20=strdup(Var2); 
",403,0
after_cmd.c,cmd_kuery,False,False,445,CWE-,CallExpression,free,1430,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', '\t\t\tfree (fn);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3,*Var4,*Var5=NULL ; 
char *Var6,*Var7,*Var8=NULL ; 
switch (Var2[0]){
char *Var9,*Var10,*Var11=strdup(Var2+2); 
if (FUNC2(0)){
if (Var2[1]== ){
char *Var12=strdup(Var2+2); 
if (!Var12){
char *Var13=strchr(Var12,); 
if (Var13){
STRUCT1 *Var14; 
if (FUNC3(Var12)){
if (Var14){
STRUCT1 *Var15=FUNC4(NULL ,Var12,0); 
if (Var15){
else 
FUNC5(STRING,Var12); 
free(Var12); 
char *Var12=strdup(Var2+2); 
char *Var13=strchr(Var12,); 
STRUCT1 *Var14=FUNC6(Var16->memberVar1,Var13,0); 
char *Var17=strdup(Var2); 
",302,0
after_cmd.c,cmd_kuery,False,False,446,CWE-,CallExpression,strdup,1441,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db;\n', '\t\t\t\tif (r_file_exists (fn)) {\n', '\t\t\t\t\tif (db) {\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\t\t\t\t\tif (newdb) {\n', 'else\n', '\t\t\t\t\t\t\teprintf (""Cannot open sdb \'%s\'\\n"", fn);\n', '\t\t\tfree (fn);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\t\t\tsdb_sync (db);\n', 'else\n', '\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
if (Var19){
STRUCT2 *Var20; 
if (FUNC5(Var18)){
if (Var20){
STRUCT2 *Var21=FUNC6(NULL ,Var18,0); 
if (Var21){
else 
FUNC7(STRING,Var18); 
free(Var18); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
if (Var19){
*Var19  Var22=0; 
STRUCT2 *Var20=FUNC8(Var5->memberVar1,Var19,0); 
if (Var20){
FUNC9(Var20,Var18); 
FUNC10(Var20); 
else 
FUNC7(STRING,Var19); 
free(Var18); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var23=strdup(Var2); 
Var23[(size_t )(Var6-Var2)]=0; 
",576,0
after_cmd.c,cmd_kuery,False,False,447,CWE-,CallExpression,strchr,1442,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tSdb *s = core->sdb;\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db;\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\t*ns++ = 0;\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\t\t\tsdb_sync (db);\n', 'else\n', '\t\t\t\t\teprintf (""Cannot find sdb \'%s\'\\n"", ns);\n', '\t\t\tfree (fn);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2 *Var4=Var3->memberVar1; 
switch (Var2[0]){
char *Var5,*Var6,*Var7=strdup(Var2+2); 
STRUCT3 *Var8=Var3->memberVar2->memberVar1; 
char *Var9=strdup(Var2+2); 
char *Var10=strchr(Var9,); 
STRUCT2 *Var11; 
STRUCT2 *Var12=FUNC2(NULL ,Var9,0); 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var9=strdup(Var2+2); 
char *Var10=strchr(Var9,); 
if (Var10){
*Var10  Var13=0; 
STRUCT2 *Var11=FUNC4(Var3->memberVar1,Var10,0); 
if (Var11){
FUNC5(Var11,Var9); 
FUNC6(Var11); 
else 
FUNC7(STRING,Var10); 
free(Var9); 
char *Var14=strdup(Var2); 
",315,0
after_cmd.c,cmd_kuery,False,False,448,CWE-,CallExpression,free,1455,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tswitch (input[0]) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db;\n', '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\tif (ns) {\n', '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', '\t\t\t\tif (db) {\n', '\t\t\t\t\tsdb_file (db, fn);\n', '\t\t\tfree (fn);\n', '\t\tchar *inp = strdup (input);\n']","static int FUNC1(void *Var1,const char *Var2){
switch (Var2[0]){
char *Var3,*Var4,*Var5=strdup(Var2+2); 
char *Var6=strdup(Var2+2); 
char *Var7=strchr(Var6,); 
STRUCT1 *Var8; 
STRUCT1 *Var9=FUNC2(NULL ,Var6,0); 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var6=strdup(Var2+2); 
char *Var7=strchr(Var6,); 
if (Var7){
STRUCT1 *Var8=FUNC4(Var10->memberVar1,Var7,0); 
if (Var8){
FUNC5(Var8,Var6); 
free(Var6); 
char *Var11=strdup(Var2); 
",236,0
after_cmd.c,cmd_kuery,False,False,449,CWE-,CallExpression,strchr,1470,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n', '\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\t\tfree (out);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
STRUCT2 *Var20=FUNC5(NULL ,Var18,0); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
STRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var22=strdup(Var2); 
Var22[(size_t )(Var6-Var2)]=0; 
Var4=FUNC2(Var8,NULL ,0,Var6+1); 
if (Var4){
FUNC7(Var4); 
free(Var4); 
",493,0
after_cmd.c,cmd_kuery,False,False,450,CWE-,CallExpression,strdup,1472,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tout = sdb_querys (s, NULL, 0, input + 1);\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n', '\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n', '\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\t\tfree (out);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
Var4=FUNC2(Var8,NULL ,0,Var2+1); 
if (Var5->memberVar2){
if (!FUNC3()){
if (Var2[1]== ){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
STRUCT2 *Var20=FUNC5(NULL ,Var18,0); 
if (FUNC4(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
STRUCT2 *Var21=FUNC6(Var5->memberVar1,Var19,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var22=strdup(Var2); 
Var22[(size_t )(Var6-Var2)]=0; 
Var8=FUNC7(Var5->memberVar1,Var22+1,1); 
Var4=FUNC2(Var8,NULL ,0,Var6+1); 
if (Var4){
FUNC8(Var4); 
free(Var4); 
free(Var22); 
",521,0
after_cmd.c,cmd_kuery,False,False,451,CWE-,CallExpression,free,1478,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tchar buf[1024], *out;\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tchar *cur_pos, *cur_cmd, *next_cmd = NULL;\n', '\tchar *temp_pos, *temp_cmd, *temp_storage = NULL;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", ""\tsp = strchr (input + 1, ' ');\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n', '\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n', '\t\tif (out) {\n', '\t\t\tr_cons_println (out);\n', '\t\t\tfree (out);\n']","static int FUNC1(void *Var1,const char *Var2){
char  Var3[1024],*Var4; 
STRUCT1 *Var5=(STRUCT1 *) Var1; 
const char *Var6,*Var7=STRING; 
STRUCT2 *Var8=Var5->memberVar1; 
char *Var9,*Var10,*Var11=NULL ; 
char *Var12,*Var13,*Var14=NULL ; 
switch (Var2[0]){
if (Var5->memberVar2){
if (!FUNC2()){
char *Var15,*Var16,*Var7=strdup(Var2+2); 
STRUCT3 *Var17=Var5->memberVar3->memberVar1; 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var18=strdup(Var2+2); 
if (!Var18){
char *Var19=strchr(Var18,); 
STRUCT2 *Var20=FUNC4(NULL ,Var18,0); 
if (FUNC3(0)){
char *Var18=strdup(Var2+2); 
char *Var19=strchr(Var18,); 
STRUCT2 *Var21=FUNC5(Var5->memberVar1,Var19,0); 
if (Var2[0]== 0){
Var6=strchr(Var2+1,); 
if (Var6){
char *Var22=strdup(Var2); 
Var8=FUNC6(Var5->memberVar1,Var22+1,1); 
Var4=FUNC7(Var8,NULL ,0,Var6+1); 
if (Var4){
FUNC8(Var4); 
free(Var4); 
",448,0
after_cmd.c,cmd_kuery,False,False,452,CWE-,CallExpression,free,1480,-3,"['static int cmd_kuery(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tconst char *sp, *p = ""[sdb]> "";\n', '\tSdb *s = core->sdb;\n', '\tswitch (input[0]) {\n', '\t\tif (core->http_up) {\n', '\t\tif (!r_cons_is_interactive ()) {\n', '\t\t\tchar *n, *o, *p = strdup (input + 2);\n', '\t\tRLine *line = core->cons->line;\n', '\t\tif (r_sandbox_enable (0)) {\n', ""\t\tif (input[1] == ' ') {\n"", '\t\t\tchar *fn = strdup (input + 2);\n', '\t\t\tif (!fn) {\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n', '\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tchar *fn = strdup (input + 2);\n', ""\t\t\tchar *ns = strchr (fn, ' ');\n"", '\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n', ""\tif (input[0] == '\\0') {\n"", '\tif (sp) {\n', '\t\tchar *inp = strdup (input);\n', '\t\tinp [(size_t)(sp - input)] = 0;\n', '\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n', '\t\tfree (inp);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
const char *Var4,*Var5=STRING; 
STRUCT2 *Var6=Var3->memberVar1; 
switch (Var2[0]){
if (Var3->memberVar2){
if (!FUNC2()){
char *Var7,*Var8,*Var5=strdup(Var2+2); 
STRUCT3 *Var9=Var3->memberVar3->memberVar1; 
if (FUNC3(0)){
if (Var2[1]== ){
char *Var10=strdup(Var2+2); 
if (!Var10){
char *Var11=strchr(Var10,); 
STRUCT2 *Var12=FUNC4(NULL ,Var10,0); 
if (FUNC3(0)){
char *Var10=strdup(Var2+2); 
char *Var11=strchr(Var10,); 
STRUCT2 *Var13=FUNC5(Var3->memberVar1,Var11,0); 
if (Var2[0]== 0){
if (Var4){
char *Var14=strdup(Var2); 
Var14[(size_t )(Var4-Var2)]=0; 
Var6=FUNC6(Var3->memberVar1,Var14+1,1); 
free(Var14); 
",368,0
after_cmd.c,__runMain,False,False,453,CWE-,CallExpression,free,1544,-3,"['static int __runMain(RMainCallback cb, const char *arg) {\n', '\tchar *a = r_str_trim_dup (arg);\n', '\tint argc = 0;\n', '\tchar **args = r_str_argv (a, &argc);\n', '\tint res = cb (argc, args);\n', '\tfree (args);\n']","static int FUNC1(STRUCT1  Var1,const char *Var2){
char *Var3=FUNC2(Var2); 
int  Var4=0; 
char **Var5=FUNC3(Var3,&Var4); 
int  Var6=Var1(Var4,Var5); 
free(Var5); 
",86,1
after_cmd.c,__runMain,False,False,454,CWE-,CallExpression,free,1545,-3,"['static int __runMain(RMainCallback cb, const char *arg) {\n', '\tchar *a = r_str_trim_dup (arg);\n', '\tchar **args = r_str_argv (a, &argc);\n', '\tint res = cb (argc, args);\n', '\tfree (a);\n']","static int FUNC1(STRUCT1  Var1,const char *Var2){
char *Var3=FUNC2(Var2); 
char **Var4=FUNC3(Var3,&Var5); 
int  Var6=Var1(Var5,Var4); 
free(Var3); 
",78,1
after_cmd.c,cmd_r2cmd,False,False,455,CWE-,CallExpression,free,1578,-3,"['static bool cmd_r2cmd(RCore *core, const char *_input) {\n', '\tchar *input = r_str_newf (""r%s"", _input);\n', '\tint rc = 0;\n', '\tif (r_str_startswith (input, ""rax2"")) {\n', 'else\n', '\t} else if (r_str_startswith (input, ""radare2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rasm2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rabin2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""ragg2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""r2pm"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""radiff2"")) {\n', '\t\trc = __runMain (core->r_main_radiff2, input);\n', 'else\n', '\t\tconst char *r2cmds[] = {\n', '\t\tint i;\n', '\t\tfor (i = 0; r2cmds[i]; i++) {\n', '\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n', '\t\t\t\tfree (input);\n', '\tfree (input);\n']","static bool FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=FUNC2(STRING,Var2); 
int  Var4=0; 
if (FUNC3(Var3,STRING)){
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
Var4=FUNC5(Var1->memberVar1,Var3); 
else 
const char *Var5[]={
int  Var6; 
for (Var6=0; Var5[Var6]; Var6  Var7){
if (FUNC3(Var3,Var5[Var6])){
free(Var3); 
free(Var3); 
",320,0
after_cmd.c,cmd_r2cmd,False,False,456,CWE-,CallExpression,free,1584,-3,"['static bool cmd_r2cmd(RCore *core, const char *_input) {\n', '\tchar *input = r_str_newf (""r%s"", _input);\n', '\tint rc = 0;\n', '\tif (r_str_startswith (input, ""rax2"")) {\n', 'else\n', '\t} else if (r_str_startswith (input, ""radare2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rasm2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""rabin2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""ragg2"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""r2pm"")) {\n', '\t\tr_sys_cmdf (""%s"", input);\n', 'else\n', '\t} else if (r_str_startswith (input, ""radiff2"")) {\n', '\t\trc = __runMain (core->r_main_radiff2, input);\n', 'else\n', '\t\tconst char *r2cmds[] = {\n', '\t\tint i;\n', '\t\tfor (i = 0; r2cmds[i]; i++) {\n', '\t\t\tif (r_str_startswith (input, r2cmds[i])) {\n', '\t\t\t\tfree (input);\n', '\tfree (input);\n']","static bool FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=FUNC2(STRING,Var2); 
int  Var4=0; 
if (FUNC3(Var3,STRING)){
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
FUNC4(STRING,Var3); 
else 
}else if (FUNC3(Var3,STRING)){
Var4=FUNC5(Var1->memberVar1,Var3); 
else 
const char *Var5[]={
int  Var6; 
for (Var6=0; Var5[Var6]; Var6  Var7){
if (FUNC3(Var3,Var5[Var6])){
free(Var3); 
free(Var3); 
",320,0
after_cmd.c,cmd_resize,False,False,457,CWE-,CallExpression,write,1653,-3,"['\tRCore *core = (RCore *)data;\n', '\tif (cmd_r2cmd (core, input)) {\n', '\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n', '\tswitch (*input) {\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n']","STRUCT1 *Var1=(STRUCT1 *) Var2; 
if (FUNC1(Var1,Var3)){
STRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; 
switch (*Var3){
const char *memberVar1=FUNC3(Var3+2); 
write(1,Var5,strlen(Var5)); 
",109,0
after_cmd.c,cmd_resize,False,False,458,CWE-,CallExpression,strlen,1653,-3,"['\tRCore *core = (RCore *)data;\n', '\tif (cmd_r2cmd (core, input)) {\n', '\tut64 oldsize = (core->file) ? r_io_fd_size (core->io, core->file->fd): 0;\n', '\tswitch (*input) {\n', '\t\t\tconst char *file = r_str_trim_ro (input + 2);\n', '\t\twrite (1, Color_RESET_TERMINAL, strlen (Color_RESET_TERMINAL));\n']","STRUCT1 *Var1=(STRUCT1 *) Var2; 
if (FUNC1(Var1,Var3)){
STRUCT2  Var4=(Var1->memberVar1) FUNC2(Var1->memberVar2,Var1->memberVar1->memberVar1) 0; 
switch (*Var3){
const char *memberVar1=FUNC3(Var3+2); 
write(1,Var5,strlen(Var5)); 
",109,0
after_cmd.c,cmd_pipein,False,False,459,CWE-,CallExpression,strdup,1727,-3,"['static int cmd_pipein(void *user, const char *input) {\n', '\tchar *buf = strdup (input);\n', '\tint len = r_str_unescape (buf);\n', '\tr_cons_readpush (buf, len);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4=FUNC2(Var3); 
FUNC3(Var3,Var4); 
free(Var3); 
",66,1
after_cmd.c,cmd_pipein,False,False,460,CWE-,CallExpression,free,1730,-3,"['static int cmd_pipein(void *user, const char *input) {\n', '\tchar *buf = strdup (input);\n', '\tint len = r_str_unescape (buf);\n', '\tr_cons_readpush (buf, len);\n', '\tfree (buf);\n']","static int FUNC1(void *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4=FUNC2(Var3); 
FUNC3(Var3,Var4); 
free(Var3); 
",66,1
after_cmd.c,cmd_pointer,False,False,461,CWE-,CallExpression,strdup,1823,-3,"['static int cmd_pointer(void *data, const char *input) {\n', '\tRCore *core = (RCore*) data;\n', '\tint ret = true;\n', '\tchar *str, *eq;\n', '\tinput = r_str_trim_ro (input);\n', ""\twhile (*input == ' ') {\n"", '\t\tinput++;\n', ""\tif (!*input || *input == '?') {\n"", '\tstr = strdup (input);\n', ""\teq = strchr (str, '=');\n"", '\tif (eq) {\n', '\t\t*eq++ = 0;\n', '\t\tif (!strncmp (eq, ""0x"", 2)) {\n', '\t\t\tret = r_core_cmdf (core, ""wv %s@%s"", eq, str);\n', 'else\n', '\t\t\tret = r_core_cmdf (core, ""wx %s@%s"", eq, str);\n', 'else\n', '\t\tret = r_core_cmdf (core, ""?v [%s]"", input);\n', '\tfree (str);\n', '\treturn ret;\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=true ; 
char *Var5,*Var6; 
Var2=FUNC2(Var2); 
while (*Var2 == ){
Var2  Var7; 
if (!*Var2||*Var2 == ){
Var5=strdup(Var2); 
Var6=strchr(Var5,=); 
if (Var6){
*Var6  Var7=0; 
if (!FUNC3(Var6,STRING,2)){
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var2); 
free(Var5); 
return  Var4; 
",236,0
after_cmd.c,cmd_pointer,False,False,462,CWE-,CallExpression,strchr,1824,-3,"['static int cmd_pointer(void *data, const char *input) {\n', '\tRCore *core = (RCore*) data;\n', '\tint ret = true;\n', '\tchar *str, *eq;\n', '\tinput = r_str_trim_ro (input);\n', ""\twhile (*input == ' ') {\n"", '\t\tinput++;\n', ""\tif (!*input || *input == '?') {\n"", '\tstr = strdup (input);\n', ""\teq = strchr (str, '=');\n"", '\tif (eq) {\n', '\t\t*eq++ = 0;\n', '\t\tif (!strncmp (eq, ""0x"", 2)) {\n', '\t\t\tret = r_core_cmdf (core, ""wv %s@%s"", eq, str);\n', 'else\n', '\t\t\tret = r_core_cmdf (core, ""wx %s@%s"", eq, str);\n', '\tfree (str);\n', '\treturn ret;\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=true ; 
char *Var5,*Var6; 
Var2=FUNC2(Var2); 
while (*Var2 == ){
Var2  Var7; 
if (!*Var2||*Var2 == ){
Var5=strdup(Var2); 
Var6=strchr(Var5,=); 
if (Var6){
*Var6  Var7=0; 
if (!FUNC3(Var6,STRING,2)){
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var6,Var5); 
free(Var5); 
return  Var4; 
",218,0
after_cmd.c,cmd_pointer,False,False,463,CWE-,CallExpression,free,1835,-3,"['static int cmd_pointer(void *data, const char *input) {\n', '\tRCore *core = (RCore*) data;\n', '\tint ret = true;\n', '\tchar *str, *eq;\n', '\tinput = r_str_trim_ro (input);\n', ""\twhile (*input == ' ') {\n"", '\t\tinput++;\n', ""\tif (!*input || *input == '?') {\n"", '\tstr = strdup (input);\n', ""\teq = strchr (str, '=');\n"", '\tif (eq) {\n', '\t\tif (!strncmp (eq, ""0x"", 2)) {\n', '\t\t\tret = r_core_cmdf (core, ""wv %s@%s"", eq, str);\n', 'else\n', '\t\t\tret = r_core_cmdf (core, ""wx %s@%s"", eq, str);\n', '\tfree (str);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=true ; 
char *Var5,*Var6; 
Var2=FUNC2(Var2); 
while (*Var2 == ){
Var2  Var7; 
if (!*Var2||*Var2 == ){
Var5=strdup(Var2); 
Var6=strchr(Var5,=); 
if (Var6){
if (!FUNC3(Var6,STRING,2)){
Var4=FUNC4(Var3,STRING,Var6,Var5); 
else 
Var4=FUNC4(Var3,STRING,Var6,Var5); 
free(Var5); 
",202,0
after_cmd.c,cmd_autocomplete,False,False,464,CWE-,CallExpression,memcpy,1950,-3,"['static void cmd_autocomplete(RCore *core, const char *input) {\n', '\tRCoreAutocomplete* b = core->autocomplete;\n', '\tinput = r_str_trim_ro (input);\n', '\tchar arg[256];\n', '\tif (!*input) {\n', ""\tif (*input == '?') {\n"", ""\tif (*input == '-') {\n"", '\t\tconst char *arg = input + 1;\n', '\t\tif (!*input) {\n', '\t\tr_core_autocomplete_remove (b, arg);\n', '\twhile (b) {\n', '\t\tconst char* end = r_str_trim_wp (input);\n', '\t\tif (!end) {\n', '\t\tif ((end - input) >= sizeof (arg)) {\n', '\t\tif (end == input) {\n', '\t\tmemcpy (arg, input, end - input);\n', '\t\targ[end - input] = 0;\n', '\t\tRCoreAutocomplete* a = r_core_autocomplete_find (b, arg, true);\n', '\t\tinput = r_str_trim_ro (end);\n', '\t\tif (input && *input && !a) {\n', '\t\t\tif (b->type == R_CORE_AUTOCMPLT_DFLT && !(b = r_core_autocomplete_add (b, arg, R_CORE_AUTOCMPLT_DFLT, false))) {\n', 'else\n', '\t\t\t} else if (b->type != R_CORE_AUTOCMPLT_DFLT) {\n', 'else\n', '\t\t} else if ((!input || !*input) && !a) {\n', ""\t\t\tif (arg[0] == '$') {\n"", '\t\t\t\tint type = autocomplete_type (arg);\n', 'else\n', '\t\t} else if ((!input || !*input) && a) {\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2){
STRUCT2 *Var3=Var1->memberVar1; 
Var2=FUNC2(Var2); 
char  Var4[256]; 
if (!*Var2){
if (*Var2 == ){
if (*Var2 == -){
const char *Var4=Var2+1; 
if (!*Var2){
FUNC3(Var3,Var4); 
while (Var3){
const char *Var5=FUNC4(Var2); 
if (!Var5){
if ((Var5-Var2) >= sizeof (Var4)){
if (Var5 ==  Var2){
memcpy(Var4,Var2,Var5-Var2); 
Var4[Var5-Var2]=0; 
STRUCT2 *Var6=FUNC5(Var3,Var4,true ); 
Var2=FUNC2(Var5); 
if (Var2&&*Var2&&!Var6){
if (Var3->memberVar1 ==  Var7&&!(Var3=FUNC6(Var3,Var4,Var7,false ))){
else 
}else if (Var3->memberVar1 !=  Var7){
else 
}else if ((!Var2||!*Var2)&&!Var6){
if (Var4[0]== ){
int  memberVar1=FUNC7(Var4); 
else 
}else if ((!Var2||!*Var2)&&Var6){
",413,0
after_cmd.c,cmd_system,False,False,465,CWE-,CallExpression,free,2032,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\t(void)r_core_cmdf (core, ""\\""#!pipe %s\\"""", cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
switch (*Var2){
if (Var2[1]== !){//!!!&!!!-
else 
}else if (Var2[1]== ){
else 
}else if (Var2[1]== *){
char *Var4=FUNC2(Var2+1); 
(void ) FUNC3(Var3,STRING!Var5%STRUCT2 STRING,Var4); 
free(Var4); 
char *Var4=FUNC4(Var3,Var2); 
char *Var4=FUNC2(Var2+1); 
const char *Var4=FUNC5(Var6); 
else 
char *Var4=FUNC4(Var3,Var2); 
",227,0
after_cmd.c,cmd_system,False,False,466,CWE-,CallExpression,free,2048,-3,"['\tswitch (*input) {\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', 'else\n', '\t\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tif (input[1]) {\n', '\t\t\t\tint olen;\n', '\t\t\t\tchar *out = NULL;\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\t\tif (cmd) {\n', '\t\t\t\t\tr_cons_memcat (out, olen);\n', '\t\t\t\t\tfree (out);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","switch (*Var1){
if (Var1[1]== !){//!!!&!!!-
else 
}else if (Var1[1]== ){
else 
}else if (Var1[1]== *){
char *Var2=FUNC1(Var1+1); 
else 
if (FUNC2(0)){
if (Var1[1]){
int  Var3; 
char *Var4=NULL ; 
char *Var2=FUNC3(Var5,Var1); 
if (Var2){
FUNC4(Var4,Var3); 
free(Var4); 
char *Var2=FUNC1(Var1+1); 
const char *Var2=FUNC5(Var6); 
else 
char *Var2=FUNC3(Var5,Var1); 
",219,0
after_cmd.c,cmd_system,False,False,467,CWE-,CallExpression,free,2049,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tint ret = 0;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', 'else\n', '\t\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tif (input[1]) {\n', '\t\t\t\tchar *out = NULL;\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\t\tif (cmd) {\n', '\t\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n', '\t\t\t\t\tfree (cmd);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=0; 
switch (*Var2){
if (Var2[1]== !){//!!!&!!!-
else 
}else if (Var2[1]== ){
else 
}else if (Var2[1]== *){
char *Var5=FUNC2(Var2+1); 
else 
if (FUNC3(0)){
if (Var2[1]){
char *Var6=NULL ; 
char *Var5=FUNC4(Var3,Var2); 
if (Var5){
Var4=FUNC5(Var5+1,NULL ,&Var6,&Var7,NULL ); 
free(Var5); 
char *Var5=FUNC2(Var2+1); 
const char *Var5=FUNC6(Var8); 
else 
char *Var5=FUNC4(Var3,Var2); 
",278,0
after_cmd.c,cmd_system,False,False,468,CWE-,CallExpression,free,2071,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tint ret = 0;\n', '\tswitch (*input) {\n', '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\tcmd = r_str_replace (cmd, "" "", ""\\\\ "", true);\n', '\t\tcmd = r_str_replace (cmd, ""\\\\ "", "" "", false);\n', '\t\tcmd = r_str_replace (cmd, ""\\"""", ""\'"", false);\n', '\t\tret = r_core_cmdf (core, ""\\""#!pipe %s\\"""", cmd);\n', '\t\tfree (cmd);\n', '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
int  Var4=0; 
switch (*Var2){
char *Var5=FUNC2(Var2+1); 
char *Var5=FUNC3(Var3,Var2); 
char *Var5=FUNC2(Var2+1); 
Var5=FUNC4(Var5,STRING,STRING,true ); 
Var5=FUNC4(Var5,STRING,STRING,false ); 
Var5=FUNC4(Var5,STRINGSTRING,false ); 
Var4=FUNC5(Var3,STRING!Var6%STRUCT2 STRING,Var5); 
free(Var5); 
const char *Var5=FUNC6(Var7); 
else 
char *Var5=FUNC3(Var3,Var2); 
",225,0
after_cmd.c,cmd_system,False,False,469,CWE-,CallExpression,atoi,2075,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tut64 n;\n', '\tswitch (*input) {\n', ""\t\tif (input[1] == '?') {\n"", 'else\n', '\t\t\tif (!r_sandbox_enable (0)) {\n', '\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n', ""\t\tif (input[1] == '!') { // !!! & !!!-\n"", 'else\n', ""\t\t} else if (input[1] == '?') {\n"", 'else\n', ""\t\t} else if (input[1] == '*') {\n"", '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', 'else\n', '\t\t\tif (r_sandbox_enable (0)) {\n', '\t\t\tif (input[1]) {\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\t\tif (cmd) {\n', '\t\t\t\t\tr_core_sysenv_end (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\tn = atoi (input);\n', ""\t\tif (*input == '0' || n > 0) {\n"", '\t\t\tconst char *cmd = r_line_hist_get (n);\n', '\t\t\tif (cmd) {\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\tif (cmd) {\n', '\t\t\t\tr_core_sysenv_end (core, input);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2  Var4; 
switch (*Var2){
if (Var2[1]== ){
else 
if (!FUNC2(0)){
Var3->memberVar1=Var2[1]10; 
if (Var2[1]== !){//!!!&!!!-
else 
}else if (Var2[1]== ){
else 
}else if (Var2[1]== *){
char *Var5=FUNC3(Var2+1); 
else 
if (FUNC2(0)){
if (Var2[1]){
char *Var5=FUNC4(Var3,Var2); 
if (Var5){
FUNC5(Var3,Var2); 
char *Var5=FUNC3(Var2+1); 
Var4=FUNC6(Var2); 
if (*Var2 == 0||Var4>0){
const char *Var5=FUNC7(Var4); 
if (Var5){
FUNC8(Var3,Var5); 
else 
char *Var5=FUNC4(Var3,Var2); 
if (Var5){
FUNC5(Var3,Var2); 
",352,0
after_cmd.c,cmd_system,False,False,470,CWE-,CallExpression,free,2089,-3,"['static int cmd_system(void *data, const char *input) {\n', '\tRCore *core = (RCore*)data;\n', '\tut64 n;\n', '\tint ret = 0;\n', '\tswitch (*input) {\n', '\t\t\tchar *cmd = r_str_trim_dup (input + 1);\n', '\t\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\tchar *cmd = r_str_trim_dup (input + 1);\n', ""\t\tif (*input == '0' || n > 0) {\n"", '\t\t\tconst char *cmd = r_line_hist_get (n);\n', 'else\n', '\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n', '\t\t\tif (cmd) {\n', '\t\t\t\tret = r_sys_cmd (cmd);\n', '\t\t\t\tfree (cmd);\n']","static int FUNC1(void *Var1,const char *Var2){
STRUCT1 *Var3=(STRUCT1 *) Var1; 
STRUCT2  Var4; 
int  Var5=0; 
switch (*Var2){
char *Var6=FUNC2(Var2+1); 
char *Var6=FUNC3(Var3,Var2); 
char *Var6=FUNC2(Var2+1); 
if (*Var2 == 0||Var4>0){
const char *Var6=FUNC4(Var4); 
else 
char *Var6=FUNC3(Var3,Var2); 
if (Var6){
Var5=FUNC5(Var6); 
free(Var6); 
",192,0
after_cmd.c,r_w32_cmd_pipe,False,False,471,CWE-,CallExpression,free,2138,-3,"['static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n', '\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\t_shell_cmd = tmp;\n', '\tfree (tmp);\n']","static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){
STRUCT2  Var4[2]={NULL ,NULL }; 
char *Var5=NULL ; 
if (!FUNC2(&Var4[0],&Var4[1],&Var6,0)){
if (!FUNC3(Var4[1],Var7,0)){
char *Var8=FUNC4(STRING%STRUCT3 STRING,Var3); 
if (!Var8){
Var5=Var8; 
free(Var8); 
",150,1
after_cmd.c,r_w32_cmd_pipe,False,False,472,CWE-,CallExpression,calloc,2142,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\t_tcscat_s (systemdir, MAX_PATH, TEXT(""\\\\cmd.exe""));\n', '\tfree (systemdir);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
char *Var2=NULL ; 
STRUCT2  Var3=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){
if (!FUNC2(Var1[1],Var5,0)){
char *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); 
if (!Var6){
if (!Var3){
STRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); 
if (!Var8){
int  Var10=FUNC4(Var8,Var9); 
if (!Var10){
FUNC5(Var8,Var9,FUNC6(STRING)); 
free(Var8); 
",206,0
after_cmd.c,r_w32_cmd_pipe,False,False,473,CWE-,CallExpression,close,2167,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tif (fd_out == -1) {\n', '\tclose (1);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
if (Var2 == -1){
close(1); 
",257,0
after_cmd.c,r_w32_cmd_pipe,False,False,474,CWE-,CallExpression,close,2168,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n', '\tif (fd_out == -1) {\n', '\tdup2 (fd_out, 1);\n', '\tclose (fd_out);\n', '\tif (fd_out != -1) {\n', '\t\tclose (fd_out);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
Var2=FUNC6((Var16) Var1[1],Var17|Var18); 
if (Var2 == -1){
FUNC7(Var2,1); 
close(Var2); 
if (Var2 != -1){
close(Var2); 
",313,0
after_cmd.c,r_w32_cmd_pipe,False,False,475,CWE-,CallExpression,close,2185,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tfd_out = _open_osfhandle ((intptr_t)pipe[1], _O_WRONLY|_O_TEXT);\n', '\tif (fd_out == -1) {\n', '\tdup2 (fd_out, 1);\n', '\tclose (fd_out);\n', '\tfd_out = -1;\n', '\tif (fd_out != -1) {\n', '\t\tclose (fd_out);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
Var2=FUNC6((Var16) Var1[1],Var17|Var18); 
if (Var2 == -1){
FUNC7(Var2,1); 
close(Var2); 
Var2=-1; 
if (Var2 != -1){
close(Var2); 
",320,0
after_cmd.c,r_w32_cmd_pipe,False,False,476,CWE-,CallExpression,close,2189,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tint fd_out = -1, cons_out = -1;\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tif (!CreateProcess (systemdir, _shell_cmd_, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n', '\tif (fd_out == -1) {\n', '\tcons_out = dup (1);\n', '\tif (cons_out != -1) {\n', '\t\tdup2 (cons_out, 1);\n', '\t\tclose (cons_out);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
int  Var2=-1,Var3=-1; 
char *Var4=NULL ; 
STRUCT2  Var5=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var6,0)){
if (!FUNC2(Var1[1],Var7,0)){
char *Var8=FUNC3(STRING%STRUCT3 STRING,Var9); 
if (!Var8){
if (!Var5){
STRUCT4 *Var10=calloc(Var11,sizeof (STRUCT4)); 
if (!Var10){
int  Var12=FUNC4(Var10,Var11); 
if (!Var12){
if (!FUNC5(Var10,Var5,NULL ,NULL ,Var13,0,NULL ,NULL ,&Var14,&Var15)){
if (Var2 == -1){
Var3=FUNC6(1); 
if (Var3 != -1){
FUNC7(Var3,1); 
close(Var3); 
",291,0
after_cmd.c,r_w32_cmd_pipe,False,False,477,CWE-,CallExpression,free,2191,-3,"['\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\t_tcscat_s (systemdir, MAX_PATH, TEXT(""\\\\cmd.exe""));\n', '\tfree (systemdir);\n']","STRUCT1  Var1[2]={NULL ,NULL }; 
char *Var2=NULL ; 
STRUCT2  Var3=NULL ; 
if (!FUNC1(&Var1[0],&Var1[1],&Var4,0)){
if (!FUNC2(Var1[1],Var5,0)){
char *Var6=FUNC3(STRING%STRUCT3 STRING,Var7); 
if (!Var6){
if (!Var3){
STRUCT4 *Var8=calloc(Var9,sizeof (STRUCT4)); 
if (!Var8){
int  Var10=FUNC4(Var8,Var9); 
if (!Var10){
FUNC5(Var8,Var9,FUNC6(STRING)); 
free(Var8); 
",206,0
after_cmd.c,r_w32_cmd_pipe,False,False,478,CWE-,CallExpression,free,2192,-3,"['static void r_w32_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n', '\tHANDLE pipe[2] = {NULL, NULL};\n', '\tchar *_shell_cmd = NULL;\n', '\tLPTSTR _shell_cmd_ = NULL;\n', '\tif (!CreatePipe (&pipe[0], &pipe[1], &sa, 0)) {\n', '\tif (!SetHandleInformation (pipe[1], HANDLE_FLAG_INHERIT, 0)) {\n', '\tchar *tmp = r_str_newf (""/Q /c \\""%s\\"""", shell_cmd);\n', '\tif (!tmp) {\n', '\t_shell_cmd = tmp;\n', '\t_shell_cmd_ = r_sys_conv_utf8_to_win (_shell_cmd);\n', '\tif (!_shell_cmd_) {\n', '\tTCHAR *systemdir = calloc (MAX_PATH, sizeof (TCHAR));\n', '\tif (!systemdir) {\n', '\tint ret = GetSystemDirectory (systemdir, MAX_PATH);\n', '\tif (!ret) {\n', '\tfree (_shell_cmd_);\n']","static void FUNC1(STRUCT1 *Var1,char *Var2,char *Var3){
STRUCT2  Var4[2]={NULL ,NULL }; 
char *Var5=NULL ; 
STRUCT3  Var6=NULL ; 
if (!FUNC2(&Var4[0],&Var4[1],&Var7,0)){
if (!FUNC3(Var4[1],Var8,0)){
char *Var9=FUNC4(STRING%STRUCT4 STRING,Var3); 
if (!Var9){
Var5=Var9; 
Var6=FUNC5(Var5); 
if (!Var6){
STRUCT5 *Var10=calloc(Var11,sizeof (STRUCT5)); 
if (!Var10){
int  Var12=FUNC6(Var10,Var11); 
if (!Var12){
free(Var6); 
",235,1
after_cmd.c,r_core_cmd_pipe,False,False,479,CWE-,CallExpression,free,2222,-3,"['R_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n', '\tchar *str, *out = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', ""\tif (*shell_cmd=='!') {\n"", '\t\tstr = r_core_cmd_str (core, radare_cmd);\n', '\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n', '\t\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
if (FUNC2(0)){
if (*Var4 == !){
Var5=FUNC3(Var2,Var3); 
FUNC4(Var4+1,Var5,&Var6,&Var7,NULL ); 
free(Var5); 
",111,0
after_cmd.c,r_core_cmd_pipe,False,False,480,CWE-,CallExpression,free,2224,-3,"['\tint si, olen, ret = -1, pipecolor = -1;\n', '\tchar *str, *out = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', ""\tif (*shell_cmd=='!') {\n"", '\t\tout = NULL;\n', '\t\tr_cons_memcat (out, olen);\n', '\t\tfree (out);\n']","int  Var1,Var2,Var3=-1,Var4=-1; 
char *Var5,*Var6=NULL ; 
if (FUNC1(0)){
if (*STRUCT1 == !){
Var6=NULL ; 
FUNC2(Var6,Var2); 
free(Var6); 
",83,0
after_cmd.c,r_core_cmd_pipe,False,False,481,CWE-,CallExpression,signal,2231,-3,"['\tif (r_sandbox_enable (0)) {\n', '\tsignal (SIGPIPE, SIG_IGN);\n']","if (FUNC1(0)){
signal(Var1,Var2); 
",20,0
after_cmd.c,r_core_cmd_pipe,False,False,482,CWE-,CallExpression,close,2238,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tstdout_fd = dup (1);\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (stdout_fd, 1);\n', '\t\t\t\tclose (stdout_fd);\n', '\t\t\t\tclose (stdout_fd);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
Var1=FUNC2(1); 
if (Var1 != -1){
if (FUNC3(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC4(Var1,1); 
close(Var1); 
close(Var1); 
",116,0
after_cmd.c,r_core_cmd_pipe,False,False,483,CWE-,CallExpression,close,2241,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (fds[1], 1);\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tclose (fds[0]);\n', 'else\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tdup2 (fds[0], 0);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC3(Var2[1],1); 
close(Var2[1]); 
close(Var2[0]); 
else 
close(Var2[1]); 
FUNC3(Var2[0],0); 
",140,0
after_cmd.c,r_core_cmd_pipe,False,False,484,CWE-,CallExpression,close,2242,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (fds[1], 1);\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tclose (fds[0]);\n', 'else\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tdup2 (fds[0], 0);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC3(Var2[1],1); 
close(Var2[1]); 
close(Var2[0]); 
else 
close(Var2[1]); 
FUNC3(Var2[0],0); 
",140,0
after_cmd.c,r_core_cmd_pipe,False,False,485,CWE-,CallExpression,close,2245,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tclose (1);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
close(1); 
",88,0
after_cmd.c,r_core_cmd_pipe,False,False,486,CWE-,CallExpression,close,2248,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tstdout_fd = dup (1);\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (stdout_fd, 1);\n', '\t\t\t\tclose (stdout_fd);\n', '\t\t\t\tclose (stdout_fd);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
Var1=FUNC2(1); 
if (Var1 != -1){
if (FUNC3(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC4(Var1,1); 
close(Var1); 
close(Var1); 
",116,0
after_cmd.c,r_core_cmd_pipe,False,False,487,CWE-,CallExpression,close,2250,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (fds[1], 1);\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tclose (fds[0]);\n', 'else\n', '\t\t\t\tclose (fds[1]);\n', '\t\t\t\tdup2 (fds[0], 0);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
if (Var1 != -1){
if (FUNC2(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC3(Var2[1],1); 
close(Var2[1]); 
close(Var2[0]); 
else 
close(Var2[1]); 
FUNC3(Var2[0],0); 
",140,0
after_cmd.c,r_core_cmd_pipe,False,False,488,CWE-,CallExpression,close,2254,-3,"['\tint stdout_fd, fds[2];\n', '\tint child;\n', '\tif (r_sandbox_enable (0)) {\n', '\tstdout_fd = dup (1);\n', '\tif (stdout_fd != -1) {\n', '\t\tif (pipe (fds) == 0) {\n', '\t\t\tif (child == -1) {\n', 'else\n', '\t\t\t} else if (child) {\n', '\t\t\t\tdup2 (stdout_fd, 1);\n', '\t\t\t\tclose (stdout_fd);\n', '\t\t\t\tclose (stdout_fd);\n']","int  Var1,Var2[2]; 
int  Var3; 
if (FUNC1(0)){
Var1=FUNC2(1); 
if (Var1 != -1){
if (FUNC3(Var2) == 0){
if (Var3 == -1){
else 
}else if (Var3){
FUNC4(Var1,1); 
close(Var1); 
close(Var1); 
",116,0
after_cmd.c,parse_tmp_evals,False,False,489,CWE-,CallExpression,strdup,2278,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', ""\t\teq = strchr (kv, '=');\n"", '\t\tif (eq) {\n', '\t\t\t*eq = 0;\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tr_config_set (core->config, kv, eq + 1);\n', ""\t\t\t*eq = '=';\n"", 'else\n', '\t\t\teprintf (""Missing \'=\' in e: expression (%s)\\n"", kv);\n', '\tfree (s);\n', '\treturn res;\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
Var8=strchr(Var9,=); 
if (Var8){
*Var8=0; 
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var6); 
Var6=FUNC6(Var6,Var11); 
free(Var11); 
FUNC7(Var1->memberVar1,Var9,Var8+1); 
*Var8==; 
else 
FUNC8(STRING,Var9); 
free(Var3); 
return  Var6; 
",319,0
after_cmd.c,parse_tmp_evals,False,False,490,CWE-,CallExpression,strdup,2280,-3,"['\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (res);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\treturn res;\n']","char *Var1=strdup(Var2); 
int  Var3,Var4=FUNC1(Var1,,); 
char *Var5=strdup(STRING); 
if (!Var1||!Var5){
free(Var5); 
for (Var3=0; Var3<Var4; Var3  Var6){
char *Var7,*Var8=(char *) FUNC2(Var1,Var3); 
if (!Var8){
if (Var7){
const char *Var9=FUNC3(Var10->memberVar1,Var8); 
if (!Var9){
char *Var11=FUNC4(STRING,Var8,Var9); 
if (!Var11){
free(Var5); 
Var5=FUNC5(Var5,Var11); 
return  Var5; 
",217,0
after_cmd.c,parse_tmp_evals,False,False,491,CWE-,CallExpression,free,2282,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\tfree (s);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var3); 
",229,0
after_cmd.c,parse_tmp_evals,False,False,492,CWE-,CallExpression,free,2283,-3,"['\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (res);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\treturn res;\n']","char *Var1=strdup(Var2); 
int  Var3,Var4=FUNC1(Var1,,); 
char *Var5=strdup(STRING); 
if (!Var1||!Var5){
free(Var5); 
for (Var3=0; Var3<Var4; Var3  Var6){
char *Var7,*Var8=(char *) FUNC2(Var1,Var3); 
if (!Var8){
if (Var7){
const char *Var9=FUNC3(Var10->memberVar1,Var8); 
if (!Var9){
char *Var11=FUNC4(STRING,Var8,Var9); 
if (!Var11){
free(Var5); 
Var5=FUNC5(Var5,Var11); 
return  Var5; 
",217,0
after_cmd.c,parse_tmp_evals,False,False,493,CWE-,CallExpression,strchr,2291,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', ""\t\teq = strchr (kv, '=');\n"", '\t\tif (eq) {\n', '\t\t\t*eq = 0;\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\tr_config_set (core->config, kv, eq + 1);\n', ""\t\t\t*eq = '=';\n"", 'else\n', '\t\t\teprintf (""Missing \'=\' in e: expression (%s)\\n"", kv);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
Var8=strchr(Var9,=); 
if (Var8){
*Var8=0; 
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
FUNC6(Var1->memberVar1,Var9,Var8+1); 
*Var8==; 
else 
FUNC7(STRING,Var9); 
",264,0
after_cmd.c,parse_tmp_evals,False,False,494,CWE-,CallExpression,free,2300,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\tfree (s);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var3); 
",229,0
after_cmd.c,parse_tmp_evals,False,False,495,CWE-,CallExpression,free,2301,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (res);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (res);\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\treturn res;\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var6); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var6); 
Var6=FUNC6(Var6,Var11); 
return  Var6; 
",242,0
after_cmd.c,parse_tmp_evals,False,False,496,CWE-,CallExpression,free,2305,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\tres = r_str_prepend (res, cmd);\n', '\t\t\tfree (cmd);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
Var6=FUNC6(Var6,Var11); 
free(Var11); 
",229,0
after_cmd.c,parse_tmp_evals,False,False,497,CWE-,CallExpression,free,2312,-3,"['static char *parse_tmp_evals(RCore *core, const char *str) {\n', '\tchar *s = strdup (str);\n', ""\tint i, argc = r_str_split (s, ',');\n"", '\tchar *res = strdup ("""");\n', '\tif (!s || !res) {\n', '\t\tfree (s);\n', '\tfor (i = 0; i < argc; i++) {\n', '\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n', '\t\tif (!kv) {\n', '\t\tif (eq) {\n', '\t\t\tconst char *ov = r_config_get (core->config, kv);\n', '\t\t\tif (!ov) {\n', '\t\t\tchar *cmd = r_str_newf (""e %s=%s;"", kv, ov);\n', '\t\t\tif (!cmd) {\n', '\t\t\t\tfree (s);\n', '\tfree (s);\n']","static char *FUNC1(STRUCT1 *Var1,const char *Var2){
char *Var3=strdup(Var2); 
int  Var4,Var5=FUNC2(Var3,,); 
char *Var6=strdup(STRING); 
if (!Var3||!Var6){
free(Var3); 
for (Var4=0; Var4<Var5; Var4  Var7){
char *Var8,*Var9=(char *) FUNC3(Var3,Var4); 
if (!Var9){
if (Var8){
const char *Var10=FUNC4(Var1->memberVar1,Var9); 
if (!Var10){
char *Var11=FUNC5(STRING,Var9,Var10); 
if (!Var11){
free(Var3); 
free(Var3); 
",229,0
after_cmd.c,r_core_cmd_subst,False,False,498,CWE-,CallExpression,memmove,2324,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\t\tchar *cr = strdup (cmdrep);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
char *Var4,*Var5=NULL ,*Var6=NULL ; 
bool  Var7=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var8=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var9=Var1->memberVar2; 
Var6=strdup(Var2); 
const char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
char *Var12=strdup(Var10); 
",218,0
after_cmd.c,r_core_cmd_subst,False,False,499,CWE-,CallExpression,strlen,2324,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\t\tchar *cr = strdup (cmdrep);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
char *Var4,*Var5=NULL ,*Var6=NULL ; 
bool  Var7=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var8=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var9=Var1->memberVar2; 
Var6=strdup(Var2); 
const char *Var10=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var11=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
char *Var12=strdup(Var10); 
",218,0
after_cmd.c,r_core_cmd_subst,False,False,500,CWE-,CallExpression,strstr,2325,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\tif (http) {\n', '\t\t\t*http = 0;\n', '\t\t\thttp--;\n', ""\t\t\tif (*http == ' ') {\n"", '\t\t\t\t*http = 0;\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\t\tchar *cr = strdup (cmdrep);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
char *Var4,*Var5=NULL ,*Var6=NULL ; 
bool  Var7=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var8=strstr(Var2,STRING); 
if (Var8){
*Var8=0; 
Var8  Var9; 
if (*Var8 == ){
*Var8=0; 
return FUNC4(Var1,Var2); 
STRUCT2  Var10=Var1->memberVar2; 
Var6=strdup(Var2); 
const char *Var11=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var12=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
char *Var13=strdup(Var11); 
",259,0
after_cmd.c,r_core_cmd_subst,False,False,501,CWE-,CallExpression,strdup,2342,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tcmt = *icmd ? (char *)r_str_firstbut (icmd, \'#\', ""\\""""): NULL;\n', ""\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n"", '\t\t*cmt = 0;\n', '\tif (*cmd != \'""\') {\n', ""\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n"", ""\t\t\tif ((colon = strchr (cmd, ';'))) {\n"", '\t\t\t\t*colon = 0;\n', '\tif (rep > 0) {\n', '\t\twhile (IS_DIGIT (*cmd)) {\n', '\t\t\tcmd++;\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', '\t\teprintf (""Command repeat sugar disabled in sandbox mode (%s)\\n"", cmd);\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', '\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n', '\tif (colon && colon[1]) {\n', ""\t\tfor (++colon; *colon == ';'; colon++) {\n"", '\t\tr_core_cmd_subst (core, colon);\n', '\tfree (icmd);\n', '\treturn ret;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var10=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC5(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
Var6=*Var8(char *) FUNC6(Var8,,STRING) NULL ; 
if (Var6&&(Var6[1]== ||Var6[1]==  Var12)){
*Var6=0; 
if (*Var2 != ){
if (!strchr(Var2,)){//Var13|Var14{Var15; Var16}//Var17; if  Var18  Var19  Var20  STRUCT3  Var21
if ((Var7=strchr(Var2,; ))){
*Var7=0; 
if (Var3>0){
while (FUNC7(*Var2)){
Var2  Var22; 
if (!*Var2){
if (Var3>1&&FUNC8(0)){
FUNC9(STRING,Var2); 
else 
if (Var3>Var23){
if (FUNC10()){
const char *Var24=Var1->STRUCT4  Var1->STRUCT4 STRING; 
int  Var25=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var26&&*Var2){
if (FUNC11()){
char *Var27=strdup(Var24); 
Var4=FUNC12(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); 
if (Var4&&*Var2 ==  Var28){
if (Var1->memberVar4){
if (Var7&&Var7[1]){
for (Var22  Var7; *Var7 == ; ; Var7  Var22){
FUNC1(Var1,Var7); 
free(Var8); 
return  Var4; 
",687,0
after_cmd.c,r_core_cmd_subst,False,False,502,CWE-,CallExpression,strchr,2364,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (*cmd != \'""\') {\n', ""\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n"", '\tif (rep > 0) {\n', '\t\twhile (IS_DIGIT (*cmd)) {\n', '\t\t\tcmd++;\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', '\t\teprintf (""Command repeat sugar disabled in sandbox mode (%s)\\n"", cmd);\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', '\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var10=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC5(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (*Var2 != ){
if (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20
if (Var3>0){
while (FUNC6(*Var2)){
Var2  Var21; 
if (!*Var2){
if (Var3>1&&FUNC7(0)){
FUNC8(STRING,Var2); 
else 
if (Var3>Var22){
if (FUNC9()){
const char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; 
int  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var25&&*Var2){
if (FUNC10()){
char *Var26=strdup(Var23); 
Var4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); 
if (Var4&&*Var2 ==  Var27){
if (Var1->memberVar4){
",531,0
after_cmd.c,r_core_cmd_subst,False,False,503,CWE-,CallExpression,strchr,2365,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tmemmove (cmd, cmd + 9, strlen (cmd + 9) + 1);\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\t\treturn r_core_cmd0 (core, cmd);\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (*cmd != \'""\') {\n', ""\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n"", ""\t\t\tif ((colon = strchr (cmd, ';'))) {\n"", '\t\t\t\t*colon = 0;\n', '\tif (rep > 0) {\n', '\t\twhile (IS_DIGIT (*cmd)) {\n', '\t\t\tcmd++;\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', '\t\teprintf (""Command repeat sugar disabled in sandbox mode (%s)\\n"", cmd);\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', '\t\tret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n', '\tif (colon && colon[1]) {\n', ""\t\tfor (++colon; *colon == ';'; colon++) {\n"", '\t\tr_core_cmd_subst (core, colon);\n', '\treturn ret;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
memmove(Var2,Var2+9,strlen(Var2+9)+1); 
char *Var10=strstr(Var2,STRING); 
return FUNC4(Var1,Var2); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC5(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (*Var2 != ){
if (!strchr(Var2,)){//Var12|Var13{Var14; Var15}//Var16; if  Var17  Var18  Var19  STRUCT3  Var20
if ((Var7=strchr(Var2,; ))){
*Var7=0; 
if (Var3>0){
while (FUNC6(*Var2)){
Var2  Var21; 
if (!*Var2){
if (Var3>1&&FUNC7(0)){
FUNC8(STRING,Var2); 
else 
if (Var3>Var22){
if (FUNC9()){
const char *Var23=Var1->STRUCT4  Var1->STRUCT4 STRING; 
int  Var24=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var25&&*Var2){
if (FUNC10()){
char *Var26=strdup(Var23); 
Var4=FUNC11(Var1,Var2,Var7,(Var3 ==  Var5-1)&memberVar1 NULL ); 
if (Var4&&*Var2 ==  Var27){
if (Var1->memberVar4){
if (Var7&&Var7[1]){
for (Var21  Var7; *Var7 == ; ; Var7  Var21){
FUNC1(Var1,Var7); 
return  Var4; 
",617,0
after_cmd.c,r_core_cmd_subst,False,False,504,CWE-,CallExpression,strdup,2416,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
after_cmd.c,r_core_cmd_subst,False,False,505,CWE-,CallExpression,free,2420,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
after_cmd.c,r_core_cmd_subst,False,False,506,CWE-,CallExpression,free,2424,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
after_cmd.c,r_core_cmd_subst,False,False,507,CWE-,CallExpression,free,2434,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\tif (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {\n', '\t\tcore->prompt_offset = core->offset;\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\t\tfree (cr);\n', '\t\tif (core->break_loop) {\n', '\t\t\tfree (cr);\n', '\t\tif (cr && *cr && orep > 1) {\n', '\t\t\t(void)r_core_cmd0 (core, cr);\n', '\t\tfree (cr);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
if (Var1->memberVar3-Var1->memberVar4->memberVar1->memberVar1 == 1){
Var1->memberVar5=Var1->memberVar2; 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC4(0)){
else 
if (Var3>Var12){
if (FUNC5()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar6&&Var1->memberVar6->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC6()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
free(Var16); 
if (Var1->memberVar7){
free(Var16); 
if (Var16&&*Var16&&Var5>1){
(void ) FUNC7(Var1,Var16); 
free(Var16); 
",443,0
after_cmd.c,r_core_cmd_subst,False,False,508,CWE-,CallExpression,free,2457,-3,"['static int r_core_cmd_subst(RCore *core, char *cmd) {\n', '\tut64 rep = strtoull (cmd, NULL, 10);\n', '\tint ret = 0, orep;\n', '\tchar *cmt, *colon = NULL, *icmd = NULL;\n', '\tbool original_tmpseek = core->tmpseek;\n', '\tif (r_str_startswith (cmd, ""GET /cmd/"")) {\n', '\t\tchar *http = strstr (cmd, ""HTTP"");\n', '\tut64 orig_offset = core->offset;\n', '\ticmd = strdup (cmd);\n', '\tcmd = r_str_trim_head_tail (icmd);\n', '\tif (!*cmd) {\n', ""\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n"", '\tcmt = *icmd ? (char *)r_str_firstbut (icmd, \'#\', ""\\""""): NULL;\n', '\tif (rep > 0) {\n', '\t\tif (!*cmd) {\n', '\tif (rep > 1 && r_sandbox_enable (0)) {\n', 'else\n', '\t\tif (rep > INTERACTIVE_MAX_REP) {\n', '\t\t\tif (r_cons_is_interactive ()) {\n', '\tconst char *cmdrep = core->cmdtimes ? core->cmdtimes: """";\n', '\tint ocur_enabled = core->print && core->print->cur_enabled;\n', '\twhile (rep-- && *cmd) {\n', '\t\tif (r_cons_is_breaked ()) {\n', '\t\tchar *cr = strdup (cmdrep);\n', ""\t\tif (ret && *cmd == 'q') {\n"", '\t\tif (core->break_loop) {\n', '\tif (colon && colon[1]) {\n', '\tfree (icmd);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2){
STRUCT2  Var3=FUNC2(Var2,NULL ,10); 
int  Var4=0,Var5; 
char *Var6,*Var7=NULL ,*Var8=NULL ; 
bool  Var9=Var1->memberVar1; 
if (FUNC3(Var2,STRING)){
char *Var10=strstr(Var2,STRING); 
STRUCT2  Var11=Var1->memberVar2; 
Var8=strdup(Var2); 
Var2=FUNC4(Var8); 
if (!*Var2){
if (!Var8||(Var2[0]== &&Var2[1]!= !&&Var2[1]!= )){
Var6=*Var8(char *) FUNC5(Var8,,STRING) NULL ; 
if (Var3>0){
if (!*Var2){
if (Var3>1&&FUNC6(0)){
else 
if (Var3>Var12){
if (FUNC7()){
const char *Var13=Var1->STRUCT3  Var1->STRUCT3 STRING; 
int  Var14=Var1->memberVar3&&Var1->memberVar3->memberVar1; 
while (Var3  Var15&&*Var2){
if (FUNC8()){
char *Var16=strdup(Var13); 
if (Var4&&*Var2 ==  Var17){
if (Var1->memberVar4){
if (Var7&&Var7[1]){
free(Var8); 
",417,0
after_cmd.c,findSeparator,False,False,509,CWE-,CallExpression,strchr,2474,-3,"['static char* findSeparator(char *p) {\n', ""\tchar *q = strchr (p, '+');\n"", '\tif (q) {\n', '\t\treturn q;\n', ""\treturn strchr (p, '-');\n""]","static char *FUNC1(char *Var1){
char *Var2=strchr(Var1,+); 
if (Var2){
return  Var2; 
return strchr(Var1,-); 
",55,0
after_cmd.c,findSeparator,False,False,510,CWE-,CallExpression,strchr,2478,-3,"['static char* findSeparator(char *p) {\n', ""\tchar *q = strchr (p, '+');\n"", '\tif (q) {\n', ""\treturn strchr (p, '-');\n""]","static char *FUNC1(char *Var1){
char *Var2=strchr(Var1,+); 
if (Var2){
return strchr(Var1,-); 
",49,0
after_cmd.c,tmpenvs_free,False,False,511,CWE-,CallExpression,free,2483,-3,"['static void tmpenvs_free(void *item) {\n', '\tr_sys_setenv (item, NULL);\n', '\tfree (item);\n']","static void FUNC1(void *Var1){
FUNC2(Var1,NULL ); 
free(Var1); 
",32,1
after_cmd.c,set_tmp_arch,False,False,512,CWE-,CallExpression,strdup,2490,-3,"['static bool set_tmp_arch(RCore *core, char *arch, char **tmparch) {\n', '\t*tmparch = strdup (r_config_get (core->config, ""asm.arch""));\n', '\tr_config_set (core->config, ""asm.arch"", arch);\n', '\tcore->fixedarch = true;\n']","static bool FUNC1(STRUCT1 *Var1,char *Var2,char **Var3){
*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); 
FUNC3(Var1->memberVar1,STRING,Var2); 
Var1->memberVar2=true ; 
",74,1
after_cmd.c,set_tmp_bits,False,False,513,CWE-,CallExpression,strdup,2500,-3,"['static bool set_tmp_bits(RCore *core, int bits, char **tmpbits) {\n', '\t*tmpbits = strdup (r_config_get (core->config, ""asm.bits""));\n', '\tr_config_set_i (core->config, ""asm.bits"", bits);\n', '\tcore->fixedbits = true;\n']","static bool FUNC1(STRUCT1 *Var1,int  Var2,char **Var3){
*Var3=strdup(FUNC2(Var1->memberVar1,STRING)); 
FUNC3(Var1->memberVar1,STRING,Var2); 
Var1->memberVar2=true ; 
",73,1
after_cmd.c,r_core_cmd_subst_i,False,False,514,CWE-,CallExpression,strstr,2533,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3074,0
after_cmd.c,r_core_cmd_subst_i,False,False,515,CWE-,CallExpression,strchr,2535,-3,"['\tif (!cmd) {\n', '\tif ($0) {\n', ""\t\tchar *$1 = strchr ($0 + 2, ')');\n"", 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", ""\t\t\t\tchar *p = strchr (range, ' ');\n""]","if (!Var1){
if (0){
char *1=strchr(0+2,)); 
else 
char *Var2=strchr(Var1,; ); 
char *Var3=strchr(Var4+1,); 
char *Var5=strchr(Var1,); 
char *Var6=FUNC1(Var7,Var1); 
const char *Var8=strstr(Var1,STRING); 
char *Var9,*Var5=strchr(Var10+1,!); 
char *Var11=strchr(Var12,=); 
char *Var1=FUNC2(Var7,Var10+2); 
char *Var3=strchr(Var10+2,); 
char *Var4=strchr(Var13,); 
",197,0
after_cmd.c,r_core_cmd_subst_i,False,False,516,CWE-,CallExpression,memmove,2539,-3,"['\tif (!cmd) {\n', '\tif ($0) {\n', '\t\tif ($1) {\n', '\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n']","if (!Var1){
if (0){
if (1){
memmove(0+1,0+2,strlen(0+2)+1); 
else 
char *Var2=strchr(Var1,; ); 
char *Var3=strchr(Var1,); 
char *Var4=FUNC1(Var5,Var1); 
const char *Var6=strstr(Var1,STRING); 
char *Var1=FUNC2(Var5,Var7+2); 
",128,0
after_cmd.c,r_core_cmd_subst_i,False,False,517,CWE-,CallExpression,strlen,2539,-3,"['\tif (!cmd) {\n', '\tif ($0) {\n', '\t\tif ($1) {\n', '\t\t\tmemmove ($0 + 1, $0 + 2, strlen ($0 + 2) + 1);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n']","if (!Var1){
if (0){
if (1){
memmove(0+1,0+2,strlen(0+2)+1); 
else 
char *Var2=strchr(Var1,; ); 
char *Var3=strchr(Var1,); 
char *Var4=FUNC1(Var5,Var1); 
const char *Var6=strstr(Var1,STRING); 
char *Var1=FUNC2(Var5,Var7+2); 
",128,0
after_cmd.c,r_core_cmd_subst_i,False,False,518,CWE-,CallExpression,strchr,2572,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (sc) {\n', '\t\t\t\t\t*sc = 0;\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tchar op0 = 0;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\top0 = *q;\n', '\t\t\t\t\t\t*q = 0;\n', '\t\t\t\t\thaveQuote = q != NULL;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\tif (p && *p && p[1] == '>') {\n"", '\t\t\t\t\tstr = p + 2;\n', ""\t\t\t\t\twhile (*str == '>') {\n"", '\t\t\t\t\t\tstr++;\n', '\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n', '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tstr = p + 2;\n', '\t\t\t\twhile (IS_WHITESPACE (*str)) {\n', '\t\t\t\t\tstr++;\n', '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\t\t\t*p = op0;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
*Var25  Var26=0; 
else 
char *Var28=strchr(Var2,; ); 
if (Var28){
*Var28=0; 
FUNC7(Var1,Var2); 
if (!Var28){
Var2=Var28+1; 
char  Var29=0; 
if (*Var25){
if (Var25[0]== ){
Var25  Var30; 
while (Var25[1]== ; ||FUNC8(Var25[1])){
Var25  Var26; 
if (Var25[1]== ||(Var25[1]&&Var25[2]== )){
char *Var31=strchr(Var25+1,); 
if (Var31){
Var29=*Var31; 
*Var31=0; 
Var19=Var31 != NULL ; 
FUNC9(Var1,FUNC10(Var1->memberVar6,Var25+2),1); 
if (Var31){
*Var25=; 
Var25=Var31; 
else 
Var25=strchr(Var25+1,; ); 
if (Var25&&*Var25&&Var25[1]== >){
Var9=Var25+2; 
while (*Var9 == >){
Var9  Var26; 
Var9=(char *) FUNC11(Var9); 
const bool  Var32=Var25[2]== >; 
Var16=FUNC12(Var9,1,Var32); 
Var24=strdup(Var2); 
Var24=FUNC13(Var24,STRINGSTRINGSTRING,true ); 
if (Var25&&*Var25&&Var25[1]== |){
Var9=Var25+2; 
while (FUNC8(*Var9)){
Var9  Var26; 
FUNC14(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var24); 
free(Var24); 
if (Var16 != -1){
FUNC15(Var16); 
if (!Var25){
if (Var18){
if (Var19){
if (*Var25 == ; ){
Var2=Var25+1; 
else 
if (*Var25 == ){
Var2=Var25; 
else 
*Var25=Var29; 
Var2=Var25; 
else 
Var2=Var25+1; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC16(Var2,,STRING); //Var33  Var34  Var5  Var35
if (*Var2 != ){
Var7=(char *) FUNC17(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC17(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var36=Var7-1; 
if (*Var36 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC18(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC19(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC20(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var37=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC14(Var1,Var2,Var7+1); 
else 
char *Var38=FUNC21(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC17(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC22(Var1,Var39,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC23()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC16(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var36=Var7-1; 
if (*Var36 == ){
if (Var7[0]&&Var7[1]== ){
int  Var40=1; 
int  Var41=FUNC24(Var1->memberVar8,STRING); 
int  Var42=false ; 
int  Var43=FUNC24(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC25(Var7[-2])){
char *Var44=Var7-1; 
const bool  Var45=(Var7[1]== >); 
if (*Var9 == ){
char *Var46=FUNC26(Var1,Var2); 
char *Var47=FUNC27(Var1->memberVar5,Var9,1); 
char *Var48=FUNC28(STRING,Var47,Var46); 
else 
char *Var49=FUNC28(STRING,Var46); 
else 
char *Var49=FUNC28(STRING,Var46); 
else 
}else if (Var40>0){
if (Var16 != -1){
Var15=FUNC29(Var1,Var2); 
const char *Var50=FUNC30(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var36=Var7-1; 
if (*Var36 == ){
bool  Var51=false ; 
if (Var51){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var43=FUNC24(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC31(strdup(Var2),Var9); 
Var15=FUNC29(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var52=false ; 
if (Var52){
if (*Var2 != .){
Var11=FUNC32(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var53=0; 
if (Var7){
char *Var54,*Var8=strchr(Var7+1,!); 
STRUCT3  Var55=Var1->memberVar9; 
bool  Var56=false ; 
char *Var57=NULL ; 
const char *Var58=NULL ; 
bool  Var59=false ; 
bool  Var60=false ; 
char *Var61=NULL ; 
char *Var62=NULL ; 
bool  Var63=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var64=strdup(Var7+2); 
char *Var65=strchr(Var64,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var55=FUNC33(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var66=(int ) FUNC10(Var1->memberVar6,Var7+2); 
STRUCT5 *Var67=FUNC34(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var68=FUNC35(Var1->memberVar1,Var69,Var70,0); 
char *Var71=strdup(Var7+2); 
char  Var36=*Var72; 
STRUCT3  Var55=FUNC10(Var1->memberVar6,Var7+2); 
char *Var2=FUNC36(Var1,Var7+2); 
STRUCT2 *Var68=FUNC35(Var1->memberVar1,Var69,Var70,0); 
char *Var73=FUNC37(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var31=strchr(Var7+2,); 
int  Var74=FUNC10(Var1->memberVar6,Var31); 
const STRUCT6 *Var75=(const STRUCT6 *) FUNC11(Var7+2); 
STRUCT2 *Var68=FUNC35(Var1->memberVar1,Var69,Var70,0); 
char *Var76=Var7-2; 
while (Var76>Var2){
if (!FUNC8(*Var76)){
Var2=FUNC18(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC38((STRUCT6) Var7[1])&&!Var55){
if (!FUNC39(Var1->memberVar12,Var7+1)){
else 
char  Var36=*Var58; 
STRUCT2 *Var68=Var12; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var77=Var7+3; 
Var15=FUNC40(Var1,Var2,Var77); 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var78[]={STRING,STRING,STRING,
const char *Var79[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var80=Var7+3; 
char *Var25=strchr(Var80,); 
if (!Var25){
STRUCT3  Var81=FUNC10(Var1->memberVar6,Var80); 
STRUCT3  Var82=FUNC10(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC42(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC42(Var2)); 
Var53=Var2 FUNC3(Var1->memberVar5,FUNC42(Var2)) false ; 
",3574,0
after_cmd.c,r_core_cmd_subst_i,False,False,519,CWE-,CallExpression,strchr,2593,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (sc) {\n', '\t\t\t\t\t*sc = 0;\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tchar op0 = 0;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\top0 = *q;\n', '\t\t\t\t\t\t*q = 0;\n', '\t\t\t\t\thaveQuote = q != NULL;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\tif (p && *p && p[1] == '>') {\n"", '\t\t\t\t\tstr = p + 2;\n', ""\t\t\t\t\twhile (*str == '>') {\n"", '\t\t\t\t\t\tstr++;\n', '\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n', '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tstr = p + 2;\n', '\t\t\t\twhile (IS_WHITESPACE (*str)) {\n', '\t\t\t\t\tstr++;\n', '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\t\t\t*p = op0;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
bool  Var17=false ; 
bool  Var18=Var1->memberVar2; 
bool  Var19=Var1->memberVar3; 
STRUCT3  Var20=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
for (; *Var2; ){
int  Var15=-1; 
char *Var21,*Var22; 
Var17=*Var2 == ; 
if (Var17){
Var2  Var23; 
Var22=*Var2 FUNC3(Var2) NULL ; 
if (!Var22||!*Var22){
FUNC4(STRINGFUNC5(%Var24).,Var2); 
*Var22  Var23=0; 
else 
char *Var25=strchr(Var2,; ); 
if (Var25){
*Var25=0; 
FUNC6(Var1,Var2); 
if (!Var25){
Var2=Var25+1; 
char  Var26=0; 
if (*Var22){
if (Var22[0]== ){
Var22  Var27; 
while (Var22[1]== ; ||FUNC7(Var22[1])){
Var22  Var23; 
if (Var22[1]== ||(Var22[1]&&Var22[2]== )){
char *Var28=strchr(Var22+1,); 
if (Var28){
Var26=*Var28; 
*Var28=0; 
Var17=Var28 != NULL ; 
FUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); 
if (Var28){
*Var22=; 
Var22=Var28; 
else 
Var22=strchr(Var22+1,; ); 
if (Var22&&*Var22&&Var22[1]== >){
Var8=Var22+2; 
while (*Var8 == >){
Var8  Var23; 
Var8=(char *) FUNC10(Var8); 
const bool  Var29=Var22[2]== >; 
Var15=FUNC11(Var8,1,Var29); 
Var21=strdup(Var2); 
Var21=FUNC12(Var21,STRINGSTRINGSTRING,true ); 
if (Var22&&*Var22&&Var22[1]== |){
Var8=Var22+2; 
while (FUNC7(*Var8)){
Var8  Var23; 
FUNC13(Var1,Var2,Var8); 
else 
FUNC14(Var1->memberVar6,Var21); 
free(Var21); 
if (Var15 != -1){
FUNC15(Var15); 
if (!Var22){
if (Var16){
if (Var17){
if (*Var22 == ; ){
Var2=Var22+1; 
else 
if (*Var22 == ){
Var2=Var22; 
else 
*Var22=Var26; 
Var2=Var22; 
else 
Var2=Var22+1; 
char *Var7=strchr(Var2,); 
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC16(Var1->memberVar1,Var6+1); 
int  Var32=FUNC17(Var1->memberVar7,STRING); 
int  Var33=FUNC17(Var1->memberVar7,STRING); 
char *Var34=FUNC18(Var1,Var2); 
char *Var35=FUNC19(Var1->memberVar6,Var8,1); 
const char *Var36=FUNC20(Var1->memberVar7,STRING); 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var33=FUNC17(Var1->memberVar7,STRING); 
const char *Var24=strstr(Var2,STRING); 
char *Var37,*Var7=strchr(Var6+1,!); 
STRUCT3  Var38=Var1->memberVar8; 
char *Var39=NULL ; 
const char *Var40=NULL ; 
char *Var41=NULL ; 
char *Var42=NULL ; 
char *Var43=strdup(Var6+2); 
char *Var44=strchr(Var43,=); 
STRUCT3  Var38=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); 
int  Var45=(int ) FUNC9(Var1->memberVar5,Var6+2); 
STRUCT4 *Var46=FUNC22(Var1->memberVar9,Var1->memberVar8); 
STRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); 
char *Var50=strdup(Var6+2); 
STRUCT3  Var38=FUNC9(Var1->memberVar5,Var6+2); 
char *Var2=FUNC24(Var1,Var6+2); 
STRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); 
char *Var51=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); 
char *Var28=strchr(Var6+2,); 
int  Var52=FUNC9(Var1->memberVar5,Var28); 
const STRUCT5 *Var53=(const STRUCT5 *) FUNC10(Var6+2); 
STRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); 
STRUCT2 *Var47=Var11; 
const char *Var54[]={STRING,STRING,STRING,
const char *Var55[]={STRING,STRING,STRING,
char *Var22=strchr(Var56,); 
STRUCT3  Var57=FUNC9(Var1->memberVar5,Var56); 
STRUCT3  Var58=FUNC9(Var1->memberVar5,Var22+1); 
",1662,0
after_cmd.c,r_core_cmd_subst_i,False,False,520,CWE-,CallExpression,strchr,2605,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (sc) {\n', '\t\t\t\t\t*sc = 0;\n', '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tchar op0 = 0;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\top0 = *q;\n', '\t\t\t\t\t\t*q = 0;\n', '\t\t\t\t\thaveQuote = q != NULL;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*p = \'""\';\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\tif (p && *p && p[1] == '>') {\n"", '\t\t\t\t\tstr = p + 2;\n', ""\t\t\t\t\twhile (*str == '>') {\n"", '\t\t\t\t\t\tstr++;\n', '\t\t\t\t\tstr = (char *)r_str_trim_ro (str);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, append);\n', '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tstr = p + 2;\n', '\t\t\t\twhile (IS_WHITESPACE (*str)) {\n', '\t\t\t\t\tstr++;\n', '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\t\t\t*p = op0;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
bool  Var17=false ; 
bool  Var18=Var1->memberVar2; 
bool  Var19=Var1->memberVar3; 
STRUCT3  Var20=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
for (; *Var2; ){
int  Var15=-1; 
char *Var21,*Var22; 
Var17=*Var2 == ; 
if (Var17){
Var2  Var23; 
Var22=*Var2 FUNC3(Var2) NULL ; 
if (!Var22||!*Var22){
FUNC4(STRINGFUNC5(%Var24).,Var2); 
*Var22  Var23=0; 
else 
char *Var25=strchr(Var2,; ); 
if (Var25){
*Var25=0; 
FUNC6(Var1,Var2); 
if (!Var25){
Var2=Var25+1; 
char  Var26=0; 
if (*Var22){
if (Var22[0]== ){
Var22  Var27; 
while (Var22[1]== ; ||FUNC7(Var22[1])){
Var22  Var23; 
if (Var22[1]== ||(Var22[1]&&Var22[2]== )){
char *Var28=strchr(Var22+1,); 
if (Var28){
Var26=*Var28; 
*Var28=0; 
Var17=Var28 != NULL ; 
FUNC8(Var1,FUNC9(Var1->memberVar5,Var22+2),1); 
if (Var28){
*Var22=; 
Var22=Var28; 
else 
Var22=strchr(Var22+1,; ); 
if (Var22&&*Var22&&Var22[1]== >){
Var8=Var22+2; 
while (*Var8 == >){
Var8  Var23; 
Var8=(char *) FUNC10(Var8); 
const bool  Var29=Var22[2]== >; 
Var15=FUNC11(Var8,1,Var29); 
Var21=strdup(Var2); 
Var21=FUNC12(Var21,STRINGSTRINGSTRING,true ); 
if (Var22&&*Var22&&Var22[1]== |){
Var8=Var22+2; 
while (FUNC7(*Var8)){
Var8  Var23; 
FUNC13(Var1,Var2,Var8); 
else 
FUNC14(Var1->memberVar6,Var21); 
free(Var21); 
if (Var15 != -1){
FUNC15(Var15); 
if (!Var22){
if (Var16){
if (Var17){
if (*Var22 == ; ){
Var2=Var22+1; 
else 
if (*Var22 == ){
Var2=Var22; 
else 
*Var22=Var26; 
Var2=Var22; 
else 
Var2=Var22+1; 
char *Var7=strchr(Var2,); 
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC16(Var1->memberVar1,Var6+1); 
int  Var32=FUNC17(Var1->memberVar7,STRING); 
int  Var33=FUNC17(Var1->memberVar7,STRING); 
char *Var34=FUNC18(Var1,Var2); 
char *Var35=FUNC19(Var1->memberVar6,Var8,1); 
const char *Var36=FUNC20(Var1->memberVar7,STRING); 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var33=FUNC17(Var1->memberVar7,STRING); 
const char *Var24=strstr(Var2,STRING); 
char *Var37,*Var7=strchr(Var6+1,!); 
STRUCT3  Var38=Var1->memberVar8; 
char *Var39=NULL ; 
const char *Var40=NULL ; 
char *Var41=NULL ; 
char *Var42=NULL ; 
char *Var43=strdup(Var6+2); 
char *Var44=strchr(Var43,=); 
STRUCT3  Var38=FUNC21(Var1->memberVar5,Var1->memberVar8,Var6+4); 
int  Var45=(int ) FUNC9(Var1->memberVar5,Var6+2); 
STRUCT4 *Var46=FUNC22(Var1->memberVar9,Var1->memberVar8); 
STRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); 
char *Var50=strdup(Var6+2); 
STRUCT3  Var38=FUNC9(Var1->memberVar5,Var6+2); 
char *Var2=FUNC24(Var1,Var6+2); 
STRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); 
char *Var51=FUNC25(Var1->memberVar10,NULL ,0,Var6+((Var6[1]) 21)); 
char *Var28=strchr(Var6+2,); 
int  Var52=FUNC9(Var1->memberVar5,Var28); 
const STRUCT5 *Var53=(const STRUCT5 *) FUNC10(Var6+2); 
STRUCT2 *Var47=FUNC23(Var1->memberVar1,Var48,Var49,0); 
STRUCT2 *Var47=Var11; 
const char *Var54[]={STRING,STRING,STRING,
const char *Var55[]={STRING,STRING,STRING,
char *Var22=strchr(Var56,); 
STRUCT3  Var57=FUNC9(Var1->memberVar5,Var56); 
STRUCT3  Var58=FUNC9(Var1->memberVar5,Var22+1); 
",1662,0
after_cmd.c,r_core_cmd_subst_i,False,False,521,CWE-,CallExpression,strdup,2619,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
*Var25  Var26=0; 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
Var2=Var28+1; 
if (*Var25){
if (Var25[0]== ){
Var25  Var29; 
while (Var25[1]== ; ||FUNC8(Var25[1])){
Var25  Var26; 
if (Var25[1]== ||(Var25[1]&&Var25[2]== )){
char *Var30=strchr(Var25+1,); 
if (Var30){
Var25=Var30; 
else 
Var25=strchr(Var25+1,; ); 
const bool  Var31=Var25[2]== >; 
Var24=strdup(Var2); 
Var24=FUNC9(Var24,STRINGSTRINGSTRING,true ); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC10(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var24); 
free(Var24); 
if (!Var25){
if (Var18){
if (Var19){
if (*Var25 == ; ){
Var2=Var25+1; 
else 
if (*Var25 == ){
Var2=Var25; 
Var2=Var25; 
else 
Var2=Var25+1; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC11(Var2,,STRING); //Var32  Var33  Var5  Var34
if (*Var2 != ){
Var7=(char *) FUNC12(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC12(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC13(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC14(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC10(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC16(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC12(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC17(Var1,Var38,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC18()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC11(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
int  Var39=1; 
int  Var40=FUNC19(Var1->memberVar8,STRING); 
int  Var41=false ; 
int  Var42=FUNC19(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC20(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
if (*Var9 == ){
char *Var45=FUNC21(Var1,Var2); 
char *Var46=FUNC22(Var1->memberVar5,Var9,1); 
char *Var47=FUNC23(STRING,Var46,Var45); 
else 
char *Var48=FUNC23(STRING,Var45); 
else 
char *Var48=FUNC23(STRING,Var45); 
else 
}else if (Var39>0){
if (Var16 != -1){
Var15=FUNC24(Var1,Var2); 
const char *Var49=FUNC25(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var42=FUNC19(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC26(strdup(Var2),Var9); 
Var15=FUNC24(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC27(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var63=strdup(Var7+2); 
char *Var64=strchr(Var63,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC28(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var65=(int ) FUNC29(Var1->memberVar6,Var7+2); 
STRUCT5 *Var66=FUNC30(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); 
char *Var70=strdup(Var7+2); 
char  Var35=*Var71; 
STRUCT3  Var54=FUNC29(Var1->memberVar6,Var7+2); 
char *Var2=FUNC32(Var1,Var7+2); 
STRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); 
char *Var72=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var30=strchr(Var7+2,); 
int  Var73=FUNC29(Var1->memberVar6,Var30); 
const STRUCT6 *Var74=(const STRUCT6 *) FUNC34(Var7+2); 
STRUCT2 *Var67=FUNC31(Var1->memberVar1,Var68,Var69,0); 
char *Var75=Var7-2; 
while (Var75>Var2){
if (!FUNC8(*Var75)){
Var2=FUNC13(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC35((STRUCT6) Var7[1])&&!Var54){
if (!FUNC36(Var1->memberVar12,Var7+1)){
else 
char  Var35=*Var57; 
STRUCT2 *Var67=Var12; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
Var15=FUNC37(Var1,Var2,Var76); 
else 
Var15=FUNC38(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC29(Var1->memberVar6,Var79); 
STRUCT3  Var81=FUNC29(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; 
",3340,0
after_cmd.c,r_core_cmd_subst_i,False,False,522,CWE-,CallExpression,free,2630,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t*p++ = 0;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (!sc) {\n', '\t\t\t\tcmd = sc + 1;\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[0] == '@') {\n"", '\t\t\t\t\tp--;\n', ""\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n"", '\t\t\t\t\tp++;\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tp = q;\n', 'else\n', ""\t\t\t\t\t\tp = strchr (p + 1, ';');\n"", ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', '\t\t\tline = r_str_replace (line, ""\\\\\\"""", ""\\"""", true);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tfree (line);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\t\tif (haveQuote) {\n', ""\t\t\t\tif (*p == ';') {\n"", '\t\t\t\t\tcmd = p + 1;\n', 'else\n', '\t\t\t\t\tif (*p == \'""\') {\n', '\t\t\t\t\t\tcmd = p;\n', '\t\t\t\t\t\tcmd = p;\n', 'else\n', '\t\t\t\tcmd = p + 1;\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6=NULL ; 
char *Var7=NULL ; 
STRUCT2 *Var8=NULL ; 
int  Var9=!Var1->memberVar1->memberVar1; 
bool  Var10=false ; 
bool  Var11=false ; 
bool  Var12=Var1->memberVar2; 
bool  Var13=Var1->memberVar3; 
STRUCT3  Var14=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
for (; *Var2; ){
char *Var15,*Var16; 
if (Var11){
Var2  Var17; 
Var16=*Var2 FUNC3(Var2) NULL ; 
if (!Var16||!*Var16){
*Var16  Var17=0; 
else 
char *Var18=strchr(Var2,; ); 
if (!Var18){
Var2=Var18+1; 
if (*Var16){
if (Var16[0]== ){
Var16  Var19; 
while (Var16[1]== ; ||FUNC4(Var16[1])){
Var16  Var17; 
if (Var16[1]== ||(Var16[1]&&Var16[2]== )){
char *Var20=strchr(Var16+1,); 
if (Var20){
Var16=Var20; 
else 
Var16=strchr(Var16+1,; ); 
const bool  Var21=Var16[2]== >; 
Var15=strdup(Var2); 
Var15=FUNC5(Var15,STRINGSTRINGSTRING,true ); 
if (Var16&&*Var16&&Var16[1]== |){
else 
FUNC6(Var1->memberVar5,Var15); 
free(Var15); 
if (!Var16){
if (Var10){
if (Var11){
if (*Var16 == ; ){
Var2=Var16+1; 
else 
if (*Var16 == ){
Var2=Var16; 
Var2=Var16; 
else 
Var2=Var16+1; 
char *Var22=strchr(Var2,); 
int  Var23=Var1->memberVar6->memberVar1; 
else 
char *Var24=FUNC7(Var1->memberVar1,Var25+1); 
int  Var26=FUNC8(Var1->memberVar7,STRING); 
int  Var27=FUNC8(Var1->memberVar7,STRING); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar5,Var30,1); 
const char *Var31=FUNC11(Var1->memberVar7,STRING); 
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var27=FUNC8(Var1->memberVar7,STRING); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var22=strchr(Var25+1,!); 
STRUCT3  Var34=Var1->memberVar8; 
char *Var35=NULL ; 
const char *Var36=NULL ; 
char *Var37=NULL ; 
char *Var38=NULL ; 
char *Var39=strdup(Var25+2); 
char *Var40=strchr(Var39,=); 
STRUCT3  Var34=FUNC12(Var1->memberVar6,Var1->memberVar8,Var25+4); 
int  Var41=(int ) FUNC13(Var1->memberVar6,Var25+2); 
STRUCT4 *Var42=FUNC14(Var1->memberVar9,Var1->memberVar8); 
STRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); 
char *Var46=strdup(Var25+2); 
STRUCT3  Var34=FUNC13(Var1->memberVar6,Var25+2); 
char *Var2=FUNC16(Var1,Var25+2); 
STRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); 
char *Var47=FUNC17(Var1->memberVar10,NULL ,0,Var25+((Var25[1]) 21)); 
char *Var20=strchr(Var25+2,); 
int  Var48=FUNC13(Var1->memberVar6,Var20); 
STRUCT2 *Var43=FUNC15(Var1->memberVar1,Var44,Var45,0); 
STRUCT2 *Var43=Var8; 
const char *Var49[]={STRING,STRING,STRING,
const char *Var50[]={STRING,STRING,STRING,
char *Var16=strchr(Var51,); 
STRUCT3  Var52=FUNC13(Var1->memberVar6,Var51); 
STRUCT3  Var53=FUNC13(Var1->memberVar6,Var16+1); 
",1308,0
after_cmd.c,r_core_cmd_subst_i,False,False,523,CWE-,CallExpression,strstr,2662,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3074,0
after_cmd.c,r_core_cmd_subst_i,False,False,524,CWE-,CallExpression,memmove,2713,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
after_cmd.c,r_core_cmd_subst_i,False,False,525,CWE-,CallExpression,strlen,2713,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
after_cmd.c,r_core_cmd_subst_i,False,False,526,CWE-,CallExpression,strchr,2717,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3074,0
after_cmd.c,r_core_cmd_subst_i,False,False,527,CWE-,CallExpression,strcmp,2722,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
after_cmd.c,r_core_cmd_subst_i,False,False,528,CWE-,CallExpression,strcmp,2729,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
after_cmd.c,r_core_cmd_subst_i,False,False,529,CWE-,CallExpression,strcmp,2733,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
memmove(Var15,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC5(Var1,Var2,Var7+1); 
else 
char *Var17=FUNC6(Var1->memberVar1,Var7+1); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1243,0
after_cmd.c,r_core_cmd_subst_i,False,False,530,CWE-,CallExpression,free,2745,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\t\tif (res) {\n', '\t\t\t\t\t\t\tr_cons_printf (""%s\\n"", res);\n', '\t\t\t\t\t\t\tfree (res);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
bool  Var11=Var1->memberVar2; 
bool  Var12=Var1->memberVar3; 
STRUCT2  Var13=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var14=strchr(Var2,; ); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
Var7=(char *) FUNC3(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var15=Var7-1; 
if (*Var15 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var16=Var1->memberVar5->memberVar1; 
if (*Var2){
else 
char *Var17=FUNC5(Var1->memberVar1,Var7+1); 
if (Var17){
FUNC6(STRING,Var17); 
free(Var17); 
char *Var15=Var7-1; 
int  Var18=FUNC7(Var1->memberVar6,STRING); 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
char *Var20=Var7-1; 
const bool  Var21=(Var7[1]== >); 
char *Var22=FUNC8(Var1,Var2); 
char *Var23=FUNC9(Var1->memberVar7,Var9,1); 
const char *Var24=FUNC10(Var1->memberVar6,STRING); 
char *Var15=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var19=FUNC7(Var1->memberVar6,STRING); 
const char *Var25=strstr(Var2,STRING); 
char *Var26,*Var8=strchr(Var7+1,!); 
STRUCT2  Var27=Var1->memberVar8; 
char *Var28=strdup(Var7+2); 
STRUCT2  Var27=FUNC11(Var1->memberVar5,Var1->memberVar8,Var7+4); 
int  Var29=(int ) FUNC12(Var1->memberVar5,Var7+2); 
STRUCT4 *Var30=FUNC13(Var1->memberVar9,Var1->memberVar8); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var34=strdup(Var7+2); 
char  Var15=*Var35; 
STRUCT2  Var27=FUNC12(Var1->memberVar5,Var7+2); 
char *Var2=FUNC15(Var1,Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var36=FUNC16(Var1->memberVar10,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var37=strchr(Var7+2,); 
int  Var38=FUNC12(Var1->memberVar5,Var37); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC17(Var7+2); 
STRUCT5 *Var31=FUNC14(Var1->memberVar1,Var32,Var33,0); 
char *Var40=Var7-2; 
else 
char  Var15=*Var41; 
char *Var42=Var7+3; 
char *Var43=Var7+3; 
STRUCT2  Var44=FUNC12(Var1->memberVar5,Var43); 
STRUCT2  Var45=FUNC12(Var1->memberVar5,Var46+1); 
",1227,0
after_cmd.c,r_core_cmd_subst_i,False,False,531,CWE-,CallExpression,strchr,2783,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', '\t\t\treturn ret;\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\teprintf (""==> Reading from stdin until \'%s\'\\n"", str);\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\teprintf (""Slurping file \'%s\'\\n"", str);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\t\t\t*fdnum = 0;\n', 'else\n', '\t\t\t\tif (IS_DIGIT (*fdnum)) {\n', ""\t\t\t\t\tfdn = *fdnum - '0';\n"", '\t\t\t\t*fdnum = 0;\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\tfree (n);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\t\tr_cons_pipe_close (pipefd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\t\tr_file_rm (str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tfree (str);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\t\treturn ret;\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\t*ptr2 = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (cmd == s) {\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""The current basic block has %d instructions\\n"", bb->ninstr);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tr_cons_grep_process (grep);\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\tif (tmpseek) {\n', '\t\t*tmpseek = cmd_tmpseek;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
int  Var28=-1; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var29,*Var30; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var31; 
Var30=*Var2 FUNC5(Var2) NULL ; 
if (!Var30||!*Var30){
FUNC6(STRINGFUNC7(%Var32).,Var2); 
else 
char *Var33=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var33){
char *Var34=strchr(Var30+1,); 
const bool  Var35=Var30[2]== >; 
Var29=strdup(Var2); 
if (Var30&&*Var30&&Var30[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var30){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38
if (Var9&&(Var9[1]== ||Var9[1]==  Var39)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var41=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var42=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
return  Var17; 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var43=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var43,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var31){
FUNC6(STRING,Var11); 
char  Var44[1024]; 
int  Var17; 
if (FUNC20(stdin)){
if (Var1->memberVar7){
if (!strcmp(Var44,Var11)){
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var31){
if (!*Var11){
FUNC6(STRING,Var11); 
Var1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); 
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
return FUNC22(Var1,(const char *) Var1->memberVar7); 
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var45=1; 
int  Var46=FUNC23(Var1->memberVar9,STRING); 
int  Var47=false ; 
int  Var48=FUNC23(Var1->memberVar9,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC24(Var9[-2])){
char *Var49=Var9-1; 
if (*Var49 ==  Var50){//STRING
Var20=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,true ); 
*Var49=0; 
else 
if (FUNC26(*Var49)){
Var45=*Var49-0; 
*Var49=0; 
if (!strcmp(Var11,STRING)){
FUNC25(Var1->memberVar9,STRING,Var51); 
const bool  Var52=(Var9[1]== >); 
if (*Var11 == ){
char *Var53=FUNC27(Var1,Var2); 
if (Var52){
char *Var54=FUNC28(Var1->memberVar5,Var11,1); 
if (Var54){
char *Var55=FUNC29(STRING,Var54,Var53); 
if (Var55){
FUNC30(Var1->memberVar5,Var11,Var55,1); 
free(Var55); 
else 
char *Var56=FUNC29(STRING,Var53); 
FUNC30(Var1->memberVar5,Var11,Var56,1); 
free(Var56); 
else 
char *Var56=FUNC29(STRING,Var53); 
FUNC30(Var1->memberVar5,Var11,Var56,1); 
free(Var56); 
else 
}else if (Var45>0){
Var18=FUNC31(Var11,Var45,Var52); 
if (Var18 != -1){
if (!Var46){
FUNC25(Var1->memberVar9,STRING,Var51); 
Var17=FUNC12(Var1,Var2); 
FUNC32(Var18); 
if (!Var46){
FUNC25(Var1->memberVar9,STRING,Var48); 
if (Var47){
const char *Var57=FUNC33(Var1->memberVar9,STRING); 
if (Var57&&*Var57){
FUNC34(STRING,Var57,Var11); 
FUNC35(Var11); 
FUNC25(Var1->memberVar9,STRING,Var48); 
free(Var11); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
Var1->memberVar10->memberVar1=false ; 
return  Var17; 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
bool  Var58=false ; 
int  Var59=1; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var58){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
*Var10=0; 
if (Var9[1]== !){
Var11=FUNC36(Var1,Var9+1); 
else 
int  Var48=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,0); 
Var11=FUNC27(Var1,Var9+1); 
FUNC25(Var1->memberVar9,STRING,Var48); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
free(Var11); 
if (Var59&&Var11){
for (Var16=0; Var11[Var16]; Var16  Var31){
if (Var11[Var16]==  Var56){
Var11[Var16]=; 
Var11=FUNC37(Var11,Var10+1); 
Var2=FUNC37(strdup(Var2),Var11); 
Var1->memberVar6->memberVar1=memberVar1; 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
free(Var11); 
return  Var17; 
if (*Var2 != &&*Var2){
const char *Var32=strstr(Var2,STRING); 
if (Var32){
bool  Var60=false ; 
if (Var2 ==  Var32){
if (Var60){
if (*Var2 != .){
Var13=FUNC38(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar11=Var9 true false ; 
int  Var61=0; 
if (Var9){
char *Var62,*Var10=strchr(Var9+1,!); 
STRUCT4  Var63=Var1->memberVar12; 
bool  Var64=false ; 
char *Var65=NULL ; 
const char *Var66=NULL ; 
bool  Var67=false ; 
bool  Var68=false ; 
char *Var69=NULL ; 
char *Var70=NULL ; 
bool  Var71=false ; 
int  Var72=-1; 
int  Var73,Var74; 
STRUCT6 *Var44; 
*Var9  Var31=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var31){
if (*Var9&&Var9[1]== ){
else 
Var9  Var75; 
Var9=FUNC39(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var76=strdup(Var9+2); 
char *Var77=strchr(Var76,=); 
if (Var77){
*Var77  Var31=0; 
FUNC40(Var76,Var77); 
FUNC41(Var5,Var76); 
else 
free(Var76); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+4); 
FUNC43(Var1,FUNC44((Var78) Var63-(Var78) Var1->memberVar12)); 
else 
Var63=FUNC42(Var1->memberVar6,Var1->memberVar12,Var9+3); 
FUNC45(Var1,Var63,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var71=FUNC46(Var1->memberVar13,Var9+2); 
int  Var79=(int ) FUNC47(Var1->memberVar6,Var9+2); 
STRUCT7 *Var80=FUNC48(Var1->memberVar14,Var1->memberVar12); 
if (Var80){
if (Var79<0){
Var79=Var80->memberVar1+Var79; 
if (Var79 >= 0&&Var79<Var80->memberVar1){
STRUCT8  Var81=FUNC49(Var80,Var79); 
FUNC45(Var1,Var80->memberVar2+Var81,1); 
else 
FUNC6(STRING,Var80->memberVar1); 
Var62=FUNC21(Var9+2,&Var73); 
if (Var62){
STRUCT9 *Var82=FUNC50((const STRUCT6 *) Var62,Var73); 
STRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); 
if (Var83){
if (Var14){
FUNC52(Var14); 
Var14=Var83; 
if (Var15){
FUNC25(Var1->memberVar9,STRING,1); 
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); 
if (Var44){
free(Var1->memberVar15); 
memcpy(Var1->memberVar15,Var62,Var73); 
free(Var62); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var85; 
char *Var86=strdup(Var9+2); 
char *Var87=FUNC55(Var86); 
if (Var87){
char  Var40=*Var87; 
*Var87=0; 
Var85=FUNC56(Var1->memberVar16,Var86); 
*Var87=Var40; 
Var85=FUNC47(Var1->memberVar6,Var88); 
else 
Var85=FUNC56(Var1->memberVar16,Var9+2); 
FUNC45(Var1,Var85,1); 
free(Var86); 
Var67=FUNC57(Var1,FUNC47(Var1->memberVar6,Var9+2),&Var65); 
Var28=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,1); 
STRUCT4  memberVar2=FUNC47(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC58(Var1,Var9+2); 
if (!Var69){
Var69=Var2; 
else 
Var69=FUNC59(Var69,Var2); 
free(Var2); 
if (Var9[1]== ){
Var44=malloc(strlen(Var9+2)+1); 
if (Var44){
Var74=FUNC60(Var9+2,Var44); 
FUNC43(Var1,FUNC44(Var74)); 
if (Var74>0){
STRUCT9 *Var82=FUNC50(Var44,Var74); 
STRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); 
if (Var83){
if (Var14){
FUNC52(Var14); 
Var14=Var83; 
if (Var15){
FUNC25(Var1->memberVar9,STRING,1); 
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); 
FUNC43(Var1,Var74); 
free(Var44); 
char *Var89=FUNC61(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var89){
FUNC45(Var1,FUNC47(Var1->memberVar6,Var89),1); 
free(Var89); 
if (Var9[1]== ){
Var72=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC62(Var1->memberVar1,FUNC63(Var9+2)); 
if (Var9[1]== ){
char *Var34=strchr(Var9+2,); 
if (Var34){
*Var34  Var31=0; 
int  Var90=FUNC47(Var1->memberVar6,Var34); 
Var67=FUNC57(Var1,Var90,&Var65); 
Var68=FUNC64(Var1,Var9+2,&Var70); 
Var74=strlen(Var9+2); 
FUNC43(Var1,Var74); 
const STRUCT6 *Var44=(const STRUCT6 *) FUNC65(Var9+2); 
if (Var74>0){
STRUCT9 *Var82=FUNC50(Var44,Var74); 
STRUCT3 *Var83=FUNC51(Var1->memberVar1,Var82,Var84,0); 
if (!Var1->memberVar1->memberVar1){
FUNC25(Var1->memberVar9,STRING,1); 
if (Var83){
if (Var14){
FUNC52(Var14); 
Var14=Var83; 
if (Var15){
FUNC25(Var1->memberVar9,STRING,1); 
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,Var1->memberVar12,FUNC54(Var82)); 
FUNC43(Var1,Var74); 
*Var9=; 
char *Var91=Var9-2; 
while (Var91>Var2){
if (!FUNC66(*Var91)){
*Var91=0; 
Var91  Var75; 
Var9=FUNC67(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
else 
*Var10=0; 
if (!Var10[1]){
FUNC43(
Var1,FUNC47(Var1->memberVar6,Var10+1)); 
Var66=FUNC67(Var9+1); 
memberVar2=FUNC47(Var1->memberVar6,Var66); 
if (FUNC68((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC69(Var1->memberVar13,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var40=*Var66; 
if (Var40 == -||Var40 == +){
memberVar2=Var1->memberVar12+memberVar2; 
if (memberVar2){
STRUCT3 *Var83=Var14; 
if (Var83){
FUNC53(Var1->memberVar1,Var83->memberVar1,Var83->memberVar2,0,memberVar2,FUNC70(Var83)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar18=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var92=Var9+3; 
while (*Var92&&*Var92 == ){
Var92  Var31; 
Var17=FUNC71(Var1,Var2,Var92); 
else 
Var17=FUNC72(Var1,Var2,Var9+2); 
else 
bool  memberVar11=false ; 
const char *Var93[]={STRING,STRING,STRING,
const char *Var94[]={STRING,STRING,STRING,
STRUCT4  Var95[FUNC73(Var93)-1],Var96[FUNC73(Var94)-1]; 
if (Var9[1]== (){
char *Var97=Var9+3; 
char *Var30=strchr(Var97,); 
if (!Var30){
free(Var69); 
*Var30=Var98; 
STRUCT4  Var99=FUNC47(Var1->memberVar6,Var97); 
STRUCT4  Var100=FUNC47(Var1->memberVar6,Var30+1); 
for (Var16=0; Var93[Var16]; Var16  Var31){
Var95[Var16]=FUNC23(Var1->memberVar9,Var93[Var16]); 
for (Var16=0; Var94[Var16]; Var16  Var31){
Var96[Var16]=FUNC23(Var1->memberVar9,Var94[Var16]); 
for (Var16=0; Var93[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var93[Var16],Var99); 
for (Var16=0; Var94[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var94[Var16],Var100); 
if (Var19){
if (Var64){
Var1->memberVar12=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC67(Var2)); 
else 
if (Var64){
if (Var9[1]){
FUNC45(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC67(Var2)); 
if (memberVar11){
for (Var16=0; Var93[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var93[Var16],Var95[Var16]); 
for (Var16=0; Var94[Var16]; Var16  Var31){
FUNC25(Var1->memberVar9,Var94[Var16],Var96[Var16]); 
if (Var10){
*Var10=!; 
if (Var72 != -1){
FUNC62(Var1->memberVar1,Var72); 
if (Var14){
if (Var15){
FUNC25(Var1->memberVar9,STRING,0); 
FUNC52(Var14); 
if (Var67){
FUNC74(Var1->memberVar9,STRING,Var65); 
if (Var69){
FUNC8(Var1,Var69); 
FUNC75(Var69); 
if (Var71){
FUNC76(Var1->memberVar13); 
*Var9=; 
Var61=Var17; 
Var61=Var2 FUNC4(Var1->memberVar5,FUNC67(Var2)) false ; 
FUNC77(Var13); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
if (Var14){
FUNC52(Var14); 
if (memberVar11){
*memberVar11=Var26; 
if (Var28 != -1){
FUNC25(Var1->memberVar9,STRING,Var28); 
return  Var61; 
",6674,0
after_cmd.c,r_core_cmd_subst_i,False,False,532,CWE-,CallExpression,strstr,2789,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var28,*Var29; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var30; 
Var29=*Var2 FUNC5(Var2) NULL ; 
if (!Var29||!*Var29){
FUNC6(STRINGFUNC7(%Var31).,Var2); 
else 
char *Var32=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var32){
char *Var33=strchr(Var29+1,); 
const bool  Var34=Var29[2]== >; 
Var28=strdup(Var2); 
if (Var29&&*Var29&&Var29[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var29){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37
if (Var9&&(Var9[1]== ||Var9[1]==  Var38)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var40=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var41=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var42=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var42,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var30){
char  Var43[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var30){
if (!*Var11){
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var44=1; 
int  Var45=FUNC20(Var1->memberVar8,STRING); 
int  Var46=false ; 
int  Var47=FUNC20(Var1->memberVar8,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC21(Var9[-2])){
char *Var48=Var9-1; 
const bool  Var49=(Var9[1]== >); 
if (*Var11 == ){
char *Var50=FUNC22(Var1,Var2); 
char *Var51=FUNC23(Var1->memberVar5,Var11,1); 
char *Var52=FUNC24(STRING,Var51,Var50); 
else 
char *Var53=FUNC24(STRING,Var50); 
else 
char *Var53=FUNC24(STRING,Var50); 
else 
}else if (Var44>0){
if (Var18 != -1){
Var17=FUNC12(Var1,Var2); 
const char *Var54=FUNC25(Var1->memberVar8,STRING); 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
bool  Var55=false ; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var55){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
if (Var9[1]== !){
Var11=FUNC26(Var1,Var9+1); 
else 
int  Var47=FUNC20(Var1->memberVar8,STRING); 
Var11=FUNC22(Var1,Var9+1); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
Var2=FUNC27(strdup(Var2),Var11); 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var31=strstr(Var2,STRING); 
if (Var31){
bool  Var56=false ; 
if (Var56){
if (*Var2 != .){
Var13=FUNC28(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar9=Var9 true false ; 
int  Var57=0; 
if (Var9){
char *Var58,*Var10=strchr(Var9+1,!); 
STRUCT4  Var59=Var1->memberVar10; 
bool  Var60=false ; 
char *Var61=NULL ; 
const char *Var62=NULL ; 
bool  Var63=false ; 
bool  Var64=false ; 
char *Var65=NULL ; 
char *Var66=NULL ; 
bool  Var67=false ; 
int  Var68=-1; 
int  Var69,Var70; 
STRUCT6 *Var43; 
*Var9  Var30=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var30){
if (*Var9&&Var9[1]== ){
else 
Var9  Var71; 
Var9=FUNC29(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var72=strdup(Var9+2); 
char *Var73=strchr(Var72,=); 
if (Var73){
*Var73  Var30=0; 
FUNC30(Var72,Var73); 
FUNC31(Var5,Var72); 
else 
free(Var72); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); 
FUNC33(Var1,FUNC34((Var74) Var59-(Var74) Var1->memberVar10)); 
else 
Var59=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); 
FUNC35(Var1,Var59,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var67=FUNC36(Var1->memberVar11,Var9+2); 
int  Var75=(int ) FUNC37(Var1->memberVar6,Var9+2); 
STRUCT7 *Var76=FUNC38(Var1->memberVar12,Var1->memberVar10); 
if (Var76){
if (Var75<0){
Var75=Var76->memberVar1+Var75; 
if (Var75 >= 0&&Var75<Var76->memberVar1){
STRUCT8  Var77=FUNC39(Var76,Var75); 
FUNC35(Var1,Var76->memberVar2+Var77,1); 
Var58=FUNC40(Var9+2,&Var69); 
if (Var58){
STRUCT9 *Var78=FUNC41((const STRUCT6 *) Var58,Var69); 
STRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var14){
FUNC43(Var14); 
Var14=Var79; 
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); 
if (Var43){
memcpy(Var1->memberVar13,Var58,Var69); 
free(Var58); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var81; 
char *Var82=strdup(Var9+2); 
char *Var83=FUNC46(Var82); 
if (Var83){
char  Var39=*Var83; 
*Var83=0; 
Var81=FUNC47(Var1->memberVar14,Var82); 
*Var83=Var39; 
else 
Var81=FUNC47(Var1->memberVar14,Var9+2); 
FUNC35(Var1,Var81,1); 
free(Var82); 
Var63=FUNC48(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var61); 
STRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC49(Var1,Var9+2); 
if (!Var65){
Var65=Var2; 
else 
Var65=FUNC50(Var65,Var2); 
free(Var2); 
if (Var9[1]== ){
Var43=malloc(strlen(Var9+2)+1); 
if (Var43){
Var70=FUNC51(Var9+2,Var43); 
FUNC33(Var1,FUNC34(Var70)); 
if (Var70>0){
STRUCT9 *Var78=FUNC41(Var43,Var70); 
STRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var14){
FUNC43(Var14); 
Var14=Var79; 
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); 
FUNC33(Var1,Var70); 
free(Var43); 
char *Var84=FUNC52(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var84){
FUNC35(Var1,FUNC37(Var1->memberVar6,Var84),1); 
free(Var84); 
if (Var9[1]== ){
FUNC53(Var1->memberVar1,FUNC54(Var9+2)); 
if (Var9[1]== ){
char *Var33=strchr(Var9+2,); 
if (Var33){
*Var33  Var30=0; 
int  Var85=FUNC37(Var1->memberVar6,Var33); 
Var63=FUNC48(Var1,Var85,&Var61); 
Var64=FUNC55(Var1,Var9+2,&Var66); 
Var70=strlen(Var9+2); 
FUNC33(Var1,Var70); 
const STRUCT6 *Var43=(const STRUCT6 *) FUNC56(Var9+2); 
if (Var70>0){
STRUCT9 *Var78=FUNC41(Var43,Var70); 
STRUCT3 *Var79=FUNC42(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var14){
FUNC43(Var14); 
Var14=Var79; 
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar10,FUNC45(Var78)); 
FUNC33(Var1,Var70); 
*Var9=; 
char *Var86=Var9-2; 
while (Var86>Var2){
if (!FUNC57(*Var86)){
*Var86=0; 
Var86  Var71; 
Var9=FUNC58(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var62=FUNC58(Var9+1); 
memberVar2=FUNC37(Var1->memberVar6,Var62); 
if (FUNC59((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC60(Var1->memberVar11,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var39=*Var62; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar10+memberVar2; 
if (memberVar2){
STRUCT3 *Var79=Var14; 
if (Var79){
FUNC44(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC61(Var79)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar16=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var87=Var9+3; 
while (*Var87&&*Var87 == ){
Var87  Var30; 
Var17=FUNC62(Var1,Var2,Var87); 
else 
Var17=FUNC63(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var88[]={STRING,STRING,STRING,
const char *Var89[]={STRING,STRING,STRING,
STRUCT4  Var90[FUNC64(Var88)-1],Var91[FUNC64(Var89)-1]; 
if (Var9[1]== (){
char *Var92=Var9+3; 
char *Var29=strchr(Var92,); 
if (!Var29){
free(Var65); 
*Var29=Var93; 
STRUCT4  Var94=FUNC37(Var1->memberVar6,Var92); 
STRUCT4  Var95=FUNC37(Var1->memberVar6,Var29+1); 
for (Var16=0; Var88[Var16]; Var16  Var30){
Var90[Var16]=FUNC20(Var1->memberVar8,Var88[Var16]); 
for (Var16=0; Var89[Var16]; Var16  Var30){
Var91[Var16]=FUNC20(Var1->memberVar8,Var89[Var16]); 
for (Var16=0; Var88[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var88[Var16],Var94); 
for (Var16=0; Var89[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var89[Var16],Var95); 
if (Var19){
if (Var60){
Var1->memberVar10=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC58(Var2)); 
else 
if (Var60){
if (Var9[1]){
FUNC35(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC58(Var2)); 
if (memberVar9){
for (Var16=0; Var88[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var88[Var16],Var90[Var16]); 
for (Var16=0; Var89[Var16]; Var16  Var30){
FUNC65(Var1->memberVar8,Var89[Var16],Var91[Var16]); 
if (Var68 != -1){
FUNC53(Var1->memberVar1,Var68); 
if (Var14){
if (Var15){
FUNC65(Var1->memberVar8,STRING,0); 
FUNC43(Var14); 
if (Var63){
FUNC66(Var1->memberVar8,STRING,Var61); 
if (Var65){
FUNC8(Var1,Var65); 
FUNC67(Var65); 
if (Var67){
FUNC68(Var1->memberVar11); 
*Var9=; 
Var57=Var17; 
Var57=Var2 FUNC4(Var1->memberVar5,FUNC58(Var2)) false ; 
if (Var20 != -1){
FUNC65(Var1->memberVar8,STRING,Var20); 
if (Var21 != -1){
FUNC65(Var1->memberVar8,STRING,Var21); 
if (Var14){
FUNC43(Var14); 
return  Var57; 
",5614,0
after_cmd.c,r_core_cmd_subst_i,False,False,533,CWE-,CallExpression,strchr,2816,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\teprintf (""==> Reading from stdin until \'%s\'\\n"", str);\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\teprintf (""Slurping file \'%s\'\\n"", str);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var28,*Var29; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var30; 
Var29=*Var2 FUNC5(Var2) NULL ; 
if (!Var29||!*Var29){
FUNC6(STRINGFUNC7(%Var31).,Var2); 
else 
char *Var32=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var32){
char *Var33=strchr(Var29+1,); 
const bool  Var34=Var29[2]== >; 
Var28=strdup(Var2); 
if (Var29&&*Var29&&Var29[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var29){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var35  Var36  Var7  Var37
if (Var9&&(Var9[1]== ||Var9[1]==  Var38)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var40=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var41=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var30){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var42=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var42,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var30){
FUNC6(STRING,Var11); 
char  Var43[1024]; 
int  Var17; 
if (FUNC20(stdin)){
if (Var1->memberVar7){
if (!strcmp(Var43,Var11)){
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var30){
if (!*Var11){
FUNC6(STRING,Var11); 
Var1->memberVar7=(STRUCT6 *) FUNC21(Var11,&Var1->memberVar8); 
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
return FUNC22(Var1,(const char *) Var1->memberVar7); 
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var44=1; 
int  Var45=FUNC23(Var1->memberVar9,STRING); 
int  Var46=false ; 
int  Var47=FUNC23(Var1->memberVar9,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC24(Var9[-2])){
char *Var48=Var9-1; 
if (*Var48 ==  Var49){//STRING
Var20=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,true ); 
if (!strcmp(Var11,STRING)){
FUNC25(Var1->memberVar9,STRING,Var50); 
const bool  Var51=(Var9[1]== >); 
if (*Var11 == ){
char *Var52=FUNC26(Var1,Var2); 
if (Var51){
char *Var53=FUNC27(Var1->memberVar5,Var11,1); 
if (Var53){
char *Var54=FUNC28(STRING,Var53,Var52); 
if (Var54){
FUNC29(Var1->memberVar5,Var11,Var54,1); 
free(Var54); 
else 
char *Var55=FUNC28(STRING,Var52); 
FUNC29(Var1->memberVar5,Var11,Var55,1); 
else 
char *Var55=FUNC28(STRING,Var52); 
FUNC29(Var1->memberVar5,Var11,Var55,1); 
else 
}else if (Var44>0){
if (Var18 != -1){
if (!Var45){
FUNC25(Var1->memberVar9,STRING,Var50); 
Var17=FUNC12(Var1,Var2); 
if (!Var45){
FUNC25(Var1->memberVar9,STRING,Var47); 
if (Var46){
const char *Var56=FUNC30(Var1->memberVar9,STRING); 
if (Var56&&*Var56){
FUNC31(STRING,Var56,Var11); 
FUNC25(Var1->memberVar9,STRING,Var47); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
Var1->memberVar10->memberVar1=false ; 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var39=Var9-1; 
if (*Var39 == ){
memmove(Var39,Var9,strlen(Var9)+1); 
bool  Var57=false ; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var57){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
if (Var9[1]== !){
Var11=FUNC32(Var1,Var9+1); 
else 
int  Var47=FUNC23(Var1->memberVar9,STRING); 
FUNC25(Var1->memberVar9,STRING,0); 
Var11=FUNC26(Var1,Var9+1); 
FUNC25(Var1->memberVar9,STRING,Var47); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
Var2=FUNC33(strdup(Var2),Var11); 
Var1->memberVar6->memberVar1=memberVar1; 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (*Var2 != &&*Var2){
const char *Var31=strstr(Var2,STRING); 
if (Var31){
bool  Var58=false ; 
if (Var58){
if (*Var2 != .){
Var13=FUNC34(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar11=Var9 true false ; 
int  Var59=0; 
if (Var9){
char *Var60,*Var10=strchr(Var9+1,!); 
STRUCT4  Var61=Var1->memberVar12; 
bool  Var62=false ; 
char *Var63=NULL ; 
const char *Var64=NULL ; 
bool  Var65=false ; 
bool  Var66=false ; 
char *Var67=NULL ; 
char *Var68=NULL ; 
bool  Var69=false ; 
int  Var70=-1; 
int  Var71,Var72; 
STRUCT6 *Var43; 
*Var9  Var30=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var30){
if (*Var9&&Var9[1]== ){
else 
Var9  Var73; 
Var9=FUNC35(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var74=strdup(Var9+2); 
char *Var75=strchr(Var74,=); 
if (Var75){
*Var75  Var30=0; 
FUNC36(Var74,Var75); 
FUNC37(Var5,Var74); 
else 
free(Var74); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+4); 
FUNC39(Var1,FUNC40((Var76) Var61-(Var76) Var1->memberVar12)); 
else 
Var61=FUNC38(Var1->memberVar6,Var1->memberVar12,Var9+3); 
FUNC41(Var1,Var61,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var69=FUNC42(Var1->memberVar13,Var9+2); 
int  Var77=(int ) FUNC43(Var1->memberVar6,Var9+2); 
STRUCT7 *Var78=FUNC44(Var1->memberVar14,Var1->memberVar12); 
if (Var78){
if (Var77<0){
Var77=Var78->memberVar1+Var77; 
if (Var77 >= 0&&Var77<Var78->memberVar1){
STRUCT8  Var79=FUNC45(Var78,Var77); 
FUNC41(Var1,Var78->memberVar2+Var79,1); 
Var60=FUNC21(Var9+2,&Var71); 
if (Var60){
STRUCT9 *Var80=FUNC46((const STRUCT6 *) Var60,Var71); 
STRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); 
if (Var81){
if (Var14){
FUNC48(Var14); 
Var14=Var81; 
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); 
if (Var43){
memcpy(Var1->memberVar15,Var60,Var71); 
free(Var60); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var83; 
char *Var84=strdup(Var9+2); 
char *Var85=FUNC51(Var84); 
if (Var85){
char  Var39=*Var85; 
*Var85=0; 
Var83=FUNC52(Var1->memberVar16,Var84); 
*Var85=Var39; 
else 
Var83=FUNC52(Var1->memberVar16,Var9+2); 
FUNC41(Var1,Var83,1); 
free(Var84); 
Var65=FUNC53(Var1,FUNC43(Var1->memberVar6,Var9+2),&Var63); 
STRUCT4  memberVar2=FUNC43(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC54(Var1,Var9+2); 
if (!Var67){
Var67=Var2; 
else 
Var67=FUNC55(Var67,Var2); 
free(Var2); 
if (Var9[1]== ){
Var43=malloc(strlen(Var9+2)+1); 
if (Var43){
Var72=FUNC56(Var9+2,Var43); 
FUNC39(Var1,FUNC40(Var72)); 
if (Var72>0){
STRUCT9 *Var80=FUNC46(Var43,Var72); 
STRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); 
if (Var81){
if (Var14){
FUNC48(Var14); 
Var14=Var81; 
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); 
FUNC39(Var1,Var72); 
free(Var43); 
char *Var86=FUNC57(Var1->memberVar17,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var86){
FUNC41(Var1,FUNC43(Var1->memberVar6,Var86),1); 
free(Var86); 
if (Var9[1]== ){
FUNC58(Var1->memberVar1,FUNC59(Var9+2)); 
if (Var9[1]== ){
char *Var33=strchr(Var9+2,); 
if (Var33){
*Var33  Var30=0; 
int  Var87=FUNC43(Var1->memberVar6,Var33); 
Var65=FUNC53(Var1,Var87,&Var63); 
Var66=FUNC60(Var1,Var9+2,&Var68); 
Var72=strlen(Var9+2); 
FUNC39(Var1,Var72); 
const STRUCT6 *Var43=(const STRUCT6 *) FUNC61(Var9+2); 
if (Var72>0){
STRUCT9 *Var80=FUNC46(Var43,Var72); 
STRUCT3 *Var81=FUNC47(Var1->memberVar1,Var80,Var82,0); 
if (Var81){
if (Var14){
FUNC48(Var14); 
Var14=Var81; 
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,Var1->memberVar12,FUNC50(Var80)); 
FUNC39(Var1,Var72); 
*Var9=; 
char *Var88=Var9-2; 
while (Var88>Var2){
if (!FUNC62(*Var88)){
*Var88=0; 
Var88  Var73; 
Var9=FUNC63(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var64=FUNC63(Var9+1); 
memberVar2=FUNC43(Var1->memberVar6,Var64); 
if (FUNC64((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC65(Var1->memberVar13,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var39=*Var64; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar12+memberVar2; 
if (memberVar2){
STRUCT3 *Var81=Var14; 
if (Var81){
FUNC49(Var1->memberVar1,Var81->memberVar1,Var81->memberVar2,0,memberVar2,FUNC66(Var81)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar18=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var89=Var9+3; 
while (*Var89&&*Var89 == ){
Var89  Var30; 
Var17=FUNC67(Var1,Var2,Var89); 
else 
Var17=FUNC68(Var1,Var2,Var9+2); 
else 
bool  memberVar11=false ; 
const char *Var90[]={STRING,STRING,STRING,
const char *Var91[]={STRING,STRING,STRING,
STRUCT4  Var92[FUNC69(Var90)-1],Var93[FUNC69(Var91)-1]; 
if (Var9[1]== (){
char *Var94=Var9+3; 
char *Var29=strchr(Var94,); 
if (!Var29){
free(Var67); 
*Var29=Var95; 
STRUCT4  Var96=FUNC43(Var1->memberVar6,Var94); 
STRUCT4  Var97=FUNC43(Var1->memberVar6,Var29+1); 
for (Var16=0; Var90[Var16]; Var16  Var30){
Var92[Var16]=FUNC23(Var1->memberVar9,Var90[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var30){
Var93[Var16]=FUNC23(Var1->memberVar9,Var91[Var16]); 
for (Var16=0; Var90[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var90[Var16],Var96); 
for (Var16=0; Var91[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var91[Var16],Var97); 
if (Var19){
if (Var62){
Var1->memberVar12=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC63(Var2)); 
else 
if (Var62){
if (Var9[1]){
FUNC41(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC63(Var2)); 
if (memberVar11){
for (Var16=0; Var90[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var90[Var16],Var92[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var30){
FUNC25(Var1->memberVar9,Var91[Var16],Var93[Var16]); 
if (Var70 != -1){
FUNC58(Var1->memberVar1,Var70); 
if (Var14){
if (Var15){
FUNC25(Var1->memberVar9,STRING,0); 
FUNC48(Var14); 
if (Var65){
FUNC70(Var1->memberVar9,STRING,Var63); 
if (Var67){
FUNC8(Var1,Var67); 
FUNC71(Var67); 
if (Var69){
FUNC72(Var1->memberVar13); 
*Var9=; 
Var59=Var17; 
Var59=Var2 FUNC4(Var1->memberVar5,FUNC63(Var2)) false ; 
if (Var20 != -1){
FUNC25(Var1->memberVar9,STRING,Var20); 
if (Var21 != -1){
FUNC25(Var1->memberVar9,STRING,Var21); 
if (Var14){
FUNC48(Var14); 
return  Var59; 
",6134,0
after_cmd.c,r_core_cmd_subst_i,False,False,534,CWE-,CallExpression,free,2828,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC26(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC30(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC32(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC37(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC38(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC38(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC40(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC28(Var1,FUNC29(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
FUNC41(Var1); 
char *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC43(Var1->memberVar1,FUNC44(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC39(Var1,Var83,&Var60); 
Var63=FUNC45(Var1,Var6+2,&Var65); 
FUNC28(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC28(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC47((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC48(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC41(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC50(Var1,Var2,Var85); 
else 
Var14=FUNC51(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC41(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC28(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC54(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC43(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC54(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC28(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC55(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5719,0
after_cmd.c,r_core_cmd_subst_i,False,False,535,CWE-,CallExpression,malloc,2829,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
free(Var50); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
if (Var52&&*Var52){
FUNC26(STRING,Var52,Var8); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC27(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC31(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC33(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC38(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC39(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC39(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC41(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC29(Var1,FUNC30(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
FUNC42(Var1); 
char *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC44(Var1->memberVar1,FUNC45(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC40(Var1,Var83,&Var60); 
Var63=FUNC46(Var1,Var6+2,&Var65); 
FUNC29(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC29(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC48((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC49(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC42(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC51(Var1,Var2,Var85); 
else 
Var14=FUNC52(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC42(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC29(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC55(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC44(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC55(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC29(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC56(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5752,0
after_cmd.c,r_core_cmd_subst_i,False,False,536,CWE-,CallExpression,write,2837,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\twrite (1, ""> "", 2);\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=Var6->memberVar2; 
bool  Var11=Var6->memberVar3; 
STRUCT1  Var12=Var6->memberVar4; 
if (!Var13){
switch (*Var13){
if (Var13[1]== ){/*STRUCT2 */
else 
char *Var14=strchr(Var13,; ); 
if (Var13[1]!= *&&!strstr(Var13,STRING)){
if (Var13[1]== >){
if (*Var13 != ){
if (Var15&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var13){
char *Var16=Var2-1; 
if (*Var16 == ){
char *Var3=strchr(Var13,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var17=Var6->memberVar5->memberVar1; 
else 
char *Var18=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var13||Var2[-1]!= )){
if (*Var13 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var19[1024]; 
int  Var8; 
write(1,STRING,2); 
if (FUNC4(stdin)){
if (Var6->memberVar6){
if (!strcmp(Var19,Var4)){
char *Var16=Var2-1; 
int  Var20=FUNC5(Var6->memberVar7,STRING); 
int  Var21=FUNC5(Var6->memberVar7,STRING); 
char *Var22=Var2-1; 
const bool  Var23=(Var2[1]== >); 
char *Var24=FUNC6(Var6,Var13); 
char *Var25=FUNC7(Var6->memberVar8,Var4,1); 
const char *Var26=FUNC8(Var6->memberVar7,STRING); 
char *Var16=Var2-1; 
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
else 
int  Var21=FUNC5(Var6->memberVar7,STRING); 
const char *Var27=strstr(Var13,STRING); 
char *Var28,*Var3=strchr(Var2+1,!); 
STRUCT1  Var29=Var6->memberVar9; 
STRUCT3 *Var19; 
char *Var30=strdup(Var2+2); 
STRUCT1  Var29=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); 
int  Var31=(int ) FUNC10(Var6->memberVar5,Var2+2); 
STRUCT4 *Var32=FUNC11(Var6->memberVar10,Var6->memberVar9); 
STRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); 
char *Var36=strdup(Var2+2); 
char  Var16=*Var37; 
STRUCT1  Var29=FUNC10(Var6->memberVar5,Var2+2); 
char *Var13=FUNC13(Var6,Var2+2); 
STRUCT6 *Var34=FUNC14(Var19,Var38); 
STRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); 
char *Var39=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var40=strchr(Var2+2,); 
int  Var41=FUNC10(Var6->memberVar5,Var40); 
const STRUCT3 *Var19=(const STRUCT3 *) FUNC16(Var2+2); 
STRUCT6 *Var34=FUNC14(Var19,Var38); 
STRUCT5 *Var33=FUNC12(Var6->memberVar1,Var34,Var35,0); 
char *Var42=Var2-2; 
else 
char  Var16=*Var43; 
char *Var44=Var2+3; 
char *Var45=Var2+3; 
STRUCT1  Var46=FUNC10(Var6->memberVar5,Var45); 
STRUCT1  Var47=FUNC10(Var6->memberVar5,Var48+1); 
",1353,0
after_cmd.c,r_core_cmd_subst_i,False,False,537,CWE-,CallExpression,fgets,2838,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=Var6->memberVar2; 
bool  Var11=Var6->memberVar3; 
STRUCT1  Var12=Var6->memberVar4; 
if (!Var13){
switch (*Var13){
if (Var13[1]== ){/*STRUCT2 */
else 
char *Var14=strchr(Var13,; ); 
if (Var13[1]!= *&&!strstr(Var13,STRING)){
if (Var13[1]== >){
if (*Var13 != ){
if (Var15&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var13){
char *Var16=Var2-1; 
if (*Var16 == ){
char *Var3=strchr(Var13,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var17=Var6->memberVar5->memberVar1; 
else 
char *Var18=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var13||Var2[-1]!= )){
if (*Var13 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var19[1024]; 
int  Var8; 
fgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21
if (FUNC4(stdin)){
if (*Var19) Var19[strlen(Var19)-1]=0; 
Var8=strlen(Var19); 
if (Var6->memberVar6){
if (!strcmp(Var19,Var4)){
strcat((char *) Var6->memberVar6,Var19); 
char *Var16=Var2-1; 
int  Var22=FUNC5(Var6->memberVar7,STRING); 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
char *Var24=Var2-1; 
const bool  Var25=(Var2[1]== >); 
char *Var26=FUNC6(Var6,Var13); 
char *Var27=FUNC7(Var6->memberVar8,Var4,1); 
const char *Var28=FUNC8(Var6->memberVar7,STRING); 
char *Var16=Var2-1; 
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
else 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
const char *Var29=strstr(Var13,STRING); 
char *Var30,*Var3=strchr(Var2+1,!); 
STRUCT1  Var31=Var6->memberVar9; 
STRUCT4 *Var19; 
char *Var32=strdup(Var2+2); 
STRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); 
int  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); 
STRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var38=strdup(Var2+2); 
char  Var16=*Var39; 
STRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); 
char *Var13=FUNC13(Var6,Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var42=strchr(Var2+2,); 
int  Var43=FUNC10(Var6->memberVar5,Var42); 
const STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var44=Var2-2; 
else 
char  Var16=*Var45; 
char *Var46=Var2+3; 
char *Var47=Var2+3; 
STRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); 
STRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); 
",1424,0
after_cmd.c,r_core_cmd_subst_i,False,False,538,CWE-,CallExpression,strlen,2842,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=Var6->memberVar2; 
bool  Var11=Var6->memberVar3; 
STRUCT1  Var12=Var6->memberVar4; 
if (!Var13){
switch (*Var13){
if (Var13[1]== ){/*STRUCT2 */
else 
char *Var14=strchr(Var13,; ); 
if (Var13[1]!= *&&!strstr(Var13,STRING)){
if (Var13[1]== >){
if (*Var13 != ){
if (Var15&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var13){
char *Var16=Var2-1; 
if (*Var16 == ){
char *Var3=strchr(Var13,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var17=Var6->memberVar5->memberVar1; 
else 
char *Var18=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var13||Var2[-1]!= )){
if (*Var13 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var19[1024]; 
int  Var8; 
fgets(Var19,sizeof (Var19)-1,stdin); //Var20  STRUCT3  Var21
if (FUNC4(stdin)){
if (*Var19) Var19[strlen(Var19)-1]=0; 
Var8=strlen(Var19); 
if (Var6->memberVar6){
if (!strcmp(Var19,Var4)){
strcat((char *) Var6->memberVar6,Var19); 
char *Var16=Var2-1; 
int  Var22=FUNC5(Var6->memberVar7,STRING); 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
char *Var24=Var2-1; 
const bool  Var25=(Var2[1]== >); 
char *Var26=FUNC6(Var6,Var13); 
char *Var27=FUNC7(Var6->memberVar8,Var4,1); 
const char *Var28=FUNC8(Var6->memberVar7,STRING); 
char *Var16=Var2-1; 
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
else 
int  Var23=FUNC5(Var6->memberVar7,STRING); 
const char *Var29=strstr(Var13,STRING); 
char *Var30,*Var3=strchr(Var2+1,!); 
STRUCT1  Var31=Var6->memberVar9; 
STRUCT4 *Var19; 
char *Var32=strdup(Var2+2); 
STRUCT1  Var31=FUNC9(Var6->memberVar5,Var6->memberVar9,Var2+4); 
int  Var33=(int ) FUNC10(Var6->memberVar5,Var2+2); 
STRUCT5 *Var34=FUNC11(Var6->memberVar10,Var6->memberVar9); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var38=strdup(Var2+2); 
char  Var16=*Var39; 
STRUCT1  Var31=FUNC10(Var6->memberVar5,Var2+2); 
char *Var13=FUNC13(Var6,Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var41=FUNC15(Var6->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var42=strchr(Var2+2,); 
int  Var43=FUNC10(Var6->memberVar5,Var42); 
const STRUCT4 *Var19=(const STRUCT4 *) FUNC16(Var2+2); 
STRUCT7 *Var36=FUNC14(Var19,Var40); 
STRUCT6 *Var35=FUNC12(Var6->memberVar1,Var36,Var37,0); 
char *Var44=Var2-2; 
else 
char  Var16=*Var45; 
char *Var46=Var2+3; 
char *Var47=Var2+3; 
STRUCT1  Var48=FUNC10(Var6->memberVar5,Var47); 
STRUCT1  Var49=FUNC10(Var6->memberVar5,Var50+1); 
",1424,0
after_cmd.c,r_core_cmd_subst_i,False,False,539,CWE-,CallExpression,strlen,2843,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tint pipefd = -1;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\t\treturn ret;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tbool flgspc_changed = false;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
int  Var5=!Var6->memberVar1->memberVar1; 
int  Var7,Var8=0,Var9; 
bool  Var10=false ; 
int  Var11=-1; 
int  Var12=-1; 
bool  Var13=false ; 
bool  Var14=false ; 
bool  Var15=Var6->memberVar2; 
bool  Var16=Var6->memberVar3; 
bool  Var17=false ; 
STRUCT1  Var18=Var6->memberVar4; 
if (!Var19){
switch (*Var19){
if (Var19[1]== ){/*STRUCT2 */
int  Var9=-1; 
else 
char *Var20=strchr(Var19,; ); 
if (Var19[1]!= *&&!strstr(Var19,STRING)){
if (Var19[1]== >){
if (*Var19 != ){
if (Var21&&Var2){
int  Var8; 
if (Var2){
if (Var2>Var19){
char *Var22=Var2-1; 
if (*Var22 == ){
char *Var3=strchr(Var19,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var23=Var6->memberVar5->memberVar1; 
else 
char *Var24=FUNC2(Var6->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var8 == -1){
if (Var2&&(Var2 ==  Var19||Var2[-1]!= )){
if (*Var19 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var25[1024]; 
int  Var8; 
fgets(Var25,sizeof (Var25)-1,stdin); //Var26  STRUCT3  Var27
if (FUNC4(stdin)){
if (*Var25) Var25[strlen(Var25)-1]=0; 
Var8=strlen(Var25); 
Var6->memberVar6  STRUCT4  Var8; 
Var6->memberVar7=realloc(Var6->memberVar7,Var6->memberVar6+1); 
if (Var6->memberVar7){
if (!strcmp(Var25,Var4)){
strcat((char *) Var6->memberVar7,Var25); 
if (!*Var4){
if (!Var6->memberVar7){
else 
}else if (Var2 ==  Var19){
if (Var2){
if (Var2>Var19){
char *Var22=Var2-1; 
if (*Var22 == ){
if (Var2[0]&&Var2[1]== ){
int  Var28=1; 
int  Var29=FUNC5(Var6->memberVar8,STRING); 
int  Var30=false ; 
int  Var31=FUNC5(Var6->memberVar8,STRING); 
if (!*Var4){
if (Var2>(Var19+1)&&FUNC6(Var2[-2])){
char *Var32=Var2-1; 
if (*Var32 ==  Var33){//STRING
Var11=FUNC5(Var6->memberVar8,STRING); 
FUNC7(Var6->memberVar8,STRING,true ); 
if (!strcmp(Var4,STRING)){
FUNC7(Var6->memberVar8,STRING,Var34); 
const bool  Var35=(Var2[1]== >); 
if (*Var4 == ){
char *Var36=FUNC8(Var6,Var19); 
if (Var35){
char *Var37=FUNC9(Var6->memberVar9,Var4,1); 
if (Var37){
char *Var38=FUNC10(STRING,Var37,Var36); 
if (Var38){
FUNC11(Var6->memberVar9,Var4,Var38,1); 
free(Var38); 
else 
char *Var39=FUNC10(STRING,Var36); 
FUNC11(Var6->memberVar9,Var4,Var39,1); 
else 
char *Var39=FUNC10(STRING,Var36); 
FUNC11(Var6->memberVar9,Var4,Var39,1); 
else 
}else if (Var28>0){
if (Var9 != -1){
if (!Var29){
FUNC7(Var6->memberVar8,STRING,Var34); 
if (!Var29){
FUNC7(Var6->memberVar8,STRING,Var31); 
if (Var30){
const char *Var40=FUNC12(Var6->memberVar8,STRING); 
if (Var40&&*Var40){
FUNC13(STRING,Var40,Var4); 
FUNC7(Var6->memberVar8,STRING,Var31); 
if (Var11 != -1){
FUNC7(Var6->memberVar8,STRING,Var11); 
if (Var12 != -1){
FUNC7(Var6->memberVar8,STRING,Var12); 
Var6->memberVar10->memberVar1=false ; 
return  Var8; 
if (Var2){
if (Var2>Var19){
char *Var22=Var2-1; 
if (*Var22 == ){
bool  Var41=false ; 
if (Var41){
else 
}else if (!Var3){
else 
int  memberVar1=Var6->memberVar5->memberVar1; 
if (Var2[1]== !){
else 
int  Var31=FUNC5(Var6->memberVar8,STRING); 
FUNC7(Var6->memberVar8,STRING,0); 
FUNC7(Var6->memberVar8,STRING,Var31); 
if (!Var4){
if (*Var4 == |||*Var4 == *){
Var6->memberVar5->memberVar1=memberVar1; 
if (Var11 != -1){
FUNC7(Var6->memberVar8,STRING,Var11); 
if (*Var19 != &&*Var19){
const char *Var42=strstr(Var19,STRING); 
if (Var42){
bool  Var43=false ; 
if (Var43){
char *Var44,*Var3=strchr(Var2+1,!); 
STRUCT1  Var45=Var6->memberVar11; 
bool  Var46=false ; 
bool  Var47=false ; 
bool  Var48=false ; 
bool  Var49=false ; 
STRUCT5 *Var25; 
char *Var50=strdup(Var2+2); 
STRUCT1  Var45=FUNC14(Var6->memberVar5,Var6->memberVar11,Var2+4); 
int  Var51=(int ) FUNC15(Var6->memberVar5,Var2+2); 
STRUCT6 *Var52=FUNC16(Var6->memberVar12,Var6->memberVar11); 
STRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); 
char *Var56=strdup(Var2+2); 
char  Var22=*Var57; 
STRUCT1  Var45=FUNC15(Var6->memberVar5,Var2+2); 
char *Var19=FUNC18(Var6,Var2+2); 
STRUCT8 *Var54=FUNC19(Var25,Var58); 
STRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); 
char *Var59=FUNC20(Var6->memberVar13,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var60=strchr(Var2+2,); 
int  Var61=FUNC15(Var6->memberVar5,Var60); 
const STRUCT5 *Var25=(const STRUCT5 *) FUNC21(Var2+2); 
STRUCT8 *Var54=FUNC19(Var25,Var58); 
STRUCT7 *Var53=FUNC17(Var6->memberVar1,Var54,Var55,0); 
char *Var62=Var2-2; 
else 
char  Var22=*Var63; 
char *Var64=Var2+3; 
else 
bool  Var65=false ; 
char *Var66=Var2+3; 
STRUCT1  Var67=FUNC15(Var6->memberVar5,Var66); 
STRUCT1  Var68=FUNC15(Var6->memberVar5,Var69+1); 
if (Var11 != -1){
FUNC7(Var6->memberVar8,STRING,Var11); 
if (Var12 != -1){
FUNC7(Var6->memberVar8,STRING,Var12); 
",2435,0
after_cmd.c,r_core_cmd_subst_i,False,False,540,CWE-,CallExpression,realloc,2845,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var14=strlen(Var40); 
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
free(Var50); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
if (Var52&&*Var52){
FUNC26(STRING,Var52,Var8); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC27(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC29(Var1,FUNC30((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC28(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC31(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC32(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC33(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC34((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC38(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC39(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC39(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC40(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC41(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC29(Var1,FUNC30(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
FUNC42(Var1); 
char *Var82=FUNC43(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC44(Var1->memberVar1,FUNC45(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC40(Var1,Var83,&Var60); 
Var63=FUNC46(Var1,Var6+2,&Var65); 
FUNC29(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC47(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC34(Var40,Var69); 
STRUCT2 *Var76=FUNC35(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC37(Var75)); 
FUNC29(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC29(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC48((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC49(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC36(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC50(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC42(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC51(Var1,Var2,Var85); 
else 
Var14=FUNC52(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC53(Var86)-1],Var89[FUNC53(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC42(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC54(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC29(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC55(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC44(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC55(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC29(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC56(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC54(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5762,0
after_cmd.c,r_core_cmd_subst_i,False,False,541,CWE-,CallExpression,strcmp,2847,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\teprintf (""==> Reading from stdin until \'%s\'\\n"", str);\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\tchar *ch = ptr - 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var23){
FUNC8(STRING,Var9); 
char  Var24[1024]; 
int  Var12; 
fgets(Var24,sizeof (Var24)-1,stdin); //Var25  STRUCT4  Var26
if (FUNC9(stdin)){
if (*Var24) Var24[strlen(Var24)-1]=0; 
Var12=strlen(Var24); 
if (Var1->memberVar6){
if (!strcmp(Var24,Var9)){
strcat((char *) Var1->memberVar6,Var24); 
char *Var20=Var7-1; 
int  Var27=FUNC10(Var1->memberVar7,STRING); 
int  Var28=FUNC10(Var1->memberVar7,STRING); 
char *Var29=Var7-1; 
const bool  Var30=(Var7[1]== >); 
char *Var31=FUNC11(Var1,Var2); 
char *Var32=FUNC12(Var1->memberVar8,Var9,1); 
const char *Var33=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var28=FUNC10(Var1->memberVar7,STRING); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar9; 
STRUCT5 *Var24; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT8 *Var42=FUNC19(Var24,Var46); 
STRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var47=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC15(Var1->memberVar5,Var18); 
const STRUCT5 *Var24=(const STRUCT5 *) FUNC21(Var7+2); 
STRUCT8 *Var42=FUNC19(Var24,Var46); 
STRUCT7 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); 
",1653,0
after_cmd.c,r_core_cmd_subst_i,False,False,542,CWE-,CallExpression,strcat,2850,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n', '\t\t\t\t\tif (feof (stdin)) {\n', ""\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n"", '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
fgets(Var40,sizeof (Var40)-1,stdin); //Var41  STRUCT5  Var42
if (FUNC17(stdin)){
if (*Var40) Var40[strlen(Var40)-1]=0; 
Var14=strlen(Var40); 
Var1->memberVar10  STRUCT6  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT7 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var43=1; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
int  Var45=false ; 
int  Var46=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var47=Var6-1; 
if (*Var47 ==  Var48){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var49=(Var6[1]== >); 
if (*Var8 == ){
char *Var50=FUNC21(Var1,Var2); 
if (Var49){
char *Var51=FUNC22(Var1->memberVar5,Var8,1); 
if (Var51){
char *Var52=FUNC23(STRING,Var51,Var50); 
if (Var52){
FUNC24(Var1->memberVar5,Var8,Var52,1); 
else 
char *Var53=FUNC23(STRING,Var50); 
FUNC24(Var1->memberVar5,Var8,Var53,1); 
else 
char *Var53=FUNC23(STRING,Var50); 
FUNC24(Var1->memberVar5,Var8,Var53,1); 
else 
}else if (Var43>0){
if (Var15 != -1){
if (!Var44){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var44){
FUNC11(Var1->memberVar8,STRING,Var46); 
if (Var45){
const char *Var54=FUNC25(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var46); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var55=false ; 
if (Var55){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC26(Var1,Var6+1); 
else 
int  Var46=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var46); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var56=strstr(Var2,STRING); 
if (Var56){
bool  Var57=false ; 
if (Var57){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var58=0; 
if (Var6){
char *Var59,*Var7=strchr(Var6+1,!); 
STRUCT3  Var60=Var1->memberVar6; 
bool  Var61=false ; 
char *Var62=NULL ; 
const char *Var63=NULL ; 
bool  Var64=false ; 
bool  Var65=false ; 
char *Var66=NULL ; 
char *Var67=NULL ; 
bool  Var68=false ; 
int  Var69=-1; 
int  Var70,Var71; 
STRUCT7 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var72=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC28(Var1,FUNC29((Var73) Var60-(Var73) Var1->memberVar6)); 
else 
Var60=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var60,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var68=FUNC30(Var1->memberVar14,Var6+2); 
int  Var74=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT8 *Var75=FUNC31(Var1->memberVar15,Var1->memberVar6); 
if (Var75){
if (Var74 >= 0&&Var74<Var75->memberVar1){
STRUCT9  Var76=FUNC32(Var75,Var74); 
FUNC4(Var1,Var75->memberVar2+Var76,1); 
Var23=Var1->memberVar13=true ; 
if (Var59){
STRUCT10 *Var77=FUNC33((const STRUCT7 *) Var59,Var70); 
STRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); 
if (Var78){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var70; 
memcpy(Var1->memberVar16,Var59,Var70); 
if (Var6[1]== ){
STRUCT3  Var80; 
char *Var81=strdup(Var6+2); 
char *Var82=FUNC37(Var81); 
if (Var82){
char  Var34=*Var82; 
Var80=FUNC38(Var1->memberVar17,Var81); 
Var80=FUNC5(Var1->memberVar7,Var83); 
else 
Var80=FUNC38(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var80,1); 
Var23=Var1->memberVar13=true ; 
Var64=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var62); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC40(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC28(Var1,FUNC29(Var71)); 
if (Var71>0){
STRUCT10 *Var77=FUNC33(Var40,Var71); 
STRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); 
if (Var78){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); 
FUNC28(Var1,Var71); 
FUNC41(Var1); 
char *Var84=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var84){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var84),1); 
if (Var6[1]== ){
Var69=Var1->memberVar1->STRUCT11  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC43(Var1->memberVar1,FUNC44(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var85=FUNC5(Var1->memberVar7,Var31); 
Var64=FUNC39(Var1,Var85,&Var62); 
Var65=FUNC45(Var1,Var6+2,&Var67); 
FUNC28(Var1,Var71); 
const STRUCT7 *Var40=(const STRUCT7 *) FUNC46(Var6+2); 
if (Var71>0){
STRUCT10 *Var77=FUNC33(Var40,Var71); 
STRUCT2 *Var78=FUNC34(Var1->memberVar1,Var77,Var79,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var78){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,Var1->memberVar6,FUNC36(Var77)); 
FUNC28(Var1,Var71); 
char *Var86=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC28(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var63); 
if (FUNC47((STRUCT7) Var6[1])&&!memberVar2){
if (!FUNC48(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var63; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var78=Var11; 
if (Var78){
FUNC35(Var1->memberVar1,Var78->memberVar1,Var78->memberVar2,0,memberVar2,FUNC49(Var78)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC41(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var87=Var6+3; 
Var14=FUNC50(Var1,Var2,Var87); 
else 
Var14=FUNC51(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var88[]={STRING,STRING,STRING,
const char *Var89[]={STRING,STRING,STRING,
STRUCT3  Var90[FUNC52(Var88)-1],Var91[FUNC52(Var89)-1]; 
if (Var6[1]== (){
char *Var92=Var6+3; 
char *Var29=strchr(Var92,); 
if (!Var29){
STRUCT3  Var93=FUNC5(Var1->memberVar7,Var92); 
STRUCT3  Var94=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var88[Var13]; Var13  Var95){
Var90[Var13]=FUNC10(Var1->memberVar8,Var88[Var13]); 
for (Var13=0; Var89[Var13]; Var13  Var95){
Var91[Var13]=FUNC10(Var1->memberVar8,Var89[Var13]); 
for (Var13=0; Var88[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var88[Var13],Var93); 
for (Var13=0; Var89[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var89[Var13],Var94); 
if (Var16){
if (Var61){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
else 
if (Var61){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC41(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
if (memberVar13){
for (Var13=0; Var88[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var88[Var13],Var90[Var13]); 
for (Var13=0; Var89[Var13]; Var13  Var95){
FUNC11(Var1->memberVar8,Var89[Var13],Var91[Var13]); 
if (Var7){
FUNC28(Var1,Var24); 
if (Var65){
Var1->memberVar2=Var21; 
FUNC54(Var1->memberVar8,STRING,Var67); 
if (Var69 != -1){
FUNC43(Var1->memberVar1,Var69); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var64){
FUNC54(Var1->memberVar8,STRING,Var62); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC28(Var1,Var24); 
if (Var66){
FUNC3(Var1,Var66); 
if (Var68){
FUNC55(Var1->memberVar14); 
Var58=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5781,0
after_cmd.c,r_core_cmd_subst_i,False,False,543,CWE-,CallExpression,free,2862,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=NULL ; 
char *Var6,*Var7,*Var8; 
char *Var9=NULL ; 
char *Var10=NULL ; 
STRUCT2 *Var11=NULL ; 
int  Var12=!Var1->memberVar1->memberVar1; 
int  Var13,Var14=0,Var15; 
bool  Var16=false ; 
int  Var17=-1; 
int  Var18=-1; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=Var1->memberVar2; 
bool  Var22=Var1->memberVar3; 
bool  Var23=false ; 
STRUCT3  Var24=Var1->memberVar4; 
int  Var25=-1; 
if (!Var2){
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC2(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var15=-1; 
STRUCT3  Var26=Var27; 
char *Var28,*Var29; 
if (Var20){
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
FUNC3(Var1,Var2); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var26=Var1->memberVar6; 
FUNC4(Var1,FUNC5(Var1->memberVar7,Var29+2),1); 
const bool  Var32=Var29[2]== >; 
if (Var29&&*Var29&&Var29[1]== |){
FUNC6(Var1,Var2,Var8); 
else 
FUNC2(Var1->memberVar5,Var28); 
if (Var26 !=  Var27){
FUNC4(Var1,Var26,1); 
if (!Var29){
if (Var19){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC2(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC7(Var1,Var33); 
if (*Var2 != ){
if (Var3&&Var6){
int  Var14; 
if (FUNC8(Var1,Var2) == -1){
Var14=FUNC8(Var1,Var2); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
char *Var7=strchr(Var2,); 
if (!Var7||(Var7&&Var7>Var6)){
if (!Var5||(Var5&&Var5>Var6)){
if (!strcmp(Var6+1,STRING)){//STRING
FUNC7(Var1,Var35); 
else 
}else if (!FUNC9(Var6+1,STRING,1)){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
else 
}else if (!strcmp(Var6+1,STRING)){//STRING
Var14=*Var2 FUNC12(Var1,STRING,Var2) 0; 
else 
}else if (Var6[1]){//STRING
int  Var37=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC6(Var1,Var2,Var6+1); 
else 
char *Var38=FUNC13(Var1->memberVar1,Var6+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var18=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var36); 
while (Var6&&*Var6&&Var6[1]== &){
Var14=FUNC2(Var1->memberVar5,Var2); 
if (Var14 == -1){
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
FUNC14(Var1->memberVar9); 
if (Var6&&(Var6 ==  Var2||Var6[-1]!= )){
if (*Var2 != ){
int  Var39=0; 
FUNC15(Var1,Var39,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
if (Var6){
if (FUNC16()->memberVar1){
if (Var6[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var40[1024]; 
int  Var14; 
if (FUNC17(stdin)){
Var1->memberVar10  STRUCT5  Var14; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var40,Var8)){
strcat((char *) Var1->memberVar9,Var40); 
if (!*Var8){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC18(Var8,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var6 ==  Var2){
return FUNC19(Var1,(const char *) Var1->memberVar9); 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
if (Var6[0]&&Var6[1]== ){
FUNC7(Var1,Var33); 
int  Var41=1; 
int  Var42=FUNC10(Var1->memberVar8,STRING); 
int  Var43=false ; 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
if (!*Var8){
if (Var6>(Var2+1)&&FUNC20(Var6[-2])){
char *Var45=Var6-1; 
if (*Var45 ==  Var46){//STRING
Var17=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var8,STRING)){
FUNC11(Var1->memberVar8,STRING,Var36); 
const bool  Var47=(Var6[1]== >); 
if (*Var8 == ){
char *Var48=FUNC21(Var1,Var2); 
if (Var47){
char *Var49=FUNC22(Var1->memberVar5,Var8,1); 
if (Var49){
char *Var50=FUNC23(STRING,Var49,Var48); 
if (Var50){
FUNC24(Var1->memberVar5,Var8,Var50,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
char *Var51=FUNC23(STRING,Var48); 
FUNC24(Var1->memberVar5,Var8,Var51,1); 
else 
}else if (Var41>0){
if (Var15 != -1){
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var36); 
Var14=FUNC8(Var1,Var2); 
if (!Var42){
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var43){
const char *Var52=FUNC25(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar11->memberVar1=false ; 
if (Var6){
if (Var6>Var2){
char *Var34=Var6-1; 
if (*Var34 == ){
bool  Var53=false ; 
if (Var53){
else 
}else if (!Var7){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var6[1]== !){
Var8=FUNC26(Var1,Var6+1); 
else 
int  Var44=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var8=FUNC21(Var1,Var6+1); 
Var1->memberVar12=false ; 
FUNC11(Var1->memberVar8,STRING,Var44); 
if (!Var8){
if (*Var8 == |||*Var8 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var14=FUNC8(Var1,Var2); 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (*Var2 != &&*Var2){
const char *Var54=strstr(Var2,STRING); 
if (Var54){
bool  Var55=false ; 
if (Var55){
Var23=Var1->memberVar13=Var6 true false ; 
int  Var56=0; 
if (Var6){
char *Var57,*Var7=strchr(Var6+1,!); 
STRUCT3  Var58=Var1->memberVar6; 
bool  Var59=false ; 
char *Var60=NULL ; 
const char *Var61=NULL ; 
bool  Var62=false ; 
bool  Var63=false ; 
char *Var64=NULL ; 
char *Var65=NULL ; 
bool  Var66=false ; 
int  Var67=-1; 
int  Var68,Var69; 
STRUCT6 *Var40; 
if (Var6[1]== ){
else 
}else if (Var6[1]== %){//STRING
char *Var70=strdup(Var6+2); 
else 
}else if (Var6[1]== .){//STRING
if (Var6[2]== .){//STRING
if (Var6[3]== .){//STRING
STRUCT3  Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+4); 
FUNC28(Var1,FUNC29((Var71) Var58-(Var71) Var1->memberVar6)); 
else 
Var58=FUNC27(Var1->memberVar7,Var1->memberVar6,Var6+3); 
FUNC4(Var1,Var58,1); 
Var23=Var1->memberVar13=true ; 
else 
}else if (Var6[0]&&Var6[1]== &&Var6[2]){
switch (Var6[0]){
Var66=FUNC30(Var1->memberVar14,Var6+2); 
int  Var72=(int ) FUNC5(Var1->memberVar7,Var6+2); 
STRUCT7 *Var73=FUNC31(Var1->memberVar15,Var1->memberVar6); 
if (Var73){
if (Var72 >= 0&&Var72<Var73->memberVar1){
STRUCT8  Var74=FUNC32(Var73,Var72); 
FUNC4(Var1,Var73->memberVar2+Var74,1); 
Var23=Var1->memberVar13=true ; 
if (Var57){
STRUCT9 *Var75=FUNC33((const STRUCT6 *) Var57,Var68); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
if (Var40){
free(Var1->memberVar16); 
Var1->memberVar16=Var40; 
Var1->memberVar4=Var68; 
memcpy(Var1->memberVar16,Var57,Var68); 
if (Var6[1]== ){
STRUCT3  Var78; 
char *Var79=strdup(Var6+2); 
char *Var80=FUNC37(Var79); 
if (Var80){
char  Var34=*Var80; 
Var78=FUNC38(Var1->memberVar17,Var79); 
Var78=FUNC5(Var1->memberVar7,Var81); 
else 
Var78=FUNC38(Var1->memberVar17,Var6+2); 
FUNC4(Var1,Var78,1); 
Var23=Var1->memberVar13=true ; 
Var62=FUNC39(Var1,FUNC5(Var1->memberVar7,Var6+2),&Var60); 
Var25=FUNC10(Var1->memberVar8,STRING); 
FUNC11(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC5(Var1->memberVar7,Var6+2); 
if (memberVar2){
FUNC12(Var1,STRING,Var6+2); 
Var23=Var1->memberVar13=true ; 
char *Var2=FUNC40(Var1,Var6+2); 
if (Var6[1]== ){
if (Var40){
FUNC28(Var1,FUNC29(Var69)); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
FUNC41(Var1); 
char *Var82=FUNC42(Var1->memberVar18,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var82){
FUNC4(Var1,FUNC5(Var1->memberVar7,Var82),1); 
if (Var6[1]== ){
Var67=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC43(Var1->memberVar1,FUNC44(Var6+2)); 
if (Var6[1]== ){
char *Var31=strchr(Var6+2,); 
if (Var31){
int  Var83=FUNC5(Var1->memberVar7,Var31); 
Var62=FUNC39(Var1,Var83,&Var60); 
Var63=FUNC45(Var1,Var6+2,&Var65); 
FUNC28(Var1,Var69); 
const STRUCT6 *Var40=(const STRUCT6 *) FUNC46(Var6+2); 
if (Var69>0){
STRUCT9 *Var75=FUNC33(Var40,Var69); 
STRUCT2 *Var76=FUNC34(Var1->memberVar1,Var75,Var77,0); 
if (!Var1->memberVar1->memberVar1){
FUNC11(Var1->memberVar8,STRING,1); 
if (Var76){
if (Var12){
FUNC11(Var1->memberVar8,STRING,1); 
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,Var1->memberVar6,FUNC36(Var75)); 
FUNC28(Var1,Var69); 
char *Var84=Var6-2; 
if (Var7){
if (strlen(Var6+1) == 13&&strlen(Var7+1) == 6&&
!memcmp(Var6+1,STRING,2)&&
!memcmp(Var7+1,STRING,2)){
else 
}else if (strlen(Var6+1) == 9&&strlen(Var7+1) == 4){
if (!Var7[1]){
FUNC28(
Var1,FUNC5(Var1->memberVar7,Var7+1)); 
memberVar2=FUNC5(Var1->memberVar7,Var61); 
if (FUNC47((STRUCT6) Var6[1])&&!memberVar2){
if (!FUNC48(Var1->memberVar14,Var6+1)){
else 
char  Var34=*Var61; 
if (Var34 == -||Var34 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var76=Var11; 
if (Var76){
FUNC35(Var1->memberVar1,Var76->memberVar1,Var76->memberVar2,0,memberVar2,FUNC49(Var76)); 
if (Var9){
Var1->memberVar19=!!Var11; 
if (Var1->memberVar19){
FUNC41(Var1); 
if (Var6[1]== ){
if (Var6[2]== ){
char *Var85=Var6+3; 
Var14=FUNC50(Var1,Var2,Var85); 
else 
Var14=FUNC51(Var1,Var2,Var6+2); 
else 
bool  memberVar13=false ; 
const char *Var86[]={STRING,STRING,STRING,
const char *Var87[]={STRING,STRING,STRING,
STRUCT3  Var88[FUNC52(Var86)-1],Var89[FUNC52(Var87)-1]; 
if (Var6[1]== (){
char *Var90=Var6+3; 
char *Var29=strchr(Var90,); 
if (!Var29){
STRUCT3  Var91=FUNC5(Var1->memberVar7,Var90); 
STRUCT3  Var92=FUNC5(Var1->memberVar7,Var29+1); 
for (Var13=0; Var86[Var13]; Var13  Var93){
Var88[Var13]=FUNC10(Var1->memberVar8,Var86[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
Var89[Var13]=FUNC10(Var1->memberVar8,Var87[Var13]); 
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var91); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var92); 
if (Var16){
if (Var59){
Var1->memberVar6=memberVar2; 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
else 
if (Var59){
if (Var6[1]){
FUNC4(Var1,memberVar2,1); 
FUNC41(Var1); 
Var14=FUNC2(Var1->memberVar5,FUNC53(Var2)); 
if (memberVar13){
for (Var13=0; Var86[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var86[Var13],Var88[Var13]); 
for (Var13=0; Var87[Var13]; Var13  Var93){
FUNC11(Var1->memberVar8,Var87[Var13],Var89[Var13]); 
if (Var7){
FUNC28(Var1,Var24); 
if (Var63){
Var1->memberVar2=Var21; 
FUNC54(Var1->memberVar8,STRING,Var65); 
if (Var67 != -1){
FUNC43(Var1->memberVar1,Var67); 
if (Var11){
if (Var12){
FUNC11(Var1->memberVar8,STRING,0); 
if (Var62){
FUNC54(Var1->memberVar8,STRING,Var60); 
Var1->memberVar3=Var22; 
if (Var24 !=  Var1->memberVar4){
FUNC28(Var1,Var24); 
if (Var64){
FUNC3(Var1,Var64); 
if (Var66){
FUNC55(Var1->memberVar14); 
Var56=Var2 FUNC2(Var1->memberVar5,FUNC53(Var2)) false ; 
if (Var17 != -1){
FUNC11(Var1->memberVar8,STRING,Var17); 
if (Var18 != -1){
FUNC11(Var1->memberVar8,STRING,Var18); 
Var1->memberVar2=Var21; 
Var1->memberVar3=Var22; 
if (Var25 != -1){
FUNC11(Var1->memberVar8,STRING,Var25); 
",5719,0
after_cmd.c,r_core_cmd_subst_i,False,False,544,CWE-,CallExpression,memmove,2885,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC9(Var1->memberVar7,STRING); 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC10(Var7[-2])){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC11(Var1,Var2); 
char *Var29=FUNC12(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
const char *Var31=strstr(Var2,STRING); 
char *Var32,*Var8=strchr(Var7+1,!); 
STRUCT2  Var33=Var1->memberVar9; 
char *Var34=strdup(Var7+2); 
char *Var35=strchr(Var34,=); 
STRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var41=strdup(Var7+2); 
char  Var20=*Var42; 
STRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var44=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var46=Var7-2; 
else 
char  Var20=*Var47; 
char *Var48=Var7+3; 
char *Var49=Var7+3; 
char *Var19=strchr(Var49,); 
STRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); 
STRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); 
",1636,0
after_cmd.c,r_core_cmd_subst_i,False,False,545,CWE-,CallExpression,strlen,2885,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC9(Var1->memberVar7,STRING); 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC10(Var7[-2])){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC11(Var1,Var2); 
char *Var29=FUNC12(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
const char *Var31=strstr(Var2,STRING); 
char *Var32,*Var8=strchr(Var7+1,!); 
STRUCT2  Var33=Var1->memberVar9; 
char *Var34=strdup(Var7+2); 
char *Var35=strchr(Var34,=); 
STRUCT2  Var33=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var36=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var37=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var41=strdup(Var7+2); 
char  Var20=*Var42; 
STRUCT2  Var33=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var43=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var44=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var45=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var38=FUNC17(Var1->memberVar1,Var39,Var40,0); 
char *Var46=Var7-2; 
else 
char  Var20=*Var47; 
char *Var48=Var7+3; 
char *Var49=Var7+3; 
char *Var19=strchr(Var49,); 
STRUCT2  Var50=FUNC15(Var1->memberVar5,Var49); 
STRUCT2  Var51=FUNC15(Var1->memberVar5,Var19+1); 
",1636,0
after_cmd.c,r_core_cmd_subst_i,False,False,546,CWE-,CallExpression,strcmp,2922,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tint pipefd = -1;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\t\tr_file_rm (str);\n', '\t\t\tfree (str);\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
int  Var13=-1; 
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=1; 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
int  Var26=false ; 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
char *Var28=Var7-1; 
const bool  Var29=(Var7[1]== >); 
if (*Var9 == ){
char *Var30=FUNC10(Var1,Var2); 
if (Var29){
char *Var31=FUNC11(Var1->memberVar8,Var9,1); 
if (Var31){
char *Var32=FUNC12(STRING,Var31,Var30); 
if (Var32){
FUNC13(Var1->memberVar8,Var9,Var32,1); 
else 
char *Var33=FUNC12(STRING,Var30); 
FUNC13(Var1->memberVar8,Var9,Var33,1); 
else 
char *Var33=FUNC12(STRING,Var30); 
FUNC13(Var1->memberVar8,Var9,Var33,1); 
else 
}else if (Var24>0){
Var13=FUNC14(Var9,Var24,Var29); 
if (Var26){
const char *Var34=FUNC15(Var1->memberVar7,STRING); 
if (Var34&&*Var34){
FUNC16(STRING,Var34,Var9); 
FUNC17(Var9); 
free(Var9); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
const char *Var35=strstr(Var2,STRING); 
char *Var36,*Var8=strchr(Var7+1,!); 
STRUCT2  Var37=Var1->memberVar9; 
char *Var38=strdup(Var7+2); 
char *Var39=strchr(Var38,=); 
STRUCT2  Var37=FUNC18(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var40=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT4 *Var41=FUNC20(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); 
char *Var45=strdup(Var7+2); 
char  Var20=*Var46; 
STRUCT2  Var37=FUNC19(Var1->memberVar5,Var7+2); 
char *Var2=FUNC22(Var1,Var7+2); 
STRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); 
char *Var47=FUNC23(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC19(Var1->memberVar5,Var18); 
const STRUCT6 *Var49=(const STRUCT6 *) FUNC24(Var7+2); 
STRUCT5 *Var42=FUNC21(Var1->memberVar1,Var43,Var44,0); 
char *Var50=Var7-2; 
else 
char  Var20=*Var51; 
char *Var52=Var7+3; 
char *Var53=Var7+3; 
char *Var19=strchr(Var53,); 
STRUCT2  Var54=FUNC19(Var1->memberVar5,Var53); 
STRUCT2  Var55=FUNC19(Var1->memberVar5,Var19+1); 
",1839,0
after_cmd.c,r_core_cmd_subst_i,False,False,547,CWE-,CallExpression,free,2938,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tret = strlen (buf);\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tstr = r_file_temp (""dumpedit"");\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', '\t\t\t\t\t\tfree (two);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tut8 *buf;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
Var1->memberVar6=malloc(1); 
Var1->memberVar7=0; 
char  Var24[1024]; 
int  Var12; 
if (FUNC8(stdin)){
Var12=strlen(Var24); 
Var1->memberVar7  STRUCT4  Var12; 
Var1->memberVar6=realloc(Var1->memberVar6,Var1->memberVar7+1); 
if (Var1->memberVar6){
if (!strcmp(Var24,Var9)){
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var23){
if (!*Var9){
Var1->memberVar6=(STRUCT5 *) FUNC9(Var9,&Var1->memberVar7); 
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC10(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var25=FUNC11(Var1->memberVar8,STRING); 
int  Var26=FUNC11(Var1->memberVar8,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
char *Var27=Var7-1; 
if (!strcmp(Var9,STRING)){
Var9=FUNC12(STRING); 
const bool  Var28=(Var7[1]== >); 
if (*Var9 == ){
char *Var29=FUNC13(Var1,Var2); 
if (Var28){
char *Var30=FUNC14(Var1->memberVar9,Var9,1); 
if (Var30){
char *Var31=FUNC15(STRING,Var30,Var29); 
if (Var31){
FUNC16(Var1->memberVar9,Var9,Var31,1); 
free(Var31); 
else 
char *Var32=FUNC15(STRING,Var29); 
else 
char *Var32=FUNC15(STRING,Var29); 
const char *Var33=FUNC17(Var1->memberVar8,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var26=FUNC11(Var1->memberVar8,STRING); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar10; 
STRUCT5 *Var24; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC18(Var1->memberVar5,Var1->memberVar10,Var7+4); 
int  Var39=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var40=FUNC20(Var1->memberVar11,Var1->memberVar10); 
STRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC19(Var1->memberVar5,Var7+2); 
char *Var2=FUNC22(Var1,Var7+2); 
STRUCT8 *Var42=FUNC23(Var24,Var46); 
STRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); 
char *Var47=FUNC24(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC19(Var1->memberVar5,Var18); 
const STRUCT5 *Var24=(const STRUCT5 *) FUNC25(Var7+2); 
STRUCT8 *Var42=FUNC23(Var24,Var46); 
STRUCT7 *Var41=FUNC21(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC19(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC19(Var1->memberVar5,Var19+1); 
",1953,0
after_cmd.c,r_core_cmd_subst_i,False,False,548,CWE-,CallExpression,free,2943,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\t\tfree (n);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
if (*Var9 == ){
char *Var28=FUNC9(Var1,Var2); 
if (Var27){
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
if (Var29){
char *Var30=FUNC11(STRING,Var29,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
FUNC12(Var1->memberVar8,Var9,Var31,1); 
free(Var31); 
else 
char *Var31=FUNC11(STRING,Var28); 
const char *Var32=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
const char *Var33=strstr(Var2,STRING); 
char *Var34,*Var8=strchr(Var7+1,!); 
STRUCT2  Var35=Var1->memberVar9; 
char *Var36=strdup(Var7+2); 
char *Var37=strchr(Var36,=); 
STRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var43=strdup(Var7+2); 
char  Var20=*Var44; 
STRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var46=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var48=Var7-2; 
else 
char  Var20=*Var49; 
char *Var50=Var7+3; 
char *Var51=Var7+3; 
char *Var19=strchr(Var51,); 
STRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); 
",1641,0
after_cmd.c,r_core_cmd_subst_i,False,False,549,CWE-,CallExpression,free,2948,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', '\t\t\t\tfree (n);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
if (*Var9 == ){
char *Var28=FUNC9(Var1,Var2); 
if (Var27){
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
char *Var30=FUNC11(STRING,Var29,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
FUNC12(Var1->memberVar8,Var9,Var31,1); 
free(Var31); 
const char *Var32=FUNC13(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
const char *Var33=strstr(Var2,STRING); 
char *Var34,*Var8=strchr(Var7+1,!); 
STRUCT2  Var35=Var1->memberVar9; 
char *Var36=strdup(Var7+2); 
char *Var37=strchr(Var36,=); 
STRUCT2  Var35=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var38=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var39=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var43=strdup(Var7+2); 
char  Var20=*Var44; 
STRUCT2  Var35=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var45=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var46=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var47=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var40=FUNC17(Var1->memberVar1,Var41,Var42,0); 
char *Var48=Var7-2; 
else 
char  Var20=*Var49; 
char *Var50=Var7+3; 
char *Var51=Var7+3; 
char *Var19=strchr(Var51,); 
STRUCT2  Var52=FUNC15(Var1->memberVar5,Var51); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var19+1); 
",1633,0
after_cmd.c,r_core_cmd_subst_i,False,False,550,CWE-,CallExpression,free,2951,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
if (*Var9 == ){
char *Var28=FUNC9(Var1,Var2); 
if (Var27){
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
if (Var29){
char *Var30=FUNC11(STRING,Var29,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
else 
char *Var31=FUNC11(STRING,Var28); 
else 
const char *Var32=FUNC12(Var1->memberVar7,STRING); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
const char *Var33=strstr(Var2,STRING); 
char *Var34,*Var8=strchr(Var7+1,!); 
STRUCT2  Var35=Var1->memberVar9; 
char *Var36=strdup(Var7+2); 
char *Var37=strchr(Var36,=); 
STRUCT2  Var35=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var38=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var39=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); 
char *Var43=strdup(Var7+2); 
char  Var20=*Var44; 
STRUCT2  Var35=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); 
char *Var45=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var46=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var47=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var40=FUNC16(Var1->memberVar1,Var41,Var42,0); 
char *Var48=Var7-2; 
else 
char  Var20=*Var49; 
char *Var50=Var7+3; 
char *Var51=Var7+3; 
char *Var19=strchr(Var51,); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var51); 
STRUCT2  Var53=FUNC14(Var1->memberVar5,Var19+1); 
",1617,0
after_cmd.c,r_core_cmd_subst_i,False,False,551,CWE-,CallExpression,free,2977,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tint pipefd = -1;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tstr = r_file_temp (""dumpedit"");\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tpipefd = r_cons_pipe_open (str, fdn, appendResult);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tif (editor && *editor) {\n', '\t\t\t\tr_sys_cmdf (""%s \'%s\'"", editor, str);\n', '\t\t\t\tr_file_rm (str);\n', '\t\t\tfree (str);\n', '\t\t\tchar *ch = ptr - 1;\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
int  Var13=-1; 
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC8(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=1; 
int  Var25=FUNC9(Var1->memberVar7,STRING); 
int  Var26=false ; 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
char *Var28=Var7-1; 
if (!strcmp(Var9,STRING)){
Var9=FUNC10(STRING); 
const bool  Var29=(Var7[1]== >); 
if (*Var9 == ){
char *Var30=FUNC11(Var1,Var2); 
if (Var29){
char *Var31=FUNC12(Var1->memberVar8,Var9,1); 
if (Var31){
char *Var32=FUNC13(STRING,Var31,Var30); 
if (Var32){
FUNC14(Var1->memberVar8,Var9,Var32,1); 
else 
char *Var33=FUNC13(STRING,Var30); 
FUNC14(Var1->memberVar8,Var9,Var33,1); 
else 
char *Var33=FUNC13(STRING,Var30); 
FUNC14(Var1->memberVar8,Var9,Var33,1); 
else 
}else if (Var24>0){
Var13=FUNC15(Var9,Var24,Var29); 
if (Var26){
const char *Var34=FUNC16(Var1->memberVar7,STRING); 
if (Var34&&*Var34){
FUNC17(STRING,Var34,Var9); 
FUNC18(Var9); 
free(Var9); 
char *Var20=Var7-1; 
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var27=FUNC9(Var1->memberVar7,STRING); 
const char *Var35=strstr(Var2,STRING); 
char *Var36,*Var8=strchr(Var7+1,!); 
STRUCT2  Var37=Var1->memberVar9; 
char *Var38=strdup(Var7+2); 
char *Var39=strchr(Var38,=); 
STRUCT2  Var37=FUNC19(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var40=(int ) FUNC20(Var1->memberVar5,Var7+2); 
STRUCT4 *Var41=FUNC21(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); 
char *Var45=strdup(Var7+2); 
char  Var20=*Var46; 
STRUCT2  Var37=FUNC20(Var1->memberVar5,Var7+2); 
char *Var2=FUNC23(Var1,Var7+2); 
STRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); 
char *Var47=FUNC24(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var48=FUNC20(Var1->memberVar5,Var18); 
const STRUCT6 *Var49=(const STRUCT6 *) FUNC25(Var7+2); 
STRUCT5 *Var42=FUNC22(Var1->memberVar1,Var43,Var44,0); 
char *Var50=Var7-2; 
else 
char  Var20=*Var51; 
char *Var52=Var7+3; 
char *Var53=Var7+3; 
char *Var19=strchr(Var53,); 
STRUCT2  Var54=FUNC20(Var1->memberVar5,Var53); 
STRUCT2  Var55=FUNC20(Var1->memberVar5,Var19+1); 
",1863,0
after_cmd.c,r_core_cmd_subst_i,False,False,552,CWE-,CallExpression,strchr,2992,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\t*ptr2 = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', ""\t\t*ptr = '@';\n"", '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
*Var7=0; 
if (FUNC11(Var1,Var2) == -1){
Var2=Var7+1; 
Var15=FUNC11(Var1,Var2); 
*Var7=; ; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC12(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC13(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC14(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC15(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC16(Var1,Var38,Var2); 
FUNC17(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC18()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var26){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var26){
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=1; 
int  Var41=FUNC19(Var1->memberVar8,STRING); 
int  Var42=false ; 
int  Var43=FUNC19(Var1->memberVar8,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC20(Var7[-2])){
char *Var44=Var7-1; 
const bool  Var45=(Var7[1]== >); 
if (*Var9 == ){
char *Var46=FUNC21(Var1,Var2); 
char *Var47=FUNC22(Var1->memberVar5,Var9,1); 
char *Var48=FUNC23(STRING,Var47,Var46); 
else 
char *Var49=FUNC23(STRING,Var46); 
else 
char *Var49=FUNC23(STRING,Var46); 
else 
}else if (Var40>0){
if (Var16 != -1){
Var15=FUNC11(Var1,Var2); 
const char *Var50=FUNC24(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
bool  Var51=false ; 
int  Var52=1; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var51){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var7=0; 
*Var8=0; 
if (Var7[1]== !){
Var9=FUNC25(Var1,Var7+1); 
else 
int  Var43=FUNC19(Var1->memberVar8,STRING); 
Var9=FUNC21(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var52&&Var9){
for (Var14=0; Var9[Var14]; Var14  Var26){
if (Var9[Var14]==  Var49){
Var9[Var14]=; 
Var9=FUNC26(Var9,Var8+1); 
Var2=FUNC26(strdup(Var2),Var9); 
Var15=FUNC11(Var1,Var2); 
free(Var2); 
free(Var9); 
return  Var15; 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var53=false ; 
if (Var53){
if (*Var2 != .){
Var11=FUNC27(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
Var22=Var1->memberVar9=Var7 true false ; 
int  Var54=0; 
if (Var7){
char *Var55,*Var8=strchr(Var7+1,!); 
STRUCT3  Var56=Var1->memberVar10; 
bool  Var57=false ; 
char *Var58=NULL ; 
const char *Var59=NULL ; 
bool  Var60=false ; 
bool  Var61=false ; 
char *Var62=NULL ; 
char *Var63=NULL ; 
bool  Var64=false ; 
int  Var65,Var66; 
STRUCT5 *Var39; 
*Var7  Var26=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var26){
if (*Var7&&Var7[1]== ){
else 
Var7  Var67; 
Var7=FUNC28(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var68=strdup(Var7+2); 
char *Var69=strchr(Var68,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+4); 
else 
Var56=FUNC29(Var1->memberVar6,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var64=FUNC30(Var1->memberVar11,Var7+2); 
int  Var70=(int ) FUNC31(Var1->memberVar6,Var7+2); 
STRUCT6 *Var71=FUNC32(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var72=FUNC33(Var71,Var70); 
Var55=FUNC34(Var7+2,&Var65); 
if (Var55){
STRUCT8 *Var73=FUNC35((const STRUCT5 *) Var55,Var65); 
STRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); 
else 
FUNC5(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var76; 
char *Var77=strdup(Var7+2); 
char *Var78=FUNC37(Var77); 
if (Var78){
char  Var35=*Var78; 
else 
Var76=FUNC38(Var1->memberVar13,Var7+2); 
Var60=FUNC39(Var1,FUNC31(Var1->memberVar6,Var7+2),&Var58); 
STRUCT3  Var56=FUNC31(Var1->memberVar6,Var7+2); 
if (Var56){
FUNC14(Var1,STRING,Var7+2); 
char *Var2=FUNC40(Var1,Var7+2); 
if (!Var62){
Var62=Var2; 
else 
Var62=FUNC41(Var62,Var2); 
free(Var2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var66=FUNC42(Var7+2,Var39); 
STRUCT8 *Var73=FUNC35(Var39,Var66); 
STRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); 
char *Var79=FUNC43(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC44(Var1->memberVar1,FUNC45(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var80=FUNC31(Var1->memberVar6,Var29); 
Var61=FUNC46(Var1,Var7+2,&Var63); 
Var66=strlen(Var7+2); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC47(Var7+2); 
STRUCT8 *Var73=FUNC35(Var39,Var66); 
STRUCT2 *Var74=FUNC36(Var1->memberVar1,Var73,Var75,0); 
*Var7=; 
char *Var81=Var7-2; 
while (Var81>Var2){
if (!FUNC48(*Var81)){
Var7=FUNC49(Var7+1)-1; 
Var2=FUNC12(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var59=FUNC49(Var7+1); 
if (FUNC50((STRUCT5) Var7[1])&&!Var56){
if (!FUNC51(Var1->memberVar11,Var7+1)){
FUNC5(STRING,Var7+1); 
else 
char  Var35=*Var59; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var82=Var7+3; 
Var15=FUNC52(Var1,Var2,Var82); 
else 
Var15=FUNC53(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var83[]={STRING,STRING,STRING,
const char *Var84[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var25=strchr(Var85,); 
if (!Var25){
STRUCT3  Var86=FUNC31(Var1->memberVar6,Var85); 
STRUCT3  Var87=FUNC31(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC49(Var2)); 
else 
if (Var57){
Var15=FUNC3(Var1->memberVar5,FUNC49(Var2)); 
*Var7=; 
Var54=Var2 FUNC3(Var1->memberVar5,FUNC49(Var2)) false ; 
",4280,0
after_cmd.c,r_core_cmd_subst_i,False,False,553,CWE-,CallExpression,memmove,2997,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
after_cmd.c,r_core_cmd_subst_i,False,False,554,CWE-,CallExpression,strlen,2997,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
after_cmd.c,r_core_cmd_subst_i,False,False,555,CWE-,CallExpression,memmove,3004,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
after_cmd.c,r_core_cmd_subst_i,False,False,556,CWE-,CallExpression,strlen,3004,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC14(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC15(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC14(Var1->memberVar5,Var7+2); 
char *Var2=FUNC17(Var1,Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC18(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC14(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC19(Var7+2); 
STRUCT5 *Var39=FUNC16(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC14(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC14(Var1->memberVar5,Var19+1); 
",1727,0
after_cmd.c,r_core_cmd_subst_i,False,False,557,CWE-,CallExpression,strchr,3008,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\t*ptr2 = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
memmove(Var20,Var7,strlen(Var7)+1); 
bool  Var31=false ; 
if (Var7[1]== ){
memmove(Var7,Var7+1,strlen(Var7)); 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
*Var7=0; 
*Var8=0; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var9=FUNC13(Var9,Var8+1); 
Var2=FUNC13(strdup(Var2),Var9); 
Var12=FUNC14(Var1,Var2); 
free(Var2); 
free(Var9); 
return  Var12; 
const char *Var32=strstr(Var2,STRING); 
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC15(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC16(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC17(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC16(Var1->memberVar5,Var7+2); 
char *Var2=FUNC19(Var1,Var7+2); 
STRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC16(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC21(Var7+2); 
STRUCT5 *Var39=FUNC18(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC16(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC16(Var1->memberVar5,Var19+1); 
",1832,0
after_cmd.c,r_core_cmd_subst_i,False,False,558,CWE-,CallExpression,free,3035,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tfree (str);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
bool  Var31=false ; 
int  Var32=1; 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var32&&Var9){
for (Var11=0; Var9[Var11]; Var11  Var23){
if (Var9[Var11]==  Var33){
Var9[Var11]=; 
Var9=FUNC13(Var9,Var8+1); 
Var2=FUNC13(strdup(Var2),Var9); 
free(Var9); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar9; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var47=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); 
",1799,0
after_cmd.c,r_core_cmd_subst_i,False,False,559,CWE-,CallExpression,strdup,3046,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\t\t\tfree (str);\n', '\t\t\treturn ret;\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
int  Var50=1; 
Var8=strchr(Var7+1,); 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
if (Var7[1]== !){
Var9=FUNC24(Var1,Var7+1); 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
Var9=FUNC19(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var50&&Var9){
for (Var14=0; Var9[Var14]; Var14  Var26){
if (Var9[Var14]==  Var47){
Var9[Var14]=; 
Var9=FUNC25(Var9,Var8+1); 
Var2=FUNC25(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
free(Var9); 
return  Var15; 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC26(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var63=strdup(Var7+2); 
char *Var64=strchr(Var63,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var65=(int ) FUNC28(Var1->memberVar6,Var7+2); 
STRUCT5 *Var66=FUNC29(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); 
char *Var70=strdup(Var7+2); 
char  Var34=*Var71; 
STRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
STRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); 
char *Var72=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var73=FUNC28(Var1->memberVar6,Var29); 
const STRUCT6 *Var74=(const STRUCT6 *) FUNC33(Var7+2); 
STRUCT2 *Var67=FUNC30(Var1->memberVar1,Var68,Var69,0); 
char *Var75=Var7-2; 
while (Var75>Var2){
if (!FUNC34(*Var75)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC35((STRUCT6) Var7[1])&&!Var54){
if (!FUNC36(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var57; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
Var15=FUNC37(Var1,Var2,Var76); 
else 
Var15=FUNC38(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC28(Var1->memberVar6,Var79); 
STRUCT3  Var81=FUNC28(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; 
",3283,0
after_cmd.c,r_core_cmd_subst_i,False,False,560,CWE-,CallExpression,free,3049,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
Var8=strchr(Var7+1,); 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
if (Var7[1]== !){
Var9=FUNC24(Var1,Var7+1); 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
Var9=FUNC19(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var9=FUNC25(Var9,Var8+1); 
Var2=FUNC25(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var50){
if (*Var2 != .){
Var11=FUNC26(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC28(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC29(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC28(Var1->memberVar6,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
STRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC32(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC28(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC33(Var7+2); 
STRUCT2 *Var66=FUNC30(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC34(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC35((STRUCT6) Var7[1])&&!Var53){
if (!FUNC36(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC37(Var1,Var2,Var75); 
else 
Var15=FUNC38(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC28(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC28(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC39(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC39(Var2)) false ; 
",3193,0
after_cmd.c,r_core_cmd_subst_i,False,False,561,CWE-,CallExpression,free,3053,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tint oneline = 1;\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\t\tfree (str);\n', '\t\t\tif (oneline && str) {\n', '\t\t\t\tfor (i = 0; str[i]; i++) {\n', ""\t\t\t\t\tif (str[i] == '\\n') {\n"", ""\t\t\t\t\t\tstr[i] = ' ';\n"", '\t\t\tstr = r_str_append (str, ptr2 + 1);\n', '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tfree (str);\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
bool  Var31=false ; 
int  Var32=1; 
Var8=strchr(Var7+1,); 
if (Var31){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
if (Var7[1]== !){
Var9=FUNC12(Var1,Var7+1); 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
Var9=FUNC9(Var1,Var7+1); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
free(Var9); 
if (Var32&&Var9){
for (Var11=0; Var9[Var11]; Var11  Var23){
if (Var9[Var11]==  Var33){
Var9[Var11]=; 
Var9=FUNC13(Var9,Var8+1); 
Var2=FUNC13(strdup(Var2),Var9); 
free(Var9); 
const char *Var34=strstr(Var2,STRING); 
char *Var35,*Var8=strchr(Var7+1,!); 
STRUCT2  Var36=Var1->memberVar9; 
char *Var37=strdup(Var7+2); 
char *Var38=strchr(Var37,=); 
STRUCT2  Var36=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var39=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT4 *Var40=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var44=strdup(Var7+2); 
char  Var20=*Var45; 
STRUCT2  Var36=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var46=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var47=FUNC15(Var1->memberVar5,Var18); 
const STRUCT6 *Var48=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT5 *Var41=FUNC17(Var1->memberVar1,Var42,Var43,0); 
char *Var49=Var7-2; 
else 
char  Var20=*Var50; 
char *Var51=Var7+3; 
char *Var52=Var7+3; 
char *Var19=strchr(Var52,); 
STRUCT2  Var53=FUNC15(Var1->memberVar5,Var52); 
STRUCT2  Var54=FUNC15(Var1->memberVar5,Var19+1); 
",1812,0
after_cmd.c,r_core_cmd_subst_i,False,False,562,CWE-,CallExpression,strstr,3061,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (cmd == s) {\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var35=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var36=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var37=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var37,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
if (Var7[0]&&Var7[1]== ){
int  Var38=1; 
int  Var39=FUNC17(Var1->memberVar8,STRING); 
int  Var40=false ; 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var42=Var7-1; 
const bool  Var43=(Var7[1]== >); 
if (*Var9 == ){
char *Var44=FUNC19(Var1,Var2); 
char *Var45=FUNC20(Var1->memberVar5,Var9,1); 
char *Var46=FUNC21(STRING,Var45,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
char *Var47=FUNC21(STRING,Var44); 
else 
}else if (Var38>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var48=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var34=Var7-1; 
if (*Var34 == ){
bool  Var49=false ; 
if (Var49){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var41=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var50=false ; 
if (Var2 ==  Var27){
if (Var50){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar9; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var53=FUNC26(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var64=(int ) FUNC27(Var1->memberVar6,Var7+2); 
STRUCT5 *Var65=FUNC28(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var69=strdup(Var7+2); 
char  Var34=*Var70; 
STRUCT3  Var53=FUNC27(Var1->memberVar6,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var71=FUNC31(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var72=FUNC27(Var1->memberVar6,Var29); 
const STRUCT6 *Var73=(const STRUCT6 *) FUNC32(Var7+2); 
STRUCT2 *Var66=FUNC29(Var1->memberVar1,Var67,Var68,0); 
char *Var74=Var7-2; 
while (Var74>Var2){
if (!FUNC33(*Var74)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC34((STRUCT6) Var7[1])&&!Var53){
if (!FUNC35(Var1->memberVar12,Var7+1)){
else 
char  Var34=*Var56; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var75=Var7+3; 
Var15=FUNC36(Var1,Var2,Var75); 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var76[]={STRING,STRING,STRING,
const char *Var77[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var78=Var7+3; 
char *Var25=strchr(Var78,); 
if (!Var25){
STRUCT3  Var79=FUNC27(Var1->memberVar6,Var78); 
STRUCT3  Var80=FUNC27(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC38(Var2)); 
Var51=Var2 FUNC3(Var1->memberVar5,FUNC38(Var2)) false ; 
",3131,0
after_cmd.c,r_core_cmd_subst_i,False,False,563,CWE-,CallExpression,strcmp,3071,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tif (cmd == s) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
int  Var10=!Var1->memberVar1->memberVar1; 
int  Var11,Var12=0,Var13; 
bool  Var14=Var1->memberVar2; 
bool  Var15=Var1->memberVar3; 
STRUCT2  Var16=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT3 */
else 
char *Var17=strchr(Var2,; ); 
char *Var18=strchr(Var19+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var12; 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var21=Var1->memberVar5->memberVar1; 
else 
char *Var22=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
if (Var12 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var23){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
int  Var12; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
if (Var7[0]&&Var7[1]== ){
int  Var24=FUNC8(Var1->memberVar7,STRING); 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var26=Var7-1; 
const bool  Var27=(Var7[1]== >); 
char *Var28=FUNC9(Var1,Var2); 
char *Var29=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var30=FUNC11(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var20=Var7-1; 
if (*Var20 == ){
bool  Var31=false ; 
if (Var31){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var25=FUNC8(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var32=strstr(Var2,STRING); 
if (Var32){
if (Var2 ==  Var32){
char *Var33,*Var8=strchr(Var7+1,!); 
STRUCT2  Var34=Var1->memberVar9; 
char *Var35=strdup(Var7+2); 
char *Var36=strchr(Var35,=); 
STRUCT2  Var34=FUNC12(Var1->memberVar5,Var1->memberVar9,Var7+4); 
int  Var37=(int ) FUNC13(Var1->memberVar5,Var7+2); 
STRUCT4 *Var38=FUNC14(Var1->memberVar10,Var1->memberVar9); 
STRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); 
char *Var42=strdup(Var7+2); 
char  Var20=*Var43; 
STRUCT2  Var34=FUNC13(Var1->memberVar5,Var7+2); 
char *Var2=FUNC16(Var1,Var7+2); 
STRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); 
char *Var44=FUNC17(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var18=strchr(Var7+2,); 
int  Var45=FUNC13(Var1->memberVar5,Var18); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC18(Var7+2); 
STRUCT5 *Var39=FUNC15(Var1->memberVar1,Var40,Var41,0); 
char *Var47=Var7-2; 
else 
char  Var20=*Var48; 
char *Var49=Var7+3; 
char *Var50=Var7+3; 
char *Var19=strchr(Var50,); 
STRUCT2  Var51=FUNC13(Var1->memberVar5,Var50); 
STRUCT2  Var52=FUNC13(Var1->memberVar5,Var19+1); 
",1618,0
after_cmd.c,r_core_cmd_subst_i,False,False,564,CWE-,CallExpression,strchr,3089,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\t\t\t*ptr = '\\0';\n"", '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tcmd = ptr + 1;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\t\t\t*ptr = ';';\n"", ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', '\t\tbool empty = false;\n', ""\t\tif (ptr[1] == '`') {\n"", '\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n', ""\t\tptr2 = strchr (ptr + 1, '`');\n"", '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\t*ptr = '\\0';\n"", ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', 'else\n', '\t\t\t\t\t\t\teprintf (""The current basic block has %d instructions\\n"", bb->ninstr);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\tif (tmpseek) {\n', '\t\t*tmpseek = cmd_tmpseek;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
int  Var28=-1; 
if (!Var2){
Var2=FUNC3(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
return FUNC4(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var18=-1; 
char *Var29,*Var30; 
Var23=*Var2 == ; 
if (Var23){
Var2  Var31; 
Var30=*Var2 FUNC5(Var2) NULL ; 
if (!Var30||!*Var30){
FUNC6(STRINGFUNC7(%Var32).,Var2); 
else 
char *Var33=strchr(Var2,; ); 
FUNC8(Var1,Var2); 
if (!Var33){
char *Var34=strchr(Var30+1,); 
const bool  Var35=Var30[2]== >; 
Var29=strdup(Var2); 
if (Var30&&*Var30&&Var30[1]== |){
FUNC9(Var1,Var2,Var11); 
if (!Var30){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC4(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC10(Var2,,STRING); //Var36  Var37  Var7  Var38
if (Var9&&(Var9[1]== ||Var9[1]==  Var39)){
*Var9=0; 
if (*Var2 != ){
Var9=(char *) FUNC11(Var2,; ,Var7); 
if (Var3&&Var9){
int  Var17; 
*Var9=0; 
if (FUNC12(Var1,Var2) == -1){
Var2=Var9+1; 
Var17=FUNC12(Var1,Var2); 
*Var9=; ; 
Var9=(char *) FUNC11(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC13(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC14(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
Var17=*Var2 FUNC15(Var1,STRING,Var2) 0; 
else 
}else if (Var9[1]){//STRING
int  Var41=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var42=FUNC16(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC11(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
Var17=FUNC4(Var1->memberVar5,Var2); 
if (Var17 == -1){
FUNC6(STRING,Var2); 
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var31){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
int  Var43=0; 
if (Var2<Var9&&Var9[-1]== ){
FUNC17(Var1,Var43,Var2); 
FUNC18(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC19()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var31){
char  Var44[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var31){
if (!*Var11){
if (!Var1->memberVar7){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC10(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var45=1; 
int  Var46=FUNC20(Var1->memberVar8,STRING); 
int  Var47=false ; 
int  Var48=FUNC20(Var1->memberVar8,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC21(Var9[-2])){
char *Var49=Var9-1; 
const bool  Var50=(Var9[1]== >); 
if (*Var11 == ){
char *Var51=FUNC22(Var1,Var2); 
char *Var52=FUNC23(Var1->memberVar5,Var11,1); 
char *Var53=FUNC24(STRING,Var52,Var51); 
else 
char *Var54=FUNC24(STRING,Var51); 
else 
char *Var54=FUNC24(STRING,Var51); 
else 
}else if (Var45>0){
if (Var18 != -1){
Var17=FUNC12(Var1,Var2); 
const char *Var55=FUNC25(Var1->memberVar8,STRING); 
Var9=strchr(Var2,); 
if (Var9){
if (Var9>Var2){
char *Var40=Var9-1; 
if (*Var40 == ){
memmove(Var40,Var9,strlen(Var9)+1); 
bool  Var56=false ; 
if (Var9[1]== ){
memmove(Var9,Var9+1,strlen(Var9)); 
Var10=strchr(Var9+1,); 
if (Var56){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
*Var9=0; 
if (Var9[1]== !){
Var11=FUNC26(Var1,Var9+1); 
else 
int  Var48=FUNC20(Var1->memberVar8,STRING); 
Var11=FUNC22(Var1,Var9+1); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
Var2=FUNC27(strdup(Var2),Var11); 
Var17=FUNC12(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var32=strstr(Var2,STRING); 
if (Var32){
bool  Var57=false ; 
if (Var57){
if (*Var2 != .){
Var13=FUNC28(Var2,Var7); 
if (*Var2 != ){
Var9=strchr(Var2,); 
Var26=Var1->memberVar9=Var9 true false ; 
int  Var58=0; 
if (Var9){
char *Var59,*Var10=strchr(Var9+1,!); 
STRUCT4  Var60=Var1->memberVar10; 
bool  Var61=false ; 
char *Var62=NULL ; 
const char *Var63=NULL ; 
bool  Var64=false ; 
bool  Var65=false ; 
char *Var66=NULL ; 
char *Var67=NULL ; 
bool  Var68=false ; 
int  Var69=-1; 
int  Var70,Var71; 
STRUCT6 *Var44; 
*Var9  Var31=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var31){
if (*Var9&&Var9[1]== ){
else 
Var9  Var72; 
Var9=FUNC29(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var73=strdup(Var9+2); 
char *Var74=strchr(Var73,=); 
if (Var74){
*Var74  Var31=0; 
FUNC30(Var73,Var74); 
FUNC31(Var5,Var73); 
else 
free(Var73); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+4); 
FUNC33(Var1,FUNC34((Var75) Var60-(Var75) Var1->memberVar10)); 
else 
Var60=FUNC32(Var1->memberVar6,Var1->memberVar10,Var9+3); 
FUNC35(Var1,Var60,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var68=FUNC36(Var1->memberVar11,Var9+2); 
int  Var76=(int ) FUNC37(Var1->memberVar6,Var9+2); 
STRUCT7 *Var77=FUNC38(Var1->memberVar12,Var1->memberVar10); 
if (Var77){
if (Var76<0){
Var76=Var77->memberVar1+Var76; 
if (Var76 >= 0&&Var76<Var77->memberVar1){
STRUCT8  Var78=FUNC39(Var77,Var76); 
FUNC35(Var1,Var77->memberVar2+Var78,1); 
else 
FUNC6(STRING,Var77->memberVar1); 
Var59=FUNC40(Var9+2,&Var70); 
if (Var59){
STRUCT9 *Var79=FUNC41((const STRUCT6 *) Var59,Var70); 
STRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); 
if (Var80){
if (Var14){
FUNC43(Var14); 
Var14=Var80; 
if (Var15){
FUNC44(Var1->memberVar8,STRING,1); 
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); 
if (Var44){
free(Var1->memberVar13); 
memcpy(Var1->memberVar13,Var59,Var70); 
free(Var59); 
else 
FUNC6(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var82; 
char *Var83=strdup(Var9+2); 
char *Var84=FUNC47(Var83); 
if (Var84){
char  Var40=*Var84; 
*Var84=0; 
Var82=FUNC48(Var1->memberVar14,Var83); 
*Var84=Var40; 
Var82=FUNC37(Var1->memberVar6,Var85); 
else 
Var82=FUNC48(Var1->memberVar14,Var9+2); 
FUNC35(Var1,Var82,1); 
free(Var83); 
Var64=FUNC49(Var1,FUNC37(Var1->memberVar6,Var9+2),&Var62); 
Var28=FUNC20(Var1->memberVar8,STRING); 
FUNC44(Var1->memberVar8,STRING,1); 
STRUCT4  memberVar2=FUNC37(Var1->memberVar6,Var9+2); 
if (memberVar2){
FUNC15(Var1,STRING,Var9+2); 
char *Var2=FUNC50(Var1,Var9+2); 
if (!Var66){
Var66=Var2; 
else 
Var66=FUNC51(Var66,Var2); 
free(Var2); 
if (Var9[1]== ){
Var44=malloc(strlen(Var9+2)+1); 
if (Var44){
Var71=FUNC52(Var9+2,Var44); 
FUNC33(Var1,FUNC34(Var71)); 
if (Var71>0){
STRUCT9 *Var79=FUNC41(Var44,Var71); 
STRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); 
if (Var80){
if (Var14){
FUNC43(Var14); 
Var14=Var80; 
if (Var15){
FUNC44(Var1->memberVar8,STRING,1); 
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); 
FUNC33(Var1,Var71); 
free(Var44); 
char *Var86=FUNC53(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var86){
FUNC35(Var1,FUNC37(Var1->memberVar6,Var86),1); 
free(Var86); 
if (Var9[1]== ){
Var69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC54(Var1->memberVar1,FUNC55(Var9+2)); 
if (Var9[1]== ){
char *Var34=strchr(Var9+2,); 
if (Var34){
*Var34  Var31=0; 
int  Var87=FUNC37(Var1->memberVar6,Var34); 
Var64=FUNC49(Var1,Var87,&Var62); 
Var65=FUNC56(Var1,Var9+2,&Var67); 
Var71=strlen(Var9+2); 
FUNC33(Var1,Var71); 
const STRUCT6 *Var44=(const STRUCT6 *) FUNC57(Var9+2); 
if (Var71>0){
STRUCT9 *Var79=FUNC41(Var44,Var71); 
STRUCT3 *Var80=FUNC42(Var1->memberVar1,Var79,Var81,0); 
if (!Var1->memberVar1->memberVar1){
FUNC44(Var1->memberVar8,STRING,1); 
if (Var80){
if (Var14){
FUNC43(Var14); 
Var14=Var80; 
if (Var15){
FUNC44(Var1->memberVar8,STRING,1); 
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,Var1->memberVar10,FUNC46(Var79)); 
FUNC33(Var1,Var71); 
*Var9=; 
char *Var88=Var9-2; 
while (Var88>Var2){
if (!FUNC58(*Var88)){
*Var88=0; 
Var88  Var72; 
Var9=FUNC59(Var9+1)-1; 
Var2=FUNC13(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
else 
*Var10=0; 
if (!Var10[1]){
FUNC33(
Var1,FUNC37(Var1->memberVar6,Var10+1)); 
Var63=FUNC59(Var9+1); 
memberVar2=FUNC37(Var1->memberVar6,Var63); 
if (FUNC60((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC61(Var1->memberVar11,Var9+1)){
FUNC6(STRING,Var9+1); 
else 
char  Var40=*Var63; 
if (Var40 == -||Var40 == +){
memberVar2=Var1->memberVar10+memberVar2; 
if (memberVar2){
STRUCT3 *Var80=Var14; 
if (Var80){
FUNC45(Var1->memberVar1,Var80->memberVar1,Var80->memberVar2,0,memberVar2,FUNC62(Var80)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var1->memberVar16=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var89=Var9+3; 
while (*Var89&&*Var89 == ){
Var89  Var31; 
Var17=FUNC63(Var1,Var2,Var89); 
else 
Var17=FUNC64(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var90[]={STRING,STRING,STRING,
const char *Var91[]={STRING,STRING,STRING,
STRUCT4  Var92[FUNC65(Var90)-1],Var93[FUNC65(Var91)-1]; 
if (Var9[1]== (){
char *Var94=Var9+3; 
char *Var30=strchr(Var94,); 
if (!Var30){
free(Var66); 
*Var30=Var95; 
STRUCT4  Var96=FUNC37(Var1->memberVar6,Var94); 
STRUCT4  Var97=FUNC37(Var1->memberVar6,Var30+1); 
for (Var16=0; Var90[Var16]; Var16  Var31){
Var92[Var16]=FUNC20(Var1->memberVar8,Var90[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var31){
Var93[Var16]=FUNC20(Var1->memberVar8,Var91[Var16]); 
for (Var16=0; Var90[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var90[Var16],Var96); 
for (Var16=0; Var91[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var91[Var16],Var97); 
if (Var19){
if (Var61){
Var1->memberVar10=memberVar2; 
Var17=FUNC4(Var1->memberVar5,FUNC59(Var2)); 
else 
if (Var61){
if (Var9[1]){
FUNC35(Var1,memberVar2,1); 
Var17=FUNC4(Var1->memberVar5,FUNC59(Var2)); 
if (memberVar9){
for (Var16=0; Var90[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var90[Var16],Var92[Var16]); 
for (Var16=0; Var91[Var16]; Var16  Var31){
FUNC44(Var1->memberVar8,Var91[Var16],Var93[Var16]); 
if (Var10){
*Var10=!; 
if (Var69 != -1){
FUNC54(Var1->memberVar1,Var69); 
if (Var14){
if (Var15){
FUNC44(Var1->memberVar8,STRING,0); 
FUNC43(Var14); 
if (Var64){
FUNC66(Var1->memberVar8,STRING,Var62); 
if (Var66){
FUNC8(Var1,Var66); 
FUNC67(Var66); 
if (Var68){
FUNC68(Var1->memberVar11); 
*Var9=; 
Var58=Var17; 
Var58=Var2 FUNC4(Var1->memberVar5,FUNC59(Var2)) false ; 
if (Var20 != -1){
FUNC44(Var1->memberVar8,STRING,Var20); 
if (Var21 != -1){
FUNC44(Var1->memberVar8,STRING,Var21); 
if (Var14){
FUNC43(Var14); 
if (memberVar9){
*memberVar9=Var26; 
if (Var28 != -1){
FUNC44(Var1->memberVar8,STRING,Var28); 
return  Var58; 
",5915,0
after_cmd.c,r_core_cmd_subst_i,False,False,565,CWE-,CallExpression,strchr,3100,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC3(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC4(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC5(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC6(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){
Var7=strchr(Var2,&); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
if (Var7){
if (FUNC7()->memberVar1){
if (Var7[1]== <){
char  Var33[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
if (Var7[0]&&Var7[1]== ){
int  Var34=FUNC8(Var1->memberVar7,STRING); 
int  Var35=false ; 
int  Var36=FUNC8(Var1->memberVar7,STRING); 
if (!*Var9){
char *Var37=Var7-1; 
const bool  Var38=(Var7[1]== >); 
char *Var39=FUNC9(Var1,Var2); 
char *Var40=FUNC10(Var1->memberVar8,Var9,1); 
const char *Var41=FUNC11(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
bool  Var42=false ; 
if (Var42){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var36=FUNC8(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var43=strstr(Var2,STRING); 
if (Var43){
bool  Var44=false ; 
if (Var44){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var45,*Var8=strchr(Var7+1,!); 
STRUCT3  Var46=Var1->memberVar10; 
bool  Var47=false ; 
char *Var48=NULL ; 
const char *Var49=NULL ; 
bool  Var50=false ; 
bool  Var51=false ; 
char *Var52=NULL ; 
char *Var53=NULL ; 
bool  Var54=false ; 
int  Var55,Var56; 
STRUCT5 *Var33; 
*Var7  Var32=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var32){
if (*Var7&&Var7[1]== ){
else 
Var7  Var57; 
Var7=FUNC12(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var58=strdup(Var7+2); 
char *Var59=strchr(Var58,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var46=FUNC13(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var54=FUNC14(Var1->memberVar11,Var7+2); 
int  Var60=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var61=FUNC16(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var62=FUNC17(Var61,Var60); 
Var45=FUNC18(Var7+2,&Var55); 
if (Var45){
STRUCT8 *Var63=FUNC19((const STRUCT5 *) Var45,Var55); 
STRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); 
else 
FUNC21(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var66; 
char *Var67=strdup(Var7+2); 
char *Var68=FUNC22(Var67); 
if (Var68){
char  Var29=*Var68; 
else 
Var66=FUNC23(Var1->memberVar13,Var7+2); 
Var50=FUNC24(Var1,FUNC15(Var1->memberVar5,Var7+2),&Var48); 
STRUCT3  Var46=FUNC15(Var1->memberVar5,Var7+2); 
if (Var46){
FUNC25(Var1,STRING,Var7+2); 
char *Var2=FUNC26(Var1,Var7+2); 
if (Var7[1]== ){
Var33=malloc(strlen(Var7+2)+1); 
if (Var33){
Var56=FUNC27(Var7+2,Var33); 
STRUCT8 *Var63=FUNC19(Var33,Var56); 
STRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); 
char *Var69=FUNC28(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC29(Var1->memberVar1,FUNC30(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var70=FUNC15(Var1->memberVar5,Var27); 
Var51=FUNC31(Var1,Var7+2,&Var53); 
Var56=strlen(Var7+2); 
const STRUCT5 *Var33=(const STRUCT5 *) FUNC32(Var7+2); 
STRUCT8 *Var63=FUNC19(Var33,Var56); 
STRUCT2 *Var64=FUNC20(Var1->memberVar1,Var63,Var65,0); 
*Var7=; 
char *Var71=Var7-2; 
Var7=FUNC33(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC34(
Var1,FUNC15(Var1->memberVar5,Var8+1)); 
Var49=FUNC33(Var7+1); 
if (FUNC35((STRUCT5) Var7[1])&&!Var46){
if (!FUNC36(Var1->memberVar11,Var7+1)){
FUNC21(STRING,Var7+1); 
else 
char  Var29=*Var49; 
STRUCT2 *Var64=Var12; 
if (Var10){
if (Var7[1]== ){
if (Var7[2]== ){
char *Var72=Var7+3; 
else 
Var15=FUNC37(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var73[]={STRING,STRING,STRING,
const char *Var74[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var75=Var7+3; 
char *Var25=strchr(Var75,); 
if (!Var25){
STRUCT3  Var76=FUNC15(Var1->memberVar5,Var75); 
STRUCT3  Var77=FUNC15(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var47){
if (Var8){
*Var8=!; 
*Var7=; 
",2977,0
after_cmd.c,r_core_cmd_subst_i,False,False,566,CWE-,CallExpression,strchr,3116,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\thaveQuote = q != NULL;\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_break_push (NULL, NULL);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', '\t\tif (arroba) {\n', '\t\t\t*arroba = 0;\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index < 0) {\n', '\t\t\t\t\t\t\tindex = bb->ninstr + index;\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\t\t\t*trim = 0;\n', '\t\t\t\ttrim--;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\t\t*arroba = '@';\n"", '\t\t\tarroba = NULL;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', ""\t\t\t\twhile (*rule && *rule == ' ') {\n"", '\t\t\t\t\trule++;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\ttmpdesc = NULL;\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\t\ttmpdesc = NULL;\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
int  Var20=-1; 
int  Var21=-1; 
bool  Var22=false ; 
bool  Var23=false ; 
bool  Var24=Var1->memberVar2; 
bool  Var25=Var1->memberVar3; 
bool  Var26=false ; 
STRUCT4  Var27=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
for (; *Var2; ){
char *Var28,*Var29; 
if (Var23){
Var29=*Var2 FUNC4(Var2) NULL ; 
if (!Var29||!*Var29){
else 
char *Var30=strchr(Var2,; ); 
if (!Var30){
if (*Var29){
if (Var29[1]== ||(Var29[1]&&Var29[2]== )){
char *Var31=strchr(Var29+1,); 
Var23=Var31 != NULL ; 
const bool  Var32=Var29[2]== >; 
if (!Var29){
if (Var22){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC5(Var2,,STRING); //Var33  Var34  Var7  Var35
if (Var9&&(Var9[1]== ||Var9[1]==  Var36)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC6(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var37=Var9-1; 
if (*Var37 == ){
memmove(Var37,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC7(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC8(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var38=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC9(Var1,Var2,Var9+1); 
else 
char *Var39=FUNC10(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC6(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var40){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
if (Var2<Var9&&Var9[-1]== ){
FUNC11(NULL ,NULL ); 
FUNC12(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC13()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var40){
char  Var41[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var40){
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC5(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var37=Var9-1; 
if (*Var37 == ){
memmove(Var37,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var42=FUNC14(Var1->memberVar7,STRING); 
int  Var43=false ; 
int  Var44=FUNC14(Var1->memberVar7,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC15(Var9[-2])){
char *Var45=Var9-1; 
const bool  Var46=(Var9[1]== >); 
char *Var47=FUNC16(Var1,Var2); 
char *Var48=FUNC17(Var1->memberVar8,Var11,1); 
const char *Var49=FUNC18(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var37=Var9-1; 
if (*Var37 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var10){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var44=FUNC14(Var1->memberVar7,STRING); 
if (!Var11){
if (*Var11 == |||*Var11 == *){
if (*Var2 != &&*Var2){
const char *Var51=strstr(Var2,STRING); 
if (Var51){
bool  Var52=false ; 
if (Var52){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
Var26=Var1->memberVar9=Var9 true false ; 
int  Var53=0; 
if (Var9){
char *Var54,*Var10=strchr(Var9+1,!); 
STRUCT4  Var55=Var1->memberVar10; 
bool  Var56=false ; 
char *Var57=NULL ; 
const char *Var58=NULL ; 
bool  Var59=false ; 
bool  Var60=false ; 
char *Var61=NULL ; 
char *Var62=NULL ; 
bool  Var63=false ; 
int  Var64=-1; 
int  Var65,Var66; 
STRUCT6 *Var41; 
*Var9  Var40=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
if (Var12){
*Var12=0; 
for (; *Var9 == ; Var9  Var40){
if (*Var9&&Var9[1]== ){
else 
Var9  Var67; 
Var9=FUNC19(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var68=strdup(Var9+2); 
char *Var69=strchr(Var68,=); 
if (Var69){
*Var69  Var40=0; 
FUNC20(Var68,Var69); 
FUNC21(Var5,Var68); 
else 
free(Var68); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+4); 
FUNC23(Var1,FUNC24((Var70) Var55-(Var70) Var1->memberVar10)); 
else 
Var55=FUNC22(Var1->memberVar5,Var1->memberVar10,Var9+3); 
FUNC25(Var1,Var55,1); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var63=FUNC26(Var1->memberVar11,Var9+2); 
int  Var71=(int ) FUNC27(Var1->memberVar5,Var9+2); 
STRUCT7 *Var72=FUNC28(Var1->memberVar12,Var1->memberVar10); 
if (Var72){
if (Var71<0){
Var71=Var72->memberVar1+Var71; 
if (Var71 >= 0&&Var71<Var72->memberVar1){
STRUCT8  Var73=FUNC29(Var72,Var71); 
FUNC25(Var1,Var72->memberVar2+Var73,1); 
Var54=FUNC30(Var9+2,&Var65); 
if (Var54){
STRUCT9 *Var74=FUNC31((const STRUCT6 *) Var54,Var65); 
STRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); 
if (Var75){
if (Var14){
FUNC33(Var14); 
Var14=Var75; 
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); 
if (Var41){
memcpy(Var1->memberVar13,Var54,Var65); 
free(Var54); 
else 
FUNC36(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var77; 
char *Var78=strdup(Var9+2); 
char *Var79=FUNC37(Var78); 
if (Var79){
char  Var37=*Var79; 
*Var79=0; 
Var77=FUNC38(Var1->memberVar14,Var78); 
*Var79=Var37; 
else 
Var77=FUNC38(Var1->memberVar14,Var9+2); 
FUNC25(Var1,Var77,1); 
free(Var78); 
Var59=FUNC39(Var1,FUNC27(Var1->memberVar5,Var9+2),&Var57); 
STRUCT4  memberVar2=FUNC27(Var1->memberVar5,Var9+2); 
if (memberVar2){
FUNC40(Var1,STRING,Var9+2); 
char *Var2=FUNC41(Var1,Var9+2); 
if (!Var61){
Var61=Var2; 
else 
Var61=FUNC42(Var61,Var2); 
free(Var2); 
if (Var9[1]== ){
Var41=malloc(strlen(Var9+2)+1); 
if (Var41){
Var66=FUNC43(Var9+2,Var41); 
FUNC23(Var1,FUNC24(Var66)); 
if (Var66>0){
STRUCT9 *Var74=FUNC31(Var41,Var66); 
STRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); 
if (Var75){
if (Var14){
FUNC33(Var14); 
Var14=Var75; 
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); 
FUNC23(Var1,Var66); 
free(Var41); 
char *Var80=FUNC44(Var1->memberVar15,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var80){
FUNC25(Var1,FUNC27(Var1->memberVar5,Var80),1); 
free(Var80); 
if (Var9[1]== ){
FUNC45(Var1->memberVar1,FUNC46(Var9+2)); 
if (Var9[1]== ){
char *Var31=strchr(Var9+2,); 
if (Var31){
*Var31  Var40=0; 
int  Var81=FUNC27(Var1->memberVar5,Var31); 
Var59=FUNC39(Var1,Var81,&Var57); 
Var60=FUNC47(Var1,Var9+2,&Var62); 
Var66=strlen(Var9+2); 
FUNC23(Var1,Var66); 
const STRUCT6 *Var41=(const STRUCT6 *) FUNC48(Var9+2); 
if (Var66>0){
STRUCT9 *Var74=FUNC31(Var41,Var66); 
STRUCT3 *Var75=FUNC32(Var1->memberVar1,Var74,Var76,0); 
if (Var75){
if (Var14){
FUNC33(Var14); 
Var14=Var75; 
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,Var1->memberVar10,FUNC35(Var74)); 
FUNC23(Var1,Var66); 
*Var9=; 
char *Var82=Var9-2; 
while (Var82>Var2){
if (!FUNC49(*Var82)){
*Var82=0; 
Var82  Var67; 
Var9=FUNC50(Var9+1)-1; 
Var2=FUNC7(Var2); 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var58=FUNC50(Var9+1); 
memberVar2=FUNC27(Var1->memberVar5,Var58); 
if (FUNC51((STRUCT6) Var9[1])&&!memberVar2){
if (!FUNC52(Var1->memberVar11,Var9+1)){
FUNC36(STRING,Var9+1); 
else 
char  Var37=*Var58; 
if (Var37 == -||Var37 == +){
memberVar2=Var1->memberVar10+memberVar2; 
if (memberVar2){
STRUCT3 *Var75=Var14; 
if (Var75){
FUNC34(Var1->memberVar1,Var75->memberVar1,Var75->memberVar2,0,memberVar2,FUNC53(Var75)); 
if (Var12){
Var9=Var12+1; 
*Var12=; 
Var12=NULL ; 
Var1->memberVar16=!!Var14; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var83=Var9+3; 
while (*Var83&&*Var83 == ){
Var83  Var40; 
Var17=FUNC54(Var1,Var2,Var83); 
else 
Var17=FUNC55(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var84[]={STRING,STRING,STRING,
const char *Var85[]={STRING,STRING,STRING,
STRUCT4  Var86[FUNC56(Var84)-1],Var87[FUNC56(Var85)-1]; 
if (Var9[1]== (){
char *Var88=Var9+3; 
char *Var29=strchr(Var88,); 
if (!Var29){
free(Var61); 
*Var29=Var89; 
STRUCT4  Var90=FUNC27(Var1->memberVar5,Var88); 
STRUCT4  Var91=FUNC27(Var1->memberVar5,Var29+1); 
for (Var16=0; Var84[Var16]; Var16  Var40){
Var86[Var16]=FUNC14(Var1->memberVar7,Var84[Var16]); 
for (Var16=0; Var85[Var16]; Var16  Var40){
Var87[Var16]=FUNC14(Var1->memberVar7,Var85[Var16]); 
for (Var16=0; Var84[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var84[Var16],Var90); 
for (Var16=0; Var85[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var85[Var16],Var91); 
if (Var19){
if (Var56){
Var1->memberVar10=memberVar2; 
Var17=FUNC58(Var1->memberVar8,FUNC50(Var2)); 
else 
if (Var56){
if (Var9[1]){
FUNC25(Var1,memberVar2,1); 
Var17=FUNC58(Var1->memberVar8,FUNC50(Var2)); 
if (memberVar9){
for (Var16=0; Var84[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var84[Var16],Var86[Var16]); 
for (Var16=0; Var85[Var16]; Var16  Var40){
FUNC57(Var1->memberVar7,Var85[Var16],Var87[Var16]); 
if (Var64 != -1){
FUNC45(Var1->memberVar1,Var64); 
if (Var14){
if (Var15){
FUNC57(Var1->memberVar7,STRING,0); 
FUNC33(Var14); 
Var14=NULL ; 
if (Var59){
FUNC59(Var1->memberVar7,STRING,Var57); 
if (Var61){
FUNC60(Var1,Var61); 
FUNC61(Var61); 
if (Var63){
FUNC62(Var1->memberVar11); 
*Var9=; 
Var53=Var17; 
Var53=Var2 FUNC58(Var1->memberVar8,FUNC50(Var2)) false ; 
if (Var20 != -1){
FUNC57(Var1->memberVar7,STRING,Var20); 
if (Var21 != -1){
FUNC57(Var1->memberVar7,STRING,Var21); 
if (Var14){
FUNC33(Var14); 
Var14=NULL ; 
return  Var53; 
",5129,0
after_cmd.c,r_core_cmd_subst_i,False,False,567,CWE-,CallExpression,strdup,3136,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=false ; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT4  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC4(Var2,,STRING); //Var31  Var32  Var7  Var33
if (Var9&&(Var9[1]== ||Var9[1]==  Var34)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC5(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var35=Var9-1; 
if (*Var35 == ){
memmove(Var35,Var9,strlen(Var9)+1); 
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC6(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC7(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var9+1); 
else 
char *Var37=FUNC9(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC5(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var38){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
if (Var2<Var9&&Var9[-1]== ){
FUNC10(Var9+2,STRING); 
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC11()->memberVar1){
if (Var9[1]== <){
for (Var11=Var9+2; Var11[0]== ; Var11  Var38){
char  Var39[1024]; 
int  Var17; 
else 
for (Var11=Var9+1; *Var11 == ; Var11  Var38){
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC4(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var35=Var9-1; 
if (*Var35 == ){
memmove(Var35,Var9,strlen(Var9)+1); 
if (Var9[0]&&Var9[1]== ){
int  Var40=FUNC12(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC12(Var1->memberVar7,STRING); 
*Var9=0; 
Var11=FUNC3(Var9+1+(Var9[1]== >)); 
if (!*Var11){
if (Var9>(Var2+1)&&FUNC13(Var9[-2])){
char *Var43=Var9-1; 
const bool  Var44=(Var9[1]== >); 
char *Var45=FUNC14(Var1,Var2); 
char *Var46=FUNC15(Var1->memberVar8,Var11,1); 
const char *Var47=FUNC16(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var35=Var9-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC12(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
Var24=Var1->memberVar9=Var9 true false ; 
if (Var9){
char *Var51,*Var10=strchr(Var9+1,!); 
STRUCT4  Var52=Var1->memberVar10; 
bool  Var53=false ; 
char *Var54=NULL ; 
const char *Var55=NULL ; 
bool  Var56=false ; 
bool  Var57=false ; 
char *Var58=NULL ; 
char *Var59=NULL ; 
bool  Var60=false ; 
int  Var61,Var62; 
STRUCT6 *Var39; 
*Var9  Var38=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
for (; *Var9 == ; Var9  Var38){
if (*Var9&&Var9[1]== ){
else 
Var9  Var63; 
Var9=FUNC17(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var64=strdup(Var9+2); 
char *Var65=strchr(Var64,=); 
if (Var65){
*Var65  Var38=0; 
FUNC18(Var64,Var65); 
FUNC19(Var5,Var64); 
else 
free(Var64); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
if (Var9[3]== .){//STRING
STRUCT4  Var52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+4); 
else 
Var52=FUNC20(Var1->memberVar5,Var1->memberVar10,Var9+3); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
Var60=FUNC21(Var1->memberVar11,Var9+2); 
int  Var66=(int ) FUNC22(Var1->memberVar5,Var9+2); 
STRUCT7 *Var67=FUNC23(Var1->memberVar12,Var1->memberVar10); 
STRUCT8  Var68=FUNC24(Var67,Var66); 
Var51=FUNC25(Var9+2,&Var61); 
if (Var51){
STRUCT9 *Var69=FUNC26((const STRUCT6 *) Var51,Var61); 
STRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); 
else 
FUNC28(STRING,Var9+3); 
if (Var9[1]== ){
STRUCT4  Var72; 
char *Var73=strdup(Var9+2); 
char *Var74=FUNC29(Var73); 
if (Var74){
char  Var35=*Var74; 
else 
Var72=FUNC30(Var1->memberVar13,Var9+2); 
Var56=FUNC31(Var1,FUNC22(Var1->memberVar5,Var9+2),&Var54); 
STRUCT4  Var52=FUNC22(Var1->memberVar5,Var9+2); 
if (Var52){
FUNC32(Var1,STRING,Var9+2); 
char *Var2=FUNC33(Var1,Var9+2); 
if (Var9[1]== ){
Var39=malloc(strlen(Var9+2)+1); 
if (Var39){
Var62=FUNC34(Var9+2,Var39); 
STRUCT9 *Var69=FUNC26(Var39,Var62); 
STRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); 
char *Var75=FUNC35(Var1->memberVar14,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var9[1]== ){
FUNC36(Var1->memberVar1,FUNC37(Var9+2)); 
if (Var9[1]== ){
char *Var29=strchr(Var9+2,); 
int  Var76=FUNC22(Var1->memberVar5,Var29); 
Var57=FUNC38(Var1,Var9+2,&Var59); 
Var62=strlen(Var9+2); 
const STRUCT6 *Var39=(const STRUCT6 *) FUNC39(Var9+2); 
STRUCT9 *Var69=FUNC26(Var39,Var62); 
STRUCT3 *Var70=FUNC27(Var1->memberVar1,Var69,Var71,0); 
*Var9=; 
char *Var77=Var9-2; 
Var9=FUNC40(Var9+1)-1; 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
Var55=FUNC40(Var9+1); 
if (FUNC41((STRUCT6) Var9[1])&&!Var52){
if (!FUNC42(Var1->memberVar11,Var9+1)){
FUNC28(STRING,Var9+1); 
else 
char  Var35=*Var55; 
STRUCT3 *Var70=Var14; 
if (Var12){
Var9=Var12+1; 
if (Var9[1]== ){
if (Var9[2]== ){
char *Var78=Var9+3; 
else 
Var17=FUNC43(Var1,Var2,Var9+2); 
else 
bool  memberVar9=false ; 
const char *Var79[]={STRING,STRING,STRING,
const char *Var80[]={STRING,STRING,STRING,
if (Var9[1]== (){
char *Var81=Var9+3; 
char *Var27=strchr(Var81,); 
if (!Var27){
STRUCT4  Var82=FUNC22(Var1->memberVar5,Var81); 
STRUCT4  Var83=FUNC22(Var1->memberVar5,Var27+1); 
if (Var19){
else 
if (Var53){
*Var9=; 
",3388,0
after_cmd.c,r_core_cmd_subst_i,False,False,568,CWE-,CallExpression,strchr,3137,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\t*v++ = 0;\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=Var1->memberVar2; 
bool  Var20=Var1->memberVar3; 
STRUCT4  Var21=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var24+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27
if (Var9&&(Var9[1]== ||Var9[1]==  Var28)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC5(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC6(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC7(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC8(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC5(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC9()->memberVar1){
if (Var9[1]== <){
int  Var17; 
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC4(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
if (Var9[0]&&Var9[1]== ){
int  Var33=FUNC10(Var1->memberVar7,STRING); 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
*Var9=0; 
if (!*Var11){
char *Var35=Var9-1; 
const bool  Var36=(Var9[1]== >); 
char *Var37=FUNC11(Var1,Var2); 
char *Var38=FUNC12(Var1->memberVar8,Var11,1); 
const char *Var39=FUNC13(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
if (Var9){
char *Var43,*Var10=strchr(Var9+1,!); 
STRUCT4  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var9  Var32=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
for (; *Var9 == ; Var9  Var32){
if (*Var9&&Var9[1]== ){
else 
Var9  Var49; 
Var9=FUNC14(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var50=strdup(Var9+2); 
char *Var51=strchr(Var50,=); 
if (Var51){
*Var51  Var32=0; 
FUNC15(Var50,Var51); 
FUNC16(Var5,Var50); 
else 
free(Var50); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
STRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
int  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); 
STRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var9+2); 
char  Var29=*Var58; 
STRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); 
char *Var2=FUNC21(Var1,Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); 
char *Var23=strchr(Var9+2,); 
int  Var60=FUNC18(Var1->memberVar5,Var23); 
const STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
*Var9=; 
char *Var62=Var9-2; 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
if (FUNC24((STRUCT7) Var9[1])&&!Var44){
if (!FUNC25(Var1->memberVar12,Var9+1)){
else 
char  Var29=*Var46; 
STRUCT3 *Var54=Var14; 
if (Var12){
Var9=Var12+1; 
char *Var63=Var9+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var9+3; 
char *Var24=strchr(Var66,); 
STRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); 
STRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); 
",2456,0
after_cmd.c,r_core_cmd_subst_i,False,False,569,CWE-,CallExpression,free,3143,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tRList *tmpenvs = r_list_newf (tmpenvs_free);\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", '\t\t\tif (v) {\n', '\t\t\t\tr_sys_setenv (k, v);\n', '\t\t\t\tr_list_append (tmpenvs, k);\n', 'else\n', '\t\t\t\tfree (k);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
STRUCT2 *Var5=FUNC2(Var6); 
const char *Var7=STRING; 
const char *Var8=NULL ; 
char *Var9,*Var10,*Var11; 
char *Var12=NULL ; 
char *Var13=NULL ; 
STRUCT3 *Var14=NULL ; 
int  Var15=!Var1->memberVar1->memberVar1; 
int  Var16,Var17=0,Var18; 
bool  Var19=Var1->memberVar2; 
bool  Var20=Var1->memberVar3; 
STRUCT4  Var21=Var1->memberVar4; 
if (!Var2){
Var2=FUNC3(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT5 */
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var24+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var9=(char *) FUNC4(Var2,,STRING); //Var25  Var26  Var7  Var27
if (Var9&&(Var9[1]== ||Var9[1]==  Var28)){
*Var9=0; 
if (*Var2 != ){
if (Var3&&Var9){
int  Var17; 
Var9=(char *) FUNC5(Var2,|,Var7); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
char *Var10=strchr(Var2,); 
if (!Var10||(Var10&&Var10>Var9)){
if (!Var8||(Var8&&Var8>Var9)){
*Var9=0; 
Var2=FUNC6(Var2); 
if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!FUNC7(Var9+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (!strcmp(Var9+1,STRING)){//STRING
else 
}else if (Var9[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC8(Var1->memberVar1,Var9+1); 
Var9=(char *) FUNC5(Var2,&,Var7); 
while (Var9&&*Var9&&Var9[1]== &){
*Var9=0; 
if (Var17 == -1){
for (Var2=Var9+2; Var2&&*Var2 == ; Var2  Var32){
Var9=strchr(Var2,&); 
Var9=strstr(Var2,STRING); 
if (Var9&&(Var9 ==  Var2||Var9[-1]!= )){
Var9[0]=0; 
if (*Var2 != ){
Var9=strchr(Var2,<); 
if (Var9){
Var9[0]=0; 
if (FUNC9()->memberVar1){
if (Var9[1]== <){
int  Var17; 
if (!*Var11){
if (!Var1->memberVar6){
else 
}else if (Var9 ==  Var2){
Var9=(char *) FUNC4(Var2,>,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
if (Var9[0]&&Var9[1]== ){
int  Var33=FUNC10(Var1->memberVar7,STRING); 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
*Var9=0; 
if (!*Var11){
char *Var35=Var9-1; 
const bool  Var36=(Var9[1]== >); 
char *Var37=FUNC11(Var1,Var2); 
char *Var38=FUNC12(Var1->memberVar8,Var11,1); 
const char *Var39=FUNC13(Var1->memberVar7,STRING); 
if (Var9){
if (Var9>Var2){
char *Var29=Var9-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC10(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var9=strchr(Var2,); 
if (Var9 ==  Var2+1&&*Var2 == ){
Var9=NULL ; 
else 
Var9=NULL ; 
if (Var9){
char *Var43,*Var10=strchr(Var9+1,!); 
STRUCT4  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var9  Var32=0; 
Var12=(Var9[0]&&Var9[1]&&Var9[2])
for (; *Var9 == ; Var9  Var32){
if (*Var9&&Var9[1]== ){
else 
Var9  Var49; 
Var9=FUNC14(Var9); 
if (Var9[1]== ){
else 
}else if (Var9[1]== %){//STRING
char *Var50=strdup(Var9+2); 
char *Var51=strchr(Var50,=); 
if (Var51){
FUNC15(Var50,Var51); 
FUNC16(Var5,Var50); 
else 
free(Var50); 
else 
}else if (Var9[1]== .){//STRING
if (Var9[2]== .){//STRING
STRUCT4  Var44=FUNC17(Var1->memberVar5,Var1->memberVar9,Var9+4); 
else 
}else if (Var9[0]&&Var9[1]== &&Var9[2]){
switch (Var9[0]){
int  Var52=(int ) FUNC18(Var1->memberVar5,Var9+2); 
STRUCT6 *Var53=FUNC19(Var1->memberVar10,Var1->memberVar9); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var9+2); 
char  Var29=*Var58; 
STRUCT4  Var44=FUNC18(Var1->memberVar5,Var9+2); 
char *Var2=FUNC21(Var1,Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC22(Var1->memberVar11,NULL ,0,Var9+((Var9[1]) 21)); 
char *Var23=strchr(Var9+2,); 
int  Var60=FUNC18(Var1->memberVar5,Var23); 
const STRUCT7 *Var61=(const STRUCT7 *) FUNC23(Var9+2); 
STRUCT3 *Var54=FUNC20(Var1->memberVar1,Var55,Var56,0); 
*Var9=; 
char *Var62=Var9-2; 
if (Var10){
if (strlen(Var9+1) == 13&&strlen(Var10+1) == 6&&
!memcmp(Var9+1,STRING,2)&&
!memcmp(Var10+1,STRING,2)){
else 
}else if (strlen(Var9+1) == 9&&strlen(Var10+1) == 4){
if (!Var10[1]){
if (FUNC24((STRUCT7) Var9[1])&&!Var44){
if (!FUNC25(Var1->memberVar12,Var9+1)){
else 
char  Var29=*Var46; 
STRUCT3 *Var54=Var14; 
if (Var12){
Var9=Var12+1; 
char *Var63=Var9+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var9+3; 
char *Var24=strchr(Var66,); 
STRUCT4  Var67=FUNC18(Var1->memberVar5,Var66); 
STRUCT4  Var68=FUNC18(Var1->memberVar5,Var24+1); 
",2446,0
after_cmd.c,r_core_cmd_subst_i,False,False,570,CWE-,CallExpression,malloc,3207,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tbuf = malloc (sz);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', 'else\n', '\t\t\t\t\t\teprintf (""cannot alloc %d"", sz);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
int  Var6=!Var7->memberVar1->memberVar1; 
int  Var8,Var9=0,Var10; 
bool  Var11=Var7->memberVar2; 
bool  Var12=Var7->memberVar3; 
STRUCT1  Var13=Var7->memberVar4; 
if (!Var14){
switch (*Var14){
if (Var14[1]== ){/*STRUCT2 */
else 
char *Var15=strchr(Var14,; ); 
if (Var14[1]!= *&&!strstr(Var14,STRING)){
if (Var14[1]== >){
if (*Var14 != ){
if (Var16&&Var2){
int  Var9; 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
char *Var3=strchr(Var14,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var18=Var7->memberVar5->memberVar1; 
else 
char *Var19=FUNC2(Var7->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var9 == -1){
if (Var2&&(Var2 ==  Var14||Var2[-1]!= )){
if (*Var14 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
char  Var20[1024]; 
int  Var9; 
if (!*Var4){
if (!Var7->memberVar6){
else 
}else if (Var2 ==  Var14){
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
if (Var2[0]&&Var2[1]== ){
int  Var21=FUNC4(Var7->memberVar7,STRING); 
int  Var22=FUNC4(Var7->memberVar7,STRING); 
if (!*Var4){
char *Var23=Var2-1; 
const bool  Var24=(Var2[1]== >); 
char *Var25=FUNC5(Var7,Var14); 
char *Var26=FUNC6(Var7->memberVar8,Var4,1); 
const char *Var27=FUNC7(Var7->memberVar7,STRING); 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
bool  Var28=false ; 
if (Var28){
else 
int  memberVar1=Var7->memberVar5->memberVar1; 
else 
int  Var22=FUNC4(Var7->memberVar7,STRING); 
if (*Var14 != &&*Var14){
const char *Var29=strstr(Var14,STRING); 
if (Var29){
bool  Var30=false ; 
if (Var30){
if (Var2){
char *Var31,*Var3=strchr(Var2+1,!); 
STRUCT1  Var32=Var7->memberVar9; 
int  Var33,Var34; 
STRUCT3 *Var20; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var35=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT1  Var32=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var36=(int ) FUNC9(Var7->memberVar5,Var2+2); 
STRUCT4 *Var37=FUNC10(Var7->memberVar10,Var7->memberVar9); 
if (Var31){
STRUCT5 *Var38=FUNC11((const STRUCT3 *) Var31,Var33); 
STRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); 
Var20=malloc(Var33); 
if (Var20){
free(Var7->memberVar11); 
Var7->memberVar11=Var20; 
Var7->memberVar4=Var33; 
memcpy(Var7->memberVar11,Var31,Var33); 
else 
FUNC13(STRING,Var33); 
char *Var41=strdup(Var2+2); 
char  Var17=*Var42; 
STRUCT1  Var32=FUNC9(Var7->memberVar5,Var2+2); 
char *Var14=FUNC14(Var7,Var2+2); 
STRUCT5 *Var38=FUNC11(Var20,Var34); 
STRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); 
char *Var43=FUNC15(Var7->memberVar12,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var44=strchr(Var2+2,); 
int  Var45=FUNC9(Var7->memberVar5,Var44); 
const STRUCT3 *Var20=(const STRUCT3 *) FUNC16(Var2+2); 
STRUCT5 *Var38=FUNC11(Var20,Var34); 
STRUCT6 *Var39=FUNC12(Var7->memberVar1,Var38,Var40,0); 
char *Var46=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC17((STRUCT3) Var2[1])&&!Var32){
if (!FUNC18(Var7->memberVar13,Var2+1)){
else 
char  Var17=*Var47; 
if (Var5){
char *Var48=Var2+3; 
char *Var49=Var2+3; 
STRUCT1  Var50=FUNC9(Var7->memberVar5,Var49); 
STRUCT1  Var51=FUNC9(Var7->memberVar5,Var52+1); 
",1917,0
after_cmd.c,r_core_cmd_subst_i,False,False,571,CWE-,CallExpression,free,3209,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tR_FREE (core->oobi);\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tbuf = malloc (sz);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
int  Var26=-1; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
STRUCT3  Var27=Var28; 
char *Var29,*Var30; 
if (Var21){
if (!Var30||!*Var30){
else 
char *Var31=strchr(Var2,; ); 
FUNC4(Var1,Var2); 
if (!Var31){
if (*Var30){
if (Var30[1]== ||(Var30[1]&&Var30[2]== )){
char *Var32=strchr(Var30+1,); 
Var27=Var1->memberVar6; 
FUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); 
const bool  Var33=Var30[2]== >; 
if (Var30&&*Var30&&Var30[1]== |){
FUNC7(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var29); 
if (Var27 !=  Var28){
FUNC5(Var1,Var27,1); 
if (!Var30){
if (Var20){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC8(Var1,Var34); 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (FUNC9(Var1,Var2) == -1){
Var15=FUNC9(Var1,Var2); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
Var2=FUNC10(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
FUNC8(Var1,Var36); 
else 
}else if (!FUNC11(Var7+1,STRING,1)){//STRING
Var18=FUNC12(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var19=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,Var37); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC14(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var38=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var39=FUNC15(Var1->memberVar1,Var7+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var18=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,0); 
Var19=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,Var37); 
Var7=(char *) FUNC16(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var40){
Var7=strchr(Var2,&); 
FUNC17(Var1->memberVar9); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
if (*Var2 != ){
int  Var41=0; 
FUNC18(Var1,Var41,Var2); 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
if (Var7){
if (FUNC19()->memberVar1){
if (Var7[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var42[1024]; 
int  Var15; 
if (FUNC20(stdin)){
Var1->memberVar10  STRUCT5  Var15; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var42,Var9)){
strcat((char *) Var1->memberVar9,Var42); 
if (!*Var9){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC21(Var9,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var7 ==  Var2){
return FUNC22(Var1,(const char *) Var1->memberVar9); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
FUNC8(Var1,Var34); 
int  Var43=1; 
int  Var44=FUNC12(Var1->memberVar8,STRING); 
int  Var45=false ; 
int  Var46=FUNC12(Var1->memberVar8,STRING); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC23(Var7[-2])){
char *Var47=Var7-1; 
if (*Var47 ==  Var48){//STRING
Var18=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var9,STRING)){
FUNC13(Var1->memberVar8,STRING,Var37); 
const bool  Var49=(Var7[1]== >); 
if (*Var9 == ){
char *Var50=FUNC24(Var1,Var2); 
if (Var49){
char *Var51=FUNC25(Var1->memberVar5,Var9,1); 
if (Var51){
char *Var52=FUNC26(STRING,Var51,Var50); 
if (Var52){
FUNC27(Var1->memberVar5,Var9,Var52,1); 
else 
char *Var53=FUNC26(STRING,Var50); 
FUNC27(Var1->memberVar5,Var9,Var53,1); 
else 
char *Var53=FUNC26(STRING,Var50); 
FUNC27(Var1->memberVar5,Var9,Var53,1); 
else 
}else if (Var43>0){
if (Var16 != -1){
if (!Var44){
FUNC13(Var1->memberVar8,STRING,Var37); 
Var15=FUNC9(Var1,Var2); 
if (!Var44){
FUNC13(Var1->memberVar8,STRING,Var46); 
if (Var45){
const char *Var54=FUNC28(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,Var46); 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
Var1->memberVar11->memberVar1=false ; 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var55=false ; 
if (Var55){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var7[1]== !){
Var9=FUNC29(Var1,Var7+1); 
else 
int  Var46=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var9=FUNC24(Var1,Var7+1); 
Var1->memberVar12=false ; 
FUNC13(Var1->memberVar8,STRING,Var46); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var15=FUNC9(Var1,Var2); 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (*Var2 != &&*Var2){
const char *Var56=strstr(Var2,STRING); 
if (Var56){
bool  Var57=false ; 
if (Var57){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar13=Var7 true false ; 
int  Var58=0; 
if (Var7){
char *Var59,*Var8=strchr(Var7+1,!); 
STRUCT3  Var60=Var1->memberVar6; 
bool  Var61=false ; 
char *Var62=NULL ; 
const char *Var63=NULL ; 
bool  Var64=false ; 
bool  Var65=false ; 
char *Var66=NULL ; 
char *Var67=NULL ; 
bool  Var68=false ; 
int  Var69=-1; 
int  Var70,Var71; 
STRUCT6 *Var42; 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var72=strdup(Var7+2); 
char *Var73=strchr(Var72,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+4); 
FUNC31(Var1,FUNC32((Var74) Var60-(Var74) Var1->memberVar6)); 
else 
Var60=FUNC30(Var1->memberVar7,Var1->memberVar6,Var7+3); 
FUNC5(Var1,Var60,1); 
Var24=Var1->memberVar13=true ; 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var68=FUNC33(Var1->memberVar14,Var7+2); 
int  Var75=(int ) FUNC6(Var1->memberVar7,Var7+2); 
STRUCT7 *Var76=FUNC34(Var1->memberVar15,Var1->memberVar6); 
if (Var76){
if (Var75 >= 0&&Var75<Var76->memberVar1){
STRUCT8  Var77=FUNC35(Var76,Var75); 
FUNC5(Var1,Var76->memberVar2+Var77,1); 
Var24=Var1->memberVar13=true ; 
if (Var59){
STRUCT9 *Var78=FUNC36((const STRUCT6 *) Var59,Var70); 
STRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var13){
FUNC13(Var1->memberVar8,STRING,1); 
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); 
Var42=malloc(Var70); 
if (Var42){
free(Var1->memberVar16); 
Var1->memberVar16=Var42; 
Var1->memberVar4=Var70; 
memcpy(Var1->memberVar16,Var59,Var70); 
if (Var7[1]== ){
STRUCT3  Var81; 
char *Var82=strdup(Var7+2); 
char *Var83=FUNC40(Var82); 
if (Var83){
char  Var35=*Var83; 
Var81=FUNC41(Var1->memberVar17,Var82); 
Var81=FUNC6(Var1->memberVar7,Var84); 
else 
Var81=FUNC41(Var1->memberVar17,Var7+2); 
FUNC5(Var1,Var81,1); 
Var24=Var1->memberVar13=true ; 
Var64=FUNC42(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var62); 
Var26=FUNC12(Var1->memberVar8,STRING); 
FUNC13(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); 
if (memberVar2){
FUNC14(Var1,STRING,Var7+2); 
Var24=Var1->memberVar13=true ; 
char *Var2=FUNC43(Var1,Var7+2); 
if (Var7[1]== ){
if (Var42){
FUNC31(Var1,FUNC32(Var71)); 
if (Var71>0){
STRUCT9 *Var78=FUNC36(Var42,Var71); 
STRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); 
if (Var79){
if (Var13){
FUNC13(Var1->memberVar8,STRING,1); 
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); 
FUNC31(Var1,Var71); 
FUNC44(Var1); 
char *Var85=FUNC45(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var85){
FUNC5(Var1,FUNC6(Var1->memberVar7,Var85),1); 
if (Var7[1]== ){
Var69=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC46(Var1->memberVar1,FUNC47(Var7+2)); 
if (Var7[1]== ){
char *Var32=strchr(Var7+2,); 
if (Var32){
int  Var86=FUNC6(Var1->memberVar7,Var32); 
Var64=FUNC42(Var1,Var86,&Var62); 
Var65=FUNC48(Var1,Var7+2,&Var67); 
FUNC31(Var1,Var71); 
const STRUCT6 *Var42=(const STRUCT6 *) FUNC49(Var7+2); 
if (Var71>0){
STRUCT9 *Var78=FUNC36(Var42,Var71); 
STRUCT2 *Var79=FUNC37(Var1->memberVar1,Var78,Var80,0); 
if (!Var1->memberVar1->memberVar1){
FUNC13(Var1->memberVar8,STRING,1); 
if (Var79){
if (Var13){
FUNC13(Var1->memberVar8,STRING,1); 
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,Var1->memberVar6,FUNC39(Var78)); 
FUNC31(Var1,Var71); 
char *Var87=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
FUNC31(
Var1,FUNC6(Var1->memberVar7,Var8+1)); 
memberVar2=FUNC6(Var1->memberVar7,Var63); 
if (FUNC50((STRUCT6) Var7[1])&&!memberVar2){
if (!FUNC51(Var1->memberVar14,Var7+1)){
else 
char  Var35=*Var63; 
if (Var35 == -||Var35 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var79=Var12; 
if (Var79){
FUNC38(Var1->memberVar1,Var79->memberVar1,Var79->memberVar2,0,memberVar2,FUNC52(Var79)); 
if (Var10){
Var1->memberVar19=!!Var12; 
if (Var1->memberVar19){
FUNC44(Var1); 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var88=Var7+3; 
Var15=FUNC53(Var1,Var2,Var88); 
else 
Var15=FUNC54(Var1,Var2,Var7+2); 
else 
bool  memberVar13=false ; 
const char *Var89[]={STRING,STRING,STRING,
const char *Var90[]={STRING,STRING,STRING,
STRUCT3  Var91[FUNC55(Var89)-1],Var92[FUNC55(Var90)-1]; 
if (Var7[1]== (){
char *Var93=Var7+3; 
char *Var30=strchr(Var93,); 
if (!Var30){
STRUCT3  Var94=FUNC6(Var1->memberVar7,Var93); 
STRUCT3  Var95=FUNC6(Var1->memberVar7,Var30+1); 
for (Var14=0; Var89[Var14]; Var14  Var40){
Var91[Var14]=FUNC12(Var1->memberVar8,Var89[Var14]); 
for (Var14=0; Var90[Var14]; Var14  Var40){
Var92[Var14]=FUNC12(Var1->memberVar8,Var90[Var14]); 
for (Var14=0; Var89[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var89[Var14],Var94); 
for (Var14=0; Var90[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var90[Var14],Var95); 
if (Var17){
if (Var61){
Var1->memberVar6=memberVar2; 
Var15=FUNC3(Var1->memberVar5,FUNC56(Var2)); 
else 
if (Var61){
if (Var7[1]){
FUNC5(Var1,memberVar2,1); 
FUNC44(Var1); 
Var15=FUNC3(Var1->memberVar5,FUNC56(Var2)); 
if (memberVar13){
for (Var14=0; Var89[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var89[Var14],Var91[Var14]); 
for (Var14=0; Var90[Var14]; Var14  Var40){
FUNC13(Var1->memberVar8,Var90[Var14],Var92[Var14]); 
if (Var8){
FUNC31(Var1,Var25); 
if (Var65){
Var1->memberVar2=Var22; 
FUNC57(Var1->memberVar8,STRING,Var67); 
if (Var69 != -1){
FUNC46(Var1->memberVar1,Var69); 
if (Var12){
if (Var13){
FUNC13(Var1->memberVar8,STRING,0); 
if (Var64){
FUNC57(Var1->memberVar8,STRING,Var62); 
Var1->memberVar3=Var23; 
if (Var25 !=  Var1->memberVar4){
FUNC31(Var1,Var25); 
if (Var66){
FUNC4(Var1,Var66); 
if (Var68){
FUNC58(Var1->memberVar14); 
Var58=Var2 FUNC3(Var1->memberVar5,FUNC56(Var2)) false ; 
if (Var18 != -1){
FUNC13(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC13(Var1->memberVar8,STRING,Var19); 
Var1->memberVar2=Var22; 
Var1->memberVar3=Var23; 
if (Var26 != -1){
FUNC13(Var1->memberVar8,STRING,Var26); 
",5905,0
after_cmd.c,r_core_cmd_subst_i,False,False,572,CWE-,CallExpression,memcpy,3212,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tR_FREE (core->oobi);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tbuf = malloc (sz);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', 'else\n', '\t\t\t\t\t\teprintf (""cannot alloc %d"", sz);\n', '\t\t\t\t\tfree (f);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
int  Var26=-1; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
STRUCT3  Var27=Var28; 
char *Var29,*Var30; 
if (Var21){
if (!Var30||!*Var30){
else 
char *Var31=strchr(Var2,; ); 
FUNC4(Var1,Var2); 
if (!Var31){
if (*Var30){
if (Var30[1]== ||(Var30[1]&&Var30[2]== )){
char *Var32=strchr(Var30+1,); 
Var27=Var1->memberVar6; 
FUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); 
const bool  Var33=Var30[2]== >; 
if (Var30&&*Var30&&Var30[1]== |){
FUNC7(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var29); 
if (Var27 !=  Var28){
FUNC5(Var1,Var27,1); 
if (!Var30){
if (Var20){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC8(Var1,Var34); 
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37
if (Var7&&(Var7[1]== ||Var7[1]==  Var38)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (FUNC10(Var1,Var2) == -1){
Var15=FUNC10(Var1,Var2); 
Var7=(char *) FUNC11(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC12(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
FUNC8(Var1,Var40); 
else 
}else if (!FUNC13(Var7+1,STRING,1)){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC16(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var42=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var43=FUNC17(Var1->memberVar1,Var7+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
Var7=(char *) FUNC11(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){
Var7=strchr(Var2,&); 
FUNC18(Var1->memberVar9); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var45=0; 
FUNC19(Var1,Var45,Var2); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC20()->memberVar1){
if (Var7[1]== <){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var46[1024]; 
int  Var15; 
if (FUNC21(stdin)){
Var1->memberVar10  STRUCT5  Var15; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var46,Var9)){
strcat((char *) Var1->memberVar9,Var46); 
if (!*Var9){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC22(Var9,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var7 ==  Var2){
return FUNC23(Var1,(const char *) Var1->memberVar9); 
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
if (Var7[0]&&Var7[1]== ){
FUNC8(Var1,Var34); 
int  Var47=1; 
int  Var48=FUNC14(Var1->memberVar8,STRING); 
int  Var49=false ; 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
*Var7=0; 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC24(Var7[-2])){
char *Var51=Var7-1; 
if (*Var51 ==  Var52){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var9,STRING)){
FUNC15(Var1->memberVar8,STRING,Var41); 
const bool  Var53=(Var7[1]== >); 
if (*Var9 == ){
char *Var54=FUNC25(Var1,Var2); 
if (Var53){
char *Var55=FUNC26(Var1->memberVar5,Var9,1); 
if (Var55){
char *Var56=FUNC27(STRING,Var55,Var54); 
if (Var56){
FUNC28(Var1->memberVar5,Var9,Var56,1); 
else 
char *Var57=FUNC27(STRING,Var54); 
FUNC28(Var1->memberVar5,Var9,Var57,1); 
else 
char *Var57=FUNC27(STRING,Var54); 
FUNC28(Var1->memberVar5,Var9,Var57,1); 
else 
}else if (Var47>0){
if (Var16 != -1){
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var41); 
Var15=FUNC10(Var1,Var2); 
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var49){
const char *Var58=FUNC29(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar11->memberVar1=false ; 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
bool  Var59=false ; 
if (Var59){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var7[1]== !){
Var9=FUNC30(Var1,Var7+1); 
else 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var9=FUNC25(Var1,Var7+1); 
Var1->memberVar12=false ; 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var15=FUNC10(Var1,Var2); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (*Var2 != &&*Var2){
const char *Var60=strstr(Var2,STRING); 
if (Var60){
bool  Var61=false ; 
if (Var61){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar13=Var7 true false ; 
int  Var62=0; 
if (Var7){
char *Var63,*Var8=strchr(Var7+1,!); 
STRUCT3  Var64=Var1->memberVar6; 
bool  Var65=false ; 
char *Var66=NULL ; 
const char *Var67=NULL ; 
bool  Var68=false ; 
bool  Var69=false ; 
char *Var70=NULL ; 
char *Var71=NULL ; 
bool  Var72=false ; 
int  Var73=-1; 
int  Var74,Var75; 
STRUCT6 *Var46; 
*Var7  Var44=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var44){
if (*Var7&&Var7[1]== ){
else 
Var7  Var76; 
Var7=FUNC31(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var77=strdup(Var7+2); 
char *Var78=strchr(Var77,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+4); 
FUNC33(Var1,FUNC34((Var79) Var64-(Var79) Var1->memberVar6)); 
else 
Var64=FUNC32(Var1->memberVar7,Var1->memberVar6,Var7+3); 
FUNC5(Var1,Var64,1); 
Var24=Var1->memberVar13=true ; 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var72=FUNC35(Var1->memberVar14,Var7+2); 
int  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); 
STRUCT7 *Var81=FUNC36(Var1->memberVar15,Var1->memberVar6); 
if (Var81){
if (Var80 >= 0&&Var80<Var81->memberVar1){
STRUCT8  Var82=FUNC37(Var81,Var80); 
FUNC5(Var1,Var81->memberVar2+Var82,1); 
Var24=Var1->memberVar13=true ; 
Var63=FUNC22(Var7+2,&Var74); 
if (Var63){
STRUCT9 *Var83=FUNC38((const STRUCT6 *) Var63,Var74); 
STRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); 
Var46=malloc(Var74); 
if (Var46){
free(Var1->memberVar16); 
Var1->memberVar16=Var46; 
Var1->memberVar4=Var74; 
memcpy(Var1->memberVar16,Var63,Var74); 
else 
FUNC42(STRING,Var74); 
free(Var63); 
if (Var7[1]== ){
STRUCT3  Var86; 
char *Var87=strdup(Var7+2); 
char *Var88=FUNC43(Var87); 
if (Var88){
char  Var39=*Var88; 
Var86=FUNC44(Var1->memberVar17,Var87); 
Var86=FUNC6(Var1->memberVar7,Var89); 
else 
Var86=FUNC44(Var1->memberVar17,Var7+2); 
FUNC5(Var1,Var86,1); 
Var24=Var1->memberVar13=true ; 
Var68=FUNC45(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); 
Var26=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); 
if (memberVar2){
FUNC16(Var1,STRING,Var7+2); 
Var24=Var1->memberVar13=true ; 
char *Var2=FUNC46(Var1,Var7+2); 
if (Var7[1]== ){
if (Var46){
FUNC33(Var1,FUNC34(Var75)); 
if (Var75>0){
STRUCT9 *Var83=FUNC38(Var46,Var75); 
STRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); 
FUNC33(Var1,Var75); 
FUNC47(Var1); 
char *Var90=FUNC48(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var90){
FUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); 
if (Var7[1]== ){
Var73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC49(Var1->memberVar1,FUNC50(Var7+2)); 
if (Var7[1]== ){
char *Var32=strchr(Var7+2,); 
if (Var32){
int  Var91=FUNC6(Var1->memberVar7,Var32); 
Var68=FUNC45(Var1,Var91,&Var66); 
Var69=FUNC51(Var1,Var7+2,&Var71); 
FUNC33(Var1,Var75); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC52(Var7+2); 
if (Var75>0){
STRUCT9 *Var83=FUNC38(Var46,Var75); 
STRUCT2 *Var84=FUNC39(Var1->memberVar1,Var83,Var85,0); 
if (!Var1->memberVar1->memberVar1){
FUNC15(Var1->memberVar8,STRING,1); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC41(Var83)); 
FUNC33(Var1,Var75); 
*Var7=; 
char *Var92=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
FUNC33(
Var1,FUNC6(Var1->memberVar7,Var8+1)); 
memberVar2=FUNC6(Var1->memberVar7,Var67); 
if (FUNC53((STRUCT6) Var7[1])&&!memberVar2){
if (!FUNC54(Var1->memberVar14,Var7+1)){
else 
char  Var39=*Var67; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var84=Var12; 
if (Var84){
FUNC40(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC55(Var84)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar19=!!Var12; 
if (Var1->memberVar19){
FUNC47(Var1); 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var93=Var7+3; 
Var15=FUNC56(Var1,Var2,Var93); 
else 
Var15=FUNC57(Var1,Var2,Var7+2); 
else 
bool  memberVar13=false ; 
const char *Var94[]={STRING,STRING,STRING,
const char *Var95[]={STRING,STRING,STRING,
STRUCT3  Var96[FUNC58(Var94)-1],Var97[FUNC58(Var95)-1]; 
if (Var7[1]== (){
char *Var98=Var7+3; 
char *Var30=strchr(Var98,); 
if (!Var30){
STRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); 
STRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); 
for (Var14=0; Var94[Var14]; Var14  Var44){
Var96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
Var97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); 
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var99); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var100); 
if (Var17){
if (Var65){
Var1->memberVar6=memberVar2; 
Var15=FUNC3(Var1->memberVar5,FUNC59(Var2)); 
else 
if (Var65){
if (Var7[1]){
FUNC5(Var1,memberVar2,1); 
FUNC47(Var1); 
Var15=FUNC3(Var1->memberVar5,FUNC59(Var2)); 
if (memberVar13){
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); 
if (Var8){
FUNC33(Var1,Var25); 
if (Var69){
Var1->memberVar2=Var22; 
FUNC60(Var1->memberVar8,STRING,Var71); 
if (Var73 != -1){
FUNC49(Var1->memberVar1,Var73); 
if (Var12){
if (Var13){
FUNC15(Var1->memberVar8,STRING,0); 
if (Var68){
FUNC60(Var1->memberVar8,STRING,Var66); 
Var1->memberVar3=Var23; 
if (Var25 !=  Var1->memberVar4){
FUNC33(Var1,Var25); 
if (Var70){
FUNC4(Var1,Var70); 
if (Var72){
FUNC61(Var1->memberVar14); 
Var62=Var2 FUNC3(Var1->memberVar5,FUNC59(Var2)) false ; 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar2=Var22; 
Var1->memberVar3=Var23; 
if (Var26 != -1){
FUNC15(Var1->memberVar8,STRING,Var26); 
",6239,0
after_cmd.c,r_core_cmd_subst_i,False,False,573,CWE-,CallExpression,free,3217,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', '\t\t\t\t\tfree (f);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var20=strchr(Var2,; ); 
char *Var21=strchr(Var22+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25
if (Var7&&(Var7[1]== ||Var7[1]==  Var26)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var28=Var1->memberVar5->memberVar1; 
else 
char *Var29=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
char  Var31[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
if (Var7[0]&&Var7[1]== ){
int  Var32=FUNC9(Var1->memberVar7,STRING); 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var34=Var7-1; 
const bool  Var35=(Var7[1]== >); 
char *Var36=FUNC10(Var1,Var2); 
char *Var37=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var38=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
bool  Var39=false ; 
if (Var39){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var40=strstr(Var2,STRING); 
if (Var40){
bool  Var41=false ; 
if (Var41){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var42,*Var8=strchr(Var7+1,!); 
STRUCT3  Var43=Var1->memberVar9; 
char *Var44=NULL ; 
const char *Var45=NULL ; 
char *Var46=NULL ; 
char *Var47=NULL ; 
int  Var48,Var49; 
STRUCT5 *Var31; 
*Var7  Var30=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var30){
if (*Var7&&Var7[1]== ){
else 
Var7  Var50; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var51=strdup(Var7+2); 
char *Var52=strchr(Var51,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); 
Var42=FUNC17(Var7+2,&Var48); 
if (Var42){
STRUCT7 *Var55=FUNC18((const STRUCT5 *) Var42,Var48); 
STRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); 
if (Var31){
memcpy(Var1->memberVar11,Var42,Var48); 
free(Var42); 
char *Var58=strdup(Var7+2); 
char  Var27=*Var59; 
STRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC20(Var1,Var7+2); 
STRUCT7 *Var55=FUNC18(Var31,Var49); 
STRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); 
char *Var60=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var21=strchr(Var7+2,); 
int  Var61=FUNC15(Var1->memberVar5,Var21); 
const STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); 
STRUCT7 *Var55=FUNC18(Var31,Var49); 
STRUCT2 *Var56=FUNC19(Var1->memberVar1,Var55,Var57,0); 
*Var7=; 
char *Var62=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC23((STRUCT5) Var7[1])&&!Var43){
if (!FUNC24(Var1->memberVar13,Var7+1)){
else 
char  Var27=*Var45; 
STRUCT2 *Var56=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var7+3; 
char *Var22=strchr(Var66,); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); 
STRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); 
",2537,0
after_cmd.c,r_core_cmd_subst_i,False,False,574,CWE-,CallExpression,strdup,3226,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\t*sep = 0;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\t*sep = ch;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
*Var72=0; 
Var70=FUNC27(Var1->memberVar13,Var71); 
*Var72=Var33; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
free(Var71); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var53=FUNC37(Var7+1); 
if (FUNC38((STRUCT5) Var7[1])&&!Var50){
if (!FUNC39(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC40(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
*Var7=; 
",3363,0
after_cmd.c,r_core_cmd_subst_i,False,False,575,CWE-,CallExpression,free,3235,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tfree (numexpr);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (arroba) {\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tchar *range = ptr + 3;\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
int  Var6=!Var7->memberVar1->memberVar1; 
int  Var8,Var9=0,Var10; 
bool  Var11=Var7->memberVar2; 
bool  Var12=Var7->memberVar3; 
STRUCT1  Var13=Var7->memberVar4; 
if (!Var14){
switch (*Var14){
if (Var14[1]== ){/*STRUCT2 */
else 
char *Var15=strchr(Var14,; ); 
if (Var14[1]!= *&&!strstr(Var14,STRING)){
if (Var14[1]== >){
if (*Var14 != ){
if (Var16&&Var2){
int  Var9; 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
char *Var3=strchr(Var14,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var18=Var7->memberVar5->memberVar1; 
else 
char *Var19=FUNC2(Var7->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var9 == -1){
if (Var2&&(Var2 ==  Var14||Var2[-1]!= )){
if (*Var14 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
int  Var9; 
if (!*Var4){
if (!Var7->memberVar6){
else 
}else if (Var2 ==  Var14){
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
if (Var2[0]&&Var2[1]== ){
int  Var20=FUNC4(Var7->memberVar7,STRING); 
int  Var21=FUNC4(Var7->memberVar7,STRING); 
if (!*Var4){
char *Var22=Var2-1; 
const bool  Var23=(Var2[1]== >); 
char *Var24=FUNC5(Var7,Var14); 
char *Var25=FUNC6(Var7->memberVar8,Var4,1); 
const char *Var26=FUNC7(Var7->memberVar7,STRING); 
if (Var2){
if (Var2>Var14){
char *Var17=Var2-1; 
if (*Var17 == ){
bool  Var27=false ; 
if (Var27){
else 
int  memberVar1=Var7->memberVar5->memberVar1; 
else 
int  Var21=FUNC4(Var7->memberVar7,STRING); 
if (*Var14 != &&*Var14){
const char *Var28=strstr(Var14,STRING); 
if (Var28){
bool  Var29=false ; 
if (Var29){
if (Var2){
char *Var30,*Var3=strchr(Var2+1,!); 
STRUCT1  Var31=Var7->memberVar9; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var32=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT1  Var31=FUNC8(Var7->memberVar5,Var7->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var33=(int ) FUNC9(Var7->memberVar5,Var2+2); 
STRUCT3 *Var34=FUNC10(Var7->memberVar10,Var7->memberVar9); 
STRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); 
if (Var2[1]== ){
char *Var38=strdup(Var2+2); 
char *Var39=FUNC12(Var38); 
if (Var39){
char  Var17=*Var39; 
free(Var40); 
STRUCT1  Var31=FUNC9(Var7->memberVar5,Var2+2); 
char *Var14=FUNC13(Var7,Var2+2); 
STRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); 
char *Var41=FUNC14(Var7->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var42=strchr(Var2+2,); 
int  Var43=FUNC9(Var7->memberVar5,Var42); 
const STRUCT5 *Var44=(const STRUCT5 *) FUNC15(Var2+2); 
STRUCT4 *Var35=FUNC11(Var7->memberVar1,Var36,Var37,0); 
char *Var45=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC16((STRUCT5) Var2[1])&&!Var31){
if (!FUNC17(Var7->memberVar12,Var2+1)){
else 
char  Var17=*Var46; 
if (Var5){
char *Var47=Var2+3; 
char *Var48=Var2+3; 
STRUCT1  Var49=FUNC9(Var7->memberVar5,Var48); 
STRUCT1  Var50=FUNC9(Var7->memberVar5,Var51+1); 
",1786,0
after_cmd.c,r_core_cmd_subst_i,False,False,576,CWE-,CallExpression,free,3241,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\tfree (mander);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var20=strchr(Var2,; ); 
char *Var21=strchr(Var22+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25
if (Var7&&(Var7[1]== ||Var7[1]==  Var26)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var28=Var1->memberVar5->memberVar1; 
else 
char *Var29=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
if (Var7[0]&&Var7[1]== ){
int  Var31=FUNC9(Var1->memberVar7,STRING); 
int  Var32=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var33=Var7-1; 
const bool  Var34=(Var7[1]== >); 
char *Var35=FUNC10(Var1,Var2); 
char *Var36=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var37=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
bool  Var38=false ; 
if (Var38){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var32=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var39=strstr(Var2,STRING); 
if (Var39){
bool  Var40=false ; 
if (Var40){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var41,*Var8=strchr(Var7+1,!); 
STRUCT3  Var42=Var1->memberVar9; 
char *Var43=NULL ; 
const char *Var44=NULL ; 
char *Var45=NULL ; 
char *Var46=NULL ; 
*Var7  Var30=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var30){
if (*Var7&&Var7[1]== ){
else 
Var7  Var47; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var48=strdup(Var7+2); 
char *Var49=strchr(Var48,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var42=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var50=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT5 *Var51=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); 
if (Var7[1]== ){
STRUCT3  Var55; 
char *Var56=strdup(Var7+2); 
char *Var57=FUNC18(Var56); 
if (Var57){
char  Var27=*Var57; 
Var55=FUNC19(Var1->memberVar11,Var56); 
free(Var56); 
STRUCT3  Var42=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC20(Var1,Var7+2); 
STRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); 
char *Var58=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var21=strchr(Var7+2,); 
int  Var59=FUNC15(Var1->memberVar5,Var21); 
const STRUCT6 *Var60=(const STRUCT6 *) FUNC22(Var7+2); 
STRUCT2 *Var52=FUNC17(Var1->memberVar1,Var53,Var54,0); 
*Var7=; 
char *Var61=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC23((STRUCT6) Var7[1])&&!Var42){
if (!FUNC24(Var1->memberVar13,Var7+1)){
else 
char  Var27=*Var44; 
STRUCT2 *Var52=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var62=Var7+3; 
const char *Var63[]={STRING,STRING,STRING,
const char *Var64[]={STRING,STRING,STRING,
char *Var65=Var7+3; 
char *Var22=strchr(Var65,); 
STRUCT3  Var66=FUNC15(Var1->memberVar5,Var65); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var22+1); 
",2458,0
after_cmd.c,r_core_cmd_subst_i,False,False,577,CWE-,CallExpression,free,3266,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tchar *$0 = strstr (cmd, ""$("");\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tchar *line, *p;\n', '\t\t\thaveQuote = *cmd == \'""\';\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tcmd++;\n', '\t\t\t\tp = *cmd ? find_eoq (cmd) : NULL;\n', '\t\t\t\tif (!p || !*p) {\n', '\t\t\t\t\teprintf (""Missing \\"" in (%s)."", cmd);\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\t\tline = strdup (cmd);\n', ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", ""\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""command error(%s)\\n"", cmd);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', ""\tptr = strchr (cmd, '`');\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcmd = r_str_append (strdup (cmd), str);\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tfree (cmd);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', ""\tif (*cmd != '.') {\n"", '\t\tgrep = r_cons_grep_strip (cmd, quotestr);\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\tfree (cmd);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\t\twhile (trim > cmd) {\n', '\t\t\t\tif (!IS_WHITESPACE (*trim)) {\n', '\t\tcmd = r_str_trim_nc (cmd);\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
char *0=strstr(Var2,STRING); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
char *Var24,*Var25; 
Var19=*Var2 == ; 
if (Var19){
Var2  Var26; 
Var25=*Var2 FUNC4(Var2) NULL ; 
if (!Var25||!*Var25){
FUNC5(STRINGFUNC6(%Var27).,Var2); 
else 
char *Var28=strchr(Var2,; ); 
FUNC7(Var1,Var2); 
if (!Var28){
char *Var29=strchr(Var25+1,); 
const bool  Var30=Var25[2]== >; 
Var24=strdup(Var2); 
if (Var25&&*Var25&&Var25[1]== |){
FUNC8(Var1,Var2,Var9); 
if (!Var25){
if (Var18){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
Var7=(char *) FUNC10(Var2,; ,Var5); 
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC10(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC11(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC12(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC13(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar6->memberVar1; 
if (*Var2){
FUNC8(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC14(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC10(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
FUNC5(STRING,Var2); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var26){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var38=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC15(Var1,Var38,Var2); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC16()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar7){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
if (Var7[0]&&Var7[1]== ){
int  Var39=1; 
int  Var40=FUNC17(Var1->memberVar8,STRING); 
int  Var41=false ; 
int  Var42=FUNC17(Var1->memberVar8,STRING); 
*Var7=0; 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC18(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
if (*Var9 == ){
char *Var45=FUNC19(Var1,Var2); 
char *Var46=FUNC20(Var1->memberVar5,Var9,1); 
char *Var47=FUNC21(STRING,Var46,Var45); 
else 
char *Var48=FUNC21(STRING,Var45); 
else 
char *Var48=FUNC21(STRING,Var45); 
else 
}else if (Var39>0){
if (Var16 != -1){
Var15=FUNC22(Var1,Var2); 
const char *Var49=FUNC23(Var1->memberVar8,STRING); 
Var7=strchr(Var2,); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var50=false ; 
if (Var50){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar6->memberVar1; 
else 
int  Var42=FUNC17(Var1->memberVar8,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var2=FUNC24(strdup(Var2),Var9); 
Var15=FUNC22(Var1,Var2); 
free(Var2); 
if (*Var2 != &&*Var2){
const char *Var27=strstr(Var2,STRING); 
if (Var27){
bool  Var51=false ; 
if (Var51){
if (*Var2 != .){
Var11=FUNC25(Var2,Var5); 
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
int  Var52=0; 
if (Var7){
char *Var53,*Var8=strchr(Var7+1,!); 
STRUCT3  Var54=Var1->memberVar9; 
bool  Var55=false ; 
char *Var56=NULL ; 
const char *Var57=NULL ; 
bool  Var58=false ; 
bool  Var59=false ; 
char *Var60=NULL ; 
char *Var61=NULL ; 
bool  Var62=false ; 
*Var7  Var26=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var26){
if (*Var7&&Var7[1]== ){
else 
Var7  Var63; 
Var7=FUNC26(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var64=strdup(Var7+2); 
char *Var65=strchr(Var64,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var54=FUNC27(Var1->memberVar6,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var66=(int ) FUNC28(Var1->memberVar6,Var7+2); 
STRUCT5 *Var67=FUNC29(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); 
char *Var71=strdup(Var7+2); 
char  Var35=*Var72; 
STRUCT3  Var54=FUNC28(Var1->memberVar6,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (!Var60){
Var60=Var2; 
else 
Var60=FUNC32(Var60,Var2); 
free(Var2); 
STRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); 
char *Var73=FUNC33(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var29=strchr(Var7+2,); 
int  Var74=FUNC28(Var1->memberVar6,Var29); 
const STRUCT6 *Var75=(const STRUCT6 *) FUNC34(Var7+2); 
STRUCT2 *Var68=FUNC30(Var1->memberVar1,Var69,Var70,0); 
*Var7=; 
char *Var76=Var7-2; 
while (Var76>Var2){
if (!FUNC35(*Var76)){
Var2=FUNC11(Var2); 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC36((STRUCT6) Var7[1])&&!Var54){
if (!FUNC37(Var1->memberVar12,Var7+1)){
else 
char  Var35=*Var57; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var77=Var7+3; 
Var15=FUNC38(Var1,Var2,Var77); 
else 
Var15=FUNC39(Var1,Var2,Var7+2); 
else 
bool  Var4=false ; 
const char *Var78[]={STRING,STRING,STRING,
const char *Var79[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var80=Var7+3; 
char *Var25=strchr(Var80,); 
if (!Var25){
STRUCT3  Var81=FUNC28(Var1->memberVar6,Var80); 
STRUCT3  Var82=FUNC28(Var1->memberVar6,Var25+1); 
if (Var17){
Var15=FUNC3(Var1->memberVar5,FUNC40(Var2)); 
Var15=FUNC3(Var1->memberVar5,FUNC40(Var2)); 
Var52=Var2 FUNC3(Var1->memberVar5,FUNC40(Var2)) false ; 
",3392,0
after_cmd.c,r_core_cmd_subst_i,False,False,578,CWE-,CallExpression,malloc,3272,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var38){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var38){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=FUNC11(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
char *Var45=FUNC13(Var1,Var2); 
char *Var46=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var47=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar9=Var7 true false ; 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar10; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
int  Var62=-1; 
int  Var63,Var64; 
STRUCT5 *Var39; 
*Var7  Var38=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var38){
if (*Var7&&Var7[1]== ){
else 
Var7  Var65; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var66=strdup(Var7+2); 
char *Var67=strchr(Var66,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var61=FUNC18(Var1->memberVar11,Var7+2); 
int  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var70=FUNC21(Var69,Var68); 
Var52=FUNC22(Var7+2,&Var63); 
if (Var52){
STRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
else 
FUNC26(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var74; 
char *Var75=strdup(Var7+2); 
char *Var76=FUNC27(Var75); 
if (Var76){
char  Var35=*Var76; 
else 
Var74=FUNC28(Var1->memberVar13,Var7+2); 
Var57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); 
STRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); 
if (Var53){
FUNC30(Var1,STRING,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var64=FUNC32(Var7+2,Var39); 
FUNC33(Var1,FUNC34(Var64)); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
Var12=Var72; 
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); 
FUNC33(Var1,Var64); 
free(Var39); 
char *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC38(Var1->memberVar1,FUNC39(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var78=FUNC19(Var1->memberVar5,Var29); 
Var58=FUNC40(Var1,Var7+2,&Var60); 
Var64=strlen(Var7+2); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
*Var7=; 
char *Var79=Var7-2; 
Var7=FUNC42(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var56=FUNC42(Var7+1); 
if (FUNC43((STRUCT5) Var7[1])&&!Var53){
if (!FUNC44(Var1->memberVar11,Var7+1)){
FUNC26(STRING,Var7+1); 
else 
char  Var35=*Var56; 
if (Var53){
STRUCT2 *Var72=Var12; 
if (Var72){
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar15=!!Var12; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var80=Var7+3; 
else 
Var15=FUNC46(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var81[]={STRING,STRING,STRING,
const char *Var82[]={STRING,STRING,STRING,
STRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; 
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var27=strchr(Var85,); 
if (!Var27){
STRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); 
STRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); 
for (Var14=0; Var81[Var14]; Var14  Var38){
Var83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
Var84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); 
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var86); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var87); 
if (Var17){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
else 
if (Var54){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
if (memberVar9){
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); 
if (Var62 != -1){
FUNC38(Var1->memberVar1,Var62); 
if (Var12){
if (Var13){
FUNC48(Var1->memberVar7,STRING,0); 
FUNC25(Var12); 
if (Var57){
FUNC50(Var1->memberVar7,STRING,Var55); 
if (Var61){
FUNC51(Var1->memberVar11); 
*Var7=; 
Var51=Var15; 
if (Var18 != -1){
FUNC48(Var1->memberVar7,STRING,Var18); 
if (Var19 != -1){
FUNC48(Var1->memberVar7,STRING,Var19); 
if (Var12){
FUNC25(Var12); 
return  Var51; 
",4205,0
after_cmd.c,r_core_cmd_subst_i,False,False,579,CWE-,CallExpression,strlen,3272,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var38){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var38){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=FUNC11(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
char *Var45=FUNC13(Var1,Var2); 
char *Var46=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var47=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar9=Var7 true false ; 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar10; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
int  Var62=-1; 
int  Var63,Var64; 
STRUCT5 *Var39; 
*Var7  Var38=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var38){
if (*Var7&&Var7[1]== ){
else 
Var7  Var65; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var66=strdup(Var7+2); 
char *Var67=strchr(Var66,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var61=FUNC18(Var1->memberVar11,Var7+2); 
int  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var70=FUNC21(Var69,Var68); 
Var52=FUNC22(Var7+2,&Var63); 
if (Var52){
STRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
else 
FUNC26(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var74; 
char *Var75=strdup(Var7+2); 
char *Var76=FUNC27(Var75); 
if (Var76){
char  Var35=*Var76; 
else 
Var74=FUNC28(Var1->memberVar13,Var7+2); 
Var57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); 
STRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); 
if (Var53){
FUNC30(Var1,STRING,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var64=FUNC32(Var7+2,Var39); 
FUNC33(Var1,FUNC34(Var64)); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
Var12=Var72; 
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC36(Var71)); 
FUNC33(Var1,Var64); 
free(Var39); 
char *Var77=FUNC37(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC38(Var1->memberVar1,FUNC39(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var78=FUNC19(Var1->memberVar5,Var29); 
Var58=FUNC40(Var1,Var7+2,&Var60); 
Var64=strlen(Var7+2); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC41(Var7+2); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
*Var7=; 
char *Var79=Var7-2; 
Var7=FUNC42(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var56=FUNC42(Var7+1); 
if (FUNC43((STRUCT5) Var7[1])&&!Var53){
if (!FUNC44(Var1->memberVar11,Var7+1)){
FUNC26(STRING,Var7+1); 
else 
char  Var35=*Var56; 
if (Var53){
STRUCT2 *Var72=Var12; 
if (Var72){
FUNC35(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar15=!!Var12; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var80=Var7+3; 
else 
Var15=FUNC46(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var81[]={STRING,STRING,STRING,
const char *Var82[]={STRING,STRING,STRING,
STRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; 
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var27=strchr(Var85,); 
if (!Var27){
STRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); 
STRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); 
for (Var14=0; Var81[Var14]; Var14  Var38){
Var83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
Var84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); 
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var86); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var87); 
if (Var17){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
else 
if (Var54){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
if (memberVar9){
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); 
if (Var62 != -1){
FUNC38(Var1->memberVar1,Var62); 
if (Var12){
if (Var13){
FUNC48(Var1->memberVar7,STRING,0); 
FUNC25(Var12); 
if (Var57){
FUNC50(Var1->memberVar7,STRING,Var55); 
if (Var61){
FUNC51(Var1->memberVar11); 
*Var7=; 
Var51=Var15; 
if (Var18 != -1){
FUNC48(Var1->memberVar7,STRING,Var18); 
if (Var19 != -1){
FUNC48(Var1->memberVar7,STRING,Var19); 
if (Var12){
FUNC25(Var12); 
return  Var51; 
",4205,0
after_cmd.c,r_core_cmd_subst_i,False,False,580,CWE-,CallExpression,free,3294,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tfree (buf);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var20=strchr(Var2,; ); 
char *Var21=strchr(Var22+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var23  Var24  Var5  Var25
if (Var7&&(Var7[1]== ||Var7[1]==  Var26)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var28=Var1->memberVar5->memberVar1; 
else 
char *Var29=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var30){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
char  Var31[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
if (Var7[0]&&Var7[1]== ){
int  Var32=FUNC9(Var1->memberVar7,STRING); 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var34=Var7-1; 
const bool  Var35=(Var7[1]== >); 
char *Var36=FUNC10(Var1,Var2); 
char *Var37=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var38=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var27=Var7-1; 
if (*Var27 == ){
bool  Var39=false ; 
if (Var39){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var33=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var40=strstr(Var2,STRING); 
if (Var40){
bool  Var41=false ; 
if (Var41){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var42,*Var8=strchr(Var7+1,!); 
STRUCT3  Var43=Var1->memberVar9; 
char *Var44=NULL ; 
const char *Var45=NULL ; 
char *Var46=NULL ; 
char *Var47=NULL ; 
int  Var48,Var49; 
STRUCT5 *Var31; 
*Var7  Var30=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var30){
if (*Var7&&Var7[1]== ){
else 
Var7  Var50; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var51=strdup(Var7+2); 
char *Var52=strchr(Var51,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var43=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var53=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var54=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT7 *Var55=FUNC17((const STRUCT5 *) Var42,Var48); 
STRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); 
char *Var58=strdup(Var7+2); 
char  Var27=*Var59; 
STRUCT3  Var43=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC19(Var1,Var7+2); 
if (Var7[1]== ){
Var31=malloc(strlen(Var7+2)+1); 
if (Var31){
Var49=FUNC20(Var7+2,Var31); 
if (Var49>0){
STRUCT7 *Var55=FUNC17(Var31,Var49); 
STRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); 
free(Var31); 
char *Var60=FUNC21(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var21=strchr(Var7+2,); 
int  Var61=FUNC15(Var1->memberVar5,Var21); 
const STRUCT5 *Var31=(const STRUCT5 *) FUNC22(Var7+2); 
STRUCT7 *Var55=FUNC17(Var31,Var49); 
STRUCT2 *Var56=FUNC18(Var1->memberVar1,Var55,Var57,0); 
*Var7=; 
char *Var62=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC23((STRUCT5) Var7[1])&&!Var43){
if (!FUNC24(Var1->memberVar12,Var7+1)){
else 
char  Var27=*Var45; 
STRUCT2 *Var56=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
char *Var66=Var7+3; 
char *Var22=strchr(Var66,); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); 
STRUCT3  Var68=FUNC15(Var1->memberVar5,Var22+1); 
",2552,0
after_cmd.c,r_core_cmd_subst_i,False,False,581,CWE-,CallExpression,free,3307,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', '\t\t\t\t\t\tfree (out);\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
else 
char *Var24=strchr(Var2,; ); 
char *Var25=strchr(Var26+1,); 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var27  Var28  Var5  Var29
if (Var7&&(Var7[1]== ||Var7[1]==  Var30)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var31=Var7-1; 
if (*Var31 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var32=Var1->memberVar5->memberVar1; 
else 
char *Var33=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var34){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
char  Var35[1024]; 
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var31=Var7-1; 
if (*Var31 == ){
if (Var7[0]&&Var7[1]== ){
int  Var36=FUNC9(Var1->memberVar7,STRING); 
int  Var37=false ; 
int  Var38=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var39=Var7-1; 
const bool  Var40=(Var7[1]== >); 
char *Var41=FUNC10(Var1,Var2); 
char *Var42=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var43=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var31=Var7-1; 
if (*Var31 == ){
bool  Var44=false ; 
if (Var44){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var38=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var45=strstr(Var2,STRING); 
if (Var45){
bool  Var46=false ; 
if (Var46){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var47,*Var8=strchr(Var7+1,!); 
STRUCT3  Var48=Var1->memberVar10; 
bool  Var49=false ; 
char *Var50=NULL ; 
const char *Var51=NULL ; 
bool  Var52=false ; 
bool  Var53=false ; 
char *Var54=NULL ; 
char *Var55=NULL ; 
bool  Var56=false ; 
int  Var57,Var58; 
STRUCT5 *Var35; 
*Var7  Var34=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var34){
if (*Var7&&Var7[1]== ){
else 
Var7  Var59; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var60=strdup(Var7+2); 
char *Var61=strchr(Var60,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var48=FUNC14(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var62=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT6 *Var63=FUNC16(Var1->memberVar11,Var1->memberVar10); 
if (Var63){
if (Var62 >= 0&&Var62<Var63->memberVar1){
STRUCT7  Var64=FUNC17(Var63,Var62); 
Var22=Var1->memberVar9=true ; 
if (Var47){
STRUCT8 *Var65=FUNC18((const STRUCT5 *) Var47,Var57); 
STRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); 
if (Var35){
Var1->memberVar4=Var57; 
if (Var7[1]== ){
char *Var68=strdup(Var7+2); 
char  Var31=*Var69; 
Var22=Var1->memberVar9=true ; 
STRUCT3  Var48=FUNC15(Var1->memberVar5,Var7+2); 
if (Var48){
Var22=Var1->memberVar9=true ; 
char *Var2=FUNC20(Var1,Var7+2); 
STRUCT8 *Var65=FUNC18(Var35,Var58); 
STRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); 
char *Var70=FUNC21(Var1->memberVar12,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var70){
FUNC22(Var1,FUNC15(Var1->memberVar5,Var70),1); 
free(Var70); 
char *Var25=strchr(Var7+2,); 
int  Var71=FUNC15(Var1->memberVar5,Var25); 
const STRUCT5 *Var35=(const STRUCT5 *) FUNC23(Var7+2); 
STRUCT8 *Var65=FUNC18(Var35,Var58); 
STRUCT2 *Var66=FUNC19(Var1->memberVar1,Var65,Var67,0); 
*Var7=; 
char *Var72=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC24((STRUCT5) Var7[1])&&!Var48){
if (!FUNC25(Var1->memberVar13,Var7+1)){
else 
char  Var31=*Var51; 
STRUCT2 *Var66=Var12; 
if (Var10){
Var7=Var10+1; 
char *Var73=Var7+3; 
else 
bool  memberVar9=false ; 
const char *Var74[]={STRING,STRING,STRING,
const char *Var75[]={STRING,STRING,STRING,
char *Var76=Var7+3; 
char *Var26=strchr(Var76,); 
STRUCT3  Var77=FUNC15(Var1->memberVar5,Var76); 
STRUCT3  Var78=FUNC15(Var1->memberVar5,Var26+1); 
",2761,0
after_cmd.c,r_core_cmd_subst_i,False,False,582,CWE-,CallExpression,atoi,3315,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tint cmd_ignbithints = -1;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', '\t\tfor (; *cmd; ) {\n', '\t\t\tint pipefd = -1;\n', '\t\t\tut64 oseek = UT64_MAX;\n', '\t\t\tchar *line, *p;\n', '\t\t\tif (haveQuote) {\n', '\t\t\t\tif (!p || !*p) {\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\tr_core_cmd0 (core, cmd);\n', '\t\t\t\tif (!sc) {\n', '\t\t\tif (*p) {\n', ""\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', '\t\t\t\t\toseek = core->offset;\n', '\t\t\t\t\tr_core_seek (core, r_num_math (core->num, p + 2), 1);\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", ""\t\t\tif (p && *p && p[1] == '|') {\n"", '\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n', 'else\n', '\t\t\t\tr_cmd_call (core->rcmd, line);\n', '\t\t\tif (oseek != UT64_MAX) {\n', '\t\t\t\tr_core_seek (core, oseek, 1);\n', '\t\t\tif (!p) {\n', '\t\t\tif (eos) {\n', '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', '\t\t\treturn r_cmd_call (core->rcmd, cmd);\n', ""\t\tif (cmd[1] == '>') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', '\t\t\t\t\tr_core_cmd_help (core, help_msg_vertical_bar);\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', '\t\t\t\t\tret = *cmd ? r_core_cmdf (core, "".%s"", cmd) : 0;\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', '\t\t\t\t\tcore->num->value = value;\n', 'else\n', '\t\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.html"", 0);\n', '\t\t\t\t\tscr_color = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tret = r_cmd_call (core->rcmd, cmd);\n', '\t\tif (ret == -1) {\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tR_FREE (core->oobi);\n', '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", '\t\t\tint detail = 0;\n', ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\trecursive_help (core, detail, cmd);\n', '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\t\tif (scr_color != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = malloc (1);\n', '\t\t\t\tif (core->oobi) {\n', ""\t\t\t\t\tcore->oobi[0] = '\\0';\n"", '\t\t\t\tcore->oobi_len = 0;\n', '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', '\t\t\t\t\tif (feof (stdin)) {\n', '\t\t\t\t\tcore->oobi_len += ret;\n', '\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n', '\t\t\t\t\tif (core->oobi) {\n', '\t\t\t\t\t\tif (!strcmp (buf, str)) {\n', '\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tfree (core->oobi);\n', '\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\t\tr_core_cmd_help (core, help_msg_greater_sign);\n', '\t\tint fdn = 1;\n', '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', '\t\t\tif (*fdnum == \'H\') { // ""H>""\n', '\t\t\t\tscr_html = r_config_get_i (core->config, ""scr.html"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", true);\n', '\t\tif (!strcmp (str, ""-"")) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", ""\t\tif (*str == '$') {\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\tif (appendResult) {\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\t\tif (oldText) {\n', '\t\t\t\t\tchar *two = r_str_newf (""%s%s"", oldText, o);\n', '\t\t\t\t\tif (two) {\n', '\t\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, two, 1);\n', 'else\n', '\t\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t\t\tchar *n = r_str_newf (""$%s"", o);\n', '\t\t\t\tr_cmd_alias_set (core->rcmd, str, n, 1);\n', 'else\n', '\t\t} else if (fdn > 0) {\n', '\t\t\tif (pipefd != -1) {\n', '\t\t\t\tif (!pipecolor) {\n', '\t\t\t\t\tr_config_set_i (core->config, ""scr.color"", COLOR_MODE_DISABLED);\n', '\t\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\tif (!pipecolor) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (use_editor) {\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\tif (scr_html != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\t\tif (scr_color != -1) {\n', '\t\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\t\tcore->cons->use_tts = false;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', ""\t\t\tif (ptr[1] == '!') {\n"", '\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", 0);\n', '\t\t\t\tcore->cmd_in_backticks = true;\n', '\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n', '\t\t\t\tcore->cmd_in_backticks = false;\n', '\t\t\t\tr_config_set_i (core->config, ""scr.color"", ocolor);\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\t\t\tcore->num->value = value;\n', '\t\t\tret = r_core_cmd_subst (core, cmd);\n', '\t\t\tif (scr_html != -1) {\n', '\t\t\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', '\t\t\t\t\tr_core_block_size (core, R_ABS ((st64)addr - (st64)core->offset));\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', '\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\tif (bb) {\n', '\t\t\t\t\t\tif (index >= 0 && index < bb->ninstr) {\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\t\t\t\tr_core_seek (core, bb->addr + inst_off, 1);\n', '\t\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tfree (core->block);\n', '\t\t\t\t\t\tcore->block = buf;\n', '\t\t\t\t\t\tcore->blocksize = sz;\n', '\t\t\t\t\t\tmemcpy (core->block, f, sz);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n', '\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\t\tr_core_seek (core, regval, 1);\n', '\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\tcmd_ignbithints = r_config_get_i (core->config, ""anal.ignbithints"");\n', '\t\t\t\tr_config_set_i (core->config, ""anal.ignbithints"", 1);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\t\tcmd_tmpseek = core->tmpseek = true;\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', '\t\t\t\t\tif (out) {\n', '\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\ttmpfd = core->io->desc ? core->io->desc->fd : -1;\n', '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (!core->io->va) {\n', '\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (pamode) {\n', '\t\t\t\t\t\t\t\tr_config_set_i (core->config, ""io.va"", 1);\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\taddr = r_num_math (core->num, offstr);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', ""\t\t\tif (ch == '-' || ch == '+') {\n"", '\t\t\t\taddr = core->offset + addr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', '\t\tif (core->fixedblock) {\n', '\t\t\tr_core_block_read (core);\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tcore->offset = addr;\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\t\tif (ptr[1]) {\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_block_read (core);\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (ptr2) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (is_arch_set) {\n', '\t\t\tcore->fixedarch = oldfixedarch;\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\t\tcore->fixedbits = oldfixedbits;\n', '\t\tif (tmpbsz != core->blocksize) {\n', '\t\t\tr_core_block_size (core, tmpbsz);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tcore->fixedarch = oldfixedarch;\n', '\tcore->fixedbits = oldfixedbits;\n', '\tif (cmd_ignbithints != -1) {\n', '\t\tr_config_set_i (core->config, ""anal.ignbithints"", cmd_ignbithints);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
int  Var26=-1; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
return FUNC3(Var1->memberVar5,Var2); 
for (; *Var2; ){
int  Var16=-1; 
STRUCT3  Var27=Var28; 
char *Var29,*Var30; 
if (Var21){
if (!Var30||!*Var30){
else 
char *Var31=strchr(Var2,; ); 
FUNC4(Var1,Var2); 
if (!Var31){
if (*Var30){
if (Var30[1]== ||(Var30[1]&&Var30[2]== )){
char *Var32=strchr(Var30+1,); 
Var27=Var1->memberVar6; 
FUNC5(Var1,FUNC6(Var1->memberVar7,Var30+2),1); 
const bool  Var33=Var30[2]== >; 
if (Var30&&*Var30&&Var30[1]== |){
FUNC7(Var1,Var2,Var9); 
else 
FUNC3(Var1->memberVar5,Var29); 
if (Var27 !=  Var28){
FUNC5(Var1,Var27,1); 
if (!Var30){
if (Var20){
if (Var2[1]!= *&&!strstr(Var2,STRING)){
return FUNC3(Var1->memberVar5,Var2); 
if (Var2[1]== >){
FUNC8(Var1,Var34); 
if (*Var2 != ){
Var7=(char *) FUNC9(Var2,,STRING); //Var35  Var36  Var5  Var37
if (Var7&&(Var7[1]== ||Var7[1]==  Var38)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
if (FUNC10(Var1,Var2) == -1){
Var15=FUNC10(Var1,Var2); 
Var7=(char *) FUNC11(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
memmove(Var39,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC12(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
FUNC8(Var1,Var40); 
else 
}else if (!FUNC13(Var7+1,STRING,1)){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
Var15=*Var2 FUNC16(Var1,STRING,Var2) 0; 
else 
}else if (Var7[1]){//STRING
int  Var42=Var1->memberVar7->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var43=FUNC17(Var1->memberVar1,Var7+1); 
Var1->memberVar7->memberVar1=memberVar1; 
else 
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var19=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var41); 
Var7=(char *) FUNC11(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
Var15=FUNC3(Var1->memberVar5,Var2); 
if (Var15 == -1){
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var44){
Var7=strchr(Var2,&); 
FUNC18(Var1->memberVar9); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
int  Var45=0; 
if (Var2<Var7&&Var7[-1]== ){
FUNC19(Var1,Var45,Var2); 
FUNC20(Var7+2,STRING); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC21()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var44){
free(Var1->memberVar9); 
Var1->memberVar9=malloc(1); 
if (Var1->memberVar9){
Var1->memberVar9[0]=0; 
Var1->memberVar10=0; 
char  Var46[1024]; 
int  Var15; 
if (FUNC22(stdin)){
Var1->memberVar10  STRUCT5  Var15; 
Var1->memberVar9=realloc(Var1->memberVar9,Var1->memberVar10+1); 
if (Var1->memberVar9){
if (!strcmp(Var46,Var9)){
strcat((char *) Var1->memberVar9,Var46); 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var44){
if (!*Var9){
free(Var1->memberVar9); 
Var1->memberVar9=(STRUCT6 *) FUNC23(Var9,&Var1->memberVar10); 
if (!Var1->memberVar9){
else 
}else if (Var7 ==  Var2){
return FUNC24(Var1,(const char *) Var1->memberVar9); 
Var7=(char *) FUNC9(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
memmove(Var39,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
FUNC8(Var1,Var34); 
int  Var47=1; 
int  Var48=FUNC14(Var1->memberVar8,STRING); 
int  Var49=false ; 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC25(Var7[-2])){
char *Var51=Var7-1; 
if (*Var51 ==  Var52){//STRING
Var18=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,true ); 
if (!strcmp(Var9,STRING)){
FUNC15(Var1->memberVar8,STRING,Var41); 
const bool  Var53=(Var7[1]== >); 
if (*Var9 == ){
char *Var54=FUNC26(Var1,Var2); 
if (Var53){
char *Var55=FUNC27(Var1->memberVar5,Var9,1); 
if (Var55){
char *Var56=FUNC28(STRING,Var55,Var54); 
if (Var56){
FUNC29(Var1->memberVar5,Var9,Var56,1); 
else 
char *Var57=FUNC28(STRING,Var54); 
FUNC29(Var1->memberVar5,Var9,Var57,1); 
else 
char *Var57=FUNC28(STRING,Var54); 
FUNC29(Var1->memberVar5,Var9,Var57,1); 
else 
}else if (Var47>0){
if (Var16 != -1){
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var41); 
Var15=FUNC10(Var1,Var2); 
if (!Var48){
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var49){
const char *Var58=FUNC30(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar11->memberVar1=false ; 
if (Var7){
if (Var7>Var2){
char *Var39=Var7-1; 
if (*Var39 == ){
bool  Var59=false ; 
if (Var59){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar7->memberVar1; 
if (Var7[1]== !){
Var9=FUNC31(Var1,Var7+1); 
else 
int  Var50=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,0); 
Var1->memberVar12=true ; 
Var9=FUNC26(Var1,Var7+1); 
Var1->memberVar12=false ; 
FUNC15(Var1->memberVar8,STRING,Var50); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
Var1->memberVar7->memberVar1=memberVar1; 
Var15=FUNC10(Var1,Var2); 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (*Var2 != &&*Var2){
const char *Var60=strstr(Var2,STRING); 
if (Var60){
bool  Var61=false ; 
if (Var61){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar13=Var7 true false ; 
int  Var62=0; 
if (Var7){
char *Var63,*Var8=strchr(Var7+1,!); 
STRUCT3  Var64=Var1->memberVar6; 
bool  Var65=false ; 
char *Var66=NULL ; 
const char *Var67=NULL ; 
bool  Var68=false ; 
bool  Var69=false ; 
char *Var70=NULL ; 
char *Var71=NULL ; 
bool  Var72=false ; 
int  Var73=-1; 
int  Var74,Var75; 
STRUCT6 *Var46; 
*Var7  Var44=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var44){
if (*Var7&&Var7[1]== ){
else 
Var7  Var76; 
Var7=FUNC32(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var77=strdup(Var7+2); 
char *Var78=strchr(Var77,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+4); 
FUNC34(Var1,FUNC35((Var79) Var64-(Var79) Var1->memberVar6)); 
else 
Var64=FUNC33(Var1->memberVar7,Var1->memberVar6,Var7+3); 
FUNC5(Var1,Var64,1); 
Var24=Var1->memberVar13=true ; 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var72=FUNC36(Var1->memberVar14,Var7+2); 
int  Var80=(int ) FUNC6(Var1->memberVar7,Var7+2); 
STRUCT7 *Var81=FUNC37(Var1->memberVar15,Var1->memberVar6); 
if (Var81){
if (Var80 >= 0&&Var80<Var81->memberVar1){
STRUCT8  Var82=FUNC38(Var81,Var80); 
FUNC5(Var1,Var81->memberVar2+Var82,1); 
Var24=Var1->memberVar13=true ; 
Var63=FUNC23(Var7+2,&Var74); 
if (Var63){
STRUCT9 *Var83=FUNC39((const STRUCT6 *) Var63,Var74); 
STRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); 
if (Var46){
free(Var1->memberVar16); 
Var1->memberVar16=Var46; 
Var1->memberVar4=Var74; 
memcpy(Var1->memberVar16,Var63,Var74); 
else 
FUNC43(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var86; 
char *Var87=strdup(Var7+2); 
char *Var88=FUNC44(Var87); 
if (Var88){
char  Var39=*Var88; 
Var86=FUNC45(Var1->memberVar17,Var87); 
Var86=FUNC6(Var1->memberVar7,Var89); 
else 
Var86=FUNC45(Var1->memberVar17,Var7+2); 
FUNC5(Var1,Var86,1); 
Var24=Var1->memberVar13=true ; 
Var68=FUNC46(Var1,FUNC6(Var1->memberVar7,Var7+2),&Var66); 
Var26=FUNC14(Var1->memberVar8,STRING); 
FUNC15(Var1->memberVar8,STRING,1); 
STRUCT3  memberVar2=FUNC6(Var1->memberVar7,Var7+2); 
if (memberVar2){
FUNC16(Var1,STRING,Var7+2); 
Var24=Var1->memberVar13=true ; 
char *Var2=FUNC47(Var1,Var7+2); 
if (Var7[1]== ){
Var46=malloc(strlen(Var7+2)+1); 
if (Var46){
Var75=FUNC48(Var7+2,Var46); 
FUNC34(Var1,FUNC35(Var75)); 
if (Var75>0){
STRUCT9 *Var83=FUNC39(Var46,Var75); 
STRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); 
FUNC34(Var1,Var75); 
FUNC49(Var1); 
char *Var90=FUNC50(Var1->memberVar18,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var90){
FUNC5(Var1,FUNC6(Var1->memberVar7,Var90),1); 
if (Var7[1]== ){
Var73=Var1->memberVar1->STRUCT10  Var1->memberVar1->memberVar2->memberVar1-1; 
FUNC51(Var1->memberVar1,FUNC52(Var7+2)); 
if (Var7[1]== ){
char *Var32=strchr(Var7+2,); 
if (Var32){
int  Var91=FUNC6(Var1->memberVar7,Var32); 
Var68=FUNC46(Var1,Var91,&Var66); 
Var69=FUNC53(Var1,Var7+2,&Var71); 
Var75=strlen(Var7+2); 
FUNC34(Var1,Var75); 
const STRUCT6 *Var46=(const STRUCT6 *) FUNC54(Var7+2); 
if (Var75>0){
STRUCT9 *Var83=FUNC39(Var46,Var75); 
STRUCT2 *Var84=FUNC40(Var1->memberVar1,Var83,Var85,0); 
if (!Var1->memberVar1->memberVar1){
FUNC15(Var1->memberVar8,STRING,1); 
if (Var84){
if (Var13){
FUNC15(Var1->memberVar8,STRING,1); 
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,Var1->memberVar6,FUNC42(Var83)); 
FUNC34(Var1,Var75); 
*Var7=; 
char *Var92=Var7-2; 
Var7=FUNC55(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
FUNC34(
Var1,FUNC6(Var1->memberVar7,Var8+1)); 
Var67=FUNC55(Var7+1); 
memberVar2=FUNC6(Var1->memberVar7,Var67); 
if (FUNC56((STRUCT6) Var7[1])&&!memberVar2){
if (!FUNC57(Var1->memberVar14,Var7+1)){
FUNC43(STRING,Var7+1); 
else 
char  Var39=*Var67; 
if (Var39 == -||Var39 == +){
memberVar2=Var1->memberVar6+memberVar2; 
if (memberVar2){
STRUCT2 *Var84=Var12; 
if (Var84){
FUNC41(Var1->memberVar1,Var84->memberVar1,Var84->memberVar2,0,memberVar2,FUNC58(Var84)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar19=!!Var12; 
if (Var1->memberVar19){
FUNC49(Var1); 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var93=Var7+3; 
Var15=FUNC59(Var1,Var2,Var93); 
else 
Var15=FUNC60(Var1,Var2,Var7+2); 
else 
bool  memberVar13=false ; 
const char *Var94[]={STRING,STRING,STRING,
const char *Var95[]={STRING,STRING,STRING,
STRUCT3  Var96[FUNC61(Var94)-1],Var97[FUNC61(Var95)-1]; 
if (Var7[1]== (){
char *Var98=Var7+3; 
char *Var30=strchr(Var98,); 
if (!Var30){
STRUCT3  Var99=FUNC6(Var1->memberVar7,Var98); 
STRUCT3  Var100=FUNC6(Var1->memberVar7,Var30+1); 
for (Var14=0; Var94[Var14]; Var14  Var44){
Var96[Var14]=FUNC14(Var1->memberVar8,Var94[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
Var97[Var14]=FUNC14(Var1->memberVar8,Var95[Var14]); 
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var99); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var100); 
if (Var17){
if (Var65){
Var1->memberVar6=memberVar2; 
Var15=FUNC3(Var1->memberVar5,FUNC55(Var2)); 
else 
if (Var65){
if (Var7[1]){
FUNC5(Var1,memberVar2,1); 
FUNC49(Var1); 
Var15=FUNC3(Var1->memberVar5,FUNC55(Var2)); 
if (memberVar13){
for (Var14=0; Var94[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var94[Var14],Var96[Var14]); 
for (Var14=0; Var95[Var14]; Var14  Var44){
FUNC15(Var1->memberVar8,Var95[Var14],Var97[Var14]); 
if (Var8){
FUNC34(Var1,Var25); 
if (Var69){
Var1->memberVar2=Var22; 
FUNC62(Var1->memberVar8,STRING,Var71); 
if (Var73 != -1){
FUNC51(Var1->memberVar1,Var73); 
if (Var12){
if (Var13){
FUNC15(Var1->memberVar8,STRING,0); 
if (Var68){
FUNC62(Var1->memberVar8,STRING,Var66); 
Var1->memberVar3=Var23; 
if (Var25 !=  Var1->memberVar4){
FUNC34(Var1,Var25); 
if (Var70){
FUNC4(Var1,Var70); 
if (Var72){
FUNC63(Var1->memberVar14); 
*Var7=; 
Var62=Var2 FUNC3(Var1->memberVar5,FUNC55(Var2)) false ; 
if (Var18 != -1){
FUNC15(Var1->memberVar8,STRING,Var18); 
if (Var19 != -1){
FUNC15(Var1->memberVar8,STRING,Var19); 
Var1->memberVar2=Var22; 
Var1->memberVar3=Var23; 
if (Var26 != -1){
FUNC15(Var1->memberVar8,STRING,Var26); 
",6467,0
after_cmd.c,r_core_cmd_subst_i,False,False,583,CWE-,CallExpression,strchr,3320,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\tif (q) {\n', '\t\t\t\t\t\t*q++ = 0;\n', '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\t\tis_bits_set = set_tmp_bits (core, bits, &tmpbits);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
if (Var27){
*Var27  Var36=0; 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var54=FUNC28(Var1,Var74,&Var52); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var53=FUNC37(Var7+1); 
if (FUNC38((STRUCT5) Var7[1])&&!Var50){
if (!FUNC39(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC40(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
*Var7=; 
",3360,0
after_cmd.c,r_core_cmd_subst_i,False,False,584,CWE-,CallExpression,strlen,3333,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tint scr_html = -1;\n', '\tint scr_color = -1;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t} else if (!ptr2) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\tif (!str) {\n', ""\t\t\tif (*str == '|' || *str == '*') {\n"", '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tint rc = 0;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint tmpfd = -1;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\tr_core_block_size (core, R_ABS (len));\n', '\t\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tr_core_block_size (core, len);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\tif (len > 0) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\t\tif (d) {\n', '\t\t\t\t\t\t\tif (tmpdesc) {\n', '\t\t\t\t\t\t\t\tr_io_desc_close (tmpdesc);\n', '\t\t\t\t\t\t\ttmpdesc = d;\n', '\t\t\t\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, core->offset, r_buf_size (b));\n', '\t\t\t\t\t\t\tr_core_block_size (core, len);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\tif (addr) {\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\t\tif (d) {\n', '\t\t\t\tr_io_map_new (core->io, d->fd, d->perm, 0, addr, r_io_desc_size (d));\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', '\t\tcore->fixedblock = !!tmpdesc;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n', '\t\t\tif (usemyblock) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n', '\t\t\tif (tmpseek) {\n', '\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n', '\t\tif (tmpfd != -1) {\n', '\t\t\tr_io_use_fd (core->io, tmpfd);\n', '\t\tif (tmpdesc) {\n', '\t\t\tif (pamode) {\n', '\t\t\t\tr_config_set_i (core->config, ""io.va"", 0);\n', '\t\t\tr_io_desc_close (tmpdesc);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n', '\t\tif (flgspc_changed) {\n', '\t\t\tr_flag_space_pop (core->flags);\n', ""\t\t*ptr = '@';\n"", '\t\trc = ret;\n', '\tif (scr_html != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.html"", scr_html);\n', '\tif (scr_color != -1) {\n', '\t\tr_config_set_i (core->config, ""scr.color"", scr_color);\n', '\tif (tmpdesc) {\n', '\t\tr_io_desc_close (tmpdesc);\n', '\treturn rc;\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
int  Var18=-1; 
int  Var19=-1; 
bool  Var20=false ; 
bool  Var21=false ; 
bool  Var22=Var1->memberVar2; 
bool  Var23=Var1->memberVar3; 
bool  Var24=false ; 
STRUCT3  Var25=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var26,*Var27; 
else 
char *Var28=strchr(Var2,; ); 
char *Var29=strchr(Var27+1,); 
const bool  Var30=Var27[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var31  Var32  Var5  Var33
if (Var7&&(Var7[1]== ||Var7[1]==  Var34)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var36=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var37=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var38){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var38){
char  Var39[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var38){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
memmove(Var35,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var40=FUNC11(Var1->memberVar7,STRING); 
int  Var41=false ; 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var43=Var7-1; 
const bool  Var44=(Var7[1]== >); 
char *Var45=FUNC13(Var1,Var2); 
char *Var46=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var47=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var35=Var7-1; 
if (*Var35 == ){
bool  Var48=false ; 
if (Var48){
else 
}else if (!Var8){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var42=FUNC11(Var1->memberVar7,STRING); 
if (!Var9){
if (*Var9 == |||*Var9 == *){
if (*Var2 != &&*Var2){
const char *Var49=strstr(Var2,STRING); 
if (Var49){
bool  Var50=false ; 
if (Var50){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var24=Var1->memberVar9=Var7 true false ; 
int  Var51=0; 
if (Var7){
char *Var52,*Var8=strchr(Var7+1,!); 
STRUCT3  Var53=Var1->memberVar10; 
bool  Var54=false ; 
char *Var55=NULL ; 
const char *Var56=NULL ; 
bool  Var57=false ; 
bool  Var58=false ; 
char *Var59=NULL ; 
char *Var60=NULL ; 
bool  Var61=false ; 
int  Var62=-1; 
int  Var63,Var64; 
STRUCT5 *Var39; 
*Var7  Var38=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var38){
if (*Var7&&Var7[1]== ){
else 
Var7  Var65; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var66=strdup(Var7+2); 
char *Var67=strchr(Var66,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var53=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var61=FUNC18(Var1->memberVar11,Var7+2); 
int  Var68=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var69=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var70=FUNC21(Var69,Var68); 
Var52=FUNC22(Var7+2,&Var63); 
if (Var52){
STRUCT8 *Var71=FUNC23((const STRUCT5 *) Var52,Var63); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
else 
FUNC26(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var74; 
char *Var75=strdup(Var7+2); 
char *Var76=FUNC27(Var75); 
if (Var76){
char  Var35=*Var76; 
else 
Var74=FUNC28(Var1->memberVar13,Var7+2); 
Var57=FUNC29(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var55); 
STRUCT3  Var53=FUNC19(Var1->memberVar5,Var7+2); 
if (Var53){
FUNC30(Var1,STRING,Var7+2); 
char *Var2=FUNC31(Var1,Var7+2); 
if (Var7[1]== ){
Var39=malloc(strlen(Var7+2)+1); 
if (Var39){
Var64=FUNC32(Var7+2,Var39); 
FUNC33(Var1,FUNC34(Var64)); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
FUNC33(Var1,Var64); 
char *Var77=FUNC35(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC36(Var1->memberVar1,FUNC37(Var7+2)); 
if (Var7[1]== ){
char *Var29=strchr(Var7+2,); 
int  Var78=FUNC19(Var1->memberVar5,Var29); 
Var58=FUNC38(Var1,Var7+2,&Var60); 
Var64=strlen(Var7+2); 
FUNC33(Var1,Var64); 
const STRUCT5 *Var39=(const STRUCT5 *) FUNC39(Var7+2); 
if (Var64>0){
STRUCT8 *Var71=FUNC23(Var39,Var64); 
STRUCT2 *Var72=FUNC24(Var1->memberVar1,Var71,Var73,0); 
if (Var72){
if (Var12){
FUNC25(Var12); 
Var12=Var72; 
FUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var1->memberVar10,FUNC41(Var71)); 
FUNC33(Var1,Var64); 
*Var7=; 
char *Var79=Var7-2; 
Var7=FUNC42(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
Var56=FUNC42(Var7+1); 
if (FUNC43((STRUCT5) Var7[1])&&!Var53){
if (!FUNC44(Var1->memberVar11,Var7+1)){
FUNC26(STRING,Var7+1); 
else 
char  Var35=*Var56; 
if (Var53){
STRUCT2 *Var72=Var12; 
if (Var72){
FUNC40(Var1->memberVar1,Var72->memberVar1,Var72->memberVar2,0,Var53,FUNC45(Var72)); 
if (Var10){
Var7=Var10+1; 
Var1->memberVar15=!!Var12; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var80=Var7+3; 
else 
Var15=FUNC46(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var81[]={STRING,STRING,STRING,
const char *Var82[]={STRING,STRING,STRING,
STRUCT3  Var83[FUNC47(Var81)-1],Var84[FUNC47(Var82)-1]; 
if (Var7[1]== (){
char *Var85=Var7+3; 
char *Var27=strchr(Var85,); 
if (!Var27){
STRUCT3  Var86=FUNC19(Var1->memberVar5,Var85); 
STRUCT3  Var87=FUNC19(Var1->memberVar5,Var27+1); 
for (Var14=0; Var81[Var14]; Var14  Var38){
Var83[Var14]=FUNC11(Var1->memberVar7,Var81[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
Var84[Var14]=FUNC11(Var1->memberVar7,Var82[Var14]); 
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var86); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var87); 
if (Var17){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
else 
if (Var54){
Var15=FUNC49(Var1->memberVar8,FUNC42(Var2)); 
if (memberVar9){
for (Var14=0; Var81[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var81[Var14],Var83[Var14]); 
for (Var14=0; Var82[Var14]; Var14  Var38){
FUNC48(Var1->memberVar7,Var82[Var14],Var84[Var14]); 
if (Var62 != -1){
FUNC36(Var1->memberVar1,Var62); 
if (Var12){
if (Var13){
FUNC48(Var1->memberVar7,STRING,0); 
FUNC25(Var12); 
if (Var57){
FUNC50(Var1->memberVar7,STRING,Var55); 
if (Var61){
FUNC51(Var1->memberVar11); 
*Var7=; 
Var51=Var15; 
if (Var18 != -1){
FUNC48(Var1->memberVar7,STRING,Var18); 
if (Var19 != -1){
FUNC48(Var1->memberVar7,STRING,Var19); 
if (Var12){
FUNC25(Var12); 
return  Var51; 
",4220,0
after_cmd.c,r_core_cmd_subst_i,False,False,585,CWE-,CallExpression,strlen,3378,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
after_cmd.c,r_core_cmd_subst_i,False,False,586,CWE-,CallExpression,strlen,3378,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
after_cmd.c,r_core_cmd_subst_i,False,False,587,CWE-,CallExpression,memcmp,3378,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
after_cmd.c,r_core_cmd_subst_i,False,False,588,CWE-,CallExpression,memcmp,3378,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
after_cmd.c,r_core_cmd_subst_i,False,False,589,CWE-,CallExpression,strlen,3382,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
after_cmd.c,r_core_cmd_subst_i,False,False,590,CWE-,CallExpression,strlen,3382,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool usemyblock = false;\n', '\tbool eos = false;\n', '\tbool haveQuote = false;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tbool cmd_tmpseek = false;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', '\t\t\t\t\tif (*cmd) {\n', '\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\t\t\tif (cmd < ptr && ptr[-1] == '?') {\n"", '\t\t\tr_cons_grep_parsecmd (ptr + 2, ""`"");\n', ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", ""\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n"", '\t\t\t\t\tchar buf[1024];\n', '\t\t\t\t\tint ret;\n', 'else\n', ""\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n"", '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\t\t\tmemmove (ch, ptr, strlen (ptr) + 1);\n', ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint use_editor = false;\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", ""\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n"", '\t\tif (!*str) {\n', '\t\tif (ptr > (cmd + 1) && IS_WHITECHAR (ptr[-2])) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tcmd_tmpseek = core->tmpseek = ptr ? true: false;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tbool addr_is_set = false;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', '\t\tbool flgspc_changed = false;\n', '\t\tint sz, len;\n', '\t\tut8 *buf;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\tif (ptr[3] == \'.\') { // ""@...""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', '\t\t\t\t\taddr = r_num_tail (core->num, core->offset, ptr + 3);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\tflgspc_changed = r_flag_space_push (core->flags, ptr + 2);\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\t\tut16 inst_off = r_anal_bb_offset_inst (bb, index);\n', '\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n', '\t\t\t\tif (f) {\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes ((const ut8*)f, sz);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', 'else\n', '\t\t\t\t\teprintf (""cannot open \'%s\'\\n"", ptr + 3);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tut64 regval;\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\tchar *sep = findSeparator (mander);\n', '\t\t\t\t\tif (sep) {\n', '\t\t\t\t\t\tchar ch = *sep;\n', 'else\n', '\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n', '\t\t\t\tis_bits_set = set_tmp_bits (core, r_num_math (core->num, ptr + 2), &tmpbits);\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tif (addr) {\n', '\t\t\t\t\t\tr_core_cmdf (core, ""so %s"", ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n', '\t\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", '\t\t\t\t\tr_io_use_fd (core->io, atoi (ptr + 2));\n', ""\t\t\t\tif (ptr[1] == ':') {\n"", ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tis_arch_set = set_tmp_arch (core, ptr + 2, &tmpasm);\n', '\t\t\t\t\tlen = strlen (ptr + 2);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRBuffer *b = r_buf_new_with_bytes (buf, len);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', 'else\n', ""\t\t\t\t*ptr2 = '\\0';\n"", '\t\t\t\tif (!ptr2[1]) {\n', '\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n', '\t\toffstr = r_str_trim_head (ptr + 1);\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', '\t\t\t\teprintf (""Invalid address (%s)\\n"", ptr + 1);\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", ""\t\t\tif (ptr[2] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', 'else\n', '\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n', 'else\n', '\t\t\tbool tmpseek = false;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\tif (usemyblock) {\n', 'else\n', '\t\t\t\tif (addr_is_set) {\n', '\t\tif (ptr2) {\n', ""\t\t\t*ptr2 = '!';\n"", ""\t\t*ptr = '@';\n""]","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=false ; 
bool  Var18=false ; 
bool  Var19=false ; 
bool  Var20=Var1->memberVar2; 
bool  Var21=Var1->memberVar3; 
bool  Var22=false ; 
STRUCT3  Var23=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var24,*Var25; 
else 
char *Var26=strchr(Var2,; ); 
char *Var27=strchr(Var25+1,); 
const bool  Var28=Var25[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var29  Var30  Var5  Var31
if (Var7&&(Var7[1]== ||Var7[1]==  Var32)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var34=Var1->memberVar5->memberVar1; 
if (*Var2){
FUNC7(Var1,Var2,Var7+1); 
else 
char *Var35=FUNC8(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var36){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
if (Var2<Var7&&Var7[-1]== ){
FUNC9(Var7+2,STRING); 
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC10()->memberVar1){
if (Var7[1]== <){
for (Var9=Var7+2; Var9[0]== ; Var9  Var36){
char  Var37[1024]; 
int  Var15; 
else 
for (Var9=Var7+1; *Var9 == ; Var9  Var36){
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
memmove(Var33,Var7,strlen(Var7)+1); 
if (Var7[0]&&Var7[1]== ){
int  Var38=FUNC11(Var1->memberVar7,STRING); 
int  Var39=false ; 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
*Var7=0; 
Var9=FUNC2(Var7+1+(Var7[1]== >)); 
if (!*Var9){
if (Var7>(Var2+1)&&FUNC12(Var7[-2])){
char *Var41=Var7-1; 
const bool  Var42=(Var7[1]== >); 
char *Var43=FUNC13(Var1,Var2); 
char *Var44=FUNC14(Var1->memberVar8,Var9,1); 
const char *Var45=FUNC15(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var33=Var7-1; 
if (*Var33 == ){
bool  Var46=false ; 
if (Var46){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var40=FUNC11(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var47=strstr(Var2,STRING); 
if (Var47){
bool  Var48=false ; 
if (Var48){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
Var22=Var1->memberVar9=Var7 true false ; 
if (Var7){
char *Var49,*Var8=strchr(Var7+1,!); 
STRUCT3  Var50=Var1->memberVar10; 
bool  Var51=false ; 
char *Var52=NULL ; 
const char *Var53=NULL ; 
bool  Var54=false ; 
bool  Var55=false ; 
char *Var56=NULL ; 
char *Var57=NULL ; 
bool  Var58=false ; 
int  Var59,Var60; 
STRUCT5 *Var37; 
*Var7  Var36=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var36){
if (*Var7&&Var7[1]== ){
else 
Var7  Var61; 
Var7=FUNC16(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var62=strdup(Var7+2); 
char *Var63=strchr(Var62,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
if (Var7[3]== .){//STRING
STRUCT3  Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+4); 
else 
Var50=FUNC17(Var1->memberVar5,Var1->memberVar10,Var7+3); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
Var58=FUNC18(Var1->memberVar11,Var7+2); 
int  Var64=(int ) FUNC19(Var1->memberVar5,Var7+2); 
STRUCT6 *Var65=FUNC20(Var1->memberVar12,Var1->memberVar10); 
STRUCT7  Var66=FUNC21(Var65,Var64); 
Var49=FUNC22(Var7+2,&Var59); 
if (Var49){
STRUCT8 *Var67=FUNC23((const STRUCT5 *) Var49,Var59); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
else 
FUNC25(STRING,Var7+3); 
if (Var7[1]== ){
STRUCT3  Var70; 
char *Var71=strdup(Var7+2); 
char *Var72=FUNC26(Var71); 
if (Var72){
char  Var33=*Var72; 
else 
Var70=FUNC27(Var1->memberVar13,Var7+2); 
Var54=FUNC28(Var1,FUNC19(Var1->memberVar5,Var7+2),&Var52); 
STRUCT3  Var50=FUNC19(Var1->memberVar5,Var7+2); 
if (Var50){
FUNC29(Var1,STRING,Var7+2); 
char *Var2=FUNC30(Var1,Var7+2); 
if (Var7[1]== ){
Var37=malloc(strlen(Var7+2)+1); 
if (Var37){
Var60=FUNC31(Var7+2,Var37); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
char *Var73=FUNC32(Var1->memberVar14,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var7[1]== ){
FUNC33(Var1->memberVar1,FUNC34(Var7+2)); 
if (Var7[1]== ){
char *Var27=strchr(Var7+2,); 
int  Var74=FUNC19(Var1->memberVar5,Var27); 
Var55=FUNC35(Var1,Var7+2,&Var57); 
Var60=strlen(Var7+2); 
const STRUCT5 *Var37=(const STRUCT5 *) FUNC36(Var7+2); 
STRUCT8 *Var67=FUNC23(Var37,Var60); 
STRUCT2 *Var68=FUNC24(Var1->memberVar1,Var67,Var69,0); 
*Var7=; 
char *Var75=Var7-2; 
Var7=FUNC37(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
else 
*Var8=0; 
if (!Var8[1]){
FUNC38(
Var1,FUNC19(Var1->memberVar5,Var8+1)); 
Var53=FUNC37(Var7+1); 
if (FUNC39((STRUCT5) Var7[1])&&!Var50){
if (!FUNC40(Var1->memberVar11,Var7+1)){
FUNC25(STRING,Var7+1); 
else 
char  Var33=*Var53; 
STRUCT2 *Var68=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
if (Var7[2]== ){
char *Var76=Var7+3; 
else 
Var15=FUNC41(Var1,Var2,Var7+2); 
else 
bool  memberVar9=false ; 
const char *Var77[]={STRING,STRING,STRING,
const char *Var78[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var79=Var7+3; 
char *Var25=strchr(Var79,); 
if (!Var25){
STRUCT3  Var80=FUNC19(Var1->memberVar5,Var79); 
STRUCT3  Var81=FUNC19(Var1->memberVar5,Var25+1); 
if (Var17){
else 
if (Var51){
if (Var8){
*Var8=!; 
*Var7=; 
",3372,0
after_cmd.c,r_core_cmd_subst_i,False,False,591,CWE-,CallExpression,strchr,3449,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tptr = r_str_trim_head (ptr + 1) - 1;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', '\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', ""\t\t\t\t*p = '\\x00';\n"", '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\t\t\tfor (i = 0; tovars[i]; i++) {\n', '\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var20,*Var21; 
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var21+1,); 
const bool  Var24=Var21[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27
if (Var7&&(Var7[1]== ||Var7[1]==  Var28)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
if (Var7[0]&&Var7[1]== ){
int  Var33=FUNC9(Var1->memberVar7,STRING); 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var35=Var7-1; 
const bool  Var36=(Var7[1]== >); 
char *Var37=FUNC10(Var1,Var2); 
char *Var38=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var39=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var43,*Var8=strchr(Var7+1,!); 
STRUCT3  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var7  Var32=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var32){
if (*Var7&&Var7[1]== ){
else 
Var7  Var49; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var50=strdup(Var7+2); 
char *Var51=strchr(Var50,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var7+2); 
char  Var29=*Var58; 
STRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC19(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var23=strchr(Var7+2,); 
int  Var60=FUNC15(Var1->memberVar5,Var23); 
const STRUCT6 *Var61=(const STRUCT6 *) FUNC20(Var7+2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
*Var7=; 
char *Var62=Var7-2; 
Var7=FUNC21(Var7+1)-1; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC22((STRUCT6) Var7[1])&&!Var44){
if (!FUNC23(Var1->memberVar12,Var7+1)){
else 
char  Var29=*Var46; 
STRUCT2 *Var54=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
STRUCT3  Var66[FUNC24(Var64)-1],Var67[FUNC24(Var65)-1]; 
if (Var7[1]== (){
char *Var68=Var7+3; 
char *Var21=strchr(Var68,); 
if (!Var21){
*Var21=Var69; 
STRUCT3  Var70=FUNC15(Var1->memberVar5,Var68); 
STRUCT3  Var71=FUNC15(Var1->memberVar5,Var21+1); 
for (Var14=0; Var65[Var14]; Var14  Var32){
FUNC25(Var1->memberVar7,Var65[Var14],Var71); 
",2555,0
after_cmd.c,r_core_cmd_subst_i,False,False,592,CWE-,CallExpression,free,3452,-3,"['static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {\n', '\tconst char *quotestr = ""`"";\n', '\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tcmd = r_str_trim_head_tail (cmd);\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tptr = (char *)r_str_firstbut (cmd, \'#\', ""`\\""""); // TODO: use quotestr here\n', ""\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n"", ""\t\t\t*ptr = '\\0';\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', ""\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n"", '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', ""\t\t\t\t*ptr = '\\0';\n"", '\t\t\t\tcmd = r_str_trim_nc (cmd);\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n"", ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", ""\t\t*ptr = '\\0';\n"", '\t\tif (ret == -1) {\n', ""\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++) {\n"", ""\t\tptr = strchr (cmd, '&');\n"", '\tptr = strstr (cmd, ""?*"");\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", '\t\tptr[0] = 0;\n', ""\t\tif (*cmd != '#') {\n"", ""\tptr = strchr (cmd, '<');\n"", '\tif (ptr) {\n', ""\t\tptr[0] = '\\0';\n"", '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tptr = (char *)r_str_firstbut (cmd, \'>\', ""\\"""");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', ""\t\t*ptr = '\\0';\n"", '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (*cmd != \'""\') {\n', ""\t\tptr = strchr (cmd, '@');\n"", ""\t\tif (ptr == cmd + 1 && *cmd == '?') {\n"", '\t\t\tptr = NULL;\n', 'else\n', '\t\tptr = NULL;\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\t*ptr++ = '\\0';\n"", '\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n', ""\t\tfor (; *ptr == ' '; ptr++) {\n"", ""\t\tif (*ptr && ptr[1] == ':') {\n"", 'else\n', '\t\t\tptr--;\n', '\t\tptr = r_str_trim_tail (ptr);\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', ""\t\t\tchar *v = strchr (k, '=');\n"", 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\tif (!tmpeval) {\n', '\t\t\t\t\t\ttmpeval = cmd;\n', 'else\n', '\t\t\t\t\t\ttmpeval = r_str_prepend (tmpeval, cmd);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', ""\t\t\t*ptr = '@';\n"", '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', '\t\t\tptr = arroba + 1;\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpeval);\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\tif (tmpeval) {\n', '\t\t\tr_core_cmd0 (core, tmpeval);\n', '\t\t\tR_FREE (tmpeval);\n']","static int FUNC1(STRUCT1 *Var1,char *Var2,char *Var3,bool *Var4){
const char *Var5=STRING; 
const char *Var6=NULL ; 
char *Var7,*Var8,*Var9; 
char *Var10=NULL ; 
char *Var11=NULL ; 
STRUCT2 *Var12=NULL ; 
int  Var13=!Var1->memberVar1->memberVar1; 
int  Var14,Var15=0,Var16; 
bool  Var17=Var1->memberVar2; 
bool  Var18=Var1->memberVar3; 
STRUCT3  Var19=Var1->memberVar4; 
if (!Var2){
Var2=FUNC2(Var2); 
switch (*Var2){
if (Var2[1]== ){/*STRUCT4 */
char *Var20,*Var21; 
else 
char *Var22=strchr(Var2,; ); 
char *Var23=strchr(Var21+1,); 
const bool  Var24=Var21[2]== >; 
if (Var2[1]!= *&&!strstr(Var2,STRING)){
if (Var2[1]== >){
if (*Var2 != ){
Var7=(char *) FUNC3(Var2,,STRING); //Var25  Var26  Var5  Var27
if (Var7&&(Var7[1]== ||Var7[1]==  Var28)){
*Var7=0; 
if (*Var2 != ){
if (Var3&&Var7){
int  Var15; 
Var7=(char *) FUNC4(Var2,|,Var5); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
char *Var8=strchr(Var2,); 
if (!Var8||(Var8&&Var8>Var7)){
if (!Var6||(Var6&&Var6>Var7)){
*Var7=0; 
Var2=FUNC5(Var2); 
if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!FUNC6(Var7+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (!strcmp(Var7+1,STRING)){//STRING
else 
}else if (Var7[1]){//STRING
int  Var30=Var1->memberVar5->memberVar1; 
else 
char *Var31=FUNC7(Var1->memberVar1,Var7+1); 
Var7=(char *) FUNC4(Var2,&,Var5); 
while (Var7&&*Var7&&Var7[1]== &){
*Var7=0; 
if (Var15 == -1){
for (Var2=Var7+2; Var2&&*Var2 == ; Var2  Var32){
Var7=strchr(Var2,&); 
Var7=strstr(Var2,STRING); 
if (Var7&&(Var7 ==  Var2||Var7[-1]!= )){
Var7[0]=0; 
if (*Var2 != ){
Var7=strchr(Var2,<); 
if (Var7){
Var7[0]=0; 
if (FUNC8()->memberVar1){
if (Var7[1]== <){
int  Var15; 
if (!*Var9){
if (!Var1->memberVar6){
else 
}else if (Var7 ==  Var2){
Var7=(char *) FUNC3(Var2,>,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
if (Var7[0]&&Var7[1]== ){
int  Var33=FUNC9(Var1->memberVar7,STRING); 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
*Var7=0; 
if (!*Var9){
char *Var35=Var7-1; 
const bool  Var36=(Var7[1]== >); 
char *Var37=FUNC10(Var1,Var2); 
char *Var38=FUNC11(Var1->memberVar8,Var9,1); 
const char *Var39=FUNC12(Var1->memberVar7,STRING); 
if (Var7){
if (Var7>Var2){
char *Var29=Var7-1; 
if (*Var29 == ){
bool  Var40=false ; 
if (Var40){
else 
int  memberVar1=Var1->memberVar5->memberVar1; 
else 
int  Var34=FUNC9(Var1->memberVar7,STRING); 
if (*Var2 != &&*Var2){
const char *Var41=strstr(Var2,STRING); 
if (Var41){
bool  Var42=false ; 
if (Var42){
if (*Var2 != ){
Var7=strchr(Var2,); 
if (Var7 ==  Var2+1&&*Var2 == ){
Var7=NULL ; 
else 
Var7=NULL ; 
if (Var7){
char *Var43,*Var8=strchr(Var7+1,!); 
STRUCT3  Var44=Var1->memberVar9; 
char *Var45=NULL ; 
const char *Var46=NULL ; 
char *Var47=NULL ; 
char *Var48=NULL ; 
*Var7  Var32=0; 
Var10=(Var7[0]&&Var7[1]&&Var7[2])
for (; *Var7 == ; Var7  Var32){
if (*Var7&&Var7[1]== ){
else 
Var7  Var49; 
Var7=FUNC13(Var7); 
if (Var7[1]== ){
else 
}else if (Var7[1]== %){//STRING
char *Var50=strdup(Var7+2); 
char *Var51=strchr(Var50,=); 
else 
}else if (Var7[1]== .){//STRING
if (Var7[2]== .){//STRING
STRUCT3  Var44=FUNC14(Var1->memberVar5,Var1->memberVar9,Var7+4); 
else 
}else if (Var7[0]&&Var7[1]== &&Var7[2]){
switch (Var7[0]){
int  Var52=(int ) FUNC15(Var1->memberVar5,Var7+2); 
STRUCT5 *Var53=FUNC16(Var1->memberVar10,Var1->memberVar9); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var57=strdup(Var7+2); 
char  Var29=*Var58; 
STRUCT3  Var44=FUNC15(Var1->memberVar5,Var7+2); 
char *Var2=FUNC18(Var1,Var7+2); 
if (!Var47){
Var47=Var2; 
else 
Var47=FUNC19(Var47,Var2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
char *Var59=FUNC20(Var1->memberVar11,NULL ,0,Var7+((Var7[1]) 21)); 
char *Var23=strchr(Var7+2,); 
int  Var60=FUNC15(Var1->memberVar5,Var23); 
const STRUCT6 *Var61=(const STRUCT6 *) FUNC21(Var7+2); 
STRUCT2 *Var54=FUNC17(Var1->memberVar1,Var55,Var56,0); 
*Var7=; 
char *Var62=Var7-2; 
if (Var8){
if (strlen(Var7+1) == 13&&strlen(Var8+1) == 6&&
!memcmp(Var7+1,STRING,2)&&
!memcmp(Var8+1,STRING,2)){
else 
}else if (strlen(Var7+1) == 9&&strlen(Var8+1) == 4){
if (!Var8[1]){
if (FUNC22((STRUCT6) Var7[1])&&!Var44){
if (!FUNC23(Var1->memberVar12,Var7+1)){
else 
char  Var29=*Var46; 
STRUCT2 *Var54=Var12; 
if (Var10){
Var7=Var10+1; 
if (Var7[1]== ){
char *Var63=Var7+3; 
const char *Var64[]={STRING,STRING,STRING,
const char *Var65[]={STRING,STRING,STRING,
if (Var7[1]== (){
char *Var66=Var7+3; 
char *Var21=strchr(Var66,); 
if (!Var21){
free(Var47); 
STRUCT3  Var67=FUNC15(Var1->memberVar5,Var66); 
STRUCT3  Var68=FUNC15(Var1->memberVar5,Var21+1); 
if (Var47){
FUNC24(Var1,Var47); 
FUNC25(Var47); 
",2522,0
after_cmd.c,r_core_cmd_subst_i,False,False,593,CWE-,CallExpression,free,3453,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_arch_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpasm);\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\tif (is_arch_set) {\n', '\t\t\tr_config_set (core->config, ""asm.arch"", tmpasm);\n', '\t\t\tR_FREE (tmpasm);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
char *Var6=NULL ; 
STRUCT1 *Var7=NULL ; 
int  Var8=!Var9->memberVar1->memberVar1; 
int  Var10,Var11=0,Var12; 
bool  Var13=Var9->memberVar2; 
bool  Var14=Var9->memberVar3; 
STRUCT2  Var15=Var9->memberVar4; 
if (!Var16){
switch (*Var16){
if (Var16[1]== ){/*STRUCT3 */
char *Var17,*Var18; 
else 
char *Var19=strchr(Var16,; ); 
char *Var20=strchr(Var18+1,); 
const bool  Var21=Var18[2]== >; 
if (Var16[1]!= *&&!strstr(Var16,STRING)){
if (Var16[1]== >){
if (*Var16 != ){
if (Var22&&Var2){
int  Var11; 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
char *Var3=strchr(Var16,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var24=Var9->memberVar5->memberVar1; 
else 
char *Var25=FUNC2(Var9->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var11 == -1){
if (Var2&&(Var2 ==  Var16||Var2[-1]!= )){
if (*Var16 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
int  Var11; 
if (!*Var4){
if (!Var9->memberVar6){
else 
}else if (Var2 ==  Var16){
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
if (Var2[0]&&Var2[1]== ){
int  Var26=FUNC4(Var9->memberVar7,STRING); 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (!*Var4){
char *Var28=Var2-1; 
const bool  Var29=(Var2[1]== >); 
char *Var30=FUNC5(Var9,Var16); 
char *Var31=FUNC6(Var9->memberVar8,Var4,1); 
const char *Var32=FUNC7(Var9->memberVar7,STRING); 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
bool  Var33=false ; 
if (Var33){
else 
int  memberVar1=Var9->memberVar5->memberVar1; 
else 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (*Var16 != &&*Var16){
const char *Var34=strstr(Var16,STRING); 
if (Var34){
bool  Var35=false ; 
if (Var35){
if (Var2){
char *Var36,*Var3=strchr(Var2+1,!); 
STRUCT2  Var37=Var9->memberVar9; 
char *Var38=NULL ; 
const char *Var39=NULL ; 
bool  Var40=false ; 
char *Var41=NULL ; 
char *Var42=NULL ; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var43=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); 
STRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var49=strdup(Var2+2); 
char  Var23=*Var50; 
STRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); 
char *Var16=FUNC12(Var9,Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var20=strchr(Var2+2,); 
int  Var52=FUNC9(Var9->memberVar5,Var20); 
const STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var54=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC15((STRUCT5) Var2[1])&&!Var37){
if (!FUNC16(Var9->memberVar12,Var2+1)){
else 
char  Var23=*Var39; 
STRUCT1 *Var46=Var7; 
if (Var5){
if (Var2[1]== ){
char *Var55=Var2+3; 
const char *Var56[]={STRING,STRING,STRING,
const char *Var57[]={STRING,STRING,STRING,
if (Var2[1]== (){
char *Var58=Var2+3; 
char *Var18=strchr(Var58,); 
if (!Var18){
free(Var42); 
STRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); 
STRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); 
if (Var40){
FUNC17(Var9->memberVar7,STRING,Var42); 
FUNC18(Var42); 
",1996,0
after_cmd.c,r_core_cmd_subst_i,False,False,594,CWE-,CallExpression,free,3454,-3,"['\tconst char *tick = NULL;\n', '\tchar *ptr, *ptr2, *str;\n', '\tchar *arroba = NULL;\n', '\tchar *grep = NULL;\n', '\tRIODesc *tmpdesc = NULL;\n', '\tint pamode = !core->io->va;\n', '\tint i, ret = 0, pipefd;\n', '\tbool oldfixedarch = core->fixedarch;\n', '\tbool oldfixedbits = core->fixedbits;\n', '\tut64 tmpbsz = core->blocksize;\n', '\tif (!cmd) {\n', '\tswitch (*cmd) {\n', '\t\tif (cmd[1] == \'""\') { /* interpret */\n', '\t\t\tchar *line, *p;\n', 'else\n', ""\t\t\t\tchar *sc = strchr (cmd, ';');\n"", '\t\t\t\t\tchar *q = strchr (p + 1, \'""\');\n', ""\t\t\t\t\tconst bool append = p[2] == '>';\n"", '\t\tif (cmd[1] != \'*\' && !strstr (cmd, "")()"")) {\n', ""\t\tif (cmd[1] == '>') {\n"", ""\tif (*cmd != '#') {\n"", '\t\tif (colon && ptr) {\n', '\t\t\tint ret ;\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tchar *ptr2 = strchr (cmd, '`');\n"", '\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n', '\t\t\tif (!tick || (tick && tick > ptr)) {\n', '\t\t\t\tif (!strcmp (ptr + 1, ""?"")) { // ""|?""\n', 'else\n', '\t\t\t\t} else if (!strncmp (ptr + 1, ""H"", 1)) { // ""|H""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""T"")) { // ""|T""\n', 'else\n', '\t\t\t\t} else if (!strcmp (ptr + 1, ""."")) { // ""|.""\n', 'else\n', '\t\t\t\t} else if (ptr[1]) { // ""| grep ..""\n', '\t\t\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\t\t\tchar *res = r_io_system (core->io, ptr + 1);\n', ""\twhile (ptr && *ptr && ptr[1] == '&') {\n"", '\t\tif (ret == -1) {\n', ""\tif (ptr && (ptr == cmd || ptr[-1] != '~')) {\n"", ""\t\tif (*cmd != '#') {\n"", '\tif (ptr) {\n', '\t\tif (r_cons_singleton ()->is_interactive) {\n', ""\t\t\tif (ptr[1] == '<') {\n"", '\t\t\t\t\tint ret;\n', '\t\t\t\tif (!*str) {\n', '\t\t\t\tif (!core->oobi) {\n', 'else\n', '\t\t\t\t} else if (ptr == cmd) {\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", ""\t\tif (ptr[0] && ptr[1] == '?') {\n"", '\t\tint pipecolor = r_config_get_i (core->config, ""scr.color.pipe"");\n', '\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\t\tif (!*str) {\n', '\t\t\tchar *fdnum = ptr - 1;\n', ""\t\tconst bool appendResult = (ptr[1] == '>');\n"", '\t\t\tchar *o = r_core_cmd_str (core, cmd);\n', '\t\t\t\tchar *oldText = r_cmd_alias_get (core->rcmd, str, 1);\n', '\t\t\tconst char *editor = r_config_get (core->config, ""cfg.editor"");\n', '\tif (ptr) {\n', '\t\tif (ptr > cmd) {\n', '\t\t\tchar *ch = ptr - 1;\n', ""\t\t\tif (*ch == '\\\\') {\n"", '\t\tbool empty = false;\n', '\t\tif (empty) {\n', 'else\n', '\t\t\tint value = core->num->value;\n', 'else\n', '\t\t\t\tint ocolor = r_config_get_i (core->config, ""scr.color"");\n', '\tif (*cmd != \'""\' && *cmd) {\n', '\t\tconst char *s = strstr (cmd, ""~?"");\n', '\t\tif (s) {\n', '\t\t\tbool showHelp = false;\n', '\t\t\tif (showHelp) {\n', '\tif (ptr) {\n', ""\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n"", '\t\tut64 addr = core->offset;\n', '\t\tchar *tmpbits = NULL;\n', '\t\tconst char *offstr = NULL;\n', '\t\tbool is_bits_set = false;\n', '\t\tchar *tmpeval = NULL;\n', '\t\tchar *tmpasm = NULL;\n', ""\t\tif (ptr[1] == '?') {\n"", 'else\n', '\t\t} else if (ptr[1] == \'%\') { // ""@%""\n', '\t\t\tchar *k = strdup (ptr + 2);\n', 'else\n', '\t\t} else if (ptr[1] == \'.\') { // ""@.""\n', '\t\t\tif (ptr[2] == \'.\') { // ""@..""\n', '\t\t\t\t\tut64 addr = r_num_tail (core->num, core->offset, ptr + 4);\n', 'else\n', ""\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n"", '\t\t\tswitch (ptr[0]) {\n', '\t\t\t\t\tint index = (int)r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *mander = strdup (ptr + 2);\n', '\t\t\t\t\t\tchar ch = *sep;\n', '\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n', '\t\t\t\t\tchar *cmd = parse_tmp_evals (core, ptr + 2);\n', '\t\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n', ""\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n"", '\t\t\t\t\t\tint bits = r_num_math (core->num, q);\n', '\t\t\t\t\tconst ut8 *buf = (const ut8*)r_str_trim_ro (ptr + 2);\n', '\t\t\t\t\t\tRIODesc *d = r_io_open_buffer (core->io, b, R_PERM_RWX, 0);\n', '\t\t\tchar *trim = ptr - 2;\n', '\t\tif (ptr2) {\n', '\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t\t!memcmp (ptr + 1, ""0x"", 2) &&\n\t\t\t\t!memcmp (ptr2 + 1, ""0x"", 2)) {\n', 'else\n', '\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n', '\t\t\t\tif (!ptr2[1]) {\n', '\t\tif (isalpha ((ut8)ptr[1]) && !addr) {\n', '\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n', 'else\n', '\t\t\tchar ch = *offstr;\n', '\t\t\tRIODesc *d = tmpdesc;\n', '\t\tif (arroba) {\n', ""\t\tif (ptr[1] == '@') {\n"", '\t\t\t\tchar *rule = ptr + 3;\n', '\t\t\tconst char *fromvars[] = { ""anal.from"", ""diff.from"", ""graph.from"",\n', '\t\t\tconst char *tovars[] = { ""anal.to"", ""diff.to"", ""graph.to"",\n', ""\t\t\tif (ptr[1] == '(') {\n"", '\t\t\t\tchar *range = ptr + 3;\n', ""\t\t\t\tchar *p = strchr (range, ' ');\n"", '\t\t\t\tif (!p) {\n', '\t\t\t\t\tfree (tmpbits);\n', '\t\t\t\tut64 from = r_num_math (core->num, range);\n', '\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n', '\t\tif (is_bits_set) {\n', '\t\t\tr_config_set (core->config, ""asm.bits"", tmpbits);\n']","const char *Var1=NULL ; 
char *Var2,*Var3,*Var4; 
char *Var5=NULL ; 
char *Var6=NULL ; 
STRUCT1 *Var7=NULL ; 
int  Var8=!Var9->memberVar1->memberVar1; 
int  Var10,Var11=0,Var12; 
bool  Var13=Var9->memberVar2; 
bool  Var14=Var9->memberVar3; 
STRUCT2  Var15=Var9->memberVar4; 
if (!Var16){
switch (*Var16){
if (Var16[1]== ){/*STRUCT3 */
char *Var17,*Var18; 
else 
char *Var19=strchr(Var16,; ); 
char *Var20=strchr(Var18+1,); 
const bool  Var21=Var18[2]== >; 
if (Var16[1]!= *&&!strstr(Var16,STRING)){
if (Var16[1]== >){
if (*Var16 != ){
if (Var22&&Var2){
int  Var11; 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
char *Var3=strchr(Var16,); 
if (!Var3||(Var3&&Var3>Var2)){
if (!Var1||(Var1&&Var1>Var2)){
if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!FUNC1(Var2+1,STRING,1)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (!strcmp(Var2+1,STRING)){//STRING
else 
}else if (Var2[1]){//STRING
int  Var24=Var9->memberVar5->memberVar1; 
else 
char *Var25=FUNC2(Var9->memberVar1,Var2+1); 
while (Var2&&*Var2&&Var2[1]== &){
if (Var11 == -1){
if (Var2&&(Var2 ==  Var16||Var2[-1]!= )){
if (*Var16 != ){
if (Var2){
if (FUNC3()->memberVar1){
if (Var2[1]== <){
int  Var11; 
if (!*Var4){
if (!Var9->memberVar6){
else 
}else if (Var2 ==  Var16){
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
if (Var2[0]&&Var2[1]== ){
int  Var26=FUNC4(Var9->memberVar7,STRING); 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (!*Var4){
char *Var28=Var2-1; 
const bool  Var29=(Var2[1]== >); 
char *Var30=FUNC5(Var9,Var16); 
char *Var31=FUNC6(Var9->memberVar8,Var4,1); 
const char *Var32=FUNC7(Var9->memberVar7,STRING); 
if (Var2){
if (Var2>Var16){
char *Var23=Var2-1; 
if (*Var23 == ){
bool  Var33=false ; 
if (Var33){
else 
int  memberVar1=Var9->memberVar5->memberVar1; 
else 
int  Var27=FUNC4(Var9->memberVar7,STRING); 
if (*Var16 != &&*Var16){
const char *Var34=strstr(Var16,STRING); 
if (Var34){
bool  Var35=false ; 
if (Var35){
if (Var2){
char *Var36,*Var3=strchr(Var2+1,!); 
STRUCT2  Var37=Var9->memberVar9; 
char *Var38=NULL ; 
const char *Var39=NULL ; 
bool  Var40=false ; 
char *Var41=NULL ; 
char *Var42=NULL ; 
if (Var2[1]== ){
else 
}else if (Var2[1]== %){//STRING
char *Var43=strdup(Var2+2); 
else 
}else if (Var2[1]== .){//STRING
if (Var2[2]== .){//STRING
STRUCT2  Var37=FUNC8(Var9->memberVar5,Var9->memberVar9,Var2+4); 
else 
}else if (Var2[0]&&Var2[1]== &&Var2[2]){
switch (Var2[0]){
int  Var44=(int ) FUNC9(Var9->memberVar5,Var2+2); 
STRUCT4 *Var45=FUNC10(Var9->memberVar10,Var9->memberVar9); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var49=strdup(Var2+2); 
char  Var23=*Var50; 
STRUCT2  Var37=FUNC9(Var9->memberVar5,Var2+2); 
char *Var16=FUNC12(Var9,Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var51=FUNC13(Var9->memberVar11,NULL ,0,Var2+((Var2[1]) 21)); 
char *Var20=strchr(Var2+2,); 
int  Var52=FUNC9(Var9->memberVar5,Var20); 
const STRUCT5 *Var53=(const STRUCT5 *) FUNC14(Var2+2); 
STRUCT1 *Var46=FUNC11(Var9->memberVar1,Var47,Var48,0); 
char *Var54=Var2-2; 
if (Var3){
if (strlen(Var2+1) == 13&&strlen(Var3+1) == 6&&
!memcmp(Var2+1,STRING,2)&&
!memcmp(Var3+1,STRING,2)){
else 
}else if (strlen(Var2+1) == 9&&strlen(Var3+1) == 4){
if (!Var3[1]){
if (FUNC15((STRUCT5) Var2[1])&&!Var37){
if (!FUNC16(Var9->memberVar12,Var2+1)){
else 
char  Var23=*Var39; 
STRUCT1 *Var46=Var7; 
if (Var5){
if (Var2[1]== ){
char *Var55=Var2+3; 
const char *Var56[]={STRING,STRING,STRING,
const char *Var57[]={STRING,STRING,STRING,
if (Var2[1]== (){
char *Var58=Var2+3; 
char *Var18=strchr(Var58,); 
if (!Var18){
free(Var38); 
STRUCT2  Var59=FUNC9(Var9->memberVar5,Var58); 
STRUCT2  Var60=FUNC9(Var9->memberVar5,Var18+1); 
if (Var40){
FUNC17(Var9->memberVar7,STRING,Var38); 
",1988,0
after_cmd.c,foreach_comment,False,False,595,CWE-,CallExpression,free,3578,-3,"['static int foreach_comment(void *user, const char *k, const char *v) {\n', '\tif (!strncmp (k, ""meta.C."", 7)) {\n', '\t\tchar *cmt = (char *)sdb_decode (v, 0);\n', '\t\tif (cmt) {\n', '\t\t\tfree (cmt);\n']","static int FUNC1(void *Var1,const char *Var2,const char *Var3){
if (!FUNC2(Var2,STRING,7)){
char *Var4=(char *) FUNC3(Var3,0); 
if (Var4){
free(Var4); 
",84,0
after_cmd.c,foreach_pairs,False,False,596,CWE-,CallExpression,strchr,3601,-3,"['static void foreach_pairs(RCore *core, const char *cmd, const char *each) {\n', '\tconst char *arg;\n', '\tint pair = 0;\n', '\tfor (arg = each ; ; ) {\n', ""\t\tchar *next = strchr (arg, ' ');\n"", '\t\tif (next) {\n', '\t\t\t*next = 0;\n', '\t\tif (arg && *arg) {\n', '\t\t\tut64 n = r_num_get (NULL, arg);\n', '\t\t\tif (pair%2) {\n', '\t\t\t\tr_core_block_size (core, n);\n', 'else\n', '\t\t\t\tr_core_seek (core, n, 1);\n', '\t\tif (!next) {\n', '\t\targ = next + 1;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
const char *Var4; 
int  Var5=0; 
for (Var4=Var3; ; ){
char *Var6=strchr(Var4,); 
if (Var6){
*Var6=0; 
if (Var4&&*Var4){
STRUCT2  Var7=FUNC2(NULL ,Var4); 
if (Var5%2){
FUNC3(Var1,Var7); 
else 
FUNC4(Var1,Var7,1); 
if (!Var6){
Var4=Var6+1; 
",176,1
after_cmd.c,r_core_cmd_foreach3,False,False,597,CWE-,CallExpression,free,3644,-3,"['R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // ""@@@""\n', '\tRDebug *dbg = core->dbg;\n', '\tconst char *filter = NULL;\n', ""\tif (each[1] == ':') {\n"", '\t\tfilter = each + 2;\n', '\tswitch (each[0]) {\n', '\t\tif (filter) {\n', '\t\t\tchar *arg = r_core_cmd_str (core, filter);\n', '\t\t\tforeach_pairs (core, cmd, arg);\n', '\t\t\tfree (arg);\n', '\t\t\tint fd = r_io_fd_get_current (core->io);\n', '\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 bszorig = core->blocksize;\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\tint cbsz = core->blocksize;\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n', '\t\t\tut64 off = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING
STRUCT2 *Var5=Var2->memberVar1; 
const char *Var6=NULL ; 
if (Var4[1]== ){
Var6=Var4+2; 
switch (Var4[0]){
if (Var6){
char *Var7=FUNC2(Var2,Var6); 
FUNC3(Var2,Var3,Var7); 
free(Var7); 
int  Var8=FUNC4(Var2->memberVar2); 
STRUCT3 *Var9=FUNC5(Var2->memberVar2,Var8); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var11=FUNC6(Var2->memberVar4,Var12); 
STRUCT5 *Var13=FUNC7(Var2->memberVar5); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var14=Var2->memberVar6; 
STRUCT5 *Var13=FUNC7(Var2->memberVar5); 
int  Var15=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
char *Var17=Var6 FUNC8(Var6) NULL ; 
STRUCT4  Var18=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT6 *Var19=FUNC9(Var2->memberVar7,Var2->memberVar3,0); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
",471,0
after_cmd.c,r_core_cmd_foreach3,False,False,598,CWE-,CallExpression,free,3730,-3,"['\tRDebug *dbg = core->dbg;\n', '\tswitch (each[0]) {\n', '\t\t\tchar *arg = r_core_cmd_str (core, filter);\n', '\t\t\tint fd = r_io_fd_get_current (core->io);\n', '\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRBinImport *imp;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tchar *impflag = r_str_newf (""sym.imp.%s"", imp->name);\n', '\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n', '\t\t\t\tfree (impflag);\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 bszorig = core->blocksize;\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\tint cbsz = core->blocksize;\n', '\t\t\t\tut64 addr = sec->vaddr;\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 off = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n']","STRUCT1 *Var1=Var2->memberVar1; 
switch (Var3[0]){
char *Var4=FUNC1(Var2,Var5); 
int  Var6=FUNC2(Var2->memberVar2); 
STRUCT2 *Var7=FUNC3(Var2->memberVar2,Var6); 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT4 *Var9; 
STRUCT3  Var8=Var2->memberVar3; 
char *Var10=FUNC4(STRING,Var9->memberVar1); 
STRUCT3  Var11=FUNC5(Var2->memberVar4,Var10); 
free(Var10); 
STRUCT5 *Var12=FUNC6(Var2->memberVar5); 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var13=Var2->memberVar6; 
STRUCT5 *Var12=FUNC6(Var2->memberVar5); 
int  Var14=Var2->memberVar6; 
STRUCT3  Var11=Var15->memberVar1; 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var17=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var16=Var2->memberVar6; 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT6 *Var18=FUNC7(Var2->memberVar7,Var2->memberVar3,0); 
STRUCT3  Var8=Var2->memberVar3; 
STRUCT3  Var16=Var2->memberVar6; 
",401,0
after_cmd.c,r_core_cmd_foreach3,False,False,599,CWE-,CallExpression,free,3821,-3,"['R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) { // ""@@@""\n', '\tRDebug *dbg = core->dbg;\n', '\tconst char *filter = NULL;\n', ""\tif (each[1] == ':') {\n"", '\t\tfilter = each + 2;\n', '\tswitch (each[0]) {\n', '\t\t\tchar *arg = r_core_cmd_str (core, filter);\n', '\t\t\tint fd = r_io_fd_get_current (core->io);\n', '\t\t\tRList *maps = r_io_map_get_for_fd (core->io, fd);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 bszorig = core->blocksize;\n', '\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n', '\t\t\tint cbsz = core->blocksize;\n', '\t\t\t\tut64 offorig = core->offset;\n', '\t\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tchar *glob = filter? r_str_trim_dup (filter): NULL;\n', '\t\t\tut64 off = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tr_flag_foreach_glob (core->flags, glob, exec_command_on_flag, &u);\n', '\t\t\tfree (glob);\n', '\t\t\tut64 obs = core->blocksize;\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n', '\t\t\tut64 offorig = core->offset;\n', '\t\t\tut64 obs = core->blocksize;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){//STRING
STRUCT2 *Var5=Var2->memberVar1; 
const char *Var6=NULL ; 
if (Var4[1]== ){
Var6=Var4+2; 
switch (Var4[0]){
char *Var7=FUNC2(Var2,Var6); 
int  Var8=FUNC3(Var2->memberVar2); 
STRUCT3 *Var9=FUNC4(Var2->memberVar2,Var8); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var11=FUNC5(Var2->memberVar4,Var12); 
STRUCT5 *Var13=FUNC6(Var2->memberVar5); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var14=Var2->memberVar6; 
STRUCT5 *Var13=FUNC6(Var2->memberVar5); 
int  Var15=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
char *Var17=Var6 FUNC7(Var6) NULL ; 
STRUCT4  Var18=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
FUNC8(Var2->memberVar7,Var17,Var19,&Var20); 
free(Var17); 
STRUCT4  Var16=Var2->memberVar6; 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT6 *Var21=FUNC9(Var2->memberVar8,Var2->memberVar3,0); 
STRUCT4  Var10=Var2->memberVar3; 
STRUCT4  Var16=Var2->memberVar6; 
",470,0
after_cmd.c,foreachOffset,False,False,600,CWE-,CallExpression,strdup,3869,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *cmd = strdup (_cmd);\n', '\twhile (each) {\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\twhile (each && *each) {\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\tr_core_cmd (core, cmd, 0);\n', '\tfree (cmd);\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=strdup(Var2); 
while (Var3){
if (!*Var3){
char *Var5=strchr(Var3,Var6); 
while (Var3&&*Var3){
char *Var7=strchr(Var3,); 
if (Var7){
else 
if (!*Var3){
FUNC2(Var1,Var4,0); 
free(Var4); 
",145,1
after_cmd.c,foreachOffset,False,False,601,CWE-,CallExpression,strchr,3883,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *nextLine = NULL;\n', '\tut64 addr;\n', '\twhile (each) {\n', ""\t\twhile (*each == ' ') {\n"", '\t\t\teach++;\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\t\tnextLine = nl + 1;\n', 'else\n', '\t\t\tnextLine = NULL;\n', ""\t\tnl = strchr (each, '#');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\twhile (each && *each) {\n', ""\t\t\twhile (*each == ' ') {\n"", '\t\t\t\teach++;\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', ""\t\t\t\t*str = '\\0';\n"", '\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t*str = ' ';\n"", '\t\t\t\teach = str + 1;\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\tr_core_seek (core, addr, 1);\n', '\t\teach = nextLine;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=NULL ; 
STRUCT2  Var5; 
while (Var3){
while (*Var3 == ){
Var3  Var6; 
if (!*Var3){
char *Var7=strchr(Var3,Var8); 
if (Var7){
*Var7=0; 
Var4=Var7+1; 
else 
Var4=NULL ; 
Var7=strchr(Var3,); 
if (Var7){
*Var7=0; 
while (Var3&&*Var3){
while (*Var3 == ){
Var3  Var6; 
char *Var9=strchr(Var3,); 
if (Var9){
*Var9=0; 
Var5=FUNC2(Var1->memberVar1,Var3); 
*Var9=; 
Var3=Var9+1; 
else 
if (!*Var3){
Var5=FUNC2(Var1->memberVar1,Var3); 
FUNC3(Var1,Var5,1); 
Var3=Var4; 
",302,1
after_cmd.c,foreachOffset,False,False,602,CWE-,CallExpression,strchr,3891,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *nextLine = NULL;\n', '\tut64 addr;\n', '\twhile (each) {\n', ""\t\twhile (*each == ' ') {\n"", '\t\t\teach++;\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\t\tnextLine = nl + 1;\n', 'else\n', '\t\t\tnextLine = NULL;\n', ""\t\tnl = strchr (each, '#');\n"", '\t\tif (nl) {\n', '\t\t\t*nl = 0;\n', '\t\twhile (each && *each) {\n', ""\t\t\twhile (*each == ' ') {\n"", '\t\t\t\teach++;\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\teach = nextLine;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=NULL ; 
STRUCT2  Var5; 
while (Var3){
while (*Var3 == ){
Var3  Var6; 
if (!*Var3){
char *Var7=strchr(Var3,Var8); 
if (Var7){
*Var7=0; 
Var4=Var7+1; 
else 
Var4=NULL ; 
Var7=strchr(Var3,); 
if (Var7){
*Var7=0; 
while (Var3&&*Var3){
while (*Var3 == ){
Var3  Var6; 
char *Var9=strchr(Var3,); 
if (Var9){
Var5=FUNC2(Var1->memberVar1,Var3); 
else 
if (!*Var3){
Var5=FUNC2(Var1->memberVar1,Var3); 
Var3=Var4; 
",267,1
after_cmd.c,foreachOffset,False,False,603,CWE-,CallExpression,strchr,3901,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *nextLine = NULL;\n', '\tut64 addr;\n', '\twhile (each) {\n', ""\t\twhile (*each == ' ') {\n"", '\t\t\teach++;\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\tif (nl) {\n', '\t\t\tnextLine = nl + 1;\n', 'else\n', '\t\t\tnextLine = NULL;\n', ""\t\tnl = strchr (each, '#');\n"", '\t\twhile (each && *each) {\n', ""\t\t\twhile (*each == ' ') {\n"", '\t\t\t\teach++;\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', ""\t\t\t\t*str = '\\0';\n"", '\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t*str = ' ';\n"", '\t\t\t\teach = str + 1;\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\teach = NULL;\n', '\t\t\tr_core_seek (core, addr, 1);\n', '\t\teach = nextLine;\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=NULL ; 
STRUCT2  Var5; 
while (Var3){
while (*Var3 == ){
Var3  Var6; 
if (!*Var3){
char *Var7=strchr(Var3,Var8); 
if (Var7){
Var4=Var7+1; 
else 
Var4=NULL ; 
Var7=strchr(Var3,); 
while (Var3&&*Var3){
while (*Var3 == ){
Var3  Var6; 
char *Var9=strchr(Var3,); 
if (Var9){
*Var9=0; 
Var5=FUNC2(Var1->memberVar1,Var3); 
*Var9=; 
Var3=Var9+1; 
else 
if (!*Var3){
Var5=FUNC2(Var1->memberVar1,Var3); 
Var3=NULL ; 
FUNC3(Var1,Var5,1); 
Var3=Var4; 
",287,1
after_cmd.c,foreachOffset,False,False,604,CWE-,CallExpression,free,3920,-3,"['static void foreachOffset(RCore *core, const char *_cmd, const char *each) {\n', '\tchar *cmd = strdup (_cmd);\n', '\twhile (each) {\n', '\t\tif (!*each) {\n', ""\t\tchar *nl = strchr (each, '\\n');\n"", '\t\twhile (each && *each) {\n', ""\t\t\tchar *str = strchr (each, ' ');\n"", '\t\t\tif (str) {\n', 'else\n', '\t\t\t\tif (!*each) {\n', '\t\t\tr_core_cmd (core, cmd, 0);\n', '\tfree (cmd);\n']","static void FUNC1(STRUCT1 *Var1,const char *Var2,const char *Var3){
char *Var4=strdup(Var2); 
while (Var3){
if (!*Var3){
char *Var5=strchr(Var3,Var6); 
while (Var3&&*Var3){
char *Var7=strchr(Var3,); 
if (Var7){
else 
if (!*Var3){
FUNC2(Var1,Var4,0); 
free(Var4); 
",145,1
after_cmd.c,r_core_cmd_foreach,False,False,605,CWE-,CallExpression,strdup,3955,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar ch;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tut64 oseek, addr;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_core_cmd0 (core, each);\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tif (*str == ':' || *str == ' ') {\n"", '\t\t\t\tstr++;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\tif (count == 3) {\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\teach = out;\n', ""\t\t\t\twhile (*each == ' ') {\n"", '\t\t\t\t\teach++;\n', '\t\t\t\tif (!*each) {\n', ""\t\t\t\tstr = strchr (each, ' ');\n"", '\t\t\t\tif (str) {\n', ""\t\t\t\t\t*str = '\\0';\n"", '\t\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t\t*str = ' ';\n"", 'else\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\teach = str + 1;\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t} while (str != NULL);\n', '\t\t\tfree (out);\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', 'else\n', '\t\t\t\teprintf (""cannot open file \'%s\' to read offsets\\n"", each + 1);\n', ""\t\tfor (; *each == ' '; each++) {\n"", '\t\twhile (str[i]) {\n', '\t\t\tch = str[i];\n', ""\t\t\tstr[i] = '\\0';\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\tstr[i] = ch;\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\tR_FREE (word);\n', '\tfree (word);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char  Var7; 
char *Var8=NULL ; 
char *Var9,*Var10=NULL ; 
STRUCT2  Var11,Var12; 
Var10=Var9=strdup(Var4); 
switch (Var4[0]){
char *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2,Var4); 
free(Var10); 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var15=Var2->memberVar4; 
if (Var14){
if (FUNC5()){
char *Var9=Var4+1; 
if (*Var9 == ||*Var9 == ){
Var9  Var16; 
int  Var17=FUNC6(Var9,); 
if (Var17 == 3){
STRUCT2  Var18=FUNC7(Var2->memberVar5,FUNC8(Var9,0)); 
STRUCT2  Var19=FUNC7(Var2->memberVar5,FUNC8(Var9,1)); 
STRUCT2  Var20=FUNC7(Var2->memberVar5,FUNC8(Var9,2)); 
int  Var5; 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT3 *Var14; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var14->memberVar1,Var4+2)){
if (FUNC5()){
else 
STRUCT3 *Var14; 
if (Var2->memberVar2){
STRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC5()){
int  Var23=Var2->memberVar7->memberVar1; 
STRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); 
if (Var4[1]== ){
char *Var25=FUNC11(Var2,Var4+2); 
FUNC12(Var2,Var3,Var9+1); 
if (Var4[1]==  Var26&&Var4[2]==  Var27){
STRUCT2  Var11=Var2->memberVar3; 
char *Var28=FUNC13(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var28){
Var4=Var28; 
while (*Var4 == ){
Var4  Var16; 
if (!*Var4){
Var9=strchr(Var4,); 
if (Var9){
*Var9=0; 
memberVar1=FUNC7(Var2->memberVar5,Var4); 
*Var9=; 
else 
memberVar1=FUNC7(Var2->memberVar5,Var4); 
Var4=Var9+1; 
FUNC14(Var2,memberVar1,1); 
}while (Var9 != NULL ); 
free(Var28); 
if (Var4[1]== (){
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){
if (FUNC5()){
FUNC15(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
STRUCT6 *Var29=FUNC16(Var4+1,STRING); 
if (Var29){
else 
FUNC17(STRING,Var4+1); 
for (; *Var4 == ; Var4  Var16){
while (Var9[Var5]){
Var7=Var9[Var5]; 
Var9[Var5]=0; 
Var8=strdup(Var9+Var6); 
if (!Var8){
Var9[Var5]=Var7; 
const STRUCT7 *Var30=FUNC18(Var2->memberVar10); 
STRUCT5 *Var31=FUNC19((Var32) Var33); 
if (!Var31){
if (FUNC5()){
char *Var34=NULL ; 
const char *Var35=NULL ; 
FUNC20(Var8); 
free(Var8); 
free(Var10); 
free(Var10); 
",1184,0
after_cmd.c,r_core_cmd_foreach,False,False,606,CWE-,CallExpression,strdup,3960,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tRFlagItem *flag;\n', '\tut64 oseek, addr;\n', '\toseek = core->offset;\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_config_set (core->config, ""cmd.hit"", cmd);\n', '\t\tr_core_cmd0 (core, each);\n', '\t\tr_config_set (core->config, ""cmd.hit"", cmdhit);\n', '\t\tfree (cmdhit);\n', '\t\tr_core_cmd_help (core, help_msg_at_at);\n', '\t\t\tRAnalBlock *bb;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tr_core_block_size (core, bb->size);\n', '\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tr_core_block_size (core, bs);\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\tif (count == 3) {\n', '\t\t\t\tut64 cur;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\t\tfor (cur = from; cur < to; cur += step) {\n', '\t\t\t\t\t(void)r_core_seek (core, cur, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tRAnalBlock *bb;\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n', '\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tcore->cons->context->grep = grep;\n', '\t\t\tRDebugPid *p;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\tr_debug_select (core->dbg, pid, pid);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tif (arg) {\n', '\t\t\t\tforeachOffset (core, cmd, arg);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\t\tRDebugFrame *frame;\n', '\t\t\tRList *list;\n', '\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n', '\t\t\t\tswitch (each[3]) {\n', '\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n', '\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n', '\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n', '\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\tr_core_seek (core, oseek, 0);\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\t\tif (!*each) {\n', '\t\t\t\tif (str) {\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', 'else\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t} while (str != NULL);\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tchar cmd2[1024];\n', '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\t\taddr = core->rcmd->macro._brk_value;\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t\tr_core_cmd (core, cmd2, 0);\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tchar cmd2[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', '\t\t\t\tcore->rcmd->macro.counter = 0;\n', '\t\t\t\twhile (!feof (fd)) {\n', '\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n', '\t\t\t\t\taddr = r_num_math (core->num, buf);\n', '\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n', '\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n', '\t\t\t\t\tcore->rcmd->macro.counter++;\n', '\t\tcore->rcmd->macro.counter = 0;\n', '\t\twhile (str[i]) {\n', '\t\t\tif (!word) {\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\tr_flag_foreach_space (core->flags, flagspace, duplicate_flag, &u);\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n', '\t\t\t\t\tr_core_cmd (core, cmd, 0);\n', '\t\t\t\tcore->rcmd->macro.counter++ ;\n', '\tcore->offset = oseek;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char *Var7=NULL ; 
char *Var8,*Var9=NULL ; 
STRUCT2 *Var10; 
STRUCT3  Var11,Var12; 
Var11=Var2->memberVar1; 
switch (Var4[0]){
char *Var13=strdup(FUNC2(Var2->memberVar2,STRING)); 
FUNC3(Var2->memberVar2,STRING,Var3); 
FUNC4(Var2,Var4); 
FUNC3(Var2->memberVar2,STRING,Var13); 
free(Var13); 
FUNC5(Var2,Var14); 
STRUCT4 *Var15; 
STRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); 
int  Var17=Var2->memberVar4; 
if (Var16){
FUNC7(Var2,Var15->size ); 
FUNC8(Var2,Var15->memberVar1,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
FUNC7(Var2,Var17); 
char *Var8=Var4+1; 
int  Var18=FUNC11(Var8,); 
if (Var18 == 3){
STRUCT3  Var19; 
STRUCT3  Var20=FUNC12(Var2->memberVar5,FUNC13(Var8,0)); 
STRUCT3  Var21=FUNC12(Var2->memberVar5,FUNC13(Var8,1)); 
STRUCT3  Var22=FUNC12(Var2->memberVar5,FUNC13(Var8,2)); 
for (Var19=Var20; Var19<Var21; Var19  STRUCT6  Var22){
(void ) FUNC8(Var2,Var19,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
STRUCT4 *Var15; 
int  Var5; 
STRUCT5 *Var16=FUNC6(Var2->memberVar3,Var2->memberVar1,0); 
if (Var16){
for (Var5=0; Var5<Var15->memberVar2; Var5  Var23){
STRUCT3  memberVar1=Var15->memberVar1+Var15->memberVar3[Var5]; 
FUNC8(Var2,memberVar1,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
if (Var4[1]== ){
STRUCT5 *Var16; 
if (Var2->memberVar3){
if (Var4[2]&&strstr(Var16->memberVar1,Var4+2)){
FUNC8(Var2,Var16->memberVar2,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
else 
STRUCT5 *Var16; 
if (Var2->memberVar3){
STRUCT7  Var24=Var2->memberVar6->memberVar1->memberVar1; 
char *Var25; 
FUNC8(Var2,Var16->memberVar2,1); 
FUNC9(Var2,Var3,0); 
if (FUNC10()){
Var2->memberVar6->memberVar1->memberVar1=memberVar1; 
STRUCT8 *Var26; 
int  Var27=Var2->memberVar7->memberVar1; 
if (Var2->memberVar7->memberVar2&&Var2->memberVar7->memberVar2->memberVar1){
STRUCT9 *Var28=Var2->memberVar7->memberVar2->memberVar1(Var2->memberVar7,FUNC14(0,memberVar1)); 
FUNC15(Var2->memberVar7,Var26->memberVar1,Var26->memberVar1); 
FUNC9(Var2,Var3,0); 
FUNC15(Var2->memberVar7,memberVar1,memberVar1); 
if (Var4[1]== ){
char *Var29=FUNC16(Var2,Var4+2); 
if (Var29){
FUNC17(Var2,Var3,Var29); 
FUNC17(Var2,Var3,Var8+1); 
if (Var4[1]==  Var30&&Var4[2]==  Var31){
STRUCT3  Var11=Var2->memberVar1; 
STRUCT10 *Var32; 
STRUCT9 *Var28; 
Var28=FUNC18(Var2->memberVar7,Var33); 
switch (Var4[3]){
FUNC8(Var2,Var32->memberVar1,1); 
FUNC8(Var2,Var32->memberVar2,1); 
FUNC8(Var2,Var32->memberVar3,1); 
FUNC9(Var2,Var3,0); 
FUNC8(Var2,Var11,0); 
char *Var34=FUNC19(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
if (Var34){
if (!*Var4){
if (Var8){
memberVar3=FUNC12(Var2->memberVar5,Var4); 
else 
memberVar3=FUNC12(Var2->memberVar5,Var4); 
FUNC8(Var2,memberVar3,1); 
FUNC9(Var2,Var3,0); 
}while (Var8 != NULL ); 
if (Var4[1]== (){
char  Var35[1024]; 
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var23){
if (FUNC10()){
FUNC20(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
memberVar3=Var2->memberVar9->memberVar1.memberVar3; 
FUNC8(Var2,memberVar3,1); 
FUNC9(Var2,Var35,0); 
else 
char  Var25[1024]; 
char  Var35[1024]; 
STRUCT11 *Var36=FUNC21(Var4+1,STRING); 
if (Var36){
Var2->memberVar9->memberVar1.memberVar1=0; 
while (!FUNC22(Var36)){
if (!fgets(Var25,sizeof (Var25),Var36)){
memberVar3=FUNC12(Var2->memberVar5,Var25); 
FUNC8(Var2,memberVar3,1); //Var37
FUNC9(Var2,Var35,0); 
Var2->memberVar9->memberVar1.memberVar1  Var23; 
Var2->memberVar9->memberVar1.memberVar1=0; 
while (Var8[Var5]){
if (!Var7){
const STRUCT12 *Var38=FUNC23(Var2->memberVar10); 
STRUCT9 *Var39=FUNC24((Var40) Var41); 
if (!Var39){
FUNC25(Var2->memberVar10,Var38,Var42,&Var43); 
if (FUNC10()){
char *Var25=NULL ; 
const char *Var44=NULL ; 
FUNC8(Var2,Var10->memberVar1,1); 
FUNC9(Var2,Var3,0); 
Var2->memberVar9->memberVar1.memberVar1  Var23; 
Var2->memberVar1=Var11; 
",1839,0
after_cmd.c,r_core_cmd_foreach,False,False,607,CWE-,CallExpression,free,3964,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_config_set (core->config, ""cmd.hit"", cmdhit);\n', '\t\tfree (cmdhit);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
switch (Var4[0]){
char *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2->memberVar1,STRING,Var5); 
free(Var5); 
STRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var7=Var2->memberVar4; 
char *Var8=Var4+1; 
STRUCT3  Var9=FUNC5(Var2->memberVar5,FUNC6(Var8,0)); 
STRUCT3  Var10=FUNC5(Var2->memberVar5,FUNC6(Var8,1)); 
STRUCT3  Var11=FUNC5(Var2->memberVar5,FUNC6(Var8,2)); 
STRUCT2 *Var6=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; 
int  Var13=Var2->memberVar7->memberVar1; 
STRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); 
char *Var15=FUNC9(Var2,Var4+2); 
STRUCT3  Var16=Var2->memberVar3; 
char *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
STRUCT6 *Var18=FUNC11(Var4+1,STRING); 
const STRUCT7 *Var19=FUNC12(Var2->memberVar9); 
",417,0
after_cmd.c,r_core_cmd_foreach,False,False,608,CWE-,CallExpression,free,3966,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
Var6=Var5=strdup(Var4); 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
free(Var6); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
if (Var8){
if (FUNC4()){
char *Var5=Var4+1; 
int  Var10=FUNC5(Var5,); 
STRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); 
STRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
if (Var4[1]== ){
STRUCT2 *Var8; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var8; 
if (Var2->memberVar2){
STRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var15=Var2->memberVar7->memberVar1; 
STRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var17=FUNC10(Var2,Var4+2); 
STRUCT3  Var18=Var2->memberVar3; 
char *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); 
STRUCT6 *Var20=FUNC12(Var4+1,STRING); 
const STRUCT7 *Var21=FUNC13(Var2->memberVar9); 
free(Var6); 
free(Var6); 
",573,0
after_cmd.c,r_core_cmd_foreach,False,False,609,CWE-,CallExpression,strstr,4045,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_core_cmd0 (core, each);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', 'else\n', '\t\t\t\teprintf (""cannot open file \'%s\' to read offsets\\n"", each + 1);\n', ""\t\tfor (; *each == ' '; each++) {\n"", '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char *Var7,*Var8=NULL ; 
Var8=Var7=strdup(Var4); 
switch (Var4[0]){
char *Var9=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2,Var4); 
STRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var11=Var2->memberVar4; 
char *Var7=Var4+1; 
int  Var12=FUNC5(Var7,); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var7,0)); 
STRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var7,1)); 
STRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var7,2)); 
int  Var5; 
STRUCT2 *Var10=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT2 *Var10; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var10->memberVar1,Var4+2)){
FUNC8(Var2,Var10->memberVar2,1); 
else 
STRUCT2 *Var10; 
STRUCT4  Var18=Var2->memberVar6->memberVar1->memberVar1; 
int  Var19=Var2->memberVar7->memberVar1; 
STRUCT5 *Var20=Var2->memberVar7->memberVar2->FUNC9(Var2->memberVar7,FUNC10(0,memberVar1)); 
if (Var4[1]== ){
char *Var21=FUNC11(Var2,Var4+2); 
if (Var4[1]==  Var22&&Var4[2]==  Var23){
STRUCT3  Var24=Var2->memberVar3; 
char *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var7+((Var7[1]) 21)); 
if (Var4[1]== (){
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var26){
if (FUNC13()){
FUNC14(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
STRUCT6 *Var27=FUNC15(Var4+1,STRING); 
if (Var27){
else 
FUNC16(STRING,Var4+1); 
for (; *Var4 == ; Var4  Var26){
const STRUCT7 *Var28=FUNC17(Var2->memberVar10); 
",753,0
after_cmd.c,r_core_cmd_foreach,False,False,610,CWE-,CallExpression,strdup,4067,-3,"['\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tbuf = strdup (buf);\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n']","switch (Var1[0]){
char *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
int  Var5=Var3->memberVar4; 
char *Var6=Var1+1; 
STRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); 
STRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); 
STRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
if (Var1[1]== ){
if (Var3->memberVar2){
STRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; 
char *Var11; 
Var11=(char *) FUNC5(); 
if (Var11){
Var11=strdup(Var11); 
FUNC6(Var11); 
free(Var11); 
int  Var12=Var3->memberVar7->memberVar1; 
STRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); 
char *Var14=FUNC9(Var3,Var1+2); 
STRUCT2  Var15=Var3->memberVar3; 
char *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); 
else 
char  Var11[1024]; 
STRUCT5 *Var17=FUNC11(Var1+1,STRING); 
const STRUCT6 *Var18=FUNC12(Var3->memberVar9); 
char *Var11=NULL ; 
",463,0
after_cmd.c,r_core_cmd_foreach,False,False,611,CWE-,CallExpression,free,4071,-3,"['\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n', '\t\t\t\t\tif (buf) {\n', '\t\t\t\t\t\tbuf = strdup (buf);\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n']","switch (Var1[0]){
char *Var2=strdup(FUNC1(Var3->memberVar1,STRING)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
int  Var5=Var3->memberVar4; 
char *Var6=Var1+1; 
STRUCT2  Var7=FUNC3(Var3->memberVar5,FUNC4(Var6,0)); 
STRUCT2  Var8=FUNC3(Var3->memberVar5,FUNC4(Var6,1)); 
STRUCT2  Var9=FUNC3(Var3->memberVar5,FUNC4(Var6,2)); 
STRUCT1 *Var4=FUNC2(Var3->memberVar2,Var3->memberVar3,0); 
if (Var1[1]== ){
if (Var3->memberVar2){
STRUCT3  Var10=Var3->memberVar6->memberVar1->memberVar1; 
char *Var11; 
Var11=(char *) FUNC5(); 
if (Var11){
Var11=strdup(Var11); 
FUNC6(Var11); 
free(Var11); 
int  Var12=Var3->memberVar7->memberVar1; 
STRUCT4 *Var13=Var3->memberVar7->memberVar2->FUNC7(Var3->memberVar7,FUNC8(0,memberVar1)); 
char *Var14=FUNC9(Var3,Var1+2); 
STRUCT2  Var15=Var3->memberVar3; 
char *Var16=FUNC10(Var3->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); 
else 
char  Var11[1024]; 
STRUCT5 *Var17=FUNC11(Var1+1,STRING); 
const STRUCT6 *Var18=FUNC12(Var3->memberVar9); 
char *Var11=NULL ; 
",463,0
after_cmd.c,r_core_cmd_foreach,False,False,612,CWE-,CallExpression,free,4104,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tif (arg) {\n', '\t\t\t\tforeachOffset (core, cmd, arg);\n', '\t\t\t\tfree (arg);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
switch (Var4[0]){
char *Var5=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var7=Var2->memberVar4; 
char *Var8=Var4+1; 
STRUCT3  Var9=FUNC4(Var2->memberVar5,FUNC5(Var8,0)); 
STRUCT3  Var10=FUNC4(Var2->memberVar5,FUNC5(Var8,1)); 
STRUCT3  Var11=FUNC4(Var2->memberVar5,FUNC5(Var8,2)); 
STRUCT2 *Var6=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT4  Var12=Var2->memberVar6->memberVar1->memberVar1; 
int  Var13=Var2->memberVar7->memberVar1; 
STRUCT5 *Var14=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); 
if (Var4[1]== ){
char *Var15=FUNC8(Var2,Var4+2); 
if (Var15){
FUNC9(Var2,Var3,Var15); 
free(Var15); 
STRUCT3  Var16=Var2->memberVar3; 
char *Var17=FUNC10(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
STRUCT6 *Var18=FUNC11(Var4+1,STRING); 
const STRUCT7 *Var19=FUNC12(Var2->memberVar9); 
",436,0
after_cmd.c,r_core_cmd_foreach,False,False,613,CWE-,CallExpression,strchr,4155,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar ch;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tut64 oseek, addr;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tr_core_cmd0 (core, each);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tif (*str == ':' || *str == ' ') {\n"", '\t\t\t\tstr++;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\tif (count == 3) {\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', ""\t\tif (each[1] == 'b' && each[2] == 't') {\n"", '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\teach = out;\n', ""\t\t\t\twhile (*each == ' ') {\n"", '\t\t\t\t\teach++;\n', '\t\t\t\tif (!*each) {\n', ""\t\t\t\tstr = strchr (each, ' ');\n"", '\t\t\t\tif (str) {\n', ""\t\t\t\t\t*str = '\\0';\n"", '\t\t\t\t\taddr = r_num_math (core->num, each);\n', ""\t\t\t\t\t*str = ' ';\n"", 'else\n', '\t\t\t\t\taddr = r_num_math (core->num, each);\n', '\t\t\t\teach = str + 1;\n', '\t\t\t\tr_core_seek (core, addr, 1);\n', '\t\t\t} while (str != NULL);\n', ""\t\tif (each[1] == '(') {\n"", '\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n', '\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n', '\t\t\t\tif (!core->rcmd->macro.brk_value) {\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', 'else\n', '\t\t\t\teprintf (""cannot open file \'%s\' to read offsets\\n"", each + 1);\n', ""\t\tfor (; *each == ' '; each++) {\n"", '\t\twhile (str[i]) {\n', '\t\t\tch = str[i];\n', ""\t\t\tstr[i] = '\\0';\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\tstr[i] = ch;\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char  Var7; 
char *Var8=NULL ; 
char *Var9,*Var10=NULL ; 
STRUCT2  Var11,Var12; 
Var10=Var9=strdup(Var4); 
switch (Var4[0]){
char *Var13=strdup(FUNC2(Var2->memberVar1,STRING)); 
FUNC3(Var2,Var4); 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
int  Var15=Var2->memberVar4; 
char *Var9=Var4+1; 
if (*Var9 == ||*Var9 == ){
Var9  Var16; 
int  Var17=FUNC5(Var9,); 
if (Var17 == 3){
STRUCT2  Var18=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); 
STRUCT2  Var19=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); 
STRUCT2  Var20=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); 
int  Var5; 
STRUCT3 *Var14=FUNC4(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT2  Var12=Var21->memberVar1+Var21->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT3 *Var14; 
if (Var2->memberVar2){
else 
STRUCT3 *Var14; 
STRUCT4  Var22=Var2->memberVar6->memberVar1->memberVar1; 
int  Var23=Var2->memberVar7->memberVar1; 
STRUCT5 *Var24=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
if (Var4[1]== ){
char *Var25=FUNC10(Var2,Var4+2); 
FUNC11(Var2,Var3,Var9+1); 
if (Var4[1]==  Var26&&Var4[2]==  Var27){
STRUCT2  Var11=Var2->memberVar3; 
char *Var28=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); 
if (Var28){
Var4=Var28; 
while (*Var4 == ){
Var4  Var16; 
if (!*Var4){
Var9=strchr(Var4,); 
if (Var9){
*Var9=0; 
memberVar1=FUNC6(Var2->memberVar5,Var4); 
*Var9=; 
else 
memberVar1=FUNC6(Var2->memberVar5,Var4); 
Var4=Var9+1; 
FUNC13(Var2,memberVar1,1); 
}while (Var9 != NULL ); 
if (Var4[1]== (){
for (Var2->memberVar9->memberVar1.memberVar1=0; Var5<999; Var2->memberVar9->memberVar1.memberVar1  Var16){
if (FUNC14()){
FUNC15(&Var2->memberVar9->memberVar1,Var4+2); 
if (!Var2->memberVar9->memberVar1.memberVar2){
STRUCT6 *Var29=FUNC16(Var4+1,STRING); 
if (Var29){
else 
FUNC17(STRING,Var4+1); 
for (; *Var4 == ; Var4  Var16){
while (Var9[Var5]){
Var7=Var9[Var5]; 
Var9[Var5]=0; 
Var8=strdup(Var9+Var6); 
if (!Var8){
Var9[Var5]=Var7; 
const STRUCT7 *Var30=FUNC18(Var2->memberVar10); 
STRUCT5 *Var31=FUNC19((Var32) Var33); 
if (!Var31){
if (FUNC14()){
char *Var34=NULL ; 
const char *Var35=NULL ; 
",1066,0
after_cmd.c,r_core_cmd_foreach,False,False,614,CWE-,CallExpression,free,4169,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\teach = out;\n', '\t\t\tfree (out);\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5=NULL ; 
char *Var6,*Var7=NULL ; 
Var7=Var6=strdup(Var4); 
switch (Var4[0]){
char *Var8=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var10=Var2->memberVar4; 
char *Var6=Var4+1; 
int  Var11=FUNC4(Var6,); 
STRUCT3  Var12=FUNC5(Var2->memberVar5,FUNC6(Var6,0)); 
STRUCT3  Var13=FUNC5(Var2->memberVar5,FUNC6(Var6,1)); 
STRUCT3  Var14=FUNC5(Var2->memberVar5,FUNC6(Var6,2)); 
STRUCT2 *Var9=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT4  Var15=Var2->memberVar6->memberVar1->memberVar1; 
int  Var16=Var2->memberVar7->memberVar1; 
STRUCT5 *Var17=Var2->memberVar7->memberVar2->FUNC7(Var2->memberVar7,FUNC8(0,memberVar1)); 
char *Var18=FUNC9(Var2,Var4+2); 
STRUCT3  Var19=Var2->memberVar3; 
char *Var20=FUNC10(Var2->memberVar8,NULL ,0,Var6+((Var6[1]) 21)); 
if (Var20){
Var4=Var20; 
free(Var20); 
STRUCT6 *Var21=FUNC11(Var4+1,STRING); 
const STRUCT7 *Var22=FUNC12(Var2->memberVar9); 
char *Var23=NULL ; 
const char *Var24=NULL ; 
",489,0
after_cmd.c,r_core_cmd_foreach,False,False,615,CWE-,CallExpression,fgets,4201,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tut64 oseek, addr;\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', ""\t\tif (each[1] == '(') {\n"", 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', '\t\t\t\twhile (!feof (fd)) {\n', ""\t\t\t\t\tbuf[0] = '\\0';\n"", '\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n', '\t\t\t\t\taddr = r_num_math (core->num, buf);\n', '\t\t\t\tfclose (fd);\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\t\tchar *buf = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
STRUCT2  Var5,Var6; 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
char *Var10=Var4+1; 
STRUCT2  Var11=FUNC4(Var2->memberVar5,FUNC5(Var10,0)); 
STRUCT2  Var12=FUNC4(Var2->memberVar5,FUNC5(Var10,1)); 
STRUCT2  Var13=FUNC4(Var2->memberVar5,FUNC5(Var10,2)); 
STRUCT3 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT2  Var6=Var14->memberVar1+Var14->memberVar2[Var15]; 
STRUCT4  Var16=Var2->memberVar6->memberVar1->memberVar1; 
char *Var17; 
int  Var18=Var2->memberVar7->memberVar1; 
STRUCT5 *Var19=Var2->memberVar7->memberVar2->FUNC6(Var2->memberVar7,FUNC7(0,memberVar1)); 
char *Var20=FUNC8(Var2,Var4+2); 
STRUCT2  Var5=Var2->memberVar3; 
char *Var21=FUNC9(Var2->memberVar8,NULL ,0,Var10+((Var10[1]) 21)); 
if (Var4[1]== (){
else 
char  Var17[1024]; 
STRUCT6 *Var22=FUNC10(Var4+1,STRING); 
if (Var22){
while (!FUNC11(Var22)){
Var17[0]=0; 
if (!fgets(Var17,sizeof (Var17),Var22)){
memberVar1=FUNC4(Var2->memberVar5,Var17); 
fclose(Var22); 
const STRUCT7 *Var23=FUNC12(Var2->memberVar9); 
char *Var17=NULL ; 
",545,0
after_cmd.c,r_core_cmd_foreach,False,False,616,CWE-,CallExpression,fclose,4211,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tswitch (each[0]) {\n', '\t\t\tchar *str = each + 1;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', ""\t\tif (each[1] == '(') {\n"", 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\tif (fd) {\n', '\t\t\t\twhile (!feof (fd)) {\n', '\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n', '\t\t\t\tfclose (fd);\n', '\t\t\t\t\tchar *buf = NULL;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
switch (Var4[0]){
char *Var5=Var4+1; 
char *Var6; 
char *Var7=FUNC2(Var2,Var4+2); 
if (Var4[1]== (){
else 
char  Var6[1024]; 
STRUCT2 *Var8=FUNC3(Var4+1,STRING); 
if (Var8){
while (!FUNC4(Var8)){
if (!fgets(Var6,sizeof (Var6),Var8)){
fclose(Var8); 
char *Var6=NULL ; 
",183,0
after_cmd.c,r_core_cmd_foreach,False,False,617,CWE-,CallExpression,strdup,4233,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar ch;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tforeachOffset (core, cmd, str + 1);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\ti = 0;\n', '\t\twhile (str[i]) {\n', '\t\t\tj = i;\n', ""\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n"", ""\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n"", '\t\t\tch = str[i];\n', ""\t\t\tstr[i] = '\\0';\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\tstr[i] = ch;\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\tR_FREE (word);\n', '\tfree (word);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char  Var7; 
char *Var8=NULL ; 
char *Var9,*Var10=NULL ; 
Var10=Var9=strdup(Var4); 
switch (Var4[0]){
char *Var11=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var13=Var2->memberVar4; 
if (Var12){
if (FUNC4()){
char *Var9=Var4+1; 
int  Var14=FUNC5(Var9,); 
STRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var9,0)); 
STRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var9,1)); 
STRUCT3  Var17=FUNC6(Var2->memberVar5,FUNC7(Var9,2)); 
int  Var5; 
STRUCT2 *Var12=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT3  Var18=Var19->memberVar1+Var19->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT2 *Var12; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var12->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var12; 
if (Var2->memberVar2){
STRUCT4  Var20=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var21=Var2->memberVar7->memberVar1; 
STRUCT5 *Var22=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var23=FUNC10(Var2,Var4+2); 
FUNC11(Var2,Var3,Var9+1); 
STRUCT3  Var24=Var2->memberVar3; 
char *Var25=FUNC12(Var2->memberVar8,NULL ,0,Var9+((Var9[1]) 21)); 
STRUCT6 *Var26=FUNC13(Var4+1,STRING); 
Var5=0; 
while (Var9[Var5]){
Var6=Var5; 
for (; Var9[Var6]&&Var9[Var6]== ; Var6  Var27){
for (Var5=Var6; Var9[Var5]&&Var9[Var5]!= ; Var5  Var27){
Var7=Var9[Var5]; 
Var9[Var5]=0; 
Var8=strdup(Var9+Var6); 
if (!Var8){
Var9[Var5]=Var7; 
const STRUCT7 *Var28=FUNC14(Var2->memberVar9); 
STRUCT5 *Var29=FUNC15((Var30) Var31); 
if (!Var29){
if (FUNC4()){
char *Var32=NULL ; 
const char *Var33=NULL ; 
FUNC16(Var8); 
free(Var8); 
",844,0
after_cmd.c,r_core_cmd_foreach,False,False,618,CWE-,CallExpression,strdup,4267,-3,"['\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tr_cons_break_push (NULL, NULL); //pop on return\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\tif (out) {\n', '\t\t\t\tif (!*each) {\n', '\t\t\t} while (str != NULL);\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\twhile (str[i]) {\n', '\t\t\tif (!word) {\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\t\ttmp = r_cons_get_buffer ();\n', '\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4,*Var5=NULL ; 
FUNC1(NULL ,NULL ); //Var6  STRUCT1 return 
switch (Var7[0]){
char *Var8=strdup(FUNC2(Var9->memberVar1,STRING)); 
STRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); 
int  Var11=Var9->memberVar4; 
char *Var4=Var7+1; 
int  Var12=FUNC4(Var4,); 
STRUCT3  Var13=FUNC5(Var9->memberVar5,FUNC6(Var4,0)); 
STRUCT3  Var14=FUNC5(Var9->memberVar5,FUNC6(Var4,1)); 
STRUCT3  Var15=FUNC5(Var9->memberVar5,FUNC6(Var4,2)); 
int  Var1; 
STRUCT2 *Var10=FUNC3(Var9->memberVar2,Var9->memberVar3,0); 
STRUCT3  Var16=Var17->memberVar1+Var17->memberVar2[Var1]; 
STRUCT4  Var18=Var9->memberVar6->memberVar1->memberVar1; 
char *Var19; 
int  Var20=Var9->memberVar7->memberVar1; 
STRUCT5 *Var21=Var9->memberVar7->memberVar2->FUNC7(Var9->memberVar7,FUNC8(0,memberVar1)); 
char *Var22=FUNC9(Var9,Var7+2); 
STRUCT3  Var23=Var9->memberVar3; 
char *Var24=FUNC10(Var9->memberVar8,NULL ,0,Var4+((Var4[1]) 21)); 
if (Var24){
if (!*Var7){
}while (Var4 != NULL ); 
else 
char  Var19[1024]; 
STRUCT6 *Var25=FUNC11(Var7+1,STRING); 
while (Var4[Var1]){
if (!Var3){
const STRUCT7 *Var26=FUNC12(Var9->memberVar9); 
STRUCT5 *Var27=FUNC13((Var28) Var29); 
if (!Var27){
if (FUNC14()){
char *Var19=NULL ; 
const char *Var30=NULL ; 
Var30=FUNC15(); 
Var19=Var30 strdup(Var30) NULL ; 
FUNC16(Var19); 
free(Var19); 
",632,0
after_cmd.c,r_core_cmd_foreach,False,False,619,CWE-,CallExpression,free,4270,-3,"['\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', '\t\t\t\t\tchar *buf;\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', 'else\n', '\t\t\tchar buf[1024];\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\twhile (str[i]) {\n', '\t\t\tif (!word) {\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\t\ttmp = r_cons_get_buffer ();\n', '\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n', '\t\t\t\t\tr_cons_strcat (buf);\n', '\t\t\t\t\tfree (buf);\n']","int  Var1,Var2; 
char *Var3=NULL ; 
char *Var4,*Var5=NULL ; 
switch (Var6[0]){
char *Var7=strdup(FUNC1(Var8->memberVar1,STRING)); 
char *Var4=Var6+1; 
int  Var9=FUNC2(Var4,); 
STRUCT1  Var10=FUNC3(Var8->memberVar2,FUNC4(Var4,0)); 
STRUCT1  Var11=FUNC3(Var8->memberVar2,FUNC4(Var4,1)); 
STRUCT1  Var12=FUNC3(Var8->memberVar2,FUNC4(Var4,2)); 
int  Var1; 
STRUCT1  Var13=Var14->memberVar1+Var14->memberVar2[Var1]; 
char *Var15; 
char *Var16=FUNC5(Var8,Var6+2); 
char *Var17=FUNC6(Var8->memberVar3,NULL ,0,Var4+((Var4[1]) 21)); 
else 
char  Var15[1024]; 
STRUCT2 *Var18=FUNC7(Var6+1,STRING); 
while (Var4[Var1]){
if (!Var3){
STRUCT3 *Var19=FUNC8((Var20) Var21); 
if (!Var19){
if (FUNC9()){
char *Var15=NULL ; 
const char *Var22=NULL ; 
Var22=FUNC10(); 
Var15=Var22 strdup(Var22) NULL ; 
FUNC11(Var15); 
free(Var15); 
",412,0
after_cmd.c,r_core_cmd_foreach,False,False,620,CWE-,CallExpression,free,4283,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tint i, j;\n', '\tchar *word = NULL;\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tint i;\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\ti = 0;\n', '\t\twhile (str[i]) {\n', '\t\t\tj = i;\n', ""\t\t\tfor (; str[j] && str[j] == ' '; j++) {\n"", ""\t\t\tfor (i = j; str[i] && str[i] != ' '; i++) {\n"", '\t\t\tword = strdup (str + j);\n', '\t\t\tif (!word) {\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\t\t\t\tRList *match_flag_items = r_list_newf ((RListFree)r_flag_item_free);\n', '\t\t\t\tif (!match_flag_items) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\t\tchar *buf = NULL;\n', '\t\t\t\t\tconst char *tmp = NULL;\n', '\t\t\t\tR_FREE (word);\n', '\tfree (word);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
int  Var5,Var6; 
char *Var7=NULL ; 
char *Var8,*Var9=NULL ; 
Var9=Var8=strdup(Var4); 
switch (Var4[0]){
char *Var10=strdup(FUNC2(Var2->memberVar1,STRING)); 
STRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var12=Var2->memberVar4; 
if (Var11){
if (FUNC4()){
char *Var8=Var4+1; 
int  Var13=FUNC5(Var8,); 
STRUCT3  Var14=FUNC6(Var2->memberVar5,FUNC7(Var8,0)); 
STRUCT3  Var15=FUNC6(Var2->memberVar5,FUNC7(Var8,1)); 
STRUCT3  Var16=FUNC6(Var2->memberVar5,FUNC7(Var8,2)); 
int  Var5; 
STRUCT2 *Var11=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
STRUCT3  Var17=Var18->memberVar1+Var18->memberVar2[Var5]; 
if (Var4[1]== ){
STRUCT2 *Var11; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var11->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var11; 
if (Var2->memberVar2){
STRUCT4  Var19=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var20=Var2->memberVar7->memberVar1; 
STRUCT5 *Var21=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var22=FUNC10(Var2,Var4+2); 
STRUCT3  Var23=Var2->memberVar3; 
char *Var24=FUNC11(Var2->memberVar8,NULL ,0,Var8+((Var8[1]) 21)); 
STRUCT6 *Var25=FUNC12(Var4+1,STRING); 
Var5=0; 
while (Var8[Var5]){
Var6=Var5; 
for (; Var8[Var6]&&Var8[Var6]== ; Var6  Var26){
for (Var5=Var6; Var8[Var5]&&Var8[Var5]!= ; Var5  Var26){
Var7=strdup(Var8+Var6); 
if (!Var7){
const STRUCT7 *Var27=FUNC13(Var2->memberVar9); 
STRUCT5 *Var28=FUNC14((Var29) Var30); 
if (!Var28){
if (FUNC4()){
char *Var31=NULL ; 
const char *Var32=NULL ; 
FUNC15(Var7); 
free(Var7); 
",790,0
after_cmd.c,r_core_cmd_foreach,False,False,621,CWE-,CallExpression,free,4284,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
Var6=Var5=strdup(Var4); 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
free(Var6); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
if (Var8){
if (FUNC4()){
char *Var5=Var4+1; 
int  Var10=FUNC5(Var5,); 
STRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); 
STRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
if (Var4[1]== ){
STRUCT2 *Var8; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var8; 
if (Var2->memberVar2){
STRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var15=Var2->memberVar7->memberVar1; 
STRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var17=FUNC10(Var2,Var4+2); 
STRUCT3  Var18=Var2->memberVar3; 
char *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); 
STRUCT6 *Var20=FUNC12(Var4+1,STRING); 
const STRUCT7 *Var21=FUNC13(Var2->memberVar9); 
free(Var6); 
free(Var6); 
",573,0
after_cmd.c,r_core_cmd_foreach,False,False,622,CWE-,CallExpression,free,4287,-3,"['R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n', '\tchar *str, *ostr = NULL;\n', '\tostr = str = strdup (each);\n', '\tswitch (each[0]) {\n', '\t\tchar *cmdhit = strdup (r_config_get (core->config, ""cmd.hit""));\n', '\t\tfree (ostr);\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', '\t\t\tint bs = core->blocksize;\n', '\t\t\tif (fcn) {\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tchar *str = each + 1;\n', ""\t\t\tint count = r_str_split (str, ' ');\n"", '\t\t\t\tut64 from = r_num_math (core->num, r_str_word_get0 (str, 0));\n', '\t\t\t\tut64 to = r_num_math (core->num, r_str_word_get0 (str, 1));\n', '\t\t\t\tut64 step = r_num_math (core->num, r_str_word_get0 (str, 2));\n', '\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n', ""\t\tif (each[1] == ':') {\n"", '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n', '\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n', 'else\n', '\t\t\tRAnalFunction *fcn;\n', '\t\t\tif (core->anal) {\n', '\t\t\t\tRConsGrep grep = core->cons->context->grep;\n', '\t\t\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\tint pid = core->dbg->pid;\n', '\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n', '\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n', '\t\t\tut64 oseek = core->offset;\n', '\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n', '\t\t\tFILE *fd = r_sandbox_fopen (each + 1, ""r"");\n', '\t\t\t\tconst RSpace *flagspace = r_flag_space_cur (core->flags);\n', '\tfree (ostr);\n', '\tfree (ostr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,char *Var4){
char *Var5,*Var6=NULL ; 
Var6=Var5=strdup(Var4); 
switch (Var4[0]){
char *Var7=strdup(FUNC2(Var2->memberVar1,STRING)); 
free(Var6); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
int  Var9=Var2->memberVar4; 
if (Var8){
if (FUNC4()){
char *Var5=Var4+1; 
int  Var10=FUNC5(Var5,); 
STRUCT3  Var11=FUNC6(Var2->memberVar5,FUNC7(Var5,0)); 
STRUCT3  Var12=FUNC6(Var2->memberVar5,FUNC7(Var5,1)); 
STRUCT3  Var13=FUNC6(Var2->memberVar5,FUNC7(Var5,2)); 
STRUCT2 *Var8=FUNC3(Var2->memberVar2,Var2->memberVar3,0); 
if (Var4[1]== ){
STRUCT2 *Var8; 
if (Var2->memberVar2){
if (Var4[2]&&strstr(Var8->memberVar1,Var4+2)){
if (FUNC4()){
else 
STRUCT2 *Var8; 
if (Var2->memberVar2){
STRUCT4  Var14=Var2->memberVar6->memberVar1->memberVar1; 
if (FUNC4()){
int  Var15=Var2->memberVar7->memberVar1; 
STRUCT5 *Var16=Var2->memberVar7->memberVar2->FUNC8(Var2->memberVar7,FUNC9(0,memberVar1)); 
char *Var17=FUNC10(Var2,Var4+2); 
STRUCT3  Var18=Var2->memberVar3; 
char *Var19=FUNC11(Var2->memberVar8,NULL ,0,Var5+((Var5[1]) 21)); 
STRUCT6 *Var20=FUNC12(Var4+1,STRING); 
const STRUCT7 *Var21=FUNC13(Var2->memberVar9); 
free(Var6); 
free(Var6); 
",573,0
after_cmd.c,run_pending_anal,False,False,623,CWE-,CallExpression,free,4299,-3,"['R_API void run_pending_anal(RCore *core) {\n', '\tcore->ev->incall = false;\n', '\tif (core && core->anal && core->anal->cmdtail) {\n', '\t\tchar *res = core->anal->cmdtail;\n', '\t\tr_core_cmd_lines (core, res);\n', '\t\tfree (res);\n']","Var1 void FUNC1(STRUCT1 *Var2){
Var2->memberVar1->memberVar1=false ; 
if (Var2&&Var2->memberVar2&&Var2->memberVar2->memberVar1){
char *Var3=Var2->memberVar2->memberVar1; 
FUNC2(Var2,Var3); 
free(Var3); 
",88,1
after_cmd.c,r_core_cmd,False,False,624,CWE-,CallExpression,strchr,4310,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
",415,0
after_cmd.c,r_core_cmd,False,False,625,CWE-,CallExpression,strlen,4315,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\t\tcore->incomment = false;\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tfree (core->lastcmd);\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tR_FREE (core->oobi);\n', '\t\tcore->oobi_len = 0;\n', '\tcore->cons->context->cmd_depth--;\n', '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\tif (!ptr) {\n', '\trun_pending_anal (core);\n', '\tcore->cons->context->cmd_depth++;\n', '\tR_FREE (core->oobi);\n', '\tcore->oobi_len = 0;\n', '\tif (r_list_empty (core->tasks)) {\n', '\t\tr_th_lock_leave (core->lock);\n', '\trun_pending_anal (core);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
Var2->memberVar4=false ; 
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
free(Var2->memberVar5); 
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
Var2->memberVar6->memberVar1->memberVar1  Var15; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
if (!Var7){
FUNC9(Var2); 
Var2->memberVar6->memberVar1->memberVar1  Var12; 
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
if (FUNC10(Var2->memberVar9)){
FUNC11(Var2->memberVar10); 
FUNC9(Var2); 
",604,0
after_cmd.c,r_core_cmd,False,False,626,CWE-,CallExpression,free,4325,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', '\t\t\tif (res) {\n', '\t\t\t\tr_cons_printf (""%s\\n"", res);\n', '\t\t\t\tfree (res);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
int  Var5=false ,Var6; 
if (Var2->memberVar1){
const char *Var7=STRING; 
for (Var6=0; Var7[Var6]; Var6  Var8){
if (strchr(Var3,Var7[Var6])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var9&&FUNC2(Var3,STRING,2)){
char *Var10=FUNC3(Var2->memberVar3,Var3); 
if (Var10){
FUNC4(STRING,Var10); 
free(Var10); 
",224,0
after_cmd.c,r_core_cmd,False,False,627,CWE-,CallExpression,free,4349,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\t\tcore->incomment = false;\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tfree (core->lastcmd);\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tR_FREE (core->oobi);\n', '\t\tcore->oobi_len = 0;\n', '\tcore->cons->context->cmd_depth--;\n', '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\tif (!ptr) {\n', '\trun_pending_anal (core);\n', '\tcore->cons->context->cmd_depth++;\n', '\tR_FREE (core->oobi);\n', '\tcore->oobi_len = 0;\n', '\tif (r_list_empty (core->tasks)) {\n', '\t\tr_th_lock_leave (core->lock);\n', '\trun_pending_anal (core);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
Var2->memberVar4=false ; 
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
free(Var2->memberVar5); 
Var2->memberVar5=strdup(Var3); 
if (!Var6){
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC5(Var2->memberVar7); 
Var2->memberVar8=0; 
Var2->memberVar6->memberVar1->memberVar1  Var15; 
Var9=FUNC6(Var2,Var8); 
if (Var9 == -1){
if (!Var7){
FUNC7(Var2); 
Var2->memberVar6->memberVar1->memberVar1  Var12; 
FUNC5(Var2->memberVar7); 
Var2->memberVar8=0; 
if (FUNC8(Var2->memberVar9)){
FUNC9(Var2->memberVar10); 
FUNC7(Var2); 
",558,0
after_cmd.c,r_core_cmd,False,False,628,CWE-,CallExpression,strdup,4350,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\t\tcore->incomment = false;\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tfree (core->lastcmd);\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tR_FREE (core->oobi);\n', '\t\tcore->oobi_len = 0;\n', '\tcore->cons->context->cmd_depth--;\n', '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\tif (!ptr) {\n', '\trun_pending_anal (core);\n', '\tcore->cons->context->cmd_depth++;\n', '\tR_FREE (core->oobi);\n', '\tcore->oobi_len = 0;\n', '\tif (r_list_empty (core->tasks)) {\n', '\t\tr_th_lock_leave (core->lock);\n', '\trun_pending_anal (core);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
Var2->memberVar4=false ; 
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
free(Var2->memberVar5); 
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
Var2->memberVar6->memberVar1->memberVar1  Var15; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
if (!Var7){
FUNC9(Var2); 
Var2->memberVar6->memberVar1->memberVar1  Var12; 
FUNC7(Var2->memberVar7); 
Var2->memberVar8=0; 
if (FUNC10(Var2->memberVar9)){
FUNC11(Var2->memberVar10); 
FUNC9(Var2); 
",604,0
after_cmd.c,r_core_cmd,False,False,629,CWE-,CallExpression,malloc,4353,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\teprintf (""r_core_cmd: That was too deep (%s)...\\n"", cmd);\n', '\t\tfree (ocmd);\n', '\tfor (rcmd = cmd;;) {\n', ""\t\tptr = strchr (rcmd, '\\n');\n"", '\t\tif (ptr) {\n', ""\t\t\t*ptr = '\\0';\n"", '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""|ERROR| Invalid command \'%s\' (0x%02x)\\n"", rcmd, *rcmd);\n', '\t\tif (!ptr) {\n', '\t\trcmd = ptr + 1;\n', '\tfree (ocmd);\n', '\treturn ret;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(STRING,Var5); 
free(Var6); 
for (Var8=Var5; ; ){
Var7=strchr(Var8,Var15); 
if (Var7){
*Var7=0; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
FUNC7(STRING,Var8,*Var8); 
if (!Var7){
Var8=Var7+1; 
free(Var6); 
return  Var9; 
",566,0
after_cmd.c,r_core_cmd,False,False,630,CWE-,CallExpression,strlen,4353,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tif (log && (*cstr && (*cstr != \'.\' || !strncmp (cstr, "".("", 2)))) {\n', '\t\tcore->lastcmd = strdup (cstr);\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tr_str_cpy (cmd, cstr);\n', '\tif (log) {\n', '\t\tr_line_hist_add (cstr);\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\teprintf (""r_core_cmd: That was too deep (%s)...\\n"", cmd);\n', '\t\tfree (ocmd);\n', '\tfor (rcmd = cmd;;) {\n', ""\t\tptr = strchr (rcmd, '\\n');\n"", '\t\tif (ptr) {\n', ""\t\t\t*ptr = '\\0';\n"", '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""|ERROR| Invalid command \'%s\' (0x%02x)\\n"", rcmd, *rcmd);\n', '\t\tif (!ptr) {\n', '\t\trcmd = ptr + 1;\n', '\tfree (ocmd);\n', '\treturn ret;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
if (Var4&&(*Var3&&(*Var3 != .||!FUNC2(Var3,STRING,2)))){
Var2->memberVar5=strdup(Var3); 
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
FUNC5(Var5,Var3); 
if (Var4){
FUNC6(Var3); 
if (Var2->memberVar6->memberVar1->memberVar1<1){
FUNC7(STRING,Var5); 
free(Var6); 
for (Var8=Var5; ; ){
Var7=strchr(Var8,Var15); 
if (Var7){
*Var7=0; 
Var9=FUNC8(Var2,Var8); 
if (Var9 == -1){
FUNC7(STRING,Var8,*Var8); 
if (!Var7){
Var8=Var7+1; 
free(Var6); 
return  Var9; 
",566,0
after_cmd.c,r_core_cmd,False,False,631,CWE-,CallExpression,free,4364,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tfree (ocmd);\n', '\tfree (ocmd);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
if (Var2->memberVar5->memberVar1->memberVar1<1){
free(Var6); 
free(Var6); 
",369,0
after_cmd.c,r_core_cmd,False,False,632,CWE-,CallExpression,strchr,4371,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\tfor (rcmd = cmd;;) {\n', ""\t\tptr = strchr (rcmd, '\\n');\n"", '\t\tif (ptr) {\n', ""\t\t\t*ptr = '\\0';\n"", '\t\tret = r_core_cmd_subst (core, rcmd);\n', '\t\tif (ret == -1) {\n', '\t\t\teprintf (""|ERROR| Invalid command \'%s\' (0x%02x)\\n"", rcmd, *rcmd);\n', '\t\tif (!ptr) {\n', '\t\trcmd = ptr + 1;\n', '\treturn ret;\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
if (Var2->memberVar5->memberVar1->memberVar1<1){
for (Var8=Var5; ; ){
Var7=strchr(Var8,Var15); 
if (Var7){
*Var7=0; 
Var9=FUNC5(Var2,Var8); 
if (Var9 == -1){
FUNC6(STRING,Var8,*Var8); 
if (!Var7){
Var8=Var7+1; 
return  Var9; 
",463,0
after_cmd.c,r_core_cmd,False,False,633,CWE-,CallExpression,free,4388,-3,"['R_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n', '\tchar *cmd, *ocmd, *ptr, *rcmd;\n', '\tint ret = false, i;\n', '\tif (core->cmdfilter) {\n', '\t\tconst char *invalid_chars = "";|>`@"";\n', '\t\tfor (i = 0; invalid_chars[i]; i++) {\n', '\t\t\tif (strchr (cstr, invalid_chars[i])) {\n', '\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n', '\tif (core->cmdremote) {\n', '\t\tif (*cstr != \'=\' && *cstr != \'q\' && strncmp (cstr, ""!="", 2)) {\n', '\t\t\tchar *res = r_io_system (core->io, cstr);\n', ""\tif (!cstr || (*cstr == '|' && cstr[1] != '?')) {\n"", '\tif (!strncmp (cstr, ""/*"", 2)) {\n', '\t\tif (r_sandbox_enable (0)) {\n', 'else\n', '\t} else if (!strncmp (cstr, ""*/"", 2)) {\n', '\tif (core->incomment) {\n', '\tocmd = cmd = malloc (strlen (cstr) + 4096);\n', '\tif (!ocmd) {\n', '\tif (core->cons->context->cmd_depth < 1) {\n', '\t\tfree (ocmd);\n', '\tfree (ocmd);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,int  Var4){
char *Var5,*Var6,*Var7,*Var8; 
int  Var9=false ,Var10; 
if (Var2->memberVar1){
const char *Var11=STRING; 
for (Var10=0; Var11[Var10]; Var10  Var12){
if (strchr(Var3,Var11[Var10])){
if (FUNC2(Var3,Var2->memberVar1,strlen(Var2->memberVar1))){
if (Var2->memberVar2){
if (*Var3 != =&&*Var3 !=  Var13&&FUNC2(Var3,STRING,2)){
char *Var14=FUNC3(Var2->memberVar3,Var3); 
if (!Var3||(*Var3 == |&&Var3[1]!= )){
if (!FUNC2(Var3,STRING,2)){
if (FUNC4(0)){
else 
}else if (!FUNC2(Var3,STRING,2)){
if (Var2->memberVar4){
Var6=Var5=malloc(strlen(Var3)+4096); 
if (!Var6){
if (Var2->memberVar5->memberVar1->memberVar1<1){
free(Var6); 
free(Var6); 
",369,0
after_cmd.c,r_core_cmd_lines,False,False,634,CWE-,CallExpression,strdup,4414,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', ""\t\t\t*nl = '\\0';\n"", '\t\t\tr = r_core_cmd (core, data, 0);\n', '\t\t\tif (r < 0) { //== -1) {\n', '\t\t\t\tdata = nl + 1;\n', ""\t\t\tif (data[0] == 'q') {\n"", '\t\t\t\tdata = nl + 1;\n', '\t\t\tdata = nl + 1;\n', ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tif (ret >= 0 && data && *data) {\n', '\t\tr_core_cmd (core, data, 0);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
*Var6=0; 
Var4=FUNC3(Var2,Var7,0); 
if (Var4<0){/Var10=-1){
Var7=Var6+1; 
if (Var7[0]==  Var11){
Var7=Var6+1; 
Var7=Var6+1; 
}while ((Var6=strchr(Var7,Var9))); 
if (Var5 >= 0&&Var7&&*Var7){
FUNC3(Var2,Var7,0); 
free(Var8); 
",269,0
after_cmd.c,r_core_cmd_lines,False,False,635,CWE-,CallExpression,strchr,4418,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', ""\t\t\t*nl = '\\0';\n"", '\t\t\tr = r_core_cmd (core, data, 0);\n', '\t\t\tif (r < 0) { //== -1) {\n', '\t\t\t\tdata = nl + 1;\n', ""\t\t\tif (data[0] == 'q') {\n"", '\t\t\t\tdata = nl + 1;\n', '\t\t\tdata = nl + 1;\n', ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tif (ret >= 0 && data && *data) {\n', '\t\tr_core_cmd (core, data, 0);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
*Var6=0; 
Var4=FUNC3(Var2,Var7,0); 
if (Var4<0){/Var10=-1){
Var7=Var6+1; 
if (Var7[0]==  Var11){
Var7=Var6+1; 
Var7=Var6+1; 
}while ((Var6=strchr(Var7,Var9))); 
if (Var5 >= 0&&Var7&&*Var7){
FUNC3(Var2,Var7,0); 
free(Var8); 
",269,0
after_cmd.c,r_core_cmd_lines,False,False,636,CWE-,CallExpression,free,4423,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', '\t\t\tif (r < 0) { //== -1) {\n', ""\t\t\tif (data[0] == 'q') {\n"", ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
if (Var4<0){/Var10=-1){
if (Var7[0]==  Var11){
}while ((Var6=strchr(Var7,Var9))); 
free(Var8); 
",186,0
after_cmd.c,r_core_cmd_lines,False,False,637,CWE-,CallExpression,strchr,4445,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', ""\t\t\t*nl = '\\0';\n"", '\t\t\tr = r_core_cmd (core, data, 0);\n', '\t\t\tif (r < 0) { //== -1) {\n', '\t\t\t\tdata = nl + 1;\n', ""\t\t\tif (data[0] == 'q') {\n"", '\t\t\t\tdata = nl + 1;\n', '\t\t\tdata = nl + 1;\n', ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tif (ret >= 0 && data && *data) {\n', '\t\tr_core_cmd (core, data, 0);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
*Var6=0; 
Var4=FUNC3(Var2,Var7,0); 
if (Var4<0){/Var10=-1){
Var7=Var6+1; 
if (Var7[0]==  Var11){
Var7=Var6+1; 
Var7=Var6+1; 
}while ((Var6=strchr(Var7,Var9))); 
if (Var5 >= 0&&Var7&&*Var7){
FUNC3(Var2,Var7,0); 
",255,0
after_cmd.c,r_core_cmd_lines,False,False,638,CWE-,CallExpression,free,4451,-3,"['R_API int r_core_cmd_lines(RCore *core, const char *lines) {\n', '\tint r, ret = true;\n', '\tchar *nl, *data, *odata;\n', '\tif (!lines || !*lines) {\n', '\tdata = odata = strdup (lines);\n', '\tif (!odata) {\n', ""\tnl = strchr (odata, '\\n');\n"", '\tif (nl) {\n', '\t\t\tif (r_cons_is_breaked ()) {\n', '\t\t\t\tfree (odata);\n', '\t\t\tif (r < 0) { //== -1) {\n', ""\t\t\tif (data[0] == 'q') {\n"", ""\t\t} while ((nl = strchr (data, '\\n')));\n"", '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
int  Var4,Var5=true ; 
char *Var6,*Var7,*Var8; 
if (!Var3||!*Var3){
Var7=Var8=strdup(Var3); 
if (!Var8){
Var6=strchr(Var8,Var9); 
if (Var6){
if (FUNC2()){
free(Var8); 
if (Var4<0){/Var10=-1){
if (Var7[0]==  Var11){
}while ((Var6=strchr(Var7,Var9))); 
free(Var8); 
",186,0
after_cmd.c,r_core_cmd_file,False,False,639,CWE-,CallExpression,free,4461,-3,"['R_API int r_core_cmd_file(RCore *core, const char *file) {\n', '\tchar *data = r_file_abspath (file);\n', '\tif (!data) {\n', '\tchar *odata = r_file_slurp (data, NULL);\n', '\tfree (data);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4=FUNC2(Var3); 
if (!Var4){
char *Var5=FUNC3(Var4,NULL ); 
free(Var4); 
",71,0
after_cmd.c,r_core_cmd_file,False,False,640,CWE-,CallExpression,free,4467,-3,"['R_API int r_core_cmd_file(RCore *core, const char *file) {\n', '\tchar *data = r_file_abspath (file);\n', '\tif (!data) {\n', '\tchar *odata = r_file_slurp (data, NULL);\n', '\tif (!odata) {\n', '\tif (!r_core_cmd_lines (core, odata)) {\n', '\t\tfree (odata);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4=FUNC2(Var3); 
if (!Var4){
char *Var5=FUNC3(Var4,NULL ); 
if (!Var5){
if (!FUNC4(Var2,Var5)){
free(Var5); 
free(Var5); 
",103,0
after_cmd.c,r_core_cmd_file,False,False,641,CWE-,CallExpression,free,4470,-3,"['R_API int r_core_cmd_file(RCore *core, const char *file) {\n', '\tchar *data = r_file_abspath (file);\n', '\tif (!data) {\n', '\tchar *odata = r_file_slurp (data, NULL);\n', '\tif (!odata) {\n', '\tif (!r_core_cmd_lines (core, odata)) {\n', '\t\tfree (odata);\n', '\tfree (odata);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4=FUNC2(Var3); 
if (!Var4){
char *Var5=FUNC3(Var4,NULL ); 
if (!Var5){
if (!FUNC4(Var2,Var5)){
free(Var5); 
free(Var5); 
",103,0
after_cmd.c,r_core_cmd_command,False,False,642,CWE-,CallExpression,free,4480,-3,"['R_API int r_core_cmd_command(RCore *core, const char *command) {\n', '\tchar *buf, *rcmd, *ptr;\n', '\tchar *cmd = r_core_sysenv_begin (core, command);\n', '\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n', '\tif (!buf) {\n', '\t\tfree (cmd);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6; 
char *Var7=FUNC2(Var2,Var3); 
Var5=Var6=Var4=FUNC3(Var7,0,&Var8); 
if (!Var4){
free(Var7); 
",95,0
after_cmd.c,r_core_cmd_command,False,False,643,CWE-,CallExpression,free,4485,-3,"['R_API int r_core_cmd_command(RCore *core, const char *command) {\n', '\tchar *buf, *rcmd, *ptr;\n', '\tchar *cmd = r_core_sysenv_begin (core, command);\n', '\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n', '\tif (!buf) {\n', '\tfree (buf);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6; 
char *Var7=FUNC2(Var2,Var3); 
Var5=Var6=Var4=FUNC3(Var7,0,&Var8); 
if (!Var4){
free(Var4); 
",95,0
after_cmd.c,r_core_disassemble_instr,False,False,644,CWE-,CallExpression,free,4495,-3,"['\tchar *cmd, *ret = NULL;\n', '\tif (cmd) {\n', '\t\tret = r_core_cmd_str (core, cmd);\n', '\t\tfree (cmd);\n']","char *Var1,*Var2=NULL ; 
if (Var1){
Var2=FUNC1(Var3,Var1); 
free(Var1); 
",42,0
after_cmd.c,r_core_disassemble_bytes,False,False,645,CWE-,CallExpression,free,4505,-3,"['\tchar *cmd, *ret = NULL;\n', '\tif (cmd) {\n', '\t\tret = r_core_cmd_str (core, cmd);\n', '\t\tfree (cmd);\n']","char *Var1,*Var2=NULL ; 
if (Var1){
Var2=FUNC1(Var3,Var1); 
free(Var1); 
",42,0
after_cmd.c,r_core_cmd_buffer,False,False,646,CWE-,CallExpression,strdup,4511,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\t*ptr = '\\0';\n"", '\t\tr_core_cmd (core, optr, 0);\n', '\t\toptr = ptr + 1;\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tr_core_cmd (core, optr, 0);\n', '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
*Var4=0; 
FUNC2(Var2,Var5,0); 
Var5=Var4+1; 
Var4=strchr(Var6,Var7); 
FUNC2(Var2,Var5,0); 
free(Var6); 
",144,0
after_cmd.c,r_core_cmd_buffer,False,False,647,CWE-,CallExpression,strchr,4516,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\t*ptr = '\\0';\n"", '\t\tr_core_cmd (core, optr, 0);\n', '\t\toptr = ptr + 1;\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tr_core_cmd (core, optr, 0);\n', '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
*Var4=0; 
FUNC2(Var2,Var5,0); 
Var5=Var4+1; 
Var4=strchr(Var6,Var7); 
FUNC2(Var2,Var5,0); 
free(Var6); 
",144,0
after_cmd.c,r_core_cmd_buffer,False,False,648,CWE-,CallExpression,strchr,4521,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\t*ptr = '\\0';\n"", '\t\tr_core_cmd (core, optr, 0);\n', '\t\toptr = ptr + 1;\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tr_core_cmd (core, optr, 0);\n', '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
*Var4=0; 
FUNC2(Var2,Var5,0); 
Var5=Var4+1; 
Var4=strchr(Var6,Var7); 
FUNC2(Var2,Var5,0); 
free(Var6); 
",144,0
after_cmd.c,r_core_cmd_buffer,False,False,649,CWE-,CallExpression,free,4524,-3,"['R_API int r_core_cmd_buffer(RCore *core, const char *buf) {\n', '\tchar *ptr, *optr, *str = strdup (buf);\n', '\tif (!str) {\n', '\toptr = str;\n', ""\tptr = strchr (str, '\\n');\n"", '\twhile (ptr) {\n', ""\t\tptr = strchr (str, '\\n');\n"", '\tfree (str);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3){
char *Var4,*Var5,*Var6=strdup(Var3); 
if (!Var6){
Var5=Var6; 
Var4=strchr(Var6,Var7); 
while (Var4){
Var4=strchr(Var6,Var7); 
free(Var6); 
",102,0
after_cmd.c,r_core_cmdf,False,False,650,CWE-,CallExpression,vsnprintf,4533,-3,"['R_API int r_core_cmdf(RCore *core, const char *fmt, ...) {\n', '\tchar string[4096];\n', '\tint ret;\n', '\tva_list ap;\n', '\tva_start (ap, fmt);\n', '\tvsnprintf (string, sizeof (string), fmt, ap);\n', '\tret = r_core_cmd (core, string, 0);\n', '\tva_end (ap);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,...){
char  Var4[4096]; 
int  Var5; 
STRUCT2  Var6; 
FUNC2(Var6,Var3); 
vsnprintf(Var4,sizeof (Var4),Var3,Var6); 
Var5=FUNC3(Var2,Var4,0); 
FUNC4(Var6); 
",106,0
after_cmd.c,r_core_cmd_str_pipe,False,False,651,CWE-,CallExpression,strchr,4552,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\treturn r_core_cmd_str (core, cmd);\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\treturn NULL;\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
return FUNC3(Var1,Var2); 
if (FUNC6(STRING,&Var4) != -1){
int  Var11=FUNC7(Var4,1,0); 
if (Var11 == -1){
return FUNC3(Var1,Var2); 
char *Var12=strdup(Var2); 
Var3=FUNC8(Var4,NULL ); 
if (Var3){
return FUNC3(Var1,Var2); 
return NULL ; 
",328,0
after_cmd.c,r_core_cmd_str_pipe,False,False,652,CWE-,CallExpression,strdup,4557,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\t\t\t\tfree (res);\n', '\t\t\t\treturn hres;\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\treturn ret;\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\treturn r_core_cmd_str (core, cmd);\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tif (s) {\n', '\t\treturn r_core_cmd_str (core, cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
free(Var6); 
char *Var8=FUNC4(Var7,NULL ); 
free(Var7); 
return  Var8; 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
free(Var6); 
return  Var10; 
return FUNC3(Var1,Var2); 
if (FUNC6(STRING,&Var4) != -1){
int  Var11=FUNC7(Var4,1,0); 
if (Var11 == -1){
return FUNC3(Var1,Var2); 
char *Var12=strdup(Var2); 
if (Var3){
return FUNC3(Var1,Var2); 
",341,0
after_cmd.c,r_core_cmd_str_pipe,False,False,653,CWE-,CallExpression,strcmp,4559,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
char *Var9=FUNC3(Var1,Var6); 
int  Var10=FUNC5(Var4,1,0); 
char *Var11=strdup(Var2); 
",208,0
after_cmd.c,r_core_cmd_str_pipe,False,False,654,CWE-,CallExpression,free,4561,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
if (FUNC2(0)){
char *Var3=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var3){
char *Var4=strdup(Var2); 
Var4[Var3-Var2]=0; 
if (!strcmp(Var3+1,STRING)){
char *Var5=FUNC3(Var1,Var4); 
free(Var4); 
char *Var6=FUNC4(Var5,NULL ); 
else 
int  Var7=FUNC5(Var1->memberVar1,STRING); 
char *Var8=FUNC3(Var1,Var4); 
free(Var4); 
char *Var9=strdup(Var2); 
",211,0
after_cmd.c,r_core_cmd_str_pipe,False,False,655,CWE-,CallExpression,free,4563,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\t\t\t\tfree (res);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
if (!strcmp(Var5+1,STRING)){
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
free(Var7); 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
char *Var11=strdup(Var2); 
",205,0
after_cmd.c,r_core_cmd_str_pipe,False,False,656,CWE-,CallExpression,free,4570,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\tif (!strcmp (p + 1, ""H"")) {\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\t\t\tfree (c);\n', '\t\tchar *_cmd = strdup (cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
if (FUNC2(0)){
char *Var3=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var3){
char *Var4=strdup(Var2); 
Var4[Var3-Var2]=0; 
if (!strcmp(Var3+1,STRING)){
char *Var5=FUNC3(Var1,Var4); 
free(Var4); 
char *Var6=FUNC4(Var5,NULL ); 
else 
int  Var7=FUNC5(Var1->memberVar1,STRING); 
char *Var8=FUNC3(Var1,Var4); 
free(Var4); 
char *Var9=strdup(Var2); 
",211,0
after_cmd.c,r_core_cmd_str_pipe,False,False,657,CWE-,CallExpression,free,4583,-3,"['\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\teprintf (""slurp %s fails\\n"", tmp);\n', '\t\tr_file_rm (tmp);\n', '\t\tfree (tmp);\n']","char *Var1,*Var2=NULL ; 
if (FUNC1(0)){
char *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; 
char *Var4=FUNC2(Var5,NULL ); 
if (FUNC3(STRING,&Var2) != -1){
int  Var6=FUNC4(Var2,1,0); 
if (Var6 == -1){
FUNC5(Var2); 
free(Var2); 
Var1=FUNC6(Var2,NULL ); 
if (Var1){
FUNC5(Var2); 
free(Var2); 
FUNC7(STRING,Var2); 
FUNC5(Var2); 
free(Var2); 
",195,0
after_cmd.c,r_core_cmd_str_pipe,False,False,658,CWE-,CallExpression,strdup,4586,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\tif (p) {\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\tc[p - cmd] = 0;\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\t\treturn r_core_cmd_str (core, cmd);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\treturn r_core_cmd_str (core, cmd);\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tr_core_cmd_subst (core, _cmd);\n', '\t\tif (s) {\n', '\t\t\tfree (_cmd);\n', '\t\tfree (_cmd);\n', '\t\treturn r_core_cmd_str (core, cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
if (Var5){
char *Var6=strdup(Var2); 
Var6[Var5-Var2]=0; 
char *Var7=FUNC3(Var1,Var6); 
char *Var8=FUNC4(Var7,NULL ); 
else 
int  Var9=FUNC5(Var1->memberVar1,STRING); 
char *Var10=FUNC3(Var1,Var6); 
return FUNC3(Var1,Var2); 
if (FUNC6(STRING,&Var4) != -1){
int  Var11=FUNC7(Var4,1,0); 
if (Var11 == -1){
return FUNC3(Var1,Var2); 
char *Var12=strdup(Var2); 
FUNC8(Var1,Var12); 
if (Var3){
free(Var12); 
free(Var12); 
return FUNC3(Var1,Var2); 
",317,0
after_cmd.c,r_core_cmd_str_pipe,False,False,659,CWE-,CallExpression,free,4594,-3,"['\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\teprintf (""slurp %s fails\\n"", tmp);\n', '\t\tr_file_rm (tmp);\n', '\t\tfree (tmp);\n']","char *Var1,*Var2=NULL ; 
if (FUNC1(0)){
char *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; 
char *Var4=FUNC2(Var5,NULL ); 
if (FUNC3(STRING,&Var2) != -1){
int  Var6=FUNC4(Var2,1,0); 
if (Var6 == -1){
FUNC5(Var2); 
free(Var2); 
Var1=FUNC6(Var2,NULL ); 
if (Var1){
FUNC5(Var2); 
free(Var2); 
FUNC7(STRING,Var2); 
FUNC5(Var2); 
free(Var2); 
",195,0
after_cmd.c,r_core_cmd_str_pipe,False,False,660,CWE-,CallExpression,free,4595,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tr_core_cmd_subst (core, _cmd);\n', '\t\tif (s) {\n', '\t\t\tfree (_cmd);\n', '\t\tfree (_cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
char *Var6=strdup(Var2); 
char *Var7=FUNC3(Var1,Var6); 
else 
int  Var8=FUNC4(Var1->memberVar1,STRING); 
char *Var9=FUNC3(Var1,Var6); 
if (FUNC5(STRING,&Var4) != -1){
int  Var10=FUNC6(Var4,1,0); 
if (Var10 == -1){
char *Var11=strdup(Var2); 
FUNC7(Var1,Var11); 
if (Var3){
free(Var11); 
free(Var11); 
",240,0
after_cmd.c,r_core_cmd_str_pipe,False,False,661,CWE-,CallExpression,free,4600,-3,"['\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\t\tchar *hres = r_cons_html_filter (res, NULL);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\ts = r_file_slurp (tmp, NULL);\n', '\t\tif (s) {\n', '\t\t\tr_file_rm (tmp);\n', '\t\t\tfree (tmp);\n', '\t\teprintf (""slurp %s fails\\n"", tmp);\n', '\t\tr_file_rm (tmp);\n', '\t\tfree (tmp);\n']","char *Var1,*Var2=NULL ; 
if (FUNC1(0)){
char *Var3=(*STRUCT1 != ) strchr(STRUCT1,|) NULL ; 
char *Var4=FUNC2(Var5,NULL ); 
if (FUNC3(STRING,&Var2) != -1){
int  Var6=FUNC4(Var2,1,0); 
if (Var6 == -1){
FUNC5(Var2); 
free(Var2); 
Var1=FUNC6(Var2,NULL ); 
if (Var1){
FUNC5(Var2); 
free(Var2); 
FUNC7(STRING,Var2); 
FUNC5(Var2); 
free(Var2); 
",195,0
after_cmd.c,r_core_cmd_str_pipe,False,False,662,CWE-,CallExpression,free,4601,-3,"['R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n', '\tchar *s, *tmp = NULL;\n', '\tif (r_sandbox_enable (0)) {\n', '\t\tchar *p = (*cmd != \'""\')? strchr (cmd, \'|\'): NULL;\n', '\t\t\tchar *c = strdup (cmd);\n', '\t\t\t\tchar *res = r_core_cmd_str (core, c);\n', 'else\n', '\t\t\t\tint sh = r_config_get_i (core->config, ""scr.color"");\n', '\t\t\t\tchar *ret = r_core_cmd_str (core, c);\n', '\tif (r_file_mkstemp (""cmd"", &tmp) != -1) {\n', '\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n', '\t\tif (pipefd == -1) {\n', '\t\tchar *_cmd = strdup (cmd);\n', '\t\tr_core_cmd_subst (core, _cmd);\n', '\t\tif (s) {\n', '\t\t\tfree (_cmd);\n', '\t\tfree (_cmd);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2){
char *Var3,*Var4=NULL ; 
if (FUNC2(0)){
char *Var5=(*Var2 != ) strchr(Var2,|) NULL ; 
char *Var6=strdup(Var2); 
char *Var7=FUNC3(Var1,Var6); 
else 
int  Var8=FUNC4(Var1->memberVar1,STRING); 
char *Var9=FUNC3(Var1,Var6); 
if (FUNC5(STRING,&Var4) != -1){
int  Var10=FUNC6(Var4,1,0); 
if (Var10 == -1){
char *Var11=strdup(Var2); 
FUNC7(Var1,Var11); 
if (Var3){
free(Var11); 
free(Var11); 
",240,0
after_cmd.c,r_core_cmd_strf,False,False,663,CWE-,CallExpression,vsnprintf,4614,-3,"['R_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n', '\tchar string[4096];\n', '\tchar *ret;\n', '\tva_list ap;\n', '\tva_start (ap, fmt);\n', '\tvsnprintf (string, sizeof (string), fmt, ap);\n', '\tret = r_core_cmd_str (core, string);\n', '\tva_end (ap);\n']","STRUCT1 char *FUNC1(STRUCT2 *Var1,const char *Var2,...){
char  Var3[4096]; 
char *Var4; 
STRUCT3  Var5; 
FUNC2(Var5,Var2); 
vsnprintf(Var3,sizeof (Var3),Var2,Var5); 
Var4=FUNC3(Var1,Var3); 
FUNC4(Var5); 
",106,0
after_cmd.c,r_core_cmd_str,False,False,664,CWE-,CallExpression,strdup,4631,-3,"['\tconst char *static_str;\n', '\tchar *retstr = NULL;\n', '\tif (r_core_cmd (core, cmd, 0) == -1) {\n', '\tstatic_str = r_cons_get_buffer ();\n', '\tretstr = strdup (static_str? static_str: """");\n', '\treturn retstr;\n']","const char *Var1; 
char *Var2=NULL ; 
if (FUNC1(Var3,Var4,0) == -1){
Var1=FUNC2(); 
Var2=strdup(Var1  Var1 STRING); 
return  Var2; 
",70,0
after_cmd.c,r_core_cmd_task_sync,False,False,665,CWE-,CallExpression,strdup,4684,-3,"['R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n', '\tRCoreTask *task = core->main_task;\n', '\tchar *s = strdup (cmd);\n', '\tif (!s) {\n', '\ttask->cmd = s;\n', '\tint res = r_core_task_run_sync (core, task);\n', '\tfree (s);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){
STRUCT2 *Var5=Var2->memberVar1; 
char *Var6=strdup(Var3); 
if (!Var6){
Var5->memberVar1=Var6; 
int  Var7=FUNC2(Var2,Var5); 
free(Var6); 
",98,0
after_cmd.c,r_core_cmd_task_sync,False,False,666,CWE-,CallExpression,free,4692,-3,"['R_API int r_core_cmd_task_sync(RCore *core, const char *cmd, bool log) {\n', '\tRCoreTask *task = core->main_task;\n', '\tchar *s = strdup (cmd);\n', '\tif (!s) {\n', '\ttask->cmd = s;\n', '\tint res = r_core_task_run_sync (core, task);\n', '\tfree (s);\n']","Var1 int FUNC1(STRUCT1 *Var2,const char *Var3,bool  Var4){
STRUCT2 *Var5=Var2->memberVar1; 
char *Var6=strdup(Var3); 
if (!Var6){
Var5->memberVar1=Var6; 
int  Var7=FUNC2(Var2,Var5); 
free(Var6); 
",98,0
after_cmd.c,compare_cmd_descriptor_name,False,False,667,CWE-,CallExpression,strcmp,4701,-3,"['static int compare_cmd_descriptor_name(const void *a, const void *b) {\n', '\treturn strcmp (((RCmdDescriptor *)a)->cmd, ((RCmdDescriptor *)b)->cmd);\n']","static int FUNC1(const void *Var1,const void *Var2){
return strcmp(((STRUCT1 *) Var1)->memberVar1,((STRUCT1 *) Var2)->memberVar1); 
",60,0
