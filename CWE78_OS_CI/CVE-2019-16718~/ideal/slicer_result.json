[
  {
    "FileName": "sandbox.c",
    "Caller": "r_sandbox_system",
    "Source": false,
    "Sink": false,
    "idx": 0,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "system",
    "line": 361,
    "label": -3,
	"slices": [
		"static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {",
		"    RBinInfo *info = r_bin_get_info (r->bin);",
		"    RList *entries = r_bin_get_entries (r->bin);",
		"    RBinSymbol *symbol;",
		"    RBinAddr *entry;",
		"    RListIter *iter;",
		"    bool firstexp = true;",
		"    bool printHere = false;",
		"    int i = 0, lastfs = 's';",
		"    bool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");",
		"    if (!info) {",
		"        return 0;",
		"    }",
		"    if (args && *args == '.') {",
		"        printHere = true;",
		"    }",
		"    bool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);",
		"    const char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;",
		"    RList *symbols = r_bin_get_symbols (r->bin);",
		"    size_t count = 0;",
		"    r_list_foreach (symbols, iter, symbol) {",
		"        if (!symbol->name) {",
		"            continue;",
		"        }",
		"        char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);",
		"    const char *name = sn.demname? sn.demname: r_symbol_name;",
		"    if (!name) {",
		"        goto next;",
		"    }",
		"    if (!strncmp (name, \"imp.\", 4)) {",
		"        if (lastfs != 'i') {",
		"            r_cons_printf (\"fs imports\\n\");",
		"        }",
		"        lastfs = 'i';",
		"    } else {",
		"        if (lastfs != 's') {",
		"            const char *fs = exponly? \"exports\": \"symbols\";",
		"            r_cons_printf (\"fs %s\\n\", fs);",
		"        }",
		"        lastfs = 's';",
		"    }",
		"    if (r->bin->prefix || *name) {",
		"        char *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);",
		"        if (!flagname) {",
		"            goto next;",
		"        }",
		"        r_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",",
		"            r->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",",
		"            flagname, symbol->size, addr);",
		"R_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {",
		"    int ret = true;",
		"    const char *name = NULL;",
		"    ut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);",
		"    va = va ? VA_TRUE : VA_FALSE;",
		"    if ((action & R_CORE_BIN_ACC_EXPORTS)) {",
		"        ret &= bin_symbols (core, mode, loadaddr, va, at, name, true, chksum);",
		"    }",
		"    if ((action & R_CORE_BIN_ACC_SYMBOLS)) {",
		"        ret &= bin_symbols (core, mode, loadaddr, va, at, name, false, chksum);",
		"static int cmd_info(void *data, const char *input) {",
		"    RCore *core = (RCore *) data;",
		"    bool newline = r_cons_is_interactive ();",
		"    int fd = r_io_fd_get_current (core->io);",
		"    RIODesc *desc = r_io_desc_get (core->io, fd);",
		"    int i, va = core->io->va || core->io->debug;",
		"    int mode = 0;",
		"    bool rdump = false;",
		"    int is_array = 0;",
		"    Sdb *db;",
		"    for (i = 0; input[i] && input[i] != ' '; i++)",
		"        ;",
		"    if (i > 0) {",
		"        switch (input[i - 1]) {",
		"        case '*': mode = R_MODE_RADARE; break;",
		"        case 'j': mode = R_MODE_JSON; break;",
		"        case 'q': mode = R_MODE_SIMPLE; break;",
		"        }",
		"    }",
		"    if (mode == R_MODE_JSON) {",
		"        int suffix_shift = 0;",
		"        if (!strncmp (input, \"SS\", 2) || !strncmp (input, \"ee\", 2)",
		"            || !strncmp (input, \"zz\", 2)) {",
		"            suffix_shift = 1;",
		"        }",
		"        if (strlen (input + 1 + suffix_shift) > 1) {",
		"            is_array = 1;",
		"        }",
		"    }",
		"    if (is_array) {",
		"        r_cons_printf (\"{\");",
		"    }",
		"    if (!*input) {",
		"        cmd_info_bin (core, va, mode);",
		"    }",
		"    if (!strcmp (input, \"*\")) {",
		"        input = \"I*\";",
		"    }",
		"    char *question = strchr (input, '?');",
		"    const char *space = strchr (input, ' ');",
		"    if (!space) {",
		"        space = question + 1;",
		"    }",
		"    if (question < space && question > input) {",
		"    while (*input) {",
		"        switch (*input) {",
		"        case 's': {",
		"            RBinObject *obj = r_bin_cur_object (core->bin);",
		"            if (input[1] == 'j' && input[2] == '.') {",
		"                mode = R_MODE_JSON;",
		"                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 2, (obj && obj->symbols)? r_list_length (obj->symbols): 0);",
		"            } else if (input[1] == 'q' && input[2] == 'q') {",
		"                mode = R_MODE_SIMPLEST;",
		"                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);",
		"            } else if (input[1] == 'q' && input[2] == '.') {",
		"                mode = R_MODE_SIMPLE;",
		"                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 2, 0);",
		"            } else {",
		"                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);",
		"R_API void r_core_cmd_init(RCore *core) {",
		"    struct {",
		"        const char *cmd;",
		"        const char *description;",
		"        int (*callback)(void *data, const char *input)",
		"        int (*cb)(void *data, const char *input)",
		"    } cmds[] = {",
		"        {\"info\",     \"get file info\", cmd_info, cmd_info_init},",
		"    for (i = 0; i < R_ARRAY_SIZE (cmds); i++) {",
		"        r_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);",
		"R_API int r_cmd_call(RCmd *cmd, const char *input) {",
		"    struct r_cmd_item_t *c;",
		"    int ret = -1;",
		"    RListIter *iter;",
		"    RCorePlugin *cp;",
		"    r_return_val_if_fail (cmd && input, -1);",
		"    if (!*input) {",
		"    } else {",
		"        char *nstr = NULL;",
		"        const char *ji = r_cmd_alias_get (cmd, input, 1);",
		"        if (ji) {",
		"        }",
		"        r_list_foreach (cmd->plist, iter, cp) {",
		"        }",
		"        if (!*input) {",
		"        }",
		"        c = cmd->cmds[((ut8)input[0]) & 0xff];",
		"        if (c && c->callback) {",
		"            const char *inp = (*input)? input + 1: \"\";",
		"            ret = c->callback (cmd->data, inp);",
		"static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {",
		"    RList *tmpenvs = r_list_newf (tmpenvs_free);",
		"    const char *quotestr = \"`\";",
		"    const char *tick = NULL;",
		"    char *ptr, *ptr2, *str;",
		"    char *arroba = NULL;",
		"    char *grep = NULL;",
		"    RIODesc *tmpdesc = NULL;",
		"    int pamode = !core->io->va;",
		"    int i, ret = 0, pipefd;",
		"    bool usemyblock = false;",
		"    int scr_html = -1;",
		"    int scr_color = -1;",
		"    bool eos = false;",
		"    bool haveQuote = false;",
		"    bool oldfixedarch = core->fixedarch;",
		"    bool oldfixedbits = core->fixedbits;",
		"    bool cmd_tmpseek = false;",
		"    ut64 tmpbsz = core->blocksize;",
		"    int cmd_ignbithints = -1;",
		"    if (!cmd) {",
		"        r_list_free (tmpenvs);",
		"        return 0;",
		"    }",
		"    cmd = r_str_trim_head_tail (cmd);",
		"fuji:",
		"    rc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;",
		"static int r_core_cmd_subst(RCore *core, char *cmd) {",
		"    ut64 rep = strtoull (cmd, NULL, 10);",
		"    int ret = 0, orep;",
		"    char *cmt, *colon = NULL, *icmd = NULL;",
		"    bool tmpseek = false;",
		"    bool original_tmpseek = core->tmpseek;",

		"    if (r_str_startswith (cmd, \"GET /cmd/\")) {",
		"        memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);",
		"        char *http = strstr (cmd, \"HTTP\");",
		"        if (http) {",
		"            *http = 0;",
		"            http--;",
		"            if (*http == ' ') {",
		"                *http = 0;",
		"            }",
		"        }",
		"        r_cons_printf (\"HTTP/1.0 %d %s\\r\\n%s\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",200, \"OK\", \"\", -1);",
		"        return r_core_cmd0 (core, cmd);",
		"    }",

		"    ut64 orig_offset = core->offset;",
		"    icmd = strdup (cmd);",

		"    if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {",
		"        core->prompt_offset = core->offset;",
		"    }",
		"    cmd = r_str_trim_head_tail (icmd);",
		"    if (*cmd != '\"') {",
		"    } else {",
		"        colon = NULL;",
		"    }",
		"    if (rep > 0) {",
		"        while (IS_DIGIT (*cmd)) {",
		"            cmd++;",
		"        }",
		"        if (!*cmd) {",
		"    }",
		"    if (rep < 1) {",
		"        rep = 1;",
		"    }",
		"    const char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";",
		"    orep = rep;",

		"    r_cons_break_push (NULL, NULL);",

		"    int ocur_enabled = core->print && core->print->cur_enabled;",
		"    while (rep-- && *cmd) {",
		"        if (core->print) {",
		"            core->print->cur_enabled = false;",
		"            if (ocur_enabled && core->seltab >= 0) {",
		"                if (core->seltab == core->curtab) {",
		"                    core->print->cur_enabled = true;",
		"                }",
		"            }",
		"        }",
		"        if (r_cons_is_breaked ()) {",
		"        char *cr = strdup (cmdrep);",
		"        core->break_loop = false;",
		"        ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);",

		"R_API int r_core_cmd(RCore *core, const char *cstr, int log) {",
		"    char *cmd, *ocmd, *ptr, *rcmd;",
		"    int ret = false, i;",

		"    if (core->cmdfilter) {",
		"        const char *invalid_chars = \";|>`@\";",
		"        for (i = 0; invalid_chars[i]; i++) {",
		"            if (strchr (cstr, invalid_chars[i])) {",
		"        }",
		"        if (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {",
		"    }",
		"    if (core->cmdremote) {",
		"        if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {",
		"    }",

		"    if (!cstr || (*cstr == '|' && cstr[1] != '?')) {",
		"    if (!strncmp (cstr, \"/*\", 2)) {",
		"        if (r_sandbox_enable (0)) {",
		"        core->incomment = true;",
		"    } else if (!strncmp (cstr, \"*/\", 2)) {",
		"    if (core->incomment) {",
		"    if (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {",
		"        free (core->lastcmd);",
		"        core->lastcmd = strdup (cstr);",
		"    }",

		"    ocmd = cmd = malloc (strlen (cstr) + 4096);",
		"    if (!ocmd) {",
		"    r_str_cpy (cmd, cstr);",
		"    if (log) {",
		"        r_line_hist_add (cstr);",
		"    }",

		"    if (core->cons->context->cmd_depth < 1) {",
		"    core->cons->context->cmd_depth--;",
		"    for (rcmd = cmd;;) {",
		"        ptr = strchr (rcmd, '\\n');",
		"        if (ptr) {",
		"            *ptr = '\\0';",
		"        }",
		"        ret = r_core_cmd_subst (core, rcmd);",

		"R_API char *r_core_cmd_str(RCore *core, const char *cmd) {",
		"    const char *static_str;",
		"    char *retstr = NULL;",
		"    r_cons_push ();",
		"    if (r_core_cmd (core, cmd, 0) == -1) {",

		"static int cmd_interpret(void *data, const char *input) {",
		"    char *str, *ptr, *eol, *rbuf, *filter, *inp;",
		"    const char *host, *port, *cmd;",
		"    RCore *core = (RCore *)data;",

		"    switch (*input) {",
		"    default:",
		"        if (*input >= 0 && *input <= 9) {",
		"            eprintf (\"|ERROR| No .[0..9] to avoid infinite loops\\n\");",
		"            break;",
		"        }",
		"        inp = strdup (input);",
		"        filter = strchr (inp, '~');",
		"        if (filter) {",
		"        int tmp_html = r_cons_singleton ()->is_html;",
		"        r_cons_singleton ()->is_html = 0;",
		"        ptr = str = r_core_cmd_str (core, inp);",

		"        r_cons_singleton ()->is_html = tmp_html;",

		"        if (filter) {",
		"        r_cons_break_push (NULL, NULL);",
		"        if (ptr) {",
		"            for (;;) {",
		"                if (r_cons_is_breaked ()) {",
		"                    break;",
		"                }",
		"                eol = strchr (ptr, '\\n');",
		"                if (eol) {",
		"                    *eol = '\\0';",
		"                }",
		"                if (*ptr) {",
		"                    char *p = r_str_append (strdup (ptr), filter); ",
		"                    r_core_cmd0 (core, p);",

		"R_API int r_core_cmd0(RCore *core, const char *cmd) {",
		"    return r_core_cmd (core, cmd, 0);",

		"R_API int r_core_cmd(RCore *core, const char *cstr, int log) {",
		"    char *cmd, *ocmd, *ptr, *rcmd;",
		"    int ret = false, i;",

		"    if (core->cmdfilter) {",
		"        const char *invalid_chars = \";|>`@\";",
		"        for (i = 0; invalid_chars[i]; i++) {",
		"            if (strchr (cstr, invalid_chars[i])) {",
		"        }",
		"        if (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {",
		"    }",
		"    if (core->cmdremote) {",
		"        if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {",
		"    }",

		"    if (!cstr || (*cstr == '|' && cstr[1] != '?')) {",
		"    if (!strncmp (cstr, \"/*\", 2)) {",
		"        if (r_sandbox_enable (0)) {",
		"        }",
		"        core->incomment = true;",
		"    } else if (!strncmp (cstr, \"*/\", 2)) {",
		"    }",
		"    if (core->incomment) {",
		"    }",
		"    if (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {",
		"        free (core->lastcmd);",
		"        core->lastcmd = strdup (cstr);",
		"    }",

		"    ocmd = cmd = malloc (strlen (cstr) + 4096);",
		"    if (!ocmd) {",
		"    r_str_cpy (cmd, cstr);",
		"    if (log) {",

		"    if (core->cons->context->cmd_depth < 1) {",
		"    core->cons->context->cmd_depth--;",
		"    for (rcmd = cmd;;) {",
		"        ptr = strchr (rcmd, '\\n'); ",
		"        if (ptr) {",
		"            *ptr = '\\0';",
		"        }",
		"        ret = r_core_cmd_subst (core, rcmd);",

		"static int r_core_cmd_subst(RCore *core, char *cmd) {",
		"    ut64 rep = strtoull (cmd, NULL, 10);",
		"    int ret = 0, orep;",
		"    char *cmt, *colon = NULL, *icmd = NULL;",
		"    bool tmpseek = false;",
		"    bool original_tmpseek = core->tmpseek;",

		"    if (r_str_startswith (cmd, \"GET /cmd/\")) {",
		"        memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);",
		"        char *http = strstr (cmd, \"HTTP\");",
		"        if (http) {",
		"            *http = 0;",
		"            http--;",
		"            if (*http == ' ') {",
		"                *http = 0;",
		"            }",
		"        }",
		"        r_cons_printf (\"HTTP/1.0 %d %s\\r\\n%s\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",200, \"OK\", \"\", -1);",
		"        return r_core_cmd0 (core, cmd);",
		"    }",

		"    ut64 orig_offset = core->offset;",
		"    icmd = strdup (cmd);",

		"    if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {",
		"        core->prompt_offset = core->offset;",
		"    }",
		"    cmd = r_str_trim_head_tail (icmd);",
		"    if (*cmd != '\"') {",
		"    } else {",
		"        colon = NULL;",
		"    }",
		"    if (rep > 0) {",
		"        while (IS_DIGIT (*cmd)) {",
		"            cmd++;",
		"        }",
		"        if (!*cmd) {",
		"    }",
		"    if (rep < 1) {",
		"        rep = 1;",
		"    }",
		"    const char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";",
		"    orep = rep;",

		"    r_cons_break_push (NULL, NULL);",

		"    int ocur_enabled = core->print && core->print->cur_enabled;",
		"    while (rep-- && *cmd) {",
		"        if (core->print) {",
		"            core->print->cur_enabled = false;",
		"            if (ocur_enabled && core->seltab >= 0) {",
		"                if (core->seltab == core->curtab) {",
		"                    core->print->cur_enabled = true;",
		"                }",
		"            }",
		"        }",
		"        if (r_cons_is_breaked ()) {",
		"        char *cr = strdup (cmdrep);",
		"        core->break_loop = false;",
		"        ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);",

		"static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {",
		"    RList *tmpenvs = r_list_newf (tmpenvs_free);",
		"    const char *quotestr = \"`\";",
		"    const char *tick = NULL;",
		"    char *ptr, *ptr2, *str;",
		"    char *arroba = NULL;",
		"    char *grep = NULL;",
		"    RIODesc *tmpdesc = NULL;",
		"    int pamode = !core->io->va;",
		"    int i, ret = 0, pipefd;",
		"    bool usemyblock = false;",
		"    int scr_html = -1;",
		"    int scr_color = -1;",
		"    bool eos = false;",
		"    bool haveQuote = false;",
		"    bool oldfixedarch = core->fixedarch;",
		"    bool oldfixedbits = core->fixedbits;",
		"    bool cmd_tmpseek = false;",
		"    ut64 tmpbsz = core->blocksize;",
		"    int cmd_ignbithints = -1;",

		"    if (!cmd) {",
		"        r_list_free (tmpenvs);",
		"        return 0;",
		"    }",
		"    cmd = r_str_trim_head_tail (cmd);",
		"escape_redir:",
		"next2:",
		"    ptr = strchr (cmd, '`');",
		"    if (ptr) {",
		"        if (ptr > cmd) {",
		"        bool empty = false;",
		"        int oneline = 1;",
		"        if (ptr[1] == '`') {",
		"        ptr2 = strchr (ptr + 1, '`');",
		"        if (empty) {",
		"        } else if (!ptr2) {",
		"        } else {",
		"            int value = core->num->value;",
		"            *ptr = '\\0';",
		"            *ptr2 = '\\0';",
		"            if (ptr[1] == '!') { ",
		"                str = r_core_cmd_str_pipe (core, ptr + 1);",
		"static char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {",
		"    char *s, *tmp = NULL;",
		"    if (r_sandbox_enable (0)) {",
		"        char *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;",
		"        if (p) {",
		"        }",
		"        return r_core_cmd_str (core, cmd);",
		"    }",
		"    r_cons_reset ();",
		"    r_sandbox_disable (1);",
		"    if (r_file_mkstemp (\"cmd\", &tmp) != -1) {",
		"        int pipefd = r_cons_pipe_open (tmp, 1, 0);",
		"        if (pipefd == -1) {",
		"        char *_cmd = strdup (cmd);",
		"        r_core_cmd_subst (core, _cmd);",

		"static int r_core_cmd_subst(RCore *core, char *cmd) {",
		"    ut64 rep = strtoull (cmd, NULL, 10);",
		"    int ret = 0, orep;",
		"    char *cmt, *colon = NULL, *icmd = NULL;",
		"    bool tmpseek = false;",
		"    bool original_tmpseek = core->tmpseek;",

		"    if (r_str_startswith (cmd, \"GET /cmd/\")) {",
		"        memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);",
		"        char *http = strstr (cmd, \"HTTP\");",
		"        if (http) {",
		"            *http = 0;",
		"            http--;",
		"            if (*http == ' ') {",
		"                *http = 0;",
		"            }",
		"        }",
		"        r_cons_printf (\"HTTP/1.0 %d %s\\r\\n%s\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",200, \"OK\", \"\", -1);",
		"        return r_core_cmd0 (core, cmd);",
		"    }",

		"    ut64 orig_offset = core->offset;",
		"    icmd = strdup (cmd);",

		"    if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {",
		"        core->prompt_offset = core->offset;",
		"    }",
		"    cmd = r_str_trim_head_tail (icmd);",
		"    if (*cmd != '\"') {",
		"    } else {",
		"        colon = NULL;",
		"    }",
		"    if (rep > 0) {",
		"        while (IS_DIGIT (*cmd)) {",
		"            cmd++;",
		"        }",
		"        if (!*cmd) {",
		"    }",
		"    if (rep < 1) {",
		"        rep = 1;",
		"    }",
		"    if (rep > 1 && r_sandbox_enable (0)) {",
		"    } else {",
		"    }",
		"    const char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";",
		"    orep = rep;",

		"    r_cons_break_push (NULL, NULL);",

		"    int ocur_enabled = core->print && core->print->cur_enabled;",
		"    while (rep-- && *cmd) {",
		"        if (core->print) {",
		"            core->print->cur_enabled = false;",
		"            if (ocur_enabled && core->seltab >= 0) {",
		"                if (core->seltab == core->curtab) {",
		"                    core->print->cur_enabled = true;",
		"                }",
		"            }",
		"        }",
		"        if (r_cons_is_breaked ()) {",
		"        char *cr = strdup (cmdrep);",
		"        core->break_loop = false;",
		"        ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);",

		"static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {",
		"    RList *tmpenvs = r_list_newf (tmpenvs_free);",
		"    const char *quotestr = \"`\";",
		"    const char *tick = NULL;",
		"    char *ptr, *ptr2, *str;",
		"    char *arroba = NULL;",
		"    char *grep = NULL;",
		"    RIODesc *tmpdesc = NULL;",
		"    int pamode = !core->io->va;",
		"    int i, ret = 0, pipefd;",
		"    bool usemyblock = false;",
		"    int scr_html = -1;",
		"    int scr_color = -1;",
		"    bool eos = false;",
		"    bool haveQuote = false;",
		"    bool oldfixedarch = core->fixedarch;",
		"    bool oldfixedbits = core->fixedbits;",
		"    bool cmd_tmpseek = false;",
		"    ut64 tmpbsz = core->blocksize;",
		"    int cmd_ignbithints = -1;",

		"    if (!cmd) {",
		"        r_list_free (tmpenvs);",
		"        return 0;",
		"    }",
		"    cmd = r_str_trim_head_tail (cmd);",
		"escape_redir:",
		"next2:",
		"    ptr = strchr (cmd, '`');",
		"    if (ptr) {",
		"        if (ptr > cmd) {",
		"        bool empty = false;",
		"        int oneline = 1;",
		"        if (ptr[1] == '`') {",
		"        ptr2 = strchr (ptr + 1, '`');",
		"        if (empty) {",
		"        } else if (!ptr2) {",
		"        } else {",
		"            int value = core->num->value;",
		"            *ptr = '\\0';",
		"            *ptr2 = '\\0';",
		"            if (ptr[1] == '!') { ",
		"                str = r_core_cmd_str_pipe (core, ptr + 1);",

		"int r_cmd_call(RCmd *cmd, const char *input) {",
		"    struct r_cmd_item_t *c;",
		"    int ret = -1;",
		"    RListIter *iter;",
		"    RCorePlugin *cp;",
		"    r_return_val_if_fail (cmd && input, -1);",
		"    if (!*input) {",
		"    } else {",
		"        char *nstr = NULL;",
		"        const char *ji = r_cmd_alias_get (cmd, input, 1);",
		"        if (ji) {",
		"        }",
		"        r_list_foreach (cmd->plist, iter, cp) {",
		"        }",
		"        if (!*input) {",
		"        }",
		"        c = cmd->cmds[((ut8)input[0]) & 0xff];",
		"        if (c && c->callback) {",
		"            const char *inp = (*input)? input + 1: \"\";",
		"            ret = c->callback (cmd->data, inp);",
		"void r_core_cmd_init(RCore *core) {",
		"    struct {",
		"        const char *cmd;",
		"        const char *description;",
		"        int (*callback)(void *data, const char *input)",
		"        int (*cb)(void *data, const char *input)",
		"    } cmds[] = {",
		"        {\"!\",        \"run system command\", cmd_system},",
		"    for (i = 0; i < R_ARRAY_SIZE (cmds); i++) {",
		"        r_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);",
		"    }",
		"static int cmd_system(void *data, const char *input) {",
		"    RCore *core = (RCore*)data;",
		"    ut64 n;",
		"    int ret = 0;",
		"    switch (*input) {",
		"    default:",
		"        n = atoi (input);",
		"        if (*input == '0' || n > 0) {",
		"        } else {",
		"            char *cmd = r_core_sysenv_begin (core, input);",
		"            if (cmd) {",
		"                void *bed = r_cons_sleep_begin ();",
		"                ret = r_sys_cmd (cmd);",
		"int r_sys_cmd(const char *str) {",
		"    if (r_sandbox_enable (0)) {",
		"        return false;",
		"    }",
		"    return r_sandbox_system (str, 1);",
		"int r_sandbox_system (const char *x, int n) {",
		"    if (enabled) {",
		"        eprintf (\"sandbox: system call disabled\\n\");",
		"        return -1;",
		"    }",
		"#if LIBC_HAVE_FORK",
		"#if LIBC_HAVE_SYSTEM",
		"    if (n) {",
		"        return system (x);"
	]
  }
]

