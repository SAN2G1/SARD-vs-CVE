[
    {
        "FileName": "sandbox.c",
        "Caller": "r_sandbox_system",
        "Source": false,
        "Sink": false,
        "idx": 0,
        "CWE-ID": "CWE-",
        "category": "CallExpression",
        "criterion": "system",
        "line": 361,
        "label": -3,
        "slices": [
            "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {",
            "    RBinInfo *info = r_bin_get_info (r->bin);",
            "    RList *entries = r_bin_get_entries (r->bin);",
            "    RBinSymbol *symbol;",
            "    RBinAddr *entry;",
            "    RListIter *iter;",
            "    bool firstexp = true;",
            "    bool printHere = false;",
            "    int i = 0, lastfs = 's';",
            "    bool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");",
            "    if (!info) {",
            "        return 0;",
            "    }",
            "    if (args && *args == '.') {",
            "        printHere = true;",
            "    }",
            "    bool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);",
            "    const char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;",
            "    RList *symbols = r_bin_get_symbols (r->bin);",
            "    size_t count = 0;",
            "    r_list_foreach (symbols, iter, symbol) {",
            "        if (!symbol->name) {",
            "            continue;",
            "        }",
            "        char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);",
            "    const char *name = sn.demname? sn.demname: r_symbol_name;",
            "    if (!name) {",
            "        goto next;",
            "    }",
            "    if (!strncmp (name, \"imp.\", 4)) {",
            "        if (lastfs != 'i') {",
            "            r_cons_printf (\"fs imports\\n\");",
            "        }",
            "        lastfs = 'i';",
            "    } else {",
            "        if (lastfs != 's') {",
            "            const char *fs = exponly? \"exports\": \"symbols\";",
            "            r_cons_printf (\"fs %s\\n\", fs);",
            "        }",
            "        lastfs = 's';",
            "    }",
            "    if (r->bin->prefix || *name) {",
            "        char *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);",
            "        if (!flagname) {",
            "            goto next;",
            "        }",
            "        r_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",",
            "            r->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",",
            "            flagname, symbol->size, addr);",
            "R_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {",
            "    int ret = true;",
            "    const char *name = NULL;",
            "    ut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);",
            "    va = va ? VA_TRUE : VA_FALSE;",
            "    if ((action & R_CORE_BIN_ACC_EXPORTS)) {",
            "        ret &= bin_symbols (core, mode, loadaddr, va, at, name, true, chksum);",
            "    }",
            "    if ((action & R_CORE_BIN_ACC_SYMBOLS)) {",
            "        ret &= bin_symbols (core, mode, loadaddr, va, at, name, false, chksum);",
            "static int cmd_info(void *data, const char *input) {",
            "    RCore *core = (RCore *) data;",
            "    bool newline = r_cons_is_interactive ();",
            "    int fd = r_io_fd_get_current (core->io);",
            "    RIODesc *desc = r_io_desc_get (core->io, fd);",
            "    int i, va = core->io->va || core->io->debug;",
            "    int mode = 0;",
            "    bool rdump = false;",
            "    int is_array = 0;",
            "    Sdb *db;",
            "    for (i = 0; input[i] && input[i] != ' '; i++)",
            "        ;",
            "    if (i > 0) {",
            "        switch (input[i - 1]) {",
            "        case '*': mode = R_MODE_RADARE; break;",
            "        case 'j': mode = R_MODE_JSON; break;",
            "        case 'q': mode = R_MODE_SIMPLE; break;",
            "        }",
            "    }",
            "    if (mode == R_MODE_JSON) {",
            "        int suffix_shift = 0;",
            "        if (!strncmp (input, \"SS\", 2) || !strncmp (input, \"ee\", 2)",
            "            || !strncmp (input, \"zz\", 2)) {",
            "            suffix_shift = 1;",
            "        }",
            "        if (strlen (input + 1 + suffix_shift) > 1) {",
            "            is_array = 1;",
            "        }",
            "    }",
            "    if (is_array) {",
            "        r_cons_printf (\"{\");",
            "    }",
            "    if (!*input) {",
            "        cmd_info_bin (core, va, mode);",
            "    }",
            "    if (!strcmp (input, \"*\")) {",
            "        input = \"I*\";",
            "    }",
            "    char *question = strchr (input, '?');",
            "    const char *space = strchr (input, ' ');",
            "    if (!space) {",
            "        space = question + 1;",
            "    }",
            "    if (question < space && question > input) {",
            "    while (*input) {",
            "        switch (*input) {",
            "        case 's': {",
            "            RBinObject *obj = r_bin_cur_object (core->bin);",
            "            if (input[1] == 'j' && input[2] == '.') {",
            "                mode = R_MODE_JSON;",
            "                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 2, (obj && obj->symbols)? r_list_length (obj->symbols): 0);",
            "            } else if (input[1] == 'q' && input[2] == 'q') {",
            "                mode = R_MODE_SIMPLEST;",
            "                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);",
            "            } else if (input[1] == 'q' && input[2] == '.') {",
            "                mode = R_MODE_SIMPLE;",
            "                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 2, 0);",
            "            } else {",
            "                RBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);",
            "R_API void r_core_cmd_init(RCore *core) {",
            "    struct {",
            "        const char *cmd;",
            "        const char *description;",
            "        int (*callback)(void *data, const char *input)",
            "        int (*cb)(void *data, const char *input)",
            "    } cmds[] = {",
            "        {\"info\",     \"get file info\", cmd_info, cmd_info_init},",
            "    for (i = 0; i < R_ARRAY_SIZE (cmds); i++) {",
            "        r_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);",
            "R_API int r_cmd_call(RCmd *cmd, const char *input) {",
            "    struct r_cmd_item_t *c;",
            "    int ret = -1;",
            "    RListIter *iter;",
            "    RCorePlugin *cp;",
            "    r_return_val_if_fail (cmd && input, -1);",
            "    if (!*input) {",
            "    } else {",
            "        char *nstr = NULL;",
            "        const char *ji = r_cmd_alias_get (cmd, input, 1);",
            "        if (ji) {",
            "        }",
            "        r_list_foreach (cmd->plist, iter, cp) {",
            "        }",
            "        if (!*input) {",
            "        }",
            "        c = cmd->cmds[((ut8)input[0]) & 0xff];",
            "        if (c && c->callback) {",
            "            const char *inp = (*input)? input + 1: \"\";",
            "            ret = c->callback (cmd->data, inp);",
            "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {",
            "    RList *tmpenvs = r_list_newf (tmpenvs_free);",
            "    const char *quotestr = \"`\";",
            "    const char *tick = NULL;",
            "    char *ptr, *ptr2, *str;",
            "    char *arroba = NULL;",
            "    char *grep = NULL;",
            "    RIODesc *tmpdesc = NULL;",
            "    int pamode = !core->io->va;",
            "    int i, ret = 0, pipefd;",
            "    bool usemyblock = false;",
            "    int scr_html = -1;",
            "    int scr_color = -1;",
            "    bool eos = false;",
            "    bool haveQuote = false;",
            "    bool oldfixedarch = core->fixedarch;",
            "    bool oldfixedbits = core->fixedbits;",
            "    bool cmd_tmpseek = false;",
            "    ut64 tmpbsz = core->blocksize;",
            "    int cmd_ignbithints = -1;",
            "    if (!cmd) {",
            "        r_list_free (tmpenvs);",
            "        return 0;",
            "    }",
            "    cmd = r_str_trim_head_tail (cmd);",
            "fuji:",
            "    rc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;",
            "static int r_core_cmd_subst(RCore *core, char *cmd) {",
            "    ut64 rep = strtoull (cmd, NULL, 10);",
            "    int ret = 0, orep;",
            "    char *cmt, *colon = NULL, *icmd = NULL;",
            "    bool tmpseek = false;",
            "    bool original_tmpseek = core->tmpseek;",
            "    if (r_str_startswith (cmd, \"GET /cmd/\")) {",
            "        memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);",
            "        char *http = strstr (cmd, \"HTTP\");",
            "        if (http) {",
            "            *http = 0;",
            "            http--;",
            "            if (*http == ' ') {",
            "                *http = 0;",
            "            }",
            "        }",
            "        r_cons_printf (\"HTTP/1.0 %d %s\\r\\n%s\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",200, \"OK\", \"\", -1);",
            "        return r_core_cmd0 (core, cmd);",
            "    }",
            "    ut64 orig_offset = core->offset;",
            "    icmd = strdup (cmd);",
            "    if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {",
            "        core->prompt_offset = core->offset;",
            "    }",
            "    cmd = r_str_trim_head_tail (icmd);",
            "    if (*cmd != '\"') {",
            "    } else {",
            "        colon = NULL;",
            "    }",
            "    if (rep > 0) {",
            "        while (IS_DIGIT (*cmd)) {",
            "            cmd++;",
            "        }",
            "        if (!*cmd) {",
            "    }",
            "    if (rep < 1) {",
            "        rep = 1;",
            "    }",
            "    const char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";",
            "    orep = rep;",
            "    r_cons_break_push (NULL, NULL);",
            "    int ocur_enabled = core->print && core->print->cur_enabled;",
            "    while (rep-- && *cmd) {",
            "        if (core->print) {",
            "            core->print->cur_enabled = false;",
            "            if (ocur_enabled && core->seltab >= 0) {",
            "                if (core->seltab == core->curtab) {",
            "                    core->print->cur_enabled = true;",
            "                }",
            "            }",
            "        }",
            "        if (r_cons_is_breaked ()) {",
            "        char *cr = strdup (cmdrep);",
            "        core->break_loop = false;",
            "        ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);",
            "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {",
            "    char *cmd, *ocmd, *ptr, *rcmd;",
            "    int ret = false, i;",
            "    if (core->cmdfilter) {",
            "        const char *invalid_chars = \";|>`@\";",
            "        for (i = 0; invalid_chars[i]; i++) {",
            "            if (strchr (cstr, invalid_chars[i])) {",
            "        }",
            "        if (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {",
            "    }",
            "    if (core->cmdremote) {",
            "        if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {",
            "    }",
            "    if (!cstr || (*cstr == '|' && cstr[1] != '?')) {",
            "    if (!strncmp (cstr, \"/*\", 2)) {",
            "        if (r_sandbox_enable (0)) {",
            "        core->incomment = true;",
            "    } else if (!strncmp (cstr, \"*/\", 2)) {",
            "    if (core->incomment) {",
            "    if (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {",
            "        free (core->lastcmd);",
            "        core->lastcmd = strdup (cstr);",
            "    }",
            "    ocmd = cmd = malloc (strlen (cstr) + 4096);",
            "    if (!ocmd) {",
            "    r_str_cpy (cmd, cstr);",
            "    if (log) {",
            "        r_line_hist_add (cstr);",
            "    }",
            "    if (core->cons->context->cmd_depth < 1) {",
            "    core->cons->context->cmd_depth--;",
            "    for (rcmd = cmd;;) {",
            "        ptr = strchr (rcmd, '\\n');",
            "        if (ptr) {",
            "            *ptr = '\\0';",
            "        }",
            "        ret = r_core_cmd_subst (core, rcmd);",
            "R_API char *r_core_cmd_str(RCore *core, const char *cmd) {",
            "    const char *static_str;",
            "    char *retstr = NULL;",
            "    r_cons_push ();",
            "    if (r_core_cmd (core, cmd, 0) == -1) {",
            "static int cmd_interpret(void *data, const char *input) {",
            "    char *str, *ptr, *eol, *rbuf, *filter, *inp;",
            "    const char *host, *port, *cmd;",
            "    RCore *core = (RCore *)data;",
            "    switch (*input) {",
            "    default:",
            "        if (*input >= 0 && *input <= 9) {",
            "            eprintf (\"|ERROR| No .[0..9] to avoid infinite loops\\n\");",
            "            break;",
            "        }",
            "        inp = strdup (input);",
            "        filter = strchr (inp, '~');",
            "        if (filter) {",
            "        int tmp_html = r_cons_singleton ()->is_html;",
            "        r_cons_singleton ()->is_html = 0;",
            "        ptr = str = r_core_cmd_str (core, inp);",
            "        r_cons_singleton ()->is_html = tmp_html;",
            "        if (filter) {",
            "        r_cons_break_push (NULL, NULL);",
            "        if (ptr) {",
            "            for (;;) {",
            "                if (r_cons_is_breaked ()) {",
            "                    break;",
            "                }",
            "                eol = strchr (ptr, '\\n');",
            "                if (eol) {",
            "                    *eol = '\\0';",
            "                }",
            "                if (*ptr) {",
            "                    char *p = r_str_append (strdup (ptr), filter); ",
            "                    r_core_cmd0 (core, p);",
            "R_API int r_core_cmd0(RCore *core, const char *cmd) {",
            "    return r_core_cmd (core, cmd, 0);",
            "R_API int r_core_cmd(RCore *core, const char *cstr, int log) {",
            "    char *cmd, *ocmd, *ptr, *rcmd;",
            "    int ret = false, i;",
            "    if (core->cmdfilter) {",
            "        const char *invalid_chars = \";|>`@\";",
            "        for (i = 0; invalid_chars[i]; i++) {",
            "            if (strchr (cstr, invalid_chars[i])) {",
            "        }",
            "        if (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {",
            "    }",
            "    if (core->cmdremote) {",
            "        if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {",
            "    }",
            "    if (!cstr || (*cstr == '|' && cstr[1] != '?')) {",
            "    if (!strncmp (cstr, \"/*\", 2)) {",
            "        if (r_sandbox_enable (0)) {",
            "        }",
            "        core->incomment = true;",
            "    } else if (!strncmp (cstr, \"*/\", 2)) {",
            "    }",
            "    if (core->incomment) {",
            "    }",
            "    if (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {",
            "        free (core->lastcmd);",
            "        core->lastcmd = strdup (cstr);",
            "    }",
            "    ocmd = cmd = malloc (strlen (cstr) + 4096);",
            "    if (!ocmd) {",
            "    r_str_cpy (cmd, cstr);",
            "    if (log) {",
            "    if (core->cons->context->cmd_depth < 1) {",
            "    core->cons->context->cmd_depth--;",
            "    for (rcmd = cmd;;) {",
            "        ptr = strchr (rcmd, '\\n'); ",
            "        if (ptr) {",
            "            *ptr = '\\0';",
            "        }",
            "        ret = r_core_cmd_subst (core, rcmd);",
            "static int r_core_cmd_subst(RCore *core, char *cmd) {",
            "    ut64 rep = strtoull (cmd, NULL, 10);",
            "    int ret = 0, orep;",
            "    char *cmt, *colon = NULL, *icmd = NULL;",
            "    bool tmpseek = false;",
            "    bool original_tmpseek = core->tmpseek;",
            "    if (r_str_startswith (cmd, \"GET /cmd/\")) {",
            "        memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);",
            "        char *http = strstr (cmd, \"HTTP\");",
            "        if (http) {",
            "            *http = 0;",
            "            http--;",
            "            if (*http == ' ') {",
            "                *http = 0;",
            "            }",
            "        }",
            "        r_cons_printf (\"HTTP/1.0 %d %s\\r\\n%s\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",200, \"OK\", \"\", -1);",
            "        return r_core_cmd0 (core, cmd);",
            "    }",
            "    ut64 orig_offset = core->offset;",
            "    icmd = strdup (cmd);",
            "    if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {",
            "        core->prompt_offset = core->offset;",
            "    }",
            "    cmd = r_str_trim_head_tail (icmd);",
            "    if (*cmd != '\"') {",
            "    } else {",
            "        colon = NULL;",
            "    }",
            "    if (rep > 0) {",
            "        while (IS_DIGIT (*cmd)) {",
            "            cmd++;",
            "        }",
            "        if (!*cmd) {",
            "    }",
            "    if (rep < 1) {",
            "        rep = 1;",
            "    }",
            "    const char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";",
            "    orep = rep;",
            "    r_cons_break_push (NULL, NULL);",
            "    int ocur_enabled = core->print && core->print->cur_enabled;",
            "    while (rep-- && *cmd) {",
            "        if (core->print) {",
            "            core->print->cur_enabled = false;",
            "            if (ocur_enabled && core->seltab >= 0) {",
            "                if (core->seltab == core->curtab) {",
            "                    core->print->cur_enabled = true;",
            "                }",
            "            }",
            "        }",
            "        if (r_cons_is_breaked ()) {",
            "        char *cr = strdup (cmdrep);",
            "        core->break_loop = false;",
            "        ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);",
            "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {",
            "    RList *tmpenvs = r_list_newf (tmpenvs_free);",
            "    const char *quotestr = \"`\";",
            "    const char *tick = NULL;",
            "    char *ptr, *ptr2, *str;",
            "    char *arroba = NULL;",
            "    char *grep = NULL;",
            "    RIODesc *tmpdesc = NULL;",
            "    int pamode = !core->io->va;",
            "    int i, ret = 0, pipefd;",
            "    bool usemyblock = false;",
            "    int scr_html = -1;",
            "    int scr_color = -1;",
            "    bool eos = false;",
            "    bool haveQuote = false;",
            "    bool oldfixedarch = core->fixedarch;",
            "    bool oldfixedbits = core->fixedbits;",
            "    bool cmd_tmpseek = false;",
            "    ut64 tmpbsz = core->blocksize;",
            "    int cmd_ignbithints = -1;",
            "    if (!cmd) {",
            "        r_list_free (tmpenvs);",
            "        return 0;",
            "    }",
            "    cmd = r_str_trim_head_tail (cmd);",
            "escape_redir:",
            "next2:",
            "    ptr = strchr (cmd, '`');",
            "    if (ptr) {",
            "        if (ptr > cmd) {",
            "        bool empty = false;",
            "        int oneline = 1;",
            "        if (ptr[1] == '`') {",
            "        ptr2 = strchr (ptr + 1, '`');",
            "        if (empty) {",
            "        } else if (!ptr2) {",
            "        } else {",
            "            int value = core->num->value;",
            "            *ptr = '\\0';",
            "            *ptr2 = '\\0';",
            "            if (ptr[1] == '!') { ",
            "                str = r_core_cmd_str_pipe (core, ptr + 1);",
            "static char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {",
            "    char *s, *tmp = NULL;",
            "    if (r_sandbox_enable (0)) {",
            "        char *p = (*cmd != '\"')? strchr (cmd, '|'): NULL;",
            "        if (p) {",
            "        }",
            "        return r_core_cmd_str (core, cmd);",
            "    }",
            "    r_cons_reset ();",
            "    r_sandbox_disable (1);",
            "    if (r_file_mkstemp (\"cmd\", &tmp) != -1) {",
            "        int pipefd = r_cons_pipe_open (tmp, 1, 0);",
            "        if (pipefd == -1) {",
            "        char *_cmd = strdup (cmd);",
            "        r_core_cmd_subst (core, _cmd);",
            "static int r_core_cmd_subst(RCore *core, char *cmd) {",
            "    ut64 rep = strtoull (cmd, NULL, 10);",
            "    int ret = 0, orep;",
            "    char *cmt, *colon = NULL, *icmd = NULL;",
            "    bool tmpseek = false;",
            "    bool original_tmpseek = core->tmpseek;",
            "    if (r_str_startswith (cmd, \"GET /cmd/\")) {",
            "        memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);",
            "        char *http = strstr (cmd, \"HTTP\");",
            "        if (http) {",
            "            *http = 0;",
            "            http--;",
            "            if (*http == ' ') {",
            "                *http = 0;",
            "            }",
            "        }",
            "        r_cons_printf (\"HTTP/1.0 %d %s\\r\\n%s\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",200, \"OK\", \"\", -1);",
            "        return r_core_cmd0 (core, cmd);",
            "    }",
            "    ut64 orig_offset = core->offset;",
            "    icmd = strdup (cmd);",
            "    if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {",
            "        core->prompt_offset = core->offset;",
            "    }",
            "    cmd = r_str_trim_head_tail (icmd);",
            "    if (*cmd != '\"') {",
            "    } else {",
            "        colon = NULL;",
            "    }",
            "    if (rep > 0) {",
            "        while (IS_DIGIT (*cmd)) {",
            "            cmd++;",
            "        }",
            "        if (!*cmd) {",
            "    }",
            "    if (rep < 1) {",
            "        rep = 1;",
            "    }",
            "    if (rep > 1 && r_sandbox_enable (0)) {",
            "    } else {",
            "    }",
            "    const char *cmdrep = core->cmdtimes ? core->cmdtimes: \"\";",
            "    orep = rep;",
            "    r_cons_break_push (NULL, NULL);",
            "    int ocur_enabled = core->print && core->print->cur_enabled;",
            "    while (rep-- && *cmd) {",
            "        if (core->print) {",
            "            core->print->cur_enabled = false;",
            "            if (ocur_enabled && core->seltab >= 0) {",
            "                if (core->seltab == core->curtab) {",
            "                    core->print->cur_enabled = true;",
            "                }",
            "            }",
            "        }",
            "        if (r_cons_is_breaked ()) {",
            "        char *cr = strdup (cmdrep);",
            "        core->break_loop = false;",
            "        ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);",
            "static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {",
            "    RList *tmpenvs = r_list_newf (tmpenvs_free);",
            "    const char *quotestr = \"`\";",
            "    const char *tick = NULL;",
            "    char *ptr, *ptr2, *str;",
            "    char *arroba = NULL;",
            "    char *grep = NULL;",
            "    RIODesc *tmpdesc = NULL;",
            "    int pamode = !core->io->va;",
            "    int i, ret = 0, pipefd;",
            "    bool usemyblock = false;",
            "    int scr_html = -1;",
            "    int scr_color = -1;",
            "    bool eos = false;",
            "    bool haveQuote = false;",
            "    bool oldfixedarch = core->fixedarch;",
            "    bool oldfixedbits = core->fixedbits;",
            "    bool cmd_tmpseek = false;",
            "    ut64 tmpbsz = core->blocksize;",
            "    int cmd_ignbithints = -1;",
            "    if (!cmd) {",
            "        r_list_free (tmpenvs);",
            "        return 0;",
            "    }",
            "    cmd = r_str_trim_head_tail (cmd);",
            "escape_redir:",
            "next2:",
            "    ptr = strchr (cmd, '`');",
            "    if (ptr) {",
            "        if (ptr > cmd) {",
            "        bool empty = false;",
            "        int oneline = 1;",
            "        if (ptr[1] == '`') {",
            "        ptr2 = strchr (ptr + 1, '`');",
            "        if (empty) {",
            "        } else if (!ptr2) {",
            "        } else {",
            "            int value = core->num->value;",
            "            *ptr = '\\0';",
            "            *ptr2 = '\\0';",
            "            if (ptr[1] == '!') { ",
            "                str = r_core_cmd_str_pipe (core, ptr + 1);",
            "int r_cmd_call(RCmd *cmd, const char *input) {",
            "    struct r_cmd_item_t *c;",
            "    int ret = -1;",
            "    RListIter *iter;",
            "    RCorePlugin *cp;",
            "    r_return_val_if_fail (cmd && input, -1);",
            "    if (!*input) {",
            "    } else {",
            "        char *nstr = NULL;",
            "        const char *ji = r_cmd_alias_get (cmd, input, 1);",
            "        if (ji) {",
            "        }",
            "        r_list_foreach (cmd->plist, iter, cp) {",
            "        }",
            "        if (!*input) {",
            "        }",
            "        c = cmd->cmds[((ut8)input[0]) & 0xff];",
            "        if (c && c->callback) {",
            "            const char *inp = (*input)? input + 1: \"\";",
            "            ret = c->callback (cmd->data, inp);",
            "void r_core_cmd_init(RCore *core) {",
            "    struct {",
            "        const char *cmd;",
            "        const char *description;",
            "        int (*callback)(void *data, const char *input)",
            "        int (*cb)(void *data, const char *input)",
            "    } cmds[] = {",
            "        {\"!\",        \"run system command\", cmd_system},",
            "    for (i = 0; i < R_ARRAY_SIZE (cmds); i++) {",
            "        r_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);",
            "    }",
            "static int cmd_system(void *data, const char *input) {",
            "    RCore *core = (RCore*)data;",
            "    ut64 n;",
            "    int ret = 0;",
            "    switch (*input) {",
            "    default:",
            "        n = atoi (input);",
            "        if (*input == '0' || n > 0) {",
            "        } else {",
            "            char *cmd = r_core_sysenv_begin (core, input);",
            "            if (cmd) {",
            "                void *bed = r_cons_sleep_begin ();",
            "                ret = r_sys_cmd (cmd);",
            "int r_sys_cmd(const char *str) {",
            "    if (r_sandbox_enable (0)) {",
            "        return false;",
            "    }",
            "    return r_sandbox_system (str, 1);",
            "int r_sandbox_system (const char *x, int n) {",
            "    if (enabled) {",
            "        eprintf (\"sandbox: system call disabled\\n\");",
            "        return -1;",
            "    }",
            "#if LIBC_HAVE_FORK",
            "#if LIBC_HAVE_SYSTEM",
            "    if (n) {",
            "        return system (x);"
        ],
        "tokenized": "static int FUNC1(STRUCT1 *Var1,int  Var2,STRUCT2  Var3,int  Var4,STRUCT2  Var5,const char *Var6,bool  Var7,const char *Var8){STRUCT3 *Var9=FUNC2(Var1->memberVar1); STRUCT4 *Var10=FUNC3(Var1->memberVar1); STRUCT5 *Var11; STRUCT6 *Var12; STRUCT7 *Var13; bool  Var14=true ; bool  Var15=false ; int  Var16=0,Var17=Var18; bool  Var19=FUNC4(Var1->memberVar2,STRING); if (!Var9){return 0; }if (Var8&&*Var8 == .){Var15=true ; }bool  Var20=Var9&&Var9->memberVar1&&!FUNC5(Var9->memberVar1,STRING,3); const char *Var21=Var19 FUNC6(Var1->memberVar2,STRING) NULL ; STRUCT4 *Var22=FUNC7(Var1->memberVar1); size_t  Var23=0; FUNC8(Var22,Var13,Var11){if (!Var11->memberVar1){continue ; }char *Var24=FUNC9(Var11->memberVar1,false ,true ); const char *memberVar1=Var25.STRUCT8  Var25.STRUCT8  Var24; if (!memberVar1){goto  Var26; }if (!FUNC5(memberVar1,STRING,4)){if (Var17 !=  Var16){FUNC10(STRING); }Var17=Var16; }else {if (Var17 !=  Var18){const char *Var27=Var7 STRINGSTRING; FUNC10(STRING,Var27); }Var17=Var18; }if (Var1->memberVar1->memberVar1||*memberVar1){char *Var28=FUNC11(STRING,memberVar1,Var29); if (!Var28){goto  Var26; }FUNC10(STRING Var30%Var18%Var18%Var18%STRUCT9  Var31%08STRINGSTRING,Var1->memberVar1->memberVar1  Var1->memberVar1->memberVar1 STRING,Var1->memberVar1->memberVar1 STRINGSTRING,Var28,Var11->size ,Var32); Var33 int FUNC12(STRUCT1 *Var34,int  Var35,int  Var2,int  Var4,STRUCT10 *Var36,const char *Var37){int  Var38=true ; const char *memberVar1=NULL ; STRUCT2  Var5=0,Var39=FUNC13(Var34->memberVar1); Var4=Var4  STRUCT11  Var40; if ((Var35&Var41)){Var38  STRUCT12 FUNC1(Var34,Var2,Var39,Var4,Var5,memberVar1,true ,Var37); }if ((Var35&Var42)){Var38  STRUCT12 FUNC1(Var34,Var2,Var39,Var4,Var5,memberVar1,false ,Var37); static int FUNC14(void *Var43,const char *Var44){STRUCT1 *Var34=(STRUCT1 *) Var43; bool  Var45=FUNC15(); int  Var46=FUNC16(Var34->memberVar2); STRUCT13 *Var47=FUNC17(Var34->memberVar2,Var46); int  Var16,Var4=Var34->memberVar2->memberVar1||Var34->memberVar2->memberVar2; int  Var2=0; bool  Var48=false ; int  Var49=0; STRUCT14 *Var50; for (Var16=0; Var44[Var16]&&Var44[Var16]!= ; Var16  Var51); if (Var16>0){switch (Var44[Var16-1]){case *Var2=Var52; break ; case  STRUCT15  Var2=Var53; break ; case  STRUCT16  Var2=Var54; break ; }}if (Var2 ==  Var53){int  Var55=0; if (!FUNC5(Var44,STRING,2)||!FUNC5(Var44,STRING,2)||!FUNC5(Var44,STRING,2)){Var55=1; }if (strlen(Var44+1+Var55)>1){Var49=1; }}if (Var49){FUNC10(STRING); }if (!*Var44){FUNC18(Var34,memberVar1,Var2); }if (!strcmp(Var44,STRING)){Var44=STRING; }char *Var56=strchr(Var44,); const char *Var57=strchr(Var44,); if (!Var57){Var57=Var56+1; }if (Var56<Var57&&Var56>Var44){while (*Var44){switch (*Var44){case  Var18{STRUCT17 *Var58=FUNC19(Var34->memberVar1); if (Var44[1]==  STRUCT15&&Var44[2]== .){Var2=Var53; FUNC20(STRING,Var42,Var44+2,(Var58&&Var58->memberVar1) FUNC21(Var58->memberVar1) 0); }else if (Var44[1]==  STRUCT16&&Var44[2]==  STRUCT16){Var2=Var59; FUNC20(STRING,Var42,Var44+1,(Var58&&Var58->memberVar1) FUNC21(Var58->memberVar1) 0); }else if (Var44[1]==  STRUCT16&&Var44[2]== .){Var2=Var54; FUNC20(STRING,Var42,Var44+2,0); }else {FUNC20(STRING,Var42,Var44+1,(Var58&&Var58->memberVar1) FUNC21(Var58->memberVar1) 0); Var33 void FUNC22(STRUCT1 *Var34){struct {const char *Var60; const char *Var61; int (*Var62)(void *Var43,const char *Var44) int (*Var63)(void *Var43,const char *Var44)}Var64[]={{STRING,STRING,FUNC14,Var65},for (Var16=0; Var16<FUNC23(Var64); Var16  Var51){FUNC24(Var34->memberVar3,Var64[Var16].memberVar1,Var64[Var16].memberVar2,Var64[Var16].memberVar3); Var33 int FUNC25(STRUCT18 *memberVar1,const char *Var44){struct STRUCT19 *Var66; int  Var38=-1; STRUCT7 *Var13; STRUCT20 *Var67; FUNC26(memberVar1&&Var44,-1); if (!*Var44){}else {char *Var68=NULL ; const char *Var69=FUNC27(memberVar1,Var44,1); if (Var69){}FUNC8(memberVar1->memberVar1,Var13,Var67){}if (!*Var44){}Var66=memberVar1->memberVar2[((Var70) Var44[0])&255]; if (Var66&&Var66->memberVar1){const char *Var71=(*Var44) Var44+1STRING; Var38=Var66->memberVar1(memberVar1->memberVar3,Var71); static int FUNC28(STRUCT1 *Var34,char *memberVar1,char *Var72,bool *Var73){STRUCT4 *Var74=FUNC29(Var75); const char *Var76=STRING; const char *Var77=NULL ; char *Var78,*Var79,*Var80; char *Var81=NULL ; char *Var82=NULL ; STRUCT13 *Var83=NULL ; int  Var84=!Var34->memberVar2->memberVar1; int  Var16,Var38=0,Var85; bool  Var86=false ; int  Var87=-1; int  Var88=-1; bool  Var89=false ; bool  Var90=false ; bool  Var91=Var34->memberVar4; bool  Var92=Var34->memberVar5; bool  Var93=false ; STRUCT2  Var94=Var34->memberVar6; int  Var95=-1; if (!memberVar1){FUNC30(Var74); return 0; }memberVar1=FUNC31(memberVar1); STRUCT21  Var96=memberVar1 FUNC25(Var34->memberVar3,FUNC32(memberVar1)) false ; static int FUNC33(STRUCT1 *Var34,char *memberVar1){STRUCT2  Var97=FUNC34(memberVar1,NULL ,10); int  Var38=0,Var98; char *Var99,*Var72=NULL ,*Var100=NULL ; bool  Var73=false ; bool  Var101=Var34->memberVar7; if (FUNC35(memberVar1,STRING)){memmove(memberVar1,memberVar1+9,strlen(memberVar1+9)+1); char *Var102=strstr(memberVar1,STRING); if (Var102){*Var102=0; Var102  Var103; if (*Var102 == ){*Var102=0; }}FUNC10(STRING Var104 close Var1  Var105-Var106%Var107  Var1  Var108  Var1  Var108 STRING Var109 STRINGSTRING){}else {Var72=NULL ; }if (Var97>0){while (FUNC36(*memberVar1)){memberVar1  Var51; }if (!*memberVar1){}if (Var97<1){Var97=1; }const char *Var110=Var34->STRUCT22  Var34->STRUCT22 STRING; Var98=Var97; FUNC37(NULL ,NULL ); int  Var111=Var34->memberVar8&&Var34->memberVar8->memberVar1; while (Var97  Var103&&*memberVar1){if (Var34->memberVar8){Var34->memberVar8->memberVar1=false ; if (Var111&&Var34->memberVar9 >= 0){if (Var34->memberVar9 ==  Var34->memberVar10){Var34->memberVar8->memberVar1=true ; }}}if (FUNC38()){char *Var112=strdup(Var110); Var34->memberVar11=false ; Var38=FUNC28(Var34,memberVar1,Var72,(Var97 ==  Var98-1)&memberVar7 NULL ); Var33 int FUNC39(STRUCT1 *Var34,const char *Var113,int  Var114){char *memberVar1,*Var115,*Var78,*memberVar3; int  Var38=false ,Var16; if (Var34->memberVar12){const char *Var116=STRING; for (Var16=0; Var116[Var16]; Var16  Var51){if (strchr(Var113,Var116[Var16])){}if (FUNC5(Var113,Var34->memberVar12,strlen(Var34->memberVar12))){}if (Var34->memberVar13){if (*Var113 != =&&*Var113 !=  STRUCT16&&FUNC5(Var113,STRING,2)){}if (!Var113||(*Var113 == |&&Var113[1]!= )){if (!FUNC5(Var113,STRING,2)){if (FUNC40(0)){Var34->memberVar14=true ; }else if (!FUNC5(Var113,STRING,2)){if (Var34->memberVar14){if (Var114&&(*Var113&&(*Var113 != .||!FUNC5(Var113,STRING,2)))){free(Var34->memberVar15); Var34->memberVar15=strdup(Var113); }Var115=memberVar1=malloc(strlen(Var113)+4096); if (!Var115){FUNC41(memberVar1,Var113); if (Var114){FUNC42(Var113); }if (Var34->memberVar16->memberVar1->memberVar1<1){Var34->memberVar16->memberVar1->memberVar1  Var103; for (memberVar3=memberVar1; ; ){Var78=strchr(memberVar3,Var108); if (Var78){*Var78=0; }Var38=FUNC33(Var34,memberVar3); Var33 char *FUNC43(STRUCT1 *Var34,const char *memberVar1){const char *Var117; char *Var118=NULL ; FUNC44(); if (FUNC39(Var34,memberVar1,0) == -1){static int FUNC45(void *memberVar3,const char *Var44){char *Var80,*Var78,*Var119,*Var120,*Var36,*Var71; const char *Var121,*Var122,*memberVar1; STRUCT1 *Var34=(STRUCT1 *) memberVar3; switch (*Var44){default if (*Var44 >= 0&&*Var44 <= 9){FUNC46(STRING); break ; }Var71=strdup(Var44); Var36=strchr(Var71,); if (Var36){int  Var123=FUNC47()->memberVar1; FUNC47()->memberVar1=0; Var78=Var80=FUNC43(Var34,Var71); FUNC47()->memberVar1=Var123; if (Var36){FUNC37(NULL ,NULL ); if (Var78){for (; ; ){if (FUNC38()){break ; }Var119=strchr(Var78,Var108); if (Var119){*Var119=0; }if (*Var78){char *Var124=FUNC48(strdup(Var78),Var36); FUNC49(Var34,Var124); Var33 int FUNC49(STRUCT1 *Var34,const char *memberVar1){return FUNC39(Var34,memberVar1,0); Var33 int FUNC39(STRUCT1 *Var34,const char *Var113,int  Var114){char *memberVar1,*Var115,*Var78,*memberVar3; int  Var38=false ,Var16; if (Var34->memberVar12){const char *Var116=STRING; for (Var16=0; Var116[Var16]; Var16  Var51){if (strchr(Var113,Var116[Var16])){}if (FUNC5(Var113,Var34->memberVar12,strlen(Var34->memberVar12))){}if (Var34->memberVar13){if (*Var113 != =&&*Var113 !=  STRUCT16&&FUNC5(Var113,STRING,2)){}if (!Var113||(*Var113 == |&&Var113[1]!= )){if (!FUNC5(Var113,STRING,2)){if (FUNC40(0)){}Var34->memberVar14=true ; }else if (!FUNC5(Var113,STRING,2)){}if (Var34->memberVar14){}if (Var114&&(*Var113&&(*Var113 != .||!FUNC5(Var113,STRING,2)))){free(Var34->memberVar15); Var34->memberVar15=strdup(Var113); }Var115=memberVar1=malloc(strlen(Var113)+4096); if (!Var115){FUNC41(memberVar1,Var113); if (Var114){if (Var34->memberVar16->memberVar1->memberVar1<1){Var34->memberVar16->memberVar1->memberVar1  Var103; for (memberVar3=memberVar1; ; ){Var78=strchr(memberVar3,Var108); if (Var78){*Var78=0; }Var38=FUNC33(Var34,memberVar3); static int FUNC33(STRUCT1 *Var34,char *memberVar1){STRUCT2  Var97=FUNC34(memberVar1,NULL ,10); int  Var38=0,Var98; char *Var99,*Var72=NULL ,*Var100=NULL ; bool  memberVar7=false ; bool  Var101=Var34->memberVar7; if (FUNC35(memberVar1,STRING)){memmove(memberVar1,memberVar1+9,strlen(memberVar1+9)+1); char *Var102=strstr(memberVar1,STRING); if (Var102){*Var102=0; Var102  Var103; if (*Var102 == ){*Var102=0; }}FUNC10(STRING Var104 close Var1  Var105-Var106%Var107  Var1  Var108  Var1  Var108 STRING Var109 STRINGSTRING){}else {Var72=NULL ; }if (Var97>0){while (FUNC36(*memberVar1)){memberVar1  Var51; }if (!*memberVar1){}if (Var97<1){Var97=1; }const char *Var110=Var34->STRUCT22  Var34->STRUCT22 STRING; Var98=Var97; FUNC37(NULL ,NULL ); int  Var111=Var34->memberVar8&&Var34->memberVar8->memberVar1; while (Var97  Var103&&*memberVar1){if (Var34->memberVar8){Var34->memberVar8->memberVar1=false ; if (Var111&&Var34->memberVar9 >= 0){if (Var34->memberVar9 ==  Var34->memberVar10){Var34->memberVar8->memberVar1=true ; }}}if (FUNC38()){char *Var112=strdup(Var110); Var34->memberVar11=false ; Var38=FUNC28(Var34,memberVar1,Var72,(Var97 ==  Var98-1)&memberVar7 NULL ); static int FUNC28(STRUCT1 *Var34,char *memberVar1,char *Var72,bool *memberVar7){STRUCT4 *Var74=FUNC29(Var75); const char *Var76=STRING; const char *Var77=NULL ; char *Var78,*Var79,*Var80; char *Var81=NULL ; char *Var82=NULL ; STRUCT13 *Var83=NULL ; int  Var84=!Var34->memberVar2->memberVar1; int  Var16,Var38=0,Var85; bool  Var86=false ; int  Var87=-1; int  Var88=-1; bool  Var89=false ; bool  Var90=false ; bool  Var91=Var34->memberVar4; bool  Var92=Var34->memberVar5; bool  Var93=false ; STRUCT2  Var94=Var34->memberVar6; int  Var95=-1; if (!memberVar1){FUNC30(Var74); return 0; }memberVar1=FUNC31(memberVar1); Var125  STRUCT23  Var78=strchr(memberVar1,); if (Var78){if (Var78>memberVar1){bool  Var126=false ; int  Var127=1; if (Var78[1]== ){Var79=strchr(Var78+1,); if (Var126){}else if (!Var79){}else {int  Var128=Var34->memberVar17->memberVar1; *Var78=0; *Var79=0; if (Var78[1]== !){Var80=FUNC50(Var34,Var78+1); static char *FUNC50(STRUCT1 *Var34,const char *memberVar1){char *Var18,*Var129=NULL ; if (FUNC40(0)){char *Var124=(*memberVar1 != STRING memberVar1 STRING Var130/memberVar1/STRING Var131 STRING Var131/1.0%Var107%Var18  Var1  Var108%Var18 STRING,200,STRING,STRING,-1); return FUNC49(Var34,memberVar1); }STRUCT2  Var132=Var34->memberVar18; Var100=strdup(memberVar1); if (Var34->memberVar19-Var34->memberVar16->memberVar1->memberVar1 == 1){Var34->memberVar20=Var34->memberVar18; }memberVar1=FUNC31(Var100); if (*memberVar1 != STRINGSTRINGSTRINGSTRING!STRING Var133 system Var134 STRING Var135 system Var136  STRUCT24  Var108); return -1; }if  Var137 if  STRUCT25 if (Var108){return system(Var138); "
    }
]