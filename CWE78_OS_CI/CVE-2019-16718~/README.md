# 📁 CVE-2019-16718

**🔗 [커밋 링크](https://github.com/radareorg/radare2/commit/dd739f5a45b3af3d1f65f00fe19af1dbfec7aea7)** | **🔗 [CVE 링크](https://www.cvedetails.com/cve/CVE-2019-16718)** | **🔗 [CWE 링크](https://cwe.mitre.org/data/definitions/78.html)** 

> WARNING of joern parser 
>```bash
>(.ksign_slicer) root@0c13b466fbd1:/KSignSlicer# tools/ReVeal/code-slicer/joern/>joern-parse data/converged/CVE-2019-16718     && mv parsed/data/converged/>CVE-2019-16718/ data/cpg.csv/     && rm data/cpg.csv/CVE-2019-16718/*.csv     && rm -rf >parsed
>data/converged/CVE-2019-16718/after_cmd.c
>warning: unresolved break statement
>data/converged/CVE-2019-16718/before_cmd.c
>warning: unresolved break statement
>```

| 총 슬라이스 수* |  정탐 | 미탐 |
| --------  | -- | -- |
| 2개       | 0개 | 2개 |

\* cve 설명에 나온 취약한 함수에 대한 슬라이스만 고려


아래는 커밋 메시지
	> "?e hello""?e world"
	hello
	world"
	> "?e hello";"?e world"
	hello
	world

r_cons_printf를 해서 출력하면, I.context(현재 콘솔 컨텍스트)의 버퍼에 내용을 출력한다.
r_cons_get_buffer()를 통해서 그 내용을 가져올 수 있다.

출처: https://bananamafia.dev/post/r2-pwndebian/

r_core_cmd0 (core, ".is*");

터미널에 `f sym.imp.getxattr 16 0x00000000`

`f sym.imp.`! sleep 999` 16 0x0` 왼쪽과 같은 페이로드가 있으면 트리거!

이 CVE 취약점을 유발하는 코드(sink:cbin.c:2216)는 아래와 같다.
```c
/* libr/core/cmd.c:2086 */
static int cmd_system(void *data, const char *input) {
	RCore *core = (RCore*)data;
	ut64 n;
	int ret = 0;
	switch (*input) {
	default:
		n = atoi (input);
		if (*input == '0' || n > 0) {
		} else {
			char *cmd = r_core_sysenv_begin (core, input);
			if (cmd) {
				void *bed = r_cons_sleep_begin ();
				ret = r_sys_cmd (cmd);

/* libr/util/sys.c:799 */
R_API int r_sys_cmd(const char *str) {
	if (r_sandbox_enable (0)) {
		return false;
	}
	return r_sandbox_system (str, 1);

/* libr/util/sandbox.c:185 */
R_API int r_sandbox_system (const char *x, int n) {
	if (enabled) {
		eprintf ("sandbox: system call disabled\n");
		return -1;
	}
#if LIBC_HAVE_FORK
#if LIBC_HAVE_SYSTEM
	if (n) {
		return system (x);
```
이 코드에서 Ksign 슬라이서 도구가 추출했어야 하는 슬라이스를 직접 작성해보면 다음과 같다.
```c
/* cbin.c:2043 */
static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {
	RBinInfo *info = r_bin_get_info (r->bin);
	RList *entries = r_bin_get_entries (r->bin);
	RBinSymbol *symbol;
	RBinAddr *entry;
	RListIter *iter;
	bool firstexp = true;
	bool printHere = false;
	int i = 0, lastfs = 's';
	bool bin_demangle = r_config_get_i (r->config, "bin.demangle");
	if (!info) {
		return 0;
	}

	if (args && *args == '.') {
		printHere = true;
	}

	bool is_arm = info && info->arch && !strncmp (info->arch, "arm", 3);
	const char *lang = bin_demangle ? r_config_get (r->config, "bin.lang") : NULL;

	RList *symbols = r_bin_get_symbols (r->bin);

	/* cbin.c:2073 */
	size_t count = 0;
	r_list_foreach (symbols, iter, symbol) {
		if (!symbol->name) {
			continue;
		}
		char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);

	/* cbin.c:2216 */
	const char *name = sn.demname? sn.demname: r_symbol_name;
	if (!name) {
		goto next;
	}
	if (!strncmp (name, "imp.", 4)) {
		if (lastfs != 'i') {
			r_cons_printf ("fs imports\n");
		}
		lastfs = 'i';
	} else {
		if (lastfs != 's') {
			const char *fs = exponly? "exports": "symbols";
			r_cons_printf ("fs %s\n", fs);
		}
		lastfs = 's';
	}
	if (r->bin->prefix || *name) { // we don't want unnamed symbol flags
		char *flagname = construct_symbol_flagname ("sym", name, MAXFLAG_LEN_DEFAULT);
		if (!flagname) {
			goto next;
		}
		r_cons_printf ("\"f %s%s%s %u 0x%08" PFMT64x "\"\n",
			r->bin->prefix ? r->bin->prefix : "", r->bin->prefix ? "." : "",
			flagname, symbol->size, addr);

/* libr/core/cbin.c:3811 */
R_API int r_core_bin_info(RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {
	int ret = true;
	const char *name = NULL;
	ut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);
	if (filter && filter->offset) {
	if (filter && filter->name) {

	// use our internal values for va
	va = va ? VA_TRUE : VA_FALSE;
	if ((action & R_CORE_BIN_ACC_STRINGS)) {
	if ((action & R_CORE_BIN_ACC_RAW_STRINGS)) {
	if ((action & R_CORE_BIN_ACC_INFO)) {
	if ((action & R_CORE_BIN_ACC_MAIN)) {
	if ((action & R_CORE_BIN_ACC_DWARF)) {
	if ((action & R_CORE_BIN_ACC_PDB)) {
	if ((action & R_CORE_BIN_ACC_SOURCE)) {
	if ((action & R_CORE_BIN_ACC_ENTRIES)) {
	if ((action & R_CORE_BIN_ACC_INITFINI)) {
	if ((action & R_CORE_BIN_ACC_SECTIONS)) {
	if ((action & R_CORE_BIN_ACC_SEGMENTS)) {
	if (r_config_get_i (core->config, "bin.relocs")) {
		if ((action & R_CORE_BIN_ACC_RELOCS)) {
	}
	if ((action & R_CORE_BIN_ACC_LIBS)) {
	if ((action & R_CORE_BIN_ACC_IMPORTS)) { // 5s
	if ((action & R_CORE_BIN_ACC_EXPORTS)) {
		ret &= bin_symbols (core, mode, loadaddr, va, at, name, true, chksum);
	}
	if ((action & R_CORE_BIN_ACC_SYMBOLS)) { // 6s
		ret &= bin_symbols (core, mode, loadaddr, va, at, name, false, chksum);

/* libr/core/cmd_info.c:571 */ 
static int cmd_info(void *data, const char *input) {
	RCore *core = (RCore *) data;
	bool newline = r_cons_is_interactive ();
	int fd = r_io_fd_get_current (core->io);
	RIODesc *desc = r_io_desc_get (core->io, fd);
	int i, va = core->io->va || core->io->debug;
	int mode = 0; //R_MODE_SIMPLE;
	bool rdump = false;
	int is_array = 0;
	Sdb *db;

	for (i = 0; input[i] && input[i] != ' '; i++)
		;
	if (i > 0) {
		switch (input[i - 1]) {
		case '*': mode = R_MODE_RADARE; break;
		case 'j': mode = R_MODE_JSON; break;
		case 'q': mode = R_MODE_SIMPLE; break;
		}
	}
	if (mode == R_MODE_JSON) {
		int suffix_shift = 0;
		if (!strncmp (input, "SS", 2) || !strncmp (input, "ee", 2)
			|| !strncmp (input, "zz", 2)) {
			suffix_shift = 1;
		}
		if (strlen (input + 1 + suffix_shift) > 1) {
			is_array = 1;
		}
	}
	if (is_array) {
		r_cons_printf ("{");
	}
	if (!*input) {
		cmd_info_bin (core, va, mode);
	}
	/* i* is an alias for iI* */
	if (!strcmp (input, "*")) {
		input = "I*";
	}
	char *question = strchr (input, '?');
	const char *space = strchr (input, ' ');
	if (!space) {
		space = question + 1;
	}
	if (question < space && question > input) {
	while (*input) {
		switch (*input) {
		case 'o': // "io"
		{
			if (!desc) {
				eprintf ("Core file not open\n");
				return 0;
			}
			const char *fn = input[1] == ' '? input + 2: desc->name;
			ut64 baddr = r_config_get_i (core->config, "bin.baddr");
			r_core_bin_load (core, fn, baddr);
		}
		break;
			#define RBININFO(n,x,y,z)\
				if (is_array) {\
					if (is_array == 1) { is_array++;\
					} else { r_cons_printf (",");}\
					r_cons_printf ("\"%s\":",n);\
				}\
				if (z) { playMsg (core, n, z);}\
				r_core_bin_info (core, x, mode, va, NULL, y);

/* libr/core/cmd_info.c:793 */ 
static int cmd_info(void *data, const char *input) {
	RCore *core = (RCore *) data;
	bool newline = r_cons_is_interactive ();
	int fd = r_io_fd_get_current (core->io);
	RIODesc *desc = r_io_desc_get (core->io, fd);
	int i, va = core->io->va || core->io->debug;
	int mode = 0; //R_MODE_SIMPLE;
	bool rdump = false;
	int is_array = 0;
	Sdb *db;

	for (i = 0; input[i] && input[i] != ' '; i++)
		;
	if (i > 0) {
		switch (input[i - 1]) {
		case '*': mode = R_MODE_RADARE; break;
		case 'j': mode = R_MODE_JSON; break;
		case 'q': mode = R_MODE_SIMPLE; break;
		}
	}
	if (mode == R_MODE_JSON) {
		int suffix_shift = 0;
		if (!strncmp (input, "SS", 2) || !strncmp (input, "ee", 2)
			|| !strncmp (input, "zz", 2)) {
			suffix_shift = 1;
		}
		if (strlen (input + 1 + suffix_shift) > 1) {
			is_array = 1;
		}
	}
	if (is_array) {
		r_cons_printf ("{");
	}
	if (!*input) {
		cmd_info_bin (core, va, mode);
	}
	/* i* is an alias for iI* */
	if (!strcmp (input, "*")) {
		input = "I*";
	}
	char *question = strchr (input, '?');
	const char *space = strchr (input, ' ');
	if (!space) {
		space = question + 1;
	}
	if (question < space && question > input) {
	while (*input) {
		switch (*input) { // *input = "s*"
		case 's': { // "is"
			RBinObject *obj = r_bin_cur_object (core->bin);
			// Case for isj.
			if (input[1] == 'j' && input[2] == '.') {
				mode = R_MODE_JSON;
				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 2, (obj && obj->symbols)? r_list_length (obj->symbols): 0);
			} else if (input[1] == 'q' && input[2] == 'q') {
				mode = R_MODE_SIMPLEST;
				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);
			} else if (input[1] == 'q' && input[2] == '.') {
				mode = R_MODE_SIMPLE;
				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 2, 0);
			} else {
				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);

/* libr/core/cmd.c:4734 */
R_API void r_core_cmd_init(RCore *core) {
	struct {
		const char *cmd;
		const char *description;
		int (*callback)(void *data, const char *input)
		int (*cb)(void *data, const char *input)
	} cmds[] = {
		{"info",     "get file info", cmd_info, cmd_info_init},
	...
		for (i = 0; i < R_ARRAY_SIZE (cmds); i++) {
		r_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);
	}

/* libr/core/cmd_api.c:244 */
R_API int r_cmd_call(RCmd *cmd, const char *input) {
	struct r_cmd_item_t *c;
	int ret = -1;
	RListIter *iter;
	RCorePlugin *cp;
	r_return_val_if_fail (cmd && input, -1);
	if (!*input) {
	} else {
		char *nstr = NULL;
		const char *ji = r_cmd_alias_get (cmd, input, 1);
		if (ji) {
		}
		r_list_foreach (cmd->plist, iter, cp) {
		}
		if (!*input) {
		}
		c = cmd->cmds[((ut8)input[0]) & 0xff];
		if (c && c->callback) {
			const char *inp = (*input)? input + 1: ""; // *input = "is*", *inp = "s*"
			ret = c->callback (cmd->data, inp);

/* libr/core/cmd.c:3538 */
static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {
	RList *tmpenvs = r_list_newf (tmpenvs_free);
	const char *quotestr = "`";
	const char *tick = NULL;
	char *ptr, *ptr2, *str;
	char *arroba = NULL;
	char *grep = NULL;
	RIODesc *tmpdesc = NULL;
	int pamode = !core->io->va;
	int i, ret = 0, pipefd;
	bool usemyblock = false;
	int scr_html = -1;
	int scr_color = -1;
	bool eos = false;
	bool haveQuote = false;
	bool oldfixedarch = core->fixedarch;
	bool oldfixedbits = core->fixedbits;
	bool cmd_tmpseek = false;
	ut64 tmpbsz = core->blocksize;
	int cmd_ignbithints = -1;

	if (!cmd) {
		r_list_free (tmpenvs);
		return 0;
	}
	cmd = r_str_trim_head_tail (cmd);
	...
	
fuji:
	rc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;

/* libr/core/cmd.c:2418 */
static int r_core_cmd_subst(RCore *core, char *cmd) {
	ut64 rep = strtoull (cmd, NULL, 10);
	int ret = 0, orep;
	char *cmt, *colon = NULL, *icmd = NULL;
	bool tmpseek = false;
	bool original_tmpseek = core->tmpseek;

	if (r_str_startswith (cmd, "GET /cmd/")) {
		memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);
		char *http = strstr (cmd, "HTTP");
		if (http) {
			*http = 0;
			http--;
			if (*http == ' ') {
				*http = 0;
			}
		}
		r_cons_printf ("HTTP/1.0 %d %s\r\n%s"
				"Connection: close\r\nContent-Length: %d\r\n\r\n",
				200, "OK", "", -1);
		return r_core_cmd0 (core, cmd);
	}

	/* must store a local orig_offset because there can be
	* nested call of this function */
	ut64 orig_offset = core->offset;
	icmd = strdup (cmd);

	if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {
		core->prompt_offset = core->offset;
	}
	cmd = r_str_trim_head_tail (icmd);
	if (*cmd != '"') {
	} else {
		colon = NULL;
	}
	if (rep > 0) {
		while (IS_DIGIT (*cmd)) {
			cmd++;
		}
		// do not repeat null cmd
		if (!*cmd) {
	}
	if (rep < 1) {
		rep = 1;
	}
	// XXX if output is a pipe then we don't want to be interactive
	if (rep > 1 && r_sandbox_enable (0)) {
	} else {
	}
	// TODO: store in core->cmdtimes to speedup ?
	const char *cmdrep = core->cmdtimes ? core->cmdtimes: "";
	orep = rep;

	r_cons_break_push (NULL, NULL);

	int ocur_enabled = core->print && core->print->cur_enabled;
	while (rep-- && *cmd) {
		if (core->print) {
			core->print->cur_enabled = false;
			if (ocur_enabled && core->seltab >= 0) {
				if (core->seltab == core->curtab) {
					core->print->cur_enabled = true;
				}
			}
		}
		if (r_cons_is_breaked ()) {
		char *cr = strdup (cmdrep);
		core->break_loop = false;
		ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);

/* libr/core/cmd.c:4373 */
R_API int r_core_cmd(RCore *core, const char *cstr, int log) {
	char *cmd, *ocmd, *ptr, *rcmd;
	int ret = false, i;

	if (core->cmdfilter) {
		const char *invalid_chars = ";|>`@";
		for (i = 0; invalid_chars[i]; i++) {
			if (strchr (cstr, invalid_chars[i])) {
		}
		if (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {
	}
	if (core->cmdremote) {
		if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, "!=", 2)) {
	}

	if (!cstr || (*cstr == '|' && cstr[1] != '?')) {
	if (!strncmp (cstr, "/*", 2)) {
		if (r_sandbox_enable (0)) {
		core->incomment = true;
	} else if (!strncmp (cstr, "*/", 2)) {
	if (core->incomment) {
	if (log && (*cstr && (*cstr != '.' || !strncmp (cstr, ".(", 2)))) {
		free (core->lastcmd);
		core->lastcmd = strdup (cstr);
	}

	ocmd = cmd = malloc (strlen (cstr) + 4096);
	if (!ocmd) {
	r_str_cpy (cmd, cstr);
	if (log) {
		r_line_hist_add (cstr);
	}

	if (core->cons->context->cmd_depth < 1) {
	core->cons->context->cmd_depth--;
	for (rcmd = cmd;;) {
		ptr = strchr (rcmd, '\n');
		if (ptr) {
			*ptr = '\0';
		}
		ret = r_core_cmd_subst (core, rcmd);


/* libr/core/cmd.c:4623 */
/* return: pointer to a buffer with the output of the command */
R_API char *r_core_cmd_str(RCore *core, const char *cmd) {
	const char *static_str;
	char *retstr = NULL;
	r_cons_push ();
	if (r_core_cmd (core, cmd, 0) == -1) {

// is*
/* libr/core/cmd.c:1231 */
static int cmd_interpret(void *data, const char *input) {
	char *str, *ptr, *eol, *rbuf, *filter, *inp;
	const char *host, *port, *cmd;
	RCore *core = (RCore *)data;

	switch (*input) {
	default:
		if (*input >= 0 && *input <= 9) {
			eprintf ("|ERROR| No .[0..9] to avoid infinite loops\n");
			break;
		}
		inp = strdup (input);
		filter = strchr (inp, '~');
		if (filter) {
		int tmp_html = r_cons_singleton ()->is_html;
		r_cons_singleton ()->is_html = 0;
		ptr = str = r_core_cmd_str (core, inp); // *inp = "is*"
		// *(ptr) = "f sym.imp.`! sleep 999` 16 0x0\nf sym.imp.`! sleep 999` 16 0x0\nf sym.imp.`! sleep 999` 16 0x0\n"

		r_cons_singleton ()->is_html = tmp_html;

		if (filter) {
		r_cons_break_push (NULL, NULL);
		if (ptr) {
			for (;;) {
				if (r_cons_is_breaked ()) {
					break;
				}
				eol = strchr (ptr, '\n');
				if (eol) {
					*eol = '\0';
				}
				if (*ptr) {
					// *(ptr) = "f sym.imp.`! sleep 999` 16 0x0\0"
					char *p = r_str_append (strdup (ptr), filter); 
					r_core_cmd0 (core, p);

                    
/* f sym.imp.`! sleep 999` 16 0x0 */
/* libr/core/cmd.c:4538 */
R_API int r_core_cmd0(RCore *core, const char *cmd) {
	return r_core_cmd (core, cmd, 0);

/* libr/core/cmd.c:4373 */
R_API int r_core_cmd(RCore *core, const char *cstr, int log) {
	char *cmd, *ocmd, *ptr, *rcmd;
	int ret = false, i;

	if (core->cmdfilter) {
		const char *invalid_chars = ";|>`@";
		for (i = 0; invalid_chars[i]; i++) {
			if (strchr (cstr, invalid_chars[i])) {
		}
		if (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {
	}
	if (core->cmdremote) {
		if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, "!=", 2)) {
	}

	if (!cstr || (*cstr == '|' && cstr[1] != '?')) {
	if (!strncmp (cstr, "/*", 2)) {
		if (r_sandbox_enable (0)) {
		}
		core->incomment = true;
	} else if (!strncmp (cstr, "*/", 2)) {
	}
	if (core->incomment) {
	}
	if (log && (*cstr && (*cstr != '.' || !strncmp (cstr, ".(", 2)))) {
		free (core->lastcmd);
		core->lastcmd = strdup (cstr);
	}

	ocmd = cmd = malloc (strlen (cstr) + 4096);
	if (!ocmd) {
	r_str_cpy (cmd, cstr);
	if (log) {

	if (core->cons->context->cmd_depth < 1) {
	core->cons->context->cmd_depth--;
	for (rcmd = cmd;;) {
		ptr = strchr (rcmd, '\n'); 
		if (ptr) {
			*ptr = '\0';
		}
		ret = r_core_cmd_subst (core, rcmd);
    
/* libr/core/cmd.c:2418 */
static int r_core_cmd_subst(RCore *core, char *cmd) {
	ut64 rep = strtoull (cmd, NULL, 10);
	int ret = 0, orep;
	char *cmt, *colon = NULL, *icmd = NULL;
	bool tmpseek = false;
	bool original_tmpseek = core->tmpseek;

	if (r_str_startswith (cmd, "GET /cmd/")) {
		memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);
		char *http = strstr (cmd, "HTTP");
		if (http) {
			*http = 0;
			http--;
			if (*http == ' ') {
				*http = 0;
			}
		}
		r_cons_printf ("HTTP/1.0 %d %s\r\n%s"
				"Connection: close\r\nContent-Length: %d\r\n\r\n",
				200, "OK", "", -1);
		return r_core_cmd0 (core, cmd);
	}

	/* must store a local orig_offset because there can be
	 * nested call of this function */
	ut64 orig_offset = core->offset;
	icmd = strdup (cmd);

	if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {
		core->prompt_offset = core->offset;
	}
	cmd = r_str_trim_head_tail (icmd);
	if (*cmd != '"') {
	} else {
		colon = NULL;
	}
	if (rep > 0) {
		while (IS_DIGIT (*cmd)) {
			cmd++;
		}
		// do not repeat null cmd
		if (!*cmd) {
	}
	if (rep < 1) {
		rep = 1;
	}
	// XXX if output is a pipe then we don't want to be interactive
	if (rep > 1 && r_sandbox_enable (0)) {
	} else {
	}
	// TODO: store in core->cmdtimes to speedup ?
	const char *cmdrep = core->cmdtimes ? core->cmdtimes: "";
	orep = rep;

	r_cons_break_push (NULL, NULL);

	int ocur_enabled = core->print && core->print->cur_enabled;
	while (rep-- && *cmd) {
		if (core->print) {
			core->print->cur_enabled = false;
			if (ocur_enabled && core->seltab >= 0) {
				if (core->seltab == core->curtab) {
					core->print->cur_enabled = true;
				}
			}
		}
		if (r_cons_is_breaked ()) {
		char *cr = strdup (cmdrep);
		core->break_loop = false;
		ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);

/* libr/core/cmd.c:3017 */
static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {
	RList *tmpenvs = r_list_newf (tmpenvs_free);
	const char *quotestr = "`";
	const char *tick = NULL;
	char *ptr, *ptr2, *str;
	char *arroba = NULL;
	char *grep = NULL;
	RIODesc *tmpdesc = NULL;
	int pamode = !core->io->va;
	int i, ret = 0, pipefd;
	bool usemyblock = false;
	int scr_html = -1;
	int scr_color = -1;
	bool eos = false;
	bool haveQuote = false;
	bool oldfixedarch = core->fixedarch;
	bool oldfixedbits = core->fixedbits;
	bool cmd_tmpseek = false;
	ut64 tmpbsz = core->blocksize;
	int cmd_ignbithints = -1;

	if (!cmd) {
		r_list_free (tmpenvs);
		return 0;
	}
	cmd = r_str_trim_head_tail (cmd);
escape_redir:
next2:
	/* sub commands */
	ptr = strchr (cmd, '`'); // *(ptr) = '`!id', ptr는 실행할 명령어, *(cmd) = "f sym.imp.`! sleep 999` 16 0x0"
	if (ptr) {
		if (ptr > cmd) {
		bool empty = false;
		int oneline = 1;
		if (ptr[1] == '`') {
		ptr2 = strchr (ptr + 1, '`');
		if (empty) {
			/* do nothing */
		} else if (!ptr2) {
		} else {
			int value = core->num->value;
			*ptr = '\0';
			*ptr2 = '\0';
			if (ptr[1] == '!') { 
				str = r_core_cmd_str_pipe (core, ptr + 1); // *(ptr + 1) = '!id', ptr는 실행할 명령어

/* libr/core/cmd.c:4585 */
R_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {
	char *s, *tmp = NULL;
	if (r_sandbox_enable (0)) {
		char *p = (*cmd != '"')? strchr (cmd, '|'): NULL;
		if (p) {
		}
		return r_core_cmd_str (core, cmd);
	}
	r_cons_reset ();
	r_sandbox_disable (1);
	if (r_file_mkstemp ("cmd", &tmp) != -1) {
		int pipefd = r_cons_pipe_open (tmp, 1, 0);
		if (pipefd == -1) {
		char *_cmd = strdup (cmd);
		r_core_cmd_subst (core, _cmd);

/* libr/core/cmd.c:2418 */
static int r_core_cmd_subst(RCore *core, char *cmd) {
	ut64 rep = strtoull (cmd, NULL, 10);
	int ret = 0, orep;
	char *cmt, *colon = NULL, *icmd = NULL;
	bool tmpseek = false;
	bool original_tmpseek = core->tmpseek;

	if (r_str_startswith (cmd, "GET /cmd/")) {
		memmove (cmd, cmd + 9, strlen (cmd + 9) + 1);
		char *http = strstr (cmd, "HTTP");
		if (http) {
			*http = 0;
			http--;
			if (*http == ' ') {
				*http = 0;
			}
		}
		r_cons_printf ("HTTP/1.0 %d %s\r\n%s"
				"Connection: close\r\nContent-Length: %d\r\n\r\n",
				200, "OK", "", -1);
		return r_core_cmd0 (core, cmd);
	}

	/* must store a local orig_offset because there can be
	 * nested call of this function */
	ut64 orig_offset = core->offset;
	icmd = strdup (cmd);

	if (core->max_cmd_depth - core->cons->context->cmd_depth == 1) {
		core->prompt_offset = core->offset;
	}
	cmd = r_str_trim_head_tail (icmd);
	if (*cmd != '"') {
	} else {
		colon = NULL;
	}
	if (rep > 0) {
		while (IS_DIGIT (*cmd)) {
			cmd++;
		}
		// do not repeat null cmd
		if (!*cmd) {
	}
	if (rep < 1) {
		rep = 1;
	}
	// XXX if output is a pipe then we don't want to be interactive
	if (rep > 1 && r_sandbox_enable (0)) {
	} else {
	}
	// TODO: store in core->cmdtimes to speedup ?
	const char *cmdrep = core->cmdtimes ? core->cmdtimes: "";
	orep = rep;

	r_cons_break_push (NULL, NULL);

	int ocur_enabled = core->print && core->print->cur_enabled;
	while (rep-- && *cmd) {
		if (core->print) {
			core->print->cur_enabled = false;
			if (ocur_enabled && core->seltab >= 0) {
				if (core->seltab == core->curtab) {
					core->print->cur_enabled = true;
				}
			}
		}
		if (r_cons_is_breaked ()) {
		char *cr = strdup (cmdrep);
		core->break_loop = false;
		ret = r_core_cmd_subst_i (core, cmd, colon, (rep == orep - 1) ? &tmpseek : NULL);

/* libr/core/cmd.c:3538 */
static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek) {
	RList *tmpenvs = r_list_newf (tmpenvs_free);
	const char *quotestr = "`";
	const char *tick = NULL;
	char *ptr, *ptr2, *str;
	char *arroba = NULL;
	char *grep = NULL;
	RIODesc *tmpdesc = NULL;
	int pamode = !core->io->va;
	int i, ret = 0, pipefd;
	bool usemyblock = false;
	int scr_html = -1;
	int scr_color = -1;
	bool eos = false;
	bool haveQuote = false;
	bool oldfixedarch = core->fixedarch;
	bool oldfixedbits = core->fixedbits;
	bool cmd_tmpseek = false;
	ut64 tmpbsz = core->blocksize;
	int cmd_ignbithints = -1;

	if (!cmd) {
		r_list_free (tmpenvs);
		return 0;
	}
	cmd = r_str_trim_head_tail (cmd);
    ...
	
fuji:
	rc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;


/* libr/core/cmd_api.c:244 */
R_API int r_cmd_call(RCmd *cmd, const char *input) {
	struct r_cmd_item_t *c;
	int ret = -1;
	RListIter *iter;
	RCorePlugin *cp;
	r_return_val_if_fail (cmd && input, -1);
	if (!*input) {
	} else {
		char *nstr = NULL;
		const char *ji = r_cmd_alias_get (cmd, input, 1);
		if (ji) {
		}
		r_list_foreach (cmd->plist, iter, cp) {
		}
		if (!*input) {
		}
		c = cmd->cmds[((ut8)input[0]) & 0xff];
		if (c && c->callback) {
			const char *inp = (*input)? input + 1: ""; // input = '{모르는 문자 1개}id', input는 실행할 명령어
			ret = c->callback (cmd->data, inp);

/*
	libr/core/cmd_api.c:199
	R_API int r_cmd_add(RCmd *c, const char *cmd, const char *desc, r_cmd_callback(cb)) {
		int idx = (ut8)cmd[0];
		RCmdItem *item = c->cmds[idx];
		if (!item) {
			item = R_NEW0 (RCmdItem);
			c->cmds[idx] = item;
		}
		strncpy (item->cmd, cmd, sizeof (item->cmd)-1);
		strncpy (item->desc, desc, sizeof (item->desc)-1);
		item->callback = cb;
*/

/* libr/core/cmd.c:4734 */
R_API void r_core_cmd_init(RCore *core) {
	struct {
		const char *cmd;
		const char *description;
		int (*callback)(void *data, const char *input)
		int (*cb)(void *data, const char *input)
	} cmds[] = {
		{"!",        "run system command", cmd_system},
    ...
    	for (i = 0; i < R_ARRAY_SIZE (cmds); i++) {
		r_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);
	}

/* libr/core/cmd.c:2086 */
static int cmd_system(void *data, const char *input) {
	RCore *core = (RCore*)data;
	ut64 n;
	int ret = 0;
	switch (*input) {
	default:
		n = atoi (input);
		if (*input == '0' || n > 0) {
		} else {
			char *cmd = r_core_sysenv_begin (core, input);
			if (cmd) {
				void *bed = r_cons_sleep_begin ();
				ret = r_sys_cmd (cmd);

/* libr/util/sys.c:799 */
R_API int r_sys_cmd(const char *str) {
	if (r_sandbox_enable (0)) {
		return false;
	}
	return r_sandbox_system (str, 1);

/* libr/util/sandbox.c:185 */
R_API int r_sandbox_system (const char *x, int n) {
	if (enabled) {
		eprintf ("sandbox: system call disabled\n");
		return -1;
	}
#if LIBC_HAVE_FORK
#if LIBC_HAVE_SYSTEM
	if (n) {
		return system (x);


// x = 'id', x는 실행할 명령어
```
이 슬라이스를 수동으로 Ksign 모델에 적용해서 결과를 탐지해보았더니 정상으로 예측했다.

## 🔍 취약점 설명
> radare2 라는 실행 파일 리버싱 프로그램의 실행 파일 분석 기능에 있는 libr/core/cbin.c:bin_symbols()에서 발생한 OS Command Injection 취약점입니다.

* **취약 조건**: 입력값 검증 부재
* **취약 동작**: 입력값을 검증하지 않고 `system()` / `execl()` / 등의 위험한 함수 혹은 구문에 사용


### ❗️ 취약 코드

**문제점**:
사용자 입력이 적절히 검증되지 않은 채로 `system()` 함수의 인자로 사용되어 **명령어 인젝션**이 발생할 수 있음.

#### Sink: `CWE78_OS_Command_Injection__wchar_t_console_execl_53d.c:50`
```c
void CWE78_OS_Command_Injection__wchar_t_console_execl_53d_badSink(wchar_t * data)
{
    /* wexecl - specify the path where the command is located */
    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);  /* POTENTIAL FLAW */
}
```


### ✅ 개선 코드

**패치 위치**: `파일명:줄번호`

```c
// 개선된 코드
char *input = getenv("USER_INPUT");
if (is_safe(input)) {
    system(input);
}
```

**개선 방법**:

* 입력값에 대해 필터링 또는 화이트리스트 검증을 추가하여 위험한 문자열을 제거
* 또는, `system()` 함수 대신 안전한 API 사용 고려

## SARD와 탐지 결과 비교
KSignSlicer의 AI 모델은 SARD CWE78에 대해 이러한 경우 취약으로 탐지해왔습니다. 그런데 이 취약점은 이러 이러한 사유로 이렇게 탐지된 것으로 보입니다.