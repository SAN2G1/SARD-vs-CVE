[
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 0,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 98,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nFUNC3(Var2); \nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \nFUNC3(Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 1,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 98,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nFUNC3(Var2); \nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \nFUNC3(Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 2,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 101,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nFUNC3(Var2); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nFUNC3(Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 3,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fopen",
    "line": 102,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nFUNC3(Var2); \nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC4(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \nFUNC3(Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 4,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 110,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 5,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 111,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 6,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 111,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 7,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 112,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 8,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 113,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 9,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 114,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 10,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 115,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 11,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 116,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 12,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 117,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nsnprintf(Var2,Var3,STRING,Var1,STRUCT1->memberVar1); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING STRUCT3 STRING,FUNC2(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 13,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fprintf",
    "line": 118,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "build_config",
    "Source": false,
    "Sink": false,
    "idx": 14,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 119,
    "label": -3,
    "slices": [
      "build_config(char *prefix, struct server *server)\n",
      "    char *path    = NULL;\n",
      "    int path_size = strlen(prefix) + strlen(server->port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"w+\");\n",
      "    if (f == NULL) {\n",
      "    fprintf(f, \"{\\n\");\n",
      "    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n",
      "    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n",
      "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n",
      "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n",
      "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n",
      "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n",
      "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n",
      "    fprintf(f, \"\\n}\\n\");\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,struct STRUCT1 *STRUCT1)\nchar *Var2=NULL ; \nint  Var3=strlen(Var1)+strlen(STRUCT1->memberVar1)+20; \nVar2=FUNC2(Var3); \nSTRUCT2 *Var4=fopen(Var2,STRING); \nif (Var4 == NULL ){\nfprintf(Var4,STRING); \nfprintf(Var4,STRING STRUCT3 STRING,FUNC3(STRUCT1->memberVar1)); \nfprintf(Var4,STRING STRUCT4 STRING%STRUCT5 STRING,STRUCT1->memberVar2); \nif (STRUCT1->memberVar3[0]) fprintf(Var4,STRING memberVar3 STRING,STRUCT1->memberVar3); \nif (STRUCT1->memberVar4) fprintf(Var4,STRING memberVar4 STRING%STRUCT5 STRING,STRUCT1->memberVar4); \nif (STRUCT1->memberVar5) fprintf(Var4,STRING memberVar5 STRING%STRUCT5 STRING,STRUCT1->memberVar5); \nif (STRUCT1->memberVar6) fprintf(Var4,STRING memberVar6 STRING%STRUCT5 STRING,STRUCT1->memberVar6); \nif (STRUCT1->memberVar7) fprintf(Var4,STRING memberVar7 STRING%STRUCT5 STRING,STRUCT1->memberVar7); \nfprintf(Var4,STRING); \nfclose(Var4); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 15,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 133,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 16,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 134,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    build_config(working_dir, server);\n",
      "    if (server->method) method = server->method;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nFUNC2(Var6,STRUCT2); \nif (STRUCT2->memberVar1) memberVar1=STRUCT2->memberVar1; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar7,memberVar1,Var1->memberVar2,\nVar6,STRUCT2->memberVar2,Var6,STRUCT2->memberVar2); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar4[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar6 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC3(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 17,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 140,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 18,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 141,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 19,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 144,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 20,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 145,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 21,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 149,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 22,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 150,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 23,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 154,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 24,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 155,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 25,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 158,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 26,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 159,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 27,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 162,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 28,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 163,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 29,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 166,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 30,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 167,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 31,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 170,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 32,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 171,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 33,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 174,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 34,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 175,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 35,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 178,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 36,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 179,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 37,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 182,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 38,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 183,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 39,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 186,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 40,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 187,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 41,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 190,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 42,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 191,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 43,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 194,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 44,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 195,
    "label": -3,
    "slices": [
      "construct_command_line(struct manager_ctx *manager, struct server *server)\n",
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nstatic char  Var2[Var3]; \nchar *Var4=Var1->memberVar1; \nint  Var5; \nmemset(Var2,0,Var3); \nsnprintf(Var2,Var3,\nSTRING,\nVar6,memberVar1,Var1->memberVar2,\nVar7,STRUCT2->memberVar1,Var7,STRUCT2->memberVar1); \nif (Var1->memberVar3 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar3); \nif (Var1->memberVar4 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar4); \nif (Var1->memberVar5){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar5); \nif (Var1->memberVar6 != NULL ){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar6); \nif (Var1->memberVar7){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar2 == NULL &&Var1->memberVar8 ==  Var10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (STRUCT2->memberVar3[0]== 0&&Var1->memberVar9){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar10){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (Var1->memberVar11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar11); \nif (STRUCT2->memberVar4 == NULL &&Var1->memberVar12){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar12); \nif (STRUCT2->memberVar5 == NULL &&Var1->memberVar13){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING%STRUCT3 STRING,Var1->memberVar13); \nfor (Var5=0; Var5<Var1->memberVar14; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar15[Var5]); \nfor (Var5=0; Var5<Var1->memberVar16; Var5  Var11){\nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING,Var1->memberVar17[Var5]); \nint  Var8=strlen(Var2); \nsnprintf(Var2+Var8,Var3-Var8,STRING); \nif (memberVar7){\nFUNC2(STRING,Var2); \nreturn  Var2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 45,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 199,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "construct_command_line",
    "Source": false,
    "Sink": false,
    "idx": 46,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 200,
    "label": -3,
    "slices": [
      "    static char cmd[BUF_SIZE];\n",
      "    char *method = manager->method;\n",
      "    int i;\n",
      "    memset(cmd, 0, BUF_SIZE);\n",
      "    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n",
      "    if (manager->acl != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n",
      "    if (manager->timeout != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n",
      "    if (manager->nofile) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n",
      "    if (manager->user != NULL) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n",
      "    if (manager->verbose) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n",
      "    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n",
      "    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n",
      "    if (server->fast_open[0] == 0 && manager->fast_open) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n",
      "    if (manager->ipv6first) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n",
      "    if (manager->mtu) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n",
      "    if (server->plugin == NULL && manager->plugin) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n",
      "    if (server->plugin_opts == NULL && manager->plugin_opts) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n",
      "    for (i = 0; i < manager->nameserver_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n",
      "    for (i = 0; i < manager->host_num; i++) {\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n",
      "        int len = strlen(cmd);\n",
      "        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n",
      "    if (verbose) {\n",
      "        LOGI(\"cmd: %s\", cmd);\n",
      "    return cmd;\n"
    ],
    "tokenized": "static char  Var1[Var2]; \nchar *Var3=Var4->memberVar1; \nint  Var5; \nmemset(Var1,0,Var2); \nsnprintf(Var1,Var2,\nSTRING,\nVar6,memberVar1,Var4->memberVar2,\nVar7,Var8->memberVar1,Var7,Var8->memberVar1); \nif (Var4->memberVar3 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar3); \nif (Var4->memberVar4 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar4); \nif (Var4->memberVar5){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar5); \nif (Var4->memberVar6 != NULL ){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar6); \nif (Var4->memberVar7){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar2 == NULL &&Var4->memberVar8 ==  Var11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var8->memberVar3[0]== 0&&Var4->memberVar9){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar10){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (Var4->memberVar11){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar11); \nif (Var8->memberVar4 == NULL &&Var4->memberVar12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar12); \nif (Var8->memberVar5 == NULL &&Var4->memberVar13){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING%STRUCT1 STRING,Var4->memberVar13); \nfor (Var5=0; Var5<Var4->memberVar14; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar15[Var5]); \nfor (Var5=0; Var5<Var4->memberVar16; Var5  Var12){\nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING,Var4->memberVar17[Var5]); \nint  Var9=strlen(Var1); \nsnprintf(Var1+Var9,Var2-Var9,STRING); \nif (memberVar7){\nFUNC1(STRING,Var1); \nreturn  Var1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 47,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 258,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "        LOGE(\"%s\", error_buf);\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "else\n",
      "                LOGE(\"invalid data: %s\", data);\n",
      "    json_value_free(obj);\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nFUNC4(STRING,Var4); \nstruct STRUCT2 *STRUCT2=FUNC5(sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \nFUNC4(STRING,Var3); \nFUNC6(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 48,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 266,
    "label": -3,
    "slices": [
      "    char *data = get_data(buf, len);\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "char *Var1=FUNC1(Var2,Var3); \nif (Var1 == NULL ){\nSTRUCT1 *Var4=FUNC2(&Var5,Var1,strlen(Var1),Var6); \nif (Var4 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC3(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var4->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var4->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var4->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var4->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 49,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 272,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 50,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 274,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 51,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 278,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 52,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 280,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 53,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 282,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 54,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 284,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 55,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 286,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 56,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 288,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 57,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 290,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 58,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 292,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 59,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 294,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 60,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 296,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 61,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 298,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nelse \n}else if (strcmp(memberVar1,STRING) == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "get_server",
    "Source": false,
    "Sink": false,
    "idx": 62,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strdup",
    "line": 300,
    "label": -3,
    "slices": [
      "get_server(char *buf, int len)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj        = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    struct server *server = ss_malloc(sizeof(struct server));\n",
      "    memset(server, 0, sizeof(struct server));\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (strcmp(name, \"server_port\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "else\n",
      "else\n",
      "            } else if (strcmp(name, \"password\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    strncpy(server->password, value->u.string.ptr, 128);\n",
      "else\n",
      "            } else if (strcmp(name, \"method\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->method = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"fast_open\") == 0) {\n",
      "                if (value->type == json_boolean) {\n",
      "                    strncpy(server->fast_open, (value->u.boolean ? \"true\" : \"false\"), 8);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"plugin_opts\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->plugin_opts = strdup(value->u.string.ptr);\n",
      "else\n",
      "            } else if (strcmp(name, \"mode\") == 0) {\n",
      "                if (value->type == json_string) {\n",
      "                    server->mode = strdup(value->u.string.ptr);\n",
      "    return server;\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2)\nchar *Var3=FUNC2(Var1,Var2); \nchar  Var4[512]; \nif (Var3 == NULL ){\nSTRUCT1 *Var5=FUNC3(&Var6,Var3,strlen(Var3),Var4); \nif (Var5 == NULL ){\nstruct STRUCT2 *STRUCT2=FUNC4(sizeof (struct  STRUCT2)); \nmemset(STRUCT2,0,sizeof (struct  STRUCT2)); \nif (Var5->memberVar1 ==  Var7){\nint  Var8=0; \nfor (Var8=0; Var8<Var5->memberVar2.memberVar1.memberVar1; Var8  Var9){\nchar *Var10=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar1; \nSTRUCT1 *Var11=Var5->memberVar2.memberVar1.memberVar2[Var8].memberVar2; \nif (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nelse \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nstrncpy(STRUCT2->memberVar1,memberVar2->memberVar2.memberVar2.memberVar1,128); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar2=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var13){\nstrncpy(STRUCT2->memberVar3,(memberVar2->memberVar2.memberVar3 STRINGSTRING),8); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar4=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar5=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nelse \n}else if (strcmp(memberVar1,STRING) == 0){\nif (memberVar2->memberVar1 ==  Var12){\nSTRUCT2->memberVar6=strdup(memberVar2->memberVar2.memberVar2.memberVar1); \nreturn  STRUCT2; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "parse_traffic",
    "Source": false,
    "Sink": false,
    "idx": 63,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 325,
    "label": -3,
    "slices": [
      "parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "        LOGE(\"%s\", error_buf);\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (value->type == json_integer) {\n",
      "                strncpy(port, name, 8);\n",
      "                *traffic = value->u.integer;\n",
      "    json_value_free(obj);\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2,char *Var3,uint64_t *Var4)\nchar *Var5=FUNC2(Var1,Var2); \nchar  Var6[512]; \nif (Var5 == NULL ){\nSTRUCT1 *Var7=FUNC3(&Var8,Var5,strlen(Var5),Var6); \nif (Var7 == NULL ){\nFUNC4(STRING,Var6); \nif (Var7->memberVar1 ==  Var9){\nint  Var10=0; \nfor (Var10=0; Var10<Var7->memberVar2.memberVar1.memberVar1; Var10  Var11){\nchar *Var12=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar1; \nSTRUCT1 *Var13=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar2; \nif (memberVar2->memberVar1 ==  Var14){\nstrncpy(Var3,memberVar1,8); \n*Var4=memberVar2->memberVar2.memberVar2; \nFUNC5(Var7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "parse_traffic",
    "Source": false,
    "Sink": false,
    "idx": 64,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 337,
    "label": -3,
    "slices": [
      "parse_traffic(char *buf, int len, char *port, uint64_t *traffic)\n",
      "    char *data = get_data(buf, len);\n",
      "    char error_buf[512];\n",
      "    if (data == NULL) {\n",
      "    json_value *obj = json_parse_ex(&settings, data, strlen(data), error_buf);\n",
      "    if (obj == NULL) {\n",
      "    if (obj->type == json_object) {\n",
      "        int i = 0;\n",
      "        for (i = 0; i < obj->u.object.length; i++) {\n",
      "            char *name        = obj->u.object.values[i].name;\n",
      "            json_value *value = obj->u.object.values[i].value;\n",
      "            if (value->type == json_integer) {\n",
      "                strncpy(port, name, 8);\n"
    ],
    "tokenized": "FUNC1(char *Var1,int  Var2,char *Var3,uint64_t *Var4)\nchar *Var5=FUNC2(Var1,Var2); \nchar  Var6[512]; \nif (Var5 == NULL ){\nSTRUCT1 *Var7=FUNC3(&Var8,Var5,strlen(Var5),Var6); \nif (Var7 == NULL ){\nif (Var7->memberVar1 ==  Var9){\nint  Var10=0; \nfor (Var10=0; Var10<Var7->memberVar2.memberVar1.memberVar1; Var10  Var11){\nchar *Var12=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar1; \nSTRUCT1 *Var13=Var7->memberVar2.memberVar1.memberVar2[Var10].memberVar2; \nif (memberVar2->memberVar1 ==  Var14){\nstrncpy(Var3,memberVar1,8); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 65,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 354,
    "label": -3,
    "slices": ["    memset(&hints, 0, sizeof(struct addrinfo));\n"],
    "tokenized": "memset(&Var1,0,sizeof (struct  Var2)); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 66,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getaddrinfo",
    "line": 361,
    "label": -3,
    "slices": [
      "create_and_bind(const char *host, const char *port, int protocol)\n",
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, listen_sock = -1;\n",
      "    s = getaddrinfo(host, port, &hints, &result);\n",
      "    if (s != 0) {\n",
      "        LOGE(\"getaddrinfo: %s\", gai_strerror(s));\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        if (listen_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "        if (s == 0) {\n"
    ],
    "tokenized": "FUNC1(const char *Var1,const char *Var2,int  Var3)\nstruct STRUCT1 *Var4,*Var5,*Var6; \nint  Var7,Var8=-1; \nVar7=getaddrinfo(Var1,Var2,&Var9,&Var4); \nif (Var7 != 0){\nFUNC2(STRING,FUNC3(Var7)); \nfor (/*Var5=Var4 */; Var5 != NULL ; Var5=Var5->memberVar1){\nif (Var8 == -1){\nif (Var5->memberVar2 ==  Var10){\nint  Var11=Var1 10; \nif (Var7 == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 67,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "socket",
    "line": 390,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, listen_sock = -1;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (listen_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n",
      "        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "            close(listen_sock);\n",
      "    if (rp == NULL) {\n",
      "    return listen_sock;\n"
    ],
    "tokenized": "struct STRUCT1 *Var1,*Var2,*Var3; \nint  Var4,Var5=-1; \nif (Var4 != 0){\nVar2=Var1; \nif (!Var6){\nVar3=Var1; \nwhile (Var3){\nif (Var3->memberVar1 ==  Var7){\nVar2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */\nVar3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */\nfor (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){\nVar5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); \nif (Var5 == -1){\nif (Var2->memberVar2 ==  Var7){\nint  Var14=Var6 10; \nFUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); \nFUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); \nFUNC1(Var5,Var17,Var20,&Var19,sizeof (Var19)); \nVar4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); \nif (Var4 == 0){\nclose(Var5); \nif (Var2 == NULL ){\nreturn  Var5; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_and_bind",
    "Source": false,
    "Sink": false,
    "idx": 68,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 410,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, listen_sock = -1;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        listen_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (listen_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(listen_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        setsockopt(listen_sock, SOL_SOCKET, SO_NOSIGPIPE, &opt, sizeof(opt));\n",
      "        s = bind(listen_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "            close(listen_sock);\n",
      "    if (rp == NULL) {\n",
      "    return listen_sock;\n"
    ],
    "tokenized": "struct STRUCT1 *Var1,*Var2,*Var3; \nint  Var4,Var5=-1; \nif (Var4 != 0){\nVar2=Var1; \nif (!Var6){\nVar3=Var1; \nwhile (Var3){\nif (Var3->memberVar1 ==  Var7){\nVar2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */\nVar3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */\nfor (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){\nVar5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); \nif (Var5 == -1){\nif (Var2->memberVar2 ==  Var7){\nint  Var14=Var6 10; \nFUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); \nFUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); \nFUNC1(Var5,Var17,Var20,&Var19,sizeof (Var19)); \nVar4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); \nif (Var4 == 0){\nclose(Var5); \nif (Var2 == NULL ){\nreturn  Var5; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "check_port",
    "Source": false,
    "Sink": false,
    "idx": 69,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 438,
    "label": -3,
    "slices": [
      "check_port(struct manager_ctx *manager, struct server *server)\n",
      "    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n",
      "    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n",
      "    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n",
      "    memset(sock_fds, 0, fd_count * sizeof(int));\n",
      "    for (int i = 0; i < manager->host_num; i++) {\n",
      "        if (manager->mode == UDP_ONLY) {\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "else\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n",
      "        if (both_tcp_udp) {\n",
      "            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n",
      "    for (int i = 0; i < fd_count; i++) {\n",
      "        if (sock_fds[i] > 0) {\n",
      "            close(sock_fds[i]);\n",
      "    ss_free(sock_fds);\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nbool  Var2=Var1->memberVar1 ==  Var3; \nint  Var4=Var1->STRUCT3 *(Var2 21); \nint *Var5=(int *) FUNC2(Var4 *sizeof (int )); \nmemset(Var5,0,Var4 *sizeof (int )); \nfor (int  Var6=0; Var6<Var1->memberVar2; Var6  Var7){\nif (Var1->memberVar1 ==  Var8){\nVar5[Var6]=FUNC3(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); \nelse \nVar5[Var6]=FUNC3(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var10); \nif (Var2){\nVar5[Var6+Var1->memberVar2]=FUNC3(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); \nif (Var5[Var6]== -1||(Var2&&Var5[Var6+Var1->memberVar2]== -1)){\nfor (int  Var6=0; Var6<Var4; Var6  Var7){\nif (Var5[Var6]>0){\nclose(Var5[Var6]); \nFUNC4(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "check_port",
    "Source": false,
    "Sink": false,
    "idx": 70,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 463,
    "label": -3,
    "slices": [
      "check_port(struct manager_ctx *manager, struct server *server)\n",
      "    bool both_tcp_udp = manager->mode == TCP_AND_UDP;\n",
      "    int fd_count      = manager->host_num * (both_tcp_udp ? 2 : 1);\n",
      "    int *sock_fds = (int *)ss_malloc(fd_count * sizeof(int));\n",
      "    memset(sock_fds, 0, fd_count * sizeof(int));\n",
      "    for (int i = 0; i < manager->host_num; i++) {\n",
      "        LOGI(\"try to bind interface: %s, port: %s\", manager->hosts[i], server->port);\n",
      "        if (manager->mode == UDP_ONLY) {\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "else\n",
      "            sock_fds[i] = create_and_bind(manager->hosts[i], server->port, IPPROTO_TCP);\n",
      "        if (both_tcp_udp) {\n",
      "            sock_fds[i + manager->host_num] = create_and_bind(manager->hosts[i], server->port, IPPROTO_UDP);\n",
      "        if (sock_fds[i] == -1 || (both_tcp_udp && sock_fds[i + manager->host_num] == -1)) {\n",
      "    for (int i = 0; i < fd_count; i++) {\n",
      "        if (sock_fds[i] > 0) {\n",
      "            close(sock_fds[i]);\n",
      "    ss_free(sock_fds);\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nbool  Var2=Var1->memberVar1 ==  Var3; \nint  Var4=Var1->STRUCT3 *(Var2 21); \nint *Var5=(int *) FUNC2(Var4 *sizeof (int )); \nmemset(Var5,0,Var4 *sizeof (int )); \nfor (int  Var6=0; Var6<Var1->memberVar2; Var6  Var7){\nFUNC3(STRING,Var1->memberVar3[Var6],STRUCT2->memberVar1); \nif (Var1->memberVar1 ==  Var8){\nVar5[Var6]=FUNC4(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); \nelse \nVar5[Var6]=FUNC4(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var10); \nif (Var2){\nVar5[Var6+Var1->memberVar2]=FUNC4(Var1->memberVar3[Var6],STRUCT2->memberVar1,Var9); \nif (Var5[Var6]== -1||(Var2&&Var5[Var6+Var1->memberVar2]== -1)){\nfor (int  Var6=0; Var6<Var4; Var6  Var7){\nif (Var5[Var6]>0){\nclose(Var5[Var6]); \nFUNC5(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "add_server",
    "Source": false,
    "Sink": false,
    "idx": 71,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "system",
    "line": 486,
    "label": -3,
    "slices": [
      "add_server(struct manager_ctx *manager, struct server *server)\n",
      "    int ret = check_port(manager, server);\n",
      "    if (ret == -1) {\n",
      "    char *cmd = construct_command_line(manager, server);\n"
    ],
    "tokenized": "FUNC1(struct STRUCT1 *Var1,struct STRUCT2 *STRUCT2)\nint  Var2=FUNC2(Var1,STRUCT2); \nif (Var2 == -1){\nchar *Var3=FUNC3(Var1,STRUCT2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 72,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 498,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nif (fscanf(Var6,STRING,&Var4) !=  Var7){\nFUNC4(Var4,Var8); \nfclose(Var6); \nremove(Var3); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 73,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 498,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nif (fscanf(Var6,STRING,&Var4) !=  Var7){\nFUNC4(Var4,Var8); \nfclose(Var6); \nremove(Var3); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 74,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 500,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nremove(Var3); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 75,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fopen",
    "line": 501,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fclose(f);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nfclose(Var6); \nremove(Var3); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 76,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fscanf",
    "line": 509,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nfclose(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 77,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 512,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nfclose(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "kill_server",
    "Source": false,
    "Sink": false,
    "idx": 78,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "remove",
    "line": 513,
    "label": -3,
    "slices": [
      "kill_server(char *prefix, char *pid_file)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(pid_file) + 2;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/%s\", prefix, pid_file);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    remove(path);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+2; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nremove(Var3); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 79,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 521,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+20; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nif (fscanf(Var6,STRING,&Var4) !=  Var7){\nFUNC4(Var4,Var8); \nfclose(Var6); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 80,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 521,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    if (fscanf(f, \"%d\", &pid) != EOF) {\n",
      "        kill(pid, SIGTERM);\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+20; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nif (fscanf(Var6,STRING,&Var4) !=  Var7){\nFUNC4(Var4,Var8); \nfclose(Var6); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 81,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 523,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+20; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 82,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fopen",
    "line": 524,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    snprintf(path, path_size, \"%s/.shadowsocks_%s.pid\", prefix, port);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "        ss_free(path);\n",
      "    fclose(f);\n",
      "    ss_free(path);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+20; \nVar3=FUNC2(Var5); \nsnprintf(Var3,Var5,STRING,Var1,Var2); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nFUNC3(Var3); \nfclose(Var6); \nFUNC3(Var3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 83,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fscanf",
    "line": 532,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+20; \nVar3=FUNC2(Var5); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nfclose(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "stop_server",
    "Source": false,
    "Sink": false,
    "idx": 84,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "fclose",
    "line": 535,
    "label": -3,
    "slices": [
      "stop_server(char *prefix, char *port)\n",
      "    char *path = NULL;\n",
      "    int pid, path_size = strlen(prefix) + strlen(port) + 20;\n",
      "    path = ss_malloc(path_size);\n",
      "    FILE *f = fopen(path, \"r\");\n",
      "    if (f == NULL) {\n",
      "    fclose(f);\n"
    ],
    "tokenized": "FUNC1(char *Var1,char *Var2)\nchar *Var3=NULL ; \nint  Var4,Var5=strlen(Var1)+strlen(Var2)+20; \nVar3=FUNC2(Var5); \nSTRUCT1 *Var6=fopen(Var3,STRING); \nif (Var6 == NULL ){\nfclose(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 85,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 577,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nVar4=recvfrom(Var1->memberVar1,Var5,Var6,0,(struct STRUCT4 *)&Var7,&Var3); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var8=FUNC1(Var5,Var4); \nif (Var8 == NULL ){\nif (strcmp(Var8,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); \nif (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0||STRUCT5->memberVar2[0]== 0){\nFUNC3(STRING,Var5,FUNC4(Var5,Var4)); \nint  Var9=FUNC5(Var1,STRUCT5); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; \nchar *Var11=STRUCT5->Var11  STRUCT5->Var11  Var1->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar2); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); \nif (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0){\nFUNC3(STRING,Var5,FUNC4(Var5,Var4)); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nchar  memberVar1[8]; \nif (FUNC6(Var5,Var4,memberVar1,&Var14) == -1){\nFUNC3(STRING,Var5,FUNC4(Var5,Var4)); \nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5,STRING); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 86,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "recvfrom",
    "line": 580,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "        LOGE(\"too large request: %d\", (int)r);\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "            if (server != NULL) {\n",
      "                destroy_server(server);\n",
      "                ss_free(server);\n",
      "        remove_server(working_dir, server->port);\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "            if (server != NULL) {\n",
      "                destroy_server(server);\n",
      "                ss_free(server);\n",
      "        remove_server(working_dir, server->port);\n",
      "        destroy_server(server);\n",
      "        ss_free(server);\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var8,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nFUNC2(STRING,(int ) Var5); \nchar *Var9=FUNC3(Var6,Var5); \nif (Var9 == NULL ){\nif (strcmp(Var9,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC4(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nFUNC2(STRING,Var6,FUNC5(Var6,Var5)); \nif (STRUCT7 != NULL ){\nFUNC6(STRUCT7); \nFUNC7(STRUCT7); \nFUNC8(Var10,STRUCT7->memberVar1); \nint  Var11=FUNC9(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC10(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nsize_t  Var17=strlen(Var6); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC4(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nFUNC2(STRING,Var6,FUNC5(Var6,Var5)); \nif (STRUCT7 != NULL ){\nFUNC6(STRUCT7); \nFUNC7(STRUCT7); \nFUNC8(Var10,STRUCT7->memberVar1); \nFUNC6(STRUCT7); \nFUNC7(STRUCT7); \nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  memberVar1[8]; \nif (FUNC11(Var6,Var5,memberVar1,&Var19) == -1){\nFUNC2(STRING,Var6,FUNC5(Var6,Var5)); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC10(&Var20)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nsize_t  Var17=strlen(Var6); \nstrcpy(Var6,STRING); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 87,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 596,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nVar4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var9=FUNC2(Var5,Var4); \nif (Var9 == NULL ){\nif (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nint  Var10=FUNC4(Var3,STRUCT6); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nchar *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 88,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 622,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "        if (ret == -1) {\n",
      "            msg     = \"port is not available\";\n",
      "            msg_len = 21;\n",
      "else\n",
      "            msg     = \"ok\";\n",
      "            msg_len = 2;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nint  Var11=FUNC4(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nif (Var11 == -1){\nVar12=STRING; \nVar13=21; \nelse \nVar12=STRING; \nVar13=2; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nsize_t  Var17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var19)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nsize_t  Var17=strlen(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 89,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 625,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nVar4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var9=FUNC2(Var5,Var4); \nif (Var9 == NULL ){\nif (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nint  Var10=FUNC4(Var3,STRUCT6); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nchar *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 90,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 629,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 91,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sprintf",
    "line": 630,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 92,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 636,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 93,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 637,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC2(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); \nint  Var8=FUNC4(Var3,STRUCT5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT6 *Var9; \nchar  Var5[Var6]; \nwhile ((Var9=FUNC5(&Var10)) != NULL ){\nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; \nchar *Var11=STRUCT5->Var11  STRUCT5->Var11  Var3->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar1); \nsprintf(Var5+Var12,STRING STRUCT7 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT5->memberVar1,STRUCT5->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstruct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); \nstruct STRUCT6 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 94,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 637,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC2(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); \nint  Var8=FUNC4(Var3,STRUCT5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT6 *Var9; \nchar  Var5[Var6]; \nwhile ((Var9=FUNC5(&Var10)) != NULL ){\nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; \nchar *Var11=STRUCT5->Var11  STRUCT5->Var11  Var3->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar1); \nsprintf(Var5+Var12,STRING STRUCT7 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT5->memberVar1,STRUCT5->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstruct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); \nstruct STRUCT6 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 95,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 637,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC2(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); \nint  Var8=FUNC4(Var3,STRUCT5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT6 *Var9; \nchar  Var5[Var6]; \nwhile ((Var9=FUNC5(&Var10)) != NULL ){\nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; \nchar *Var11=STRUCT5->Var11  STRUCT5->Var11  Var3->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar1); \nsprintf(Var5+Var12,STRING STRUCT7 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT5->memberVar1,STRUCT5->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstruct STRUCT5 *STRUCT5=FUNC3(Var5,Var4); \nstruct STRUCT6 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 96,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 639,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nint  Var11=FUNC4(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nsprintf(Var6,STRING); \nwhile ((Var14=FUNC5(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nmemset(Var6,0,Var7); \nsprintf(Var6+Var17,STRING STRUCT9 STRING%Var19 STRING memberVar2 STRING%Var19 STRING memberVar2 STRING%Var19 STRING,\nSTRUCT7->memberVar1,STRUCT7->memberVar2,memberVar2); \nsize_t  Var17=strlen(Var6); \nstrcpy(Var6+Var17-1,STRING); //Var20  STRUCT10 STRING\nVar17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var21)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nsize_t  Var17=strlen(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 97,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 643,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 98,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sprintf",
    "line": 646,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "                pos = 0;\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var8=FUNC2(Var6,Var5); \nif (Var8 == NULL ){\nif (strcmp(Var8,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var6,Var5); \nint  Var9=FUNC4(Var3,STRUCT6); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nstruct STRUCT7 *Var10; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nsprintf(Var6,STRING); \nwhile ((Var10=FUNC5(&Var11)) != NULL ){\nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var10->memberVar1; \nchar *Var12=STRUCT6->Var12  STRUCT6->Var12  Var3->memberVar1; \nsize_t  Var13=strlen(Var6); \nsize_t  Var14=strlen(STRUCT6->memberVar1)+strlen(STRUCT6->memberVar2)+strlen(memberVar1); \nif (Var13>Var7-Var14-50){\nmemset(Var6,0,Var7); \nVar13=0; \nsprintf(Var6+Var13,STRING STRUCT8 STRING%Var15 STRING memberVar2 STRING%Var15 STRING memberVar1 STRING%Var15 STRING,\nSTRUCT6->memberVar1,STRUCT6->memberVar2,memberVar1); \nsize_t  Var13=strlen(Var6); \nstrcpy(Var6+Var13-1,STRING); //Var16  STRUCT9 STRING\nVar13=strlen(Var6); \nstruct STRUCT6 *STRUCT6=FUNC3(Var6,Var5); \nstruct STRUCT7 *Var10; \nchar  Var6[Var7]; \nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var10->memberVar1; \nsize_t  Var13=strlen(Var6); \nsize_t  Var13=strlen(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 99,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 651,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 100,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcpy",
    "line": 652,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 101,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 653,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "        struct server *server = get_server(buf, r);\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var10)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var11=STRUCT4->Var11  STRUCT4->Var11  Var1->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nif (Var12>Var6-Var13-50){\nmemset(Var5,0,Var6); \nsprintf(Var5+Var12,STRING STRUCT6 STRING%Var14 STRING memberVar2 STRING%Var14 STRING memberVar1 STRING%Var14 STRING,\nSTRUCT4->memberVar1,STRUCT4->memberVar2,memberVar1); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5+Var12-1,STRING); //Var15  STRUCT7 STRING\nVar12=strlen(Var5); \nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 102,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 654,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"[\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "            sprintf(buf + pos, \"\\n\\t{\\\"server_port\\\":\\\"%s\\\",\\\"password\\\":\\\"%s\\\",\\\"method\\\":\\\"%s\\\"},\", \n                    server->port,server->password,method);\n",
      "        size_t pos = strlen(buf);\n",
      "        strcpy(buf + pos - 1, \"\\n]\"); //Remove trailing \",\"\n",
      "        pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nint  Var11=FUNC4(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nsprintf(Var6,STRING); \nwhile ((Var14=FUNC5(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nmemset(Var6,0,Var7); \nsprintf(Var6+Var17,STRING STRUCT9 STRING%Var19 STRING memberVar2 STRING%Var19 STRING memberVar2 STRING%Var19 STRING,\nSTRUCT7->memberVar1,STRUCT7->memberVar2,memberVar2); \nsize_t  Var17=strlen(Var6); \nstrcpy(Var6+Var17-1,STRING); //Var20  STRUCT10 STRING\nVar17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var21)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nsize_t  Var17=strlen(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 103,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 658,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nVar4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var9=FUNC2(Var5,Var4); \nif (Var9 == NULL ){\nif (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nint  Var10=FUNC4(Var3,STRUCT6); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nchar *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 104,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 675,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nint  Var11=FUNC4(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nsize_t  Var17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var19)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nsize_t  Var17=strlen(Var6); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 105,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 678,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nVar4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var9=FUNC2(Var5,Var4); \nif (Var9 == NULL ){\nif (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nint  Var10=FUNC4(Var3,STRUCT6); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nchar *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 106,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 688,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nchar  Var5[Var6]; \nVar4=recvfrom(Var3->memberVar1,Var5,Var6,0,(struct STRUCT5 *)&Var7,&Var8); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var9=FUNC2(Var5,Var4); \nif (Var9 == NULL ){\nif (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nint  Var10=FUNC4(Var3,STRUCT6); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nchar *Var11=STRUCT6->Var11  STRUCT6->Var11  Var3->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nstruct STRUCT6 *STRUCT6=FUNC3(Var5,Var4); \nelse \n}else if (strcmp(Var9,STRING) == 0){\nelse \n}else if (strcmp(Var9,STRING) == 0){\nchar  Var5[Var6]; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 107,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 694,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; \nsize_t  Var11=strlen(Var5); \nsize_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nsize_t  Var11=strlen(Var5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var13)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var11=strlen(Var5); \nif (Var11>Var6/2){\nVar5[Var11-1]=}; \nmemset(Var5,0,Var6); \nsize_t  Var11=strlen(Var5); \nif (Var11>7){\nVar5[Var11-1]=}; \nelse \nVar5[Var11]=}; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 108,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sprintf",
    "line": 695,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; \nsize_t  Var11=strlen(Var5); \nsize_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nsize_t  Var11=strlen(Var5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var13)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var11=strlen(Var5); \nif (Var11>Var6/2){\nVar5[Var11-1]=}; \nmemset(Var5,0,Var6); \nsize_t  Var11=strlen(Var5); \nif (Var11>7){\nVar5[Var11-1]=}; \nelse \nVar5[Var11]=}; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 109,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 701,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; \nsize_t  Var11=strlen(Var5); \nsize_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nsize_t  Var11=strlen(Var5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var13)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var11=strlen(Var5); \nif (Var11>Var6/2){\nVar5[Var11-1]=}; \nmemset(Var5,0,Var6); \nsize_t  Var11=strlen(Var5); \nif (Var11>7){\nVar5[Var11-1]=}; \nelse \nVar5[Var11]=}; \nVar11  Var14; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 110,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 704,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nint  Var11=FUNC4(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nsize_t  Var17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nsprintf(Var6,STRING); \nwhile ((Var14=FUNC5(&Var19)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nVar6[Var17-1]=}; \nmemset(Var6,0,Var7); \nsize_t  Var17=strlen(Var6); \nif (Var17>7){\nVar6[Var17-1]=}; \nelse \nVar6[Var17]=}; \nVar17  Var20; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 111,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 708,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; \nsize_t  Var11=strlen(Var5); \nsize_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nsize_t  Var11=strlen(Var5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var13)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var11=strlen(Var5); \nif (Var11>Var6/2){\nVar5[Var11-1]=}; \nmemset(Var5,0,Var6); \nsize_t  Var11=strlen(Var5); \nif (Var11>7){\nVar5[Var11-1]=}; \nelse \nVar5[Var11]=}; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 112,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 714,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var7=FUNC1(Var5,Var4); \nif (Var7 == NULL ){\nif (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nint  Var8=FUNC3(Var1,STRUCT4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nchar *Var10=STRUCT4->Var10  STRUCT4->Var10  Var1->memberVar1; \nsize_t  Var11=strlen(Var5); \nsize_t  Var12=strlen(STRUCT4->memberVar1)+strlen(STRUCT4->memberVar2)+strlen(memberVar1); \nsize_t  Var11=strlen(Var5); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT4 *STRUCT4=FUNC2(Var5,Var4); \nelse \n}else if (strcmp(Var7,STRING) == 0){\nelse \n}else if (strcmp(Var7,STRING) == 0){\nstruct STRUCT5 *Var9; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nsprintf(Var5,STRING); \nwhile ((Var9=FUNC4(&Var13)) != NULL ){\nstruct STRUCT4 *STRUCT4=(struct STRUCT4 *) Var9->memberVar1; \nsize_t  Var11=strlen(Var5); \nif (Var11>Var6/2){\nVar5[Var11-1]=}; \nmemset(Var5,0,Var6); \nsize_t  Var11=strlen(Var5); \nif (Var11>7){\nVar5[Var11-1]=}; \nelse \nVar5[Var11]=}; \nVar11  Var14; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 113,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 722,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        memset(buf, 0, BUF_SIZE);\n",
      "        sprintf(buf, \"stat: {\");\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "                buf[pos - 1] = '}';\n",
      "                memset(buf, 0, BUF_SIZE);\n",
      "        size_t pos = strlen(buf);\n",
      "        if (pos > 7) {\n",
      "            buf[pos - 1] = '}';\n",
      "else\n",
      "            buf[pos] = '}';\n",
      "            pos++;\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nint  Var11=FUNC4(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC5(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nsize_t  Var17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nsprintf(Var6,STRING); \nwhile ((Var14=FUNC5(&Var19)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nVar6[Var17-1]=}; \nmemset(Var6,0,Var7); \nsize_t  Var17=strlen(Var6); \nif (Var17>7){\nVar6[Var17-1]=}; \nelse \nVar6[Var17]=}; \nVar17  Var20; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 114,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcpy",
    "line": 731,
    "label": -3,
    "slices": [
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        int ret = add_server(manager, server);\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        char buf[BUF_SIZE];\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ],
    "tokenized": "struct STRUCT1 *Var1=(struct STRUCT1 *) Var2; \nSTRUCT2  Var3; \nSTRUCT3  Var4; \nchar  Var5[Var6]; \nmemset(Var5,0,Var6); \nVar4=recvfrom(Var1->memberVar1,Var5,Var6,0,(struct STRUCT4 *)&Var7,&Var3); \nif (Var4 == -1){\nif (Var4>Var6/2){\nchar *Var8=FUNC1(Var5,Var4); \nif (Var8 == NULL ){\nif (strcmp(Var8,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); \nif (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0||STRUCT5->memberVar2[0]== 0){\nFUNC3(STRING,Var5,FUNC4(Var5,Var4)); \nint  Var9=FUNC5(Var1,STRUCT5); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; \nchar *Var11=STRUCT5->Var11  STRUCT5->Var11  Var1->memberVar2; \nsize_t  Var12=strlen(Var5); \nsize_t  Var13=strlen(STRUCT5->memberVar1)+strlen(STRUCT5->memberVar2)+strlen(memberVar2); \nsize_t  Var12=strlen(Var5); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nstruct STRUCT5 *STRUCT5=FUNC2(Var5,Var4); \nif (STRUCT5 == NULL ||STRUCT5->memberVar1[0]== 0){\nFUNC3(STRING,Var5,FUNC4(Var5,Var4)); \nelse \n}else if (strcmp(Var8,STRING) == 0){\nchar  memberVar1[8]; \nif (FUNC6(Var5,Var4,memberVar1,&Var14) == -1){\nFUNC3(STRING,Var5,FUNC4(Var5,Var4)); \nchar  Var5[Var6]; \nstruct STRUCT5 *STRUCT5=(struct STRUCT5 *) Var10->memberVar1; \nsize_t  Var12=strlen(Var5); \nsize_t  Var12=strlen(Var5); \nstrcpy(Var5,STRING); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "manager_recv_cb",
    "Source": false,
    "Sink": false,
    "idx": 115,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "sendto",
    "line": 732,
    "label": -3,
    "slices": [
      "manager_recv_cb(EV_P_ ev_io *w, int revents)\n",
      "    struct manager_ctx *manager = (struct manager_ctx *)w;\n",
      "    socklen_t len;\n",
      "    ssize_t r;\n",
      "    char buf[BUF_SIZE];\n",
      "    memset(buf, 0, BUF_SIZE);\n",
      "    len = sizeof(struct sockaddr_un);\n",
      "    r   = recvfrom(manager->fd, buf, BUF_SIZE, 0, (struct sockaddr *)&claddr, &len);\n",
      "    if (r == -1) {\n",
      "    if (r > BUF_SIZE / 2) {\n",
      "    char *action = get_action(buf, r);\n",
      "    if (action == NULL) {\n",
      "    if (strcmp(action, \"add\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0 || server->password[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        int ret = add_server(manager, server);\n",
      "        char *msg;\n",
      "        int msg_len;\n",
      "else\n",
      "    } else if (strcmp(action, \"list\") == 0) {\n",
      "        struct cork_hash_table_entry  *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            char *method = server->method?server->method:manager->method;\n",
      "            size_t pos = strlen(buf);\n",
      "            size_t entry_len = strlen(server->port) + strlen(server->password) + strlen(method);\n",
      "            if (pos > BUF_SIZE-entry_len-50) {\n",
      "        size_t pos = strlen(buf);\n",
      "else\n",
      "    } else if (strcmp(action, \"remove\") == 0) {\n",
      "        struct server *server = get_server(buf, r);\n",
      "        if (server == NULL || server->port[0] == 0) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "        char msg[3] = \"ok\";\n",
      "else\n",
      "    } else if (strcmp(action, \"stat\") == 0) {\n",
      "        char port[8];\n",
      "        if (parse_traffic(buf, r, port, &traffic) == -1) {\n",
      "            LOGE(\"invalid command: %s:%s\", buf, get_data(buf, r));\n",
      "else\n",
      "    } else if (strcmp(action, \"ping\") == 0) {\n",
      "        struct cork_hash_table_entry *entry;\n",
      "        char buf[BUF_SIZE];\n",
      "        while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "            struct server *server = (struct server *)entry->value;\n",
      "            size_t pos            = strlen(buf);\n",
      "            if (pos > BUF_SIZE / 2) {\n",
      "        size_t pos = strlen(buf);\n",
      "    strcpy(buf, \"err\");\n"
    ],
    "tokenized": "FUNC1(STRUCT1 STRUCT2 *Var1,int  Var2)\nstruct STRUCT3 *Var3=(struct STRUCT3 *) Var1; \nSTRUCT4  Var4; \nSTRUCT5  Var5; \nchar  Var6[Var7]; \nmemset(Var6,0,Var7); \nVar4=sizeof (struct  Var8); \nVar5=recvfrom(Var3->memberVar1,Var6,Var7,0,(struct STRUCT6 *)&Var9,&Var4); \nif (Var5 == -1){\nif (Var5>Var7/2){\nchar *Var10=FUNC2(Var6,Var5); \nif (Var10 == NULL ){\nif (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0||STRUCT7->memberVar2[0]== 0){\nFUNC4(STRING,Var6,FUNC5(Var6,Var5)); \nint  Var11=FUNC6(Var3,STRUCT7); \nchar *Var12; \nint  Var13; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC7(&Var15)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nchar *Var16=STRUCT7->Var16  STRUCT7->Var16  Var3->memberVar2; \nsize_t  Var17=strlen(Var6); \nsize_t  Var18=strlen(STRUCT7->memberVar1)+strlen(STRUCT7->memberVar2)+strlen(memberVar2); \nif (Var17>Var7-Var18-50){\nsize_t  Var17=strlen(Var6); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT7 *STRUCT7=FUNC3(Var6,Var5); \nif (STRUCT7 == NULL ||STRUCT7->memberVar1[0]== 0){\nFUNC4(STRING,Var6,FUNC5(Var6,Var5)); \nchar  Var12[3]=STRING; \nelse \n}else if (strcmp(Var10,STRING) == 0){\nchar  memberVar1[8]; \nif (FUNC8(Var6,Var5,memberVar1,&Var19) == -1){\nFUNC4(STRING,Var6,FUNC5(Var6,Var5)); \nelse \n}else if (strcmp(Var10,STRING) == 0){\nstruct STRUCT8 *Var14; \nchar  Var6[Var7]; \nwhile ((Var14=FUNC7(&Var20)) != NULL ){\nstruct STRUCT7 *STRUCT7=(struct STRUCT7 *) Var14->memberVar1; \nsize_t  Var17=strlen(Var6); \nif (Var17>Var7/2){\nsize_t  Var17=strlen(Var6); \nstrcpy(Var6,STRING); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 116,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 756,
    "label": -3,
    "slices": ["    memset(&hints, 0, sizeof(struct addrinfo));\n"],
    "tokenized": "memset(&Var1,0,sizeof (struct  Var2)); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 117,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getaddrinfo",
    "line": 762,
    "label": -3,
    "slices": [
      "create_server_socket(const char *host, const char *port)\n",
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, server_sock;\n",
      "    s = getaddrinfo(host, port, &hints, &result);\n",
      "    if (s != 0) {\n",
      "        LOGE(\"getaddrinfo: %s\", gai_strerror(s));\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        if (server_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "        if (s == 0) {\n"
    ],
    "tokenized": "FUNC1(const char *Var1,const char *Var2)\nstruct STRUCT1 *Var3,*Var4,*Var5; \nint  Var6,Var7; \nVar6=getaddrinfo(Var1,Var2,&Var8,&Var3); \nif (Var6 != 0){\nFUNC2(STRING,FUNC3(Var6)); \nfor (/*Var4=Var3 */; Var4 != NULL ; Var4=Var4->memberVar1){\nif (Var7 == -1){\nif (Var4->memberVar2 ==  Var9){\nint  Var10=Var1 10; \nif (Var6 == 0){\n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 118,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "socket",
    "line": 790,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, server_sock;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (server_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "        close(server_sock);\n",
      "    if (rp == NULL) {\n",
      "    return server_sock;\n"
    ],
    "tokenized": "struct STRUCT1 *Var1,*Var2,*Var3; \nint  Var4,Var5; \nif (Var4 != 0){\nVar2=Var1; \nif (!Var6){\nVar3=Var1; \nwhile (Var3){\nif (Var3->memberVar1 ==  Var7){\nVar2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */\nVar3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */\nfor (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){\nVar5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); \nif (Var5 == -1){\nif (Var2->memberVar2 ==  Var7){\nint  Var14=Var6 10; \nFUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); \nFUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); \nVar4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); \nif (Var4 == 0){\nclose(Var5); \nif (Var2 == NULL ){\nreturn  Var5; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "create_server_socket",
    "Source": false,
    "Sink": false,
    "idx": 119,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "close",
    "line": 811,
    "label": -3,
    "slices": [
      "    struct addrinfo *result, *rp, *ipv4v6bindall;\n",
      "    int s, server_sock;\n",
      "    if (s != 0) {\n",
      "    rp = result;\n",
      "    if (!host) {\n",
      "        ipv4v6bindall = result;\n",
      "        while (ipv4v6bindall) {\n",
      "            if (ipv4v6bindall->ai_family == AF_INET6) {\n",
      "                rp = ipv4v6bindall; /* Take first IPV6 address available */\n",
      "            ipv4v6bindall = ipv4v6bindall->ai_next; /* Get next address info, if any */\n",
      "    for (/*rp = result*/; rp != NULL; rp = rp->ai_next) {\n",
      "        server_sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n",
      "        if (server_sock == -1) {\n",
      "        if (rp->ai_family == AF_INET6) {\n",
      "            int ipv6only = host ? 1 : 0;\n",
      "            setsockopt(server_sock, IPPROTO_IPV6, IPV6_V6ONLY, &ipv6only, sizeof(ipv6only));\n",
      "        setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n",
      "        s = bind(server_sock, rp->ai_addr, rp->ai_addrlen);\n",
      "        if (s == 0) {\n",
      "        close(server_sock);\n",
      "    if (rp == NULL) {\n",
      "    return server_sock;\n"
    ],
    "tokenized": "struct STRUCT1 *Var1,*Var2,*Var3; \nint  Var4,Var5; \nif (Var4 != 0){\nVar2=Var1; \nif (!Var6){\nVar3=Var1; \nwhile (Var3){\nif (Var3->memberVar1 ==  Var7){\nVar2=Var3; /*Var8  Var9  Var10  STRUCT2 STRUCT3 */\nVar3=Var3->memberVar2; /*Var11  Var12  STRUCT2  Var13,if STRUCT4 */\nfor (/*Var2=Var1 */; Var2 != NULL ; Var2=Var2->memberVar1){\nVar5=socket(Var2->memberVar2,Var2->memberVar3,Var2->memberVar4); \nif (Var5 == -1){\nif (Var2->memberVar2 ==  Var7){\nint  Var14=Var6 10; \nFUNC1(Var5,Var15,Var16,&Var14,sizeof (Var14)); \nFUNC1(Var5,Var17,Var18,&Var19,sizeof (Var19)); \nVar4=FUNC2(Var5,Var2->memberVar5,Var2->memberVar6); \nif (Var4 == 0){\nclose(Var5); \nif (Var2 == NULL ){\nreturn  Var5; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 120,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getopt_long",
    "line": 879,
    "label": -3,
    "slices": [
      "main(int argc, char **argv)\n",
      "    int i, c;\n",
      "    int pid_flags         = 0;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int server_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "    if (conf_path != NULL) {\n",
      "    USE_SYSLOG(argv[0], pid_flags);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ],
    "tokenized": "main(int  Var1,char **Var2)\nint  Var3,Var4; \nint  Var5=0; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nchar *Var14=NULL ; \nchar *Var15=NULL ; \nchar *Var16=NULL ; \nint  Var17=0; \nSTRUCT1 *Var18=NULL ; \nstatic struct  STRUCT2  Var19[]={\nwhile ((Var4=getopt_long(Var1,Var2,STRING,\nVar19,NULL )) != -1)\nif (Var12 != NULL ){\nFUNC1(Var2[0],Var5); \nSTRUCT3 *Var20; \nstruct STRUCT4 *Var21; \nif (Var20 != NULL ){\nwhile ((Var21=FUNC2(Var20)) != NULL ){\nsize_t  Var22=strlen(Var21->memberVar1); \nstruct STRUCT5 *Var23; \nwhile ((Var23=FUNC3(&Var24)) != NULL ){\nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var23->memberVar1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 121,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 898,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int mtu        = 0;\n",
      "    int ipv6first  = 0;\n",
      "    static int nofile = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            mtu = atoi(optarg);\n",
      "    if (conf_path != NULL) {\n",
      "    struct manager_ctx manager;\n",
      "    manager.mtu             = mtu;\n",
      "    manager.plugin          = plugin;\n",
      "    manager.plugin_opts     = plugin_opts;\n",
      "    manager.ipv6first       = ipv6first;\n",
      "    manager.nofile = nofile;\n",
      "    struct ev_loop *loop = EV_DEFAULT;\n",
      "    int sfd;\n",
      "    manager.fd = sfd;\n",
      "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
      "    ev_io_start(loop, &manager.io);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nint  Var14=0; \nint  Var15=0; \nstatic int  Var16=0; \nSTRUCT1 *Var17=NULL ; \nstatic struct  STRUCT2  Var18[]={\nwhile ((Var2=getopt_long(Var19,Var20,STRING,\nVar18,NULL )) != -1)\nswitch (Var2){\nVar14=FUNC1(Var21); \nif (Var9 != NULL ){\nstruct  STRUCT3  Var22; \nVar22.memberVar1=memberVar1; \nVar22.memberVar2=memberVar2; \nVar22.memberVar3=memberVar3; \nVar22.memberVar4=memberVar4; \nVar22.memberVar5=memberVar5; \nstruct STRUCT4 *Var23=Var24; \nint  Var25; \nVar22.memberVar6=Var25; \nFUNC2(&Var22.memberVar7,Var26,Var22.memberVar6,Var27); \nFUNC3(Var23,&Var22.memberVar7); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 122,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "atoi",
    "line": 957,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    static int nofile = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            nofile = atoi(optarg);\n",
      "    if (conf_path != NULL) {\n",
      "    struct manager_ctx manager;\n",
      "    manager.nofile = nofile;\n",
      "    struct ev_loop *loop = EV_DEFAULT;\n",
      "    int sfd;\n",
      "    manager.fd = sfd;\n",
      "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
      "    ev_io_start(loop, &manager.io);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nstatic int  Var14=0; \nSTRUCT1 *Var15=NULL ; \nstatic struct  STRUCT2  Var16[]={\nwhile ((Var2=getopt_long(Var17,Var18,STRING,\nVar16,NULL )) != -1)\nswitch (Var2){\nVar14=FUNC1(Var19); \nif (Var9 != NULL ){\nstruct  STRUCT3  Var20; \nVar20.memberVar1=memberVar1; \nstruct STRUCT4 *Var21=Var22; \nint  Var23; \nVar20.memberVar2=Var23; \nFUNC2(&Var20.memberVar3,Var24,Var20.memberVar2,Var25); \nFUNC3(Var21,&Var20.memberVar3); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 123,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 1061,
    "label": -3,
    "slices": ["    signal(SIGPIPE, SIG_IGN);\n"],
    "tokenized": "signal(Var1,Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 124,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 1062,
    "label": -3,
    "slices": ["    signal(SIGCHLD, SIG_IGN);\n"],
    "tokenized": "signal(Var1,Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 125,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "signal",
    "line": 1063,
    "label": -3,
    "slices": ["    signal(SIGABRT, SIG_IGN);\n"],
    "tokenized": "signal(Var1,Var2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 126,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 1073,
    "label": -3,
    "slices": ["    memset(&manager, 0, sizeof(struct manager_ctx));\n"],
    "tokenized": "memset(&Var1,0,sizeof (struct  Var2)); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 127,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "getpwuid",
    "line": 1105,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "        closedir(dp);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct STRUCT3 *Var14=getpwuid(FUNC1()); \nconst char *Var15=Var14->memberVar1; \nVar16=strlen(Var15)+15; \nVar17=FUNC2(Var16); \nsnprintf(Var17,Var16,STRING,Var15); \nint  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); \nif (Var18 != 0&&Var23 !=  Var24){\nFUNC3(Var17); \nSTRUCT4 *Var25; \nstruct STRUCT5 *Var26; \nVar25=FUNC4(Var17); \nif (Var25 != NULL ){\nwhile ((Var26=FUNC5(Var25)) != NULL ){\nsize_t  Var27=strlen(Var26->memberVar1); \nif (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){\nFUNC6(Var17,Var26->memberVar1); \nif (Var28)\nFUNC7(STRING,Var26->memberVar1); \nFUNC8(Var25); \nelse \nFUNC3(Var17); \nstruct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); \nint  Var29; \nif (Var30.memberVar1 == NULL ||Var30.memberVar2 == NULL ){\nif (Var29 == -1){\nFUNC3(Var17); \nif (remove(Var9) == -1&&Var23 !=  Var31){\nFUNC3(Var17); \nif (FUNC9(Var29,(struct STRUCT7 *)&Var32,sizeof (struct  Var33)) == -1){\nFUNC3(Var17); \nif (Var29 == -1){\nFUNC3(Var17); \nstruct STRUCT8 *Var34; \nwhile ((Var34=FUNC10(&Var35)) != NULL ){\nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var34->memberVar1; \nFUNC11(Var17,STRUCT6->memberVar1); \nFUNC3(Var17); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 128,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1107,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "        closedir(dp);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct STRUCT3 *Var14=getpwuid(FUNC1()); \nconst char *Var15=Var14->memberVar1; \nVar16=strlen(Var15)+15; \nVar17=FUNC2(Var16); \nsnprintf(Var17,Var16,STRING,Var15); \nint  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); \nif (Var18 != 0&&Var23 !=  Var24){\nFUNC3(Var17); \nSTRUCT4 *Var25; \nstruct STRUCT5 *Var26; \nVar25=FUNC4(Var17); \nif (Var25 != NULL ){\nwhile ((Var26=FUNC5(Var25)) != NULL ){\nsize_t  Var27=strlen(Var26->memberVar1); \nif (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){\nFUNC6(Var17,Var26->memberVar1); \nif (Var28)\nFUNC7(STRING,Var26->memberVar1); \nFUNC8(Var25); \nelse \nFUNC3(Var17); \nstruct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); \nint  Var29; \nif (Var30.memberVar1 == NULL ||Var30.memberVar2 == NULL ){\nif (Var29 == -1){\nFUNC3(Var17); \nif (remove(Var9) == -1&&Var23 !=  Var31){\nFUNC3(Var17); \nif (FUNC9(Var29,(struct STRUCT7 *)&Var32,sizeof (struct  Var33)) == -1){\nFUNC3(Var17); \nif (Var29 == -1){\nFUNC3(Var17); \nstruct STRUCT8 *Var34; \nwhile ((Var34=FUNC10(&Var35)) != NULL ){\nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var34->memberVar1; \nFUNC11(Var17,STRUCT6->memberVar1); \nFUNC3(Var17); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 129,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "snprintf",
    "line": 1109,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct STRUCT3 *Var14=getpwuid(FUNC1()); \nconst char *Var15=Var14->memberVar1; \nVar16=strlen(Var15)+15; \nVar17=FUNC2(Var16); \nsnprintf(Var17,Var16,STRING,Var15); \nint  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); \nif (Var18 != 0&&Var23 !=  Var24){\nFUNC3(Var17); \nSTRUCT4 *Var25; \nstruct STRUCT5 *Var26; \nVar25=FUNC4(Var17); \nif (Var25 != NULL ){\nwhile ((Var26=FUNC5(Var25)) != NULL ){\nsize_t  Var27=strlen(Var26->memberVar1); \nif (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){\nFUNC6(Var17,Var26->memberVar1); \nelse \nFUNC3(Var17); \nstruct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); \nint  Var28; \nif (Var29.memberVar1 == NULL ||Var29.memberVar2 == NULL ){\nif (Var28 == -1){\nFUNC3(Var17); \nif (remove(Var9) == -1&&Var23 !=  Var30){\nFUNC3(Var17); \nif (FUNC7(Var28,(struct STRUCT7 *)&Var31,sizeof (struct  Var32)) == -1){\nFUNC3(Var17); \nif (Var28 == -1){\nFUNC3(Var17); \nstruct STRUCT8 *Var33; \nwhile ((Var33=FUNC8(&Var34)) != NULL ){\nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var33->memberVar1; \nFUNC9(Var17,STRUCT6->memberVar1); \nFUNC3(Var17); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 130,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "mkdir",
    "line": 1111,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    snprintf(working_dir, working_dir_size, \"%s/.shadowsocks\", homedir);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    if (err != 0 && errno != EEXIST) {\n",
      "        ss_free(working_dir);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "else\n",
      "        ss_free(working_dir);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (remove(manager_address) == -1 && errno != ENOENT) {\n",
      "            ss_free(working_dir);\n",
      "        if (bind(sfd, (struct sockaddr *)&svaddr, sizeof(struct sockaddr_un)) == -1) {\n",
      "            ss_free(working_dir);\n",
      "        if (sfd == -1) {\n",
      "            ss_free(working_dir);\n",
      "    struct cork_hash_table_entry *entry;\n",
      "    while ((entry = cork_hash_table_iterator_next(&server_iter)) != NULL) {\n",
      "        struct server *server = (struct server *)entry->value;\n",
      "        stop_server(working_dir, server->port);\n",
      "    ss_free(working_dir);\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct STRUCT3 *Var14=getpwuid(FUNC1()); \nconst char *Var15=Var14->memberVar1; \nVar16=strlen(Var15)+15; \nVar17=FUNC2(Var16); \nsnprintf(Var17,Var16,STRING,Var15); \nint  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); \nif (Var18 != 0&&Var23 !=  Var24){\nFUNC3(Var17); \nSTRUCT4 *Var25; \nstruct STRUCT5 *Var26; \nVar25=FUNC4(Var17); \nif (Var25 != NULL ){\nwhile ((Var26=FUNC5(Var25)) != NULL ){\nsize_t  Var27=strlen(Var26->memberVar1); \nif (strcmp(Var26->memberVar1+Var27-3,STRING) == 0){\nFUNC6(Var17,Var26->memberVar1); \nelse \nFUNC3(Var17); \nstruct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); \nint  Var28; \nif (Var29.memberVar1 == NULL ||Var29.memberVar2 == NULL ){\nif (Var28 == -1){\nFUNC3(Var17); \nif (remove(Var9) == -1&&Var23 !=  Var30){\nFUNC3(Var17); \nif (FUNC7(Var28,(struct STRUCT7 *)&Var31,sizeof (struct  Var32)) == -1){\nFUNC3(Var17); \nif (Var28 == -1){\nFUNC3(Var17); \nstruct STRUCT8 *Var33; \nwhile ((Var33=FUNC8(&Var34)) != NULL ){\nstruct STRUCT6 *STRUCT6=(struct STRUCT6 *) Var33->memberVar1; \nFUNC9(Var17,STRUCT6->memberVar1); \nFUNC3(Var17); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 131,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strlen",
    "line": 1124,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct STRUCT3 *Var14=getpwuid(FUNC1()); \nconst char *Var15=Var14->memberVar1; \nVar16=strlen(Var15)+15; \nVar17=FUNC2(Var16); \nint  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); \nSTRUCT4 *Var23; \nstruct STRUCT5 *Var24; \nVar23=FUNC3(Var17); \nif (Var23 != NULL ){\nwhile ((Var24=FUNC4(Var23)) != NULL ){\nsize_t  Var25=strlen(Var24->memberVar1); \nif (strcmp(Var24->memberVar1+Var25-3,STRING) == 0){\nFUNC5(Var17,Var24->memberVar1); \nif (Var26)\nFUNC6(STRING,Var24->memberVar1); \nstruct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 132,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strcmp",
    "line": 1125,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct passwd *pw   = getpwuid(getuid());\n",
      "    const char *homedir = pw->pw_dir;\n",
      "    working_dir_size = strlen(homedir) + 15;\n",
      "    working_dir      = ss_malloc(working_dir_size);\n",
      "    int err = mkdir(working_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n",
      "    DIR *dp;\n",
      "    struct dirent *ep;\n",
      "    dp = opendir(working_dir);\n",
      "    if (dp != NULL) {\n",
      "        while ((ep = readdir(dp)) != NULL) {\n",
      "            size_t len = strlen(ep->d_name);\n",
      "            if (strcmp(ep->d_name + len - 3, \"pid\") == 0) {\n",
      "                kill_server(working_dir, ep->d_name);\n",
      "                if (verbose)\n",
      "                    LOGI(\"kill %s\", ep->d_name);\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct STRUCT3 *Var14=getpwuid(FUNC1()); \nconst char *Var15=Var14->memberVar1; \nVar16=strlen(Var15)+15; \nVar17=FUNC2(Var16); \nint  Var18=mkdir(Var17,Var19|Var20|Var21|Var22); \nSTRUCT4 *Var23; \nstruct STRUCT5 *Var24; \nVar23=FUNC3(Var17); \nif (Var23 != NULL ){\nwhile ((Var24=FUNC4(Var23)) != NULL ){\nsize_t  Var25=strlen(Var24->memberVar1); \nif (strcmp(Var24->memberVar1+Var25-3,STRING) == 0){\nFUNC5(Var17,Var24->memberVar1); \nif (Var26)\nFUNC6(STRING,Var24->memberVar1); \nstruct STRUCT6 *STRUCT6=FUNC2(sizeof (struct  STRUCT6)); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 133,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 1142,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    if (conf != NULL) {\n",
      "        for (i = 0; i < conf->port_password_num; i++) {\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "            memset(server, 0, sizeof(struct server));\n",
      "            strncpy(server->port, conf->port_password[i].port, 8);\n",
      "            strncpy(server->password, conf->port_password[i].password, 128);\n",
      "            add_server(&manager, server);\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nSTRUCT1 *Var14=NULL ; \nstatic struct  STRUCT2  Var15[]={\nif (Var14 != NULL ){\nfor (Var1=0; Var1<Var14->memberVar1; Var1  Var16){\nstruct STRUCT3 *STRUCT3=FUNC1(sizeof (struct  STRUCT3)); \nmemset(STRUCT3,0,sizeof (struct  STRUCT3)); \nstrncpy(STRUCT3->memberVar1,Var14->memberVar2[Var1].memberVar1,8); \nstrncpy(STRUCT3->memberVar2,Var14->memberVar2[Var1].memberVar2,128); \nFUNC2(&Var17,STRUCT3); \nstruct STRUCT3 *STRUCT3=(struct STRUCT3 *) Var18->memberVar1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 134,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1143,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int fast_open  = 0;\n",
      "    int reuse_port = 0;\n",
      "    int mode       = TCP_ONLY;\n",
      "    int mtu        = 0;\n",
      "    int ipv6first  = 0;\n",
      "    static int nofile = 0;\n",
      "    int server_num = 0;\n",
      "    char *server_host[MAX_REMOTE_NUM];\n",
      "    char *nameservers[MAX_DNS_NUM + 1];\n",
      "    int nameserver_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            conf_path = optarg;\n",
      "    if (conf_path != NULL) {\n",
      "        conf = read_jconf(conf_path);\n",
      "        if (server_num == 0) {\n",
      "            server_num = conf->remote_num;\n",
      "            for (i = 0; i < server_num; i++)\n",
      "                server_host[i] = conf->remote_addr[i].host;\n",
      "        if (password == NULL) {\n",
      "            password = conf->password;\n",
      "        if (method == NULL) {\n",
      "            method = conf->method;\n",
      "        if (timeout == NULL) {\n",
      "            timeout = conf->timeout;\n",
      "        if (user == NULL) {\n",
      "            user = conf->user;\n",
      "        if (fast_open == 0) {\n",
      "            fast_open = conf->fast_open;\n",
      "        if (reuse_port == 0) {\n",
      "            reuse_port = conf->reuse_port;\n",
      "        if (conf->nameserver != NULL) {\n",
      "            nameservers[nameserver_num++] = conf->nameserver;\n",
      "        if (mode == TCP_ONLY) {\n",
      "            mode = conf->mode;\n",
      "        if (mtu == 0) {\n",
      "            mtu = conf->mtu;\n",
      "        if (plugin == NULL) {\n",
      "            plugin = conf->plugin;\n",
      "        if (plugin_opts == NULL) {\n",
      "            plugin_opts = conf->plugin_opts;\n",
      "        if (ipv6first == 0) {\n",
      "            ipv6first = conf->ipv6_first;\n",
      "        if (nofile == 0) {\n",
      "            nofile = conf->nofile;\n",
      "    if (conf != NULL) {\n",
      "        for (i = 0; i < conf->port_password_num; i++) {\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "            memset(server, 0, sizeof(struct server));\n",
      "            strncpy(server->port, conf->port_password[i].port, 8);\n",
      "            strncpy(server->password, conf->port_password[i].password, 128);\n",
      "            add_server(&manager, server);\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nint  Var14=0; \nint  Var15=0; \nint  Var16=Var17; \nint  Var18=0; \nint  Var19=0; \nstatic int  Var20=0; \nint  Var21=0; \nchar *Var22[Var23]; \nchar *Var24[Var25+1]; \nint  Var26=0; \nSTRUCT1 *Var27=NULL ; \nstatic struct  STRUCT2  Var28[]={\nwhile ((Var2=getopt_long(Var29,Var30,STRING,\nVar28,NULL )) != -1)\nswitch (Var2){\nVar9=Var31; \nif (Var9 != NULL ){\nVar27=FUNC1(Var9); \nif (Var21 == 0){\nVar21=Var27->memberVar1; \nfor (Var1=0; Var1<Var21; Var1  Var32)\nVar22[Var1]=Var27->memberVar2[Var1].memberVar1; \nif (Var5 == NULL ){\nVar5=Var27->memberVar3; \nif (Var7 == NULL ){\nVar7=Var27->memberVar4; \nif (Var6 == NULL ){\nVar6=Var27->memberVar5; \nif (Var4 == NULL ){\nVar4=Var27->memberVar6; \nif (Var14 == 0){\nVar14=Var27->memberVar7; \nif (Var15 == 0){\nVar15=Var27->memberVar8; \nif (Var27->memberVar9 != NULL ){\nVar24[Var26  Var32]=Var27->memberVar9; \nif (Var16 ==  Var17){\nVar16=Var27->memberVar10; \nif (Var18 == 0){\nVar18=Var27->memberVar11; \nif (Var12 == NULL ){\nVar12=Var27->memberVar12; \nif (Var13 == NULL ){\nVar13=Var27->memberVar13; \nif (Var19 == 0){\nVar19=Var27->memberVar14; \nif (Var20 == 0){\nVar20=Var27->memberVar15; \nif (Var27 != NULL ){\nfor (Var1=0; Var1<Var27->memberVar16; Var1  Var32){\nstruct STRUCT3 *STRUCT3=FUNC2(sizeof (struct  STRUCT3)); \nmemset(STRUCT3,0,sizeof (struct  STRUCT3)); \nstrncpy(STRUCT3->memberVar1,Var27->memberVar17[Var1].memberVar2,8); \nstrncpy(STRUCT3->memberVar2,Var27->memberVar17[Var1].memberVar3,128); \nFUNC3(&Var33,STRUCT3); \nstruct STRUCT3 *STRUCT3=(struct STRUCT3 *) Var34->memberVar1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 135,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1144,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int fast_open  = 0;\n",
      "    int reuse_port = 0;\n",
      "    int mode       = TCP_ONLY;\n",
      "    int mtu        = 0;\n",
      "    int ipv6first  = 0;\n",
      "    static int nofile = 0;\n",
      "    int server_num = 0;\n",
      "    char *server_host[MAX_REMOTE_NUM];\n",
      "    char *nameservers[MAX_DNS_NUM + 1];\n",
      "    int nameserver_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            conf_path = optarg;\n",
      "    if (conf_path != NULL) {\n",
      "        conf = read_jconf(conf_path);\n",
      "        if (server_num == 0) {\n",
      "            server_num = conf->remote_num;\n",
      "            for (i = 0; i < server_num; i++)\n",
      "                server_host[i] = conf->remote_addr[i].host;\n",
      "        if (password == NULL) {\n",
      "            password = conf->password;\n",
      "        if (method == NULL) {\n",
      "            method = conf->method;\n",
      "        if (timeout == NULL) {\n",
      "            timeout = conf->timeout;\n",
      "        if (user == NULL) {\n",
      "            user = conf->user;\n",
      "        if (fast_open == 0) {\n",
      "            fast_open = conf->fast_open;\n",
      "        if (reuse_port == 0) {\n",
      "            reuse_port = conf->reuse_port;\n",
      "        if (conf->nameserver != NULL) {\n",
      "            nameservers[nameserver_num++] = conf->nameserver;\n",
      "        if (mode == TCP_ONLY) {\n",
      "            mode = conf->mode;\n",
      "        if (mtu == 0) {\n",
      "            mtu = conf->mtu;\n",
      "        if (plugin == NULL) {\n",
      "            plugin = conf->plugin;\n",
      "        if (plugin_opts == NULL) {\n",
      "            plugin_opts = conf->plugin_opts;\n",
      "        if (ipv6first == 0) {\n",
      "            ipv6first = conf->ipv6_first;\n",
      "        if (nofile == 0) {\n",
      "            nofile = conf->nofile;\n",
      "    if (conf != NULL) {\n",
      "        for (i = 0; i < conf->port_password_num; i++) {\n",
      "            struct server *server = ss_malloc(sizeof(struct server));\n",
      "            memset(server, 0, sizeof(struct server));\n",
      "            strncpy(server->port, conf->port_password[i].port, 8);\n",
      "            strncpy(server->password, conf->port_password[i].password, 128);\n",
      "            add_server(&manager, server);\n",
      "        struct server *server = (struct server *)entry->value;\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nint  Var14=0; \nint  Var15=0; \nint  Var16=Var17; \nint  Var18=0; \nint  Var19=0; \nstatic int  Var20=0; \nint  Var21=0; \nchar *Var22[Var23]; \nchar *Var24[Var25+1]; \nint  Var26=0; \nSTRUCT1 *Var27=NULL ; \nstatic struct  STRUCT2  Var28[]={\nwhile ((Var2=getopt_long(Var29,Var30,STRING,\nVar28,NULL )) != -1)\nswitch (Var2){\nVar9=Var31; \nif (Var9 != NULL ){\nVar27=FUNC1(Var9); \nif (Var21 == 0){\nVar21=Var27->memberVar1; \nfor (Var1=0; Var1<Var21; Var1  Var32)\nVar22[Var1]=Var27->memberVar2[Var1].memberVar1; \nif (Var5 == NULL ){\nVar5=Var27->memberVar3; \nif (Var7 == NULL ){\nVar7=Var27->memberVar4; \nif (Var6 == NULL ){\nVar6=Var27->memberVar5; \nif (Var4 == NULL ){\nVar4=Var27->memberVar6; \nif (Var14 == 0){\nVar14=Var27->memberVar7; \nif (Var15 == 0){\nVar15=Var27->memberVar8; \nif (Var27->memberVar9 != NULL ){\nVar24[Var26  Var32]=Var27->memberVar9; \nif (Var16 ==  Var17){\nVar16=Var27->memberVar10; \nif (Var18 == 0){\nVar18=Var27->memberVar11; \nif (Var12 == NULL ){\nVar12=Var27->memberVar12; \nif (Var13 == NULL ){\nVar13=Var27->memberVar13; \nif (Var19 == 0){\nVar19=Var27->memberVar14; \nif (Var20 == 0){\nVar20=Var27->memberVar15; \nif (Var27 != NULL ){\nfor (Var1=0; Var1<Var27->memberVar16; Var1  Var32){\nstruct STRUCT3 *STRUCT3=FUNC2(sizeof (struct  STRUCT3)); \nmemset(STRUCT3,0,sizeof (struct  STRUCT3)); \nstrncpy(STRUCT3->memberVar1,Var27->memberVar17[Var1].memberVar2,8); \nstrncpy(STRUCT3->memberVar2,Var27->memberVar17[Var1].memberVar3,128); \nFUNC3(&Var33,STRUCT3); \nstruct STRUCT3 *STRUCT3=(struct STRUCT3 *) Var34->memberVar1; \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 136,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "socket",
    "line": 1155,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    struct manager_ctx manager;\n",
      "    struct ev_loop *loop = EV_DEFAULT;\n",
      "    int sfd;\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        sfd = socket(AF_UNIX, SOCK_DGRAM, 0);       /*  Create server socket */\n",
      "        setnonblocking(sfd);\n",
      "    manager.fd = sfd;\n",
      "    ev_io_init(&manager.io, manager_recv_cb, manager.fd, EV_READ);\n",
      "    ev_io_start(loop, &manager.io);\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nstruct  STRUCT3  Var14; \nstruct STRUCT4 *Var15=Var16; \nint  Var17; \nif (Var18.memberVar1 == NULL ||Var18.memberVar2 == NULL ){\nVar17=socket(Var19,Var20,0); /*Var21  STRUCT5 socket*/\nFUNC1(Var17); \nVar14.memberVar1=Var17; \nFUNC2(&Var14.memberVar2,Var22,Var14.memberVar1,Var23); \nFUNC3(Var15,&Var14.memberVar2); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 137,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "remove",
    "line": 1163,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int server_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            manager_address = optarg;\n",
      "    if (manager_address == NULL) {\n",
      "        manager_address = \"127.0.0.1:8839\";\n",
      "        LOGI(\"using the default manager address: %s\", manager_address);\n",
      "    struct manager_ctx manager;\n",
      "    manager.manager_address = manager_address;\n",
      "    parse_addr(manager_address, &ip_addr);\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        struct sockaddr_un svaddr;\n",
      "        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nint  Var14=0; \nSTRUCT1 *Var15=NULL ; \nstatic struct  STRUCT2  Var16[]={\nwhile ((Var2=getopt_long(Var17,Var18,STRING,\nVar16,NULL )) != -1)\nswitch (Var2){\nVar11=Var19; \nif (Var11 == NULL ){\nVar11=STRING; \nFUNC1(STRING,Var11); \nstruct  STRUCT3  Var20; \nVar20.memberVar1=memberVar1; \nFUNC2(memberVar1,&Var21); \nif (Var21.memberVar1 == NULL ||Var21.memberVar2 == NULL ){\nstruct  STRUCT4  Var22; \nstrncpy(Var22.memberVar1,memberVar1,sizeof (Var22.memberVar1)-1); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 138,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "memset",
    "line": 1169,
    "label": -3,
    "slices": [
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        memset(&svaddr, 0, sizeof(struct sockaddr_un));\n"
    ],
    "tokenized": "char *Var1=NULL ; \nchar *Var2=NULL ; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nSTRUCT1 *Var12=NULL ; \nstatic struct  STRUCT2  Var13[]={\nif (Var14.memberVar1 == NULL ||Var14.memberVar2 == NULL ){\nmemset(&Var15,0,sizeof (struct  Var16)); \n"
  },
  {
    "FileName": "manager.c",
    "Caller": "main",
    "Source": false,
    "Sink": false,
    "idx": 139,
    "CWE-ID": "CWE-",
    "category": "CallExpression",
    "criterion": "strncpy",
    "line": 1171,
    "label": -3,
    "slices": [
      "    int i, c;\n",
      "    char *acl             = NULL;\n",
      "    char *user            = NULL;\n",
      "    char *password        = NULL;\n",
      "    char *timeout         = NULL;\n",
      "    char *method          = NULL;\n",
      "    char *pid_path        = NULL;\n",
      "    char *conf_path       = NULL;\n",
      "    char *iface           = NULL;\n",
      "    char *manager_address = NULL;\n",
      "    char *plugin          = NULL;\n",
      "    char *plugin_opts     = NULL;\n",
      "    int server_num = 0;\n",
      "    jconf_t *conf = NULL;\n",
      "    static struct option long_options[] = {\n",
      "    while ((c = getopt_long(argc, argv, \"f:s:l:k:t:m:c:i:d:a:n:6huUvA\",\n                            long_options, NULL)) != -1)\n",
      "        switch (c) {\n",
      "            manager_address = optarg;\n",
      "    if (manager_address == NULL) {\n",
      "        manager_address = \"127.0.0.1:8839\";\n",
      "        LOGI(\"using the default manager address: %s\", manager_address);\n",
      "    struct manager_ctx manager;\n",
      "    manager.manager_address = manager_address;\n",
      "    parse_addr(manager_address, &ip_addr);\n",
      "    if (ip_addr.host == NULL || ip_addr.port == NULL) {\n",
      "        struct sockaddr_un svaddr;\n",
      "        svaddr.sun_family = AF_UNIX;\n",
      "        strncpy(svaddr.sun_path, manager_address, sizeof(svaddr.sun_path) - 1);\n"
    ],
    "tokenized": "int  Var1,Var2; \nchar *Var3=NULL ; \nchar *Var4=NULL ; \nchar *Var5=NULL ; \nchar *Var6=NULL ; \nchar *Var7=NULL ; \nchar *Var8=NULL ; \nchar *Var9=NULL ; \nchar *Var10=NULL ; \nchar *Var11=NULL ; \nchar *Var12=NULL ; \nchar *Var13=NULL ; \nint  Var14=0; \nSTRUCT1 *Var15=NULL ; \nstatic struct  STRUCT2  Var16[]={\nwhile ((Var2=getopt_long(Var17,Var18,STRING,\nVar16,NULL )) != -1)\nswitch (Var2){\nVar11=Var19; \nif (Var11 == NULL ){\nVar11=STRING; \nFUNC1(STRING,Var11); \nstruct  STRUCT3  Var20; \nVar20.memberVar1=memberVar1; \nFUNC2(memberVar1,&Var21); \nif (Var21.memberVar1 == NULL ||Var21.memberVar2 == NULL ){\nstruct  STRUCT4  Var22; \nVar22.memberVar1=Var23; \nstrncpy(Var22.memberVar2,memberVar1,sizeof (Var22.memberVar2)-1); \n"
  }
]
